/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version					   2015/08/04              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "YpmMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include <zlib.h>
#include "b64.h"
#include "ObjPtr.h"
#include <time.h>
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"

OBJPTR(DB);
OBJPTR(BO);
char	cDebug;

void	YpmMsg(char cdebug)
{
	cDebug = cdebug;
}

int FormatMsg(const hash_t* hIn,unsigned char *outMsg,int *outLen)
{
	int	iRet = PD_OK;
	char*   csTmp = NULL;
	char*   csPtr = NULL;
	char*   csBuf;
	char*   csMethod = NULL;
	char*   csData;
	char*   csEncrypKey;
	char*   csPspID;
	char*   csTmpData;
	char*   csAESKey;
	char*   csRSAKey;
	double	dTmp;
	char	csTime[PD_DATETIME_LEN];

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1 );
	csTmpData = (char*) malloc (MAX_MSG_SIZE + 1 );
	csData = (char*) malloc (MAX_MSG_SIZE + 1 );
	csEncrypKey = (char*) malloc (MAX_MSG_SIZE + 1 );

	memset(outMsg,0,sizeof(outMsg));
	memset(csTmpData,0,sizeof(csTmpData));
	if (GetField_CString(hIn,"redirect_url",&csPtr)) {
DEBUGLOG(("FormatMsg here\n"));
		strcat((char*)outMsg,csPtr);
		strcat((char*)outMsg,"?");


//////merchantaccount
		if (GetField_CString(hIn,"psp_merchant_id",&csTmp)) {
			strcat((char*)outMsg,"merchantaccount");
			strcat((char*)outMsg,MY_YPM_FIELD_TOKEN);
			strcat((char*)outMsg,csTmp);
			strcat((char*)outMsg,MY_YPM_TOKEN);
DEBUGLOG(("FormatMsg:: merchantaccount = [%s]\n",csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: *** psp_merchant_id is missing\n"));
		}

//////data
		// amount
        	if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("FormatDataMsg:: amount = [%f]\n",dTmp));
                	sprintf((char*)csTmp,"%ld",double2long(dTmp));
DEBUGLOG(("FormatDataMsg:: amount = [%s]\n",csTmp));
			strcat((char*)csTmpData,MY_YPM_JSON_START_TOKEN);
                	strcat((char*)csTmpData,"\"amount\":");
                	strcat((char*)csTmpData,(char*)csTmp);
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
        	}

		//callbackurl
		if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: callbackurl = [%s]\n",csPtr));
                	strcat((char*)csTmpData,"\"callbackurl\":");
                	strcat((char*)csTmpData,csPtr);
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		//fcallbackurl
		if (GetField_CString(hIn,"fe_url",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: fcallbackurl = [%s]\n",csPtr));
                	strcat((char*)csTmpData,"\"fcallbackurl\":");
			strcat((char*)csTmpData,csPtr);
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		//identityid
		if (GetField_CString(hIn,"customer_tag",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: identityid = [%s]\n",csPtr));
                	strcat((char*)csTmpData,"\"identityid\":");
                	strcat((char*)csTmpData,csPtr);
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		//identitytype
		//2: cust. id
		strcat((char*)csTmpData,"\"identitytype\":");
		strcat((char*)csTmpData,"2");
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: identitytype = [2]\n"));

		//merchantaccount 
		if (GetField_CString(hIn,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: merchantaccount = [%s]\n",csPtr));
			strcat((char*)csTmpData,"\"merchantaccount\":");
                	strcat((char*)csTmpData,csPtr);
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		// orderid 
		if (GetField_CString(hIn,"txn_seq",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: orderid = [%s]\n",csPtr));
			strcat((char*)csTmpData,"\"orderid\":");
                	strcat((char*)csTmpData,csPtr);
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		//productcatalog
		//20: Other
		strcat((char*)csTmpData,"\"productcatalog\":");
		strcat((char*)csTmpData,"20");
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: productcatalog = [20]\n"));

		//productname
		//PAY
		strcat((char*)csTmpData,"\"productname\":");
		strcat((char*)csTmpData,"PAY");
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: productname = [PAY]\n"));

		//terminalid
		//hardcode, no meaning
		strcat((char*)csTmpData,"\"terminalid\":");
		strcat((char*)csTmpData,"T00101");
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: terminalid = [T00101]\n"));

		//terminaltype
		//3: Other
		strcat((char*)csTmpData,"\"terminaltype\":");
		strcat((char*)csTmpData,"3");
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: terminaltype = [3]\n"));

		//transtime (Unix timestamp) 
		sprintf(csTime,"%d",(int)time(NULL));
		strcat((char*)csTmpData,"\"transtime\":");
		strcat((char*)csTmpData,csTime);
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: transtime = [%s]\n",csTime));

		//userip
        	if (GetField_CString(hIn,"userip",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: userip = [%s]\n",csPtr));
			strcat((char*)csTmpData,"\"userip\":");
        	        strcat((char*)csTmpData,csPtr);
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
        	}

		//sign
        	if (GetField_CString(hIn,"sign",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: sign = [%s]\n",csPtr));
			strcat((char*)csTmpData,"\"sign\":");
        	        strcat((char*)csTmpData,csPtr);
			strcat((char*)csTmpData,MY_YPM_JSON_END_TOKEN);
        	}

//
		if (GetField_CString(hIn,"psp_id",&csPspID) &&
		    GetField_CString(hIn,"aes_key",&csAESKey) &&
		    GetField_CString(hIn,"rsa_key",&csRSAKey)){ 
                        char*   csResult;
                        csResult = (char*) malloc (strlen(csTmpData) *2  +1);
			memset(csResult,0,sizeof(csResult));
                        BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESEncryptData");
                        iRet = (unsigned long)(*BOObjPtr)(csAESKey,csTmpData,csResult);
                        if (iRet == PD_OK) {
                                base64_encode((unsigned char *)csResult,strlen(csResult),csData,PD_MAX_BUFFER);
                                strcat((char*)outMsg,"data");
				strcat((char*)outMsg,MY_YPM_FIELD_TOKEN);
                                strcat((char*)outMsg,csData);
                                strcat((char*)outMsg,MY_YPM_TOKEN);
DEBUGLOG(("FormatMsg:: data = [%s]\n",csData));
                        }


			if(iRet == PD_OK){
				memset(csResult,0,sizeof(csResult));
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","RSAEncryptData");
				iRet = (unsigned long)(*BOObjPtr)(csRSAKey,csAESKey,csResult,PD_FALSE);
				if (iRet == PD_OK) {
					strcat((char*)outMsg,"encryptkey");
					strcat((char*)outMsg,MY_YPM_FIELD_TOKEN);
					strcat((char*)outMsg,csResult);
DEBUGLOG(("FormatMsg:: encryptkey = [%s]\n",csResult));
				}
			}

                }
                else {
                        iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: psp_id/aes_key/rsa_key not found\n"));
ERRLOG("YpmMsg::FormatMsg psp_id/aes_key/rsa_key not found\n");
                }


// url_method
                if (GetField_CString(hIn,"url_method",&csMethod)) {
DEBUGLOG(("FormatMsg:: url_method = [%s]\n",csMethod));
		}


DEBUGLOG(("FormatMsg:: outmsg = [%s]\n",outMsg));

		base64_encode((unsigned char *)outMsg,strlen((const char*)outMsg),csBuf,PD_MAX_BUFFER);
                outMsg[0] = '\0';
                strcat((char*)outMsg,"redirect_url");
                strcat((char*)outMsg,"=");
                strcat((char*)outMsg,csBuf);
		strcat((char*)outMsg,MY_YPM_TOKEN);
		strcat((char*)outMsg,"url_method");
                strcat((char*)outMsg,"=");
                strcat((char*)outMsg,csMethod);
		strcat((char*)outMsg,MY_YPM_TOKEN);
                strcat((char*)outMsg,"ret_status=0");

DEBUGLOG(("FormatMsg:: outMsg = [%s]\n",outMsg));


		*outLen = strlen((const char*)outMsg);
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: Redirct url not found\n"));
	}


	FREE_ME(csBuf);
	FREE_ME(csData);
	FREE_ME(csEncrypKey);
	FREE_ME(csTmpData);
	return 	iRet;
}


int BuildData(hash_t* hIn)
{
        int     iRet = PD_OK;
        char*   csPtr,*csDATA;
        char    csTime[PD_DATETIME_LEN];
	char*	csBuf;
	char	csTmp[PD_AMOUNT_LEN];
        double  dTmp;
        csDATA = (char*) malloc (1024 * 2 +1);
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1 ); 

DEBUGLOG(("BuildData()\n"));

        memset(csDATA,0,sizeof(csDATA));
        

// amount
        if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("BuildData:: amount = [%f]\n",dTmp));
                sprintf((char*)csTmp,"%ld",double2long(dTmp));
DEBUGLOG(("BuildData:: amount = [%s]\n",csTmp));
                strcat((char*)csDATA,(char*)csTmp);
        }

//callbackurl
        if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("BuildData:: callbackurl = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }

//fcallbackurl
        if (GetField_CString(hIn,"fe_url",&csPtr)) {
DEBUGLOG(("BuildData:: fcallbackurl = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }

//identityid
        if (GetField_CString(hIn,"customer_tag",&csPtr)) {
DEBUGLOG(("BuildData:: identityid = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
	}

//identitytype
	//2: cust. id
	strcat((char*)csDATA,"2");
DEBUGLOG(("BuildData:: identitytype = [2]\n"));

//merchantaccount 
        if (GetField_CString(hIn,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("BuildData:: merchantaccount = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }

// orderid 
        if (GetField_CString(hIn,"txn_seq",&csPtr)) {
DEBUGLOG(("BuildData:: orderid = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }

//productcatalog
	//20: Other
	strcat((char*)csDATA,"20");
DEBUGLOG(("BuildData:: productcatalog = [20]\n"));

//productname
	//PAY
	strcat((char*)csDATA,"PAY");
DEBUGLOG(("BuildData:: productname = [PAY]\n"));

//terminalid
	//hardcode, no meaning
	strcat((char*)csDATA,"T00101");
DEBUGLOG(("BuildData:: terminalid = [T00101]\n"));

//terminaltype
	//3: Other
	strcat((char*)csDATA,"3");
DEBUGLOG(("BuildData:: terminaltype = [3]\n"));

//transtime (Unix timestamp) 
	sprintf(csTime,"%d",(int)time(NULL));
	strcat((char*)csDATA,csTime);
DEBUGLOG(("BuildData:: transtime = [%s]\n",csTime));

//userip
        if (GetField_CString(hIn,"userip",&csPtr)) {
DEBUGLOG(("BuildData:: userip = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }


        PutField_CString(hIn,"plainttext_data",csDATA);

DEBUGLOG(("BuildData:: DATA = [%s]\n",csDATA));

        FREE_ME(csDATA);
DEBUGLOG(("BuildData() Exit iRet = [%d]\n",iRet));
        return  iRet;
}


int BreakDownMsg(hash_t *hOut,const unsigned char *inMsg,int inLen)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csKey;
	char    csPrivKey[PD_TMP_MSG_BUF_LEN+1];
        char    csRsaPemPath[PD_MAX_FILE_LEN + 1];

        hash_t  *hKey;
        hash_t  *hRec;

        hRec = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hRec,0);

	csKey = (char*) malloc (MAX_MSG_SIZE + 1 );
DEBUGLOG(("BreakDownMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n",inMsg,inLen));

	if (Str2Cls(hRec,(const char *)inMsg,MY_YPM_TOKEN, MY_YPM_FIELD_TOKEN) == PD_OK) {

/*pid*/
		if (GetField_CString(hRec,"pid",&csPtr)) {
			//get private key
			csPrivKey[0]='\0';
			recordset_t     *rKeySet;
			rKeySet = (recordset_t*) malloc (sizeof(recordset_t));
			recordset_init(rKeySet,0);
			DBObjPtr = CreateObj(DBPtr,"DBPspKeys","GetPspKey");
			if (!(*DBObjPtr)(csPtr,PD_PTK_KEY_NAME,rKeySet)) {
				hKey = RecordSet_GetFirst(rKeySet);
				while(hKey){
					if (GetField_CString(hKey,"privatepem",&csPtr)) {
DEBUGLOG(("PTK file = [%s]\n",csPtr));
						sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csPtr);
						FILE    *fKey;
						fKey = fopen(csRsaPemPath,"r");
						if (fKey == NULL) {
							iRet = INT_ERR;
DEBUGLOG(("BreakDownMsg cannot open key file[%s]\n",csRsaPemPath));
ERRLOG("YpmMsg:BreakDownMsg cannot open key file[%s]\n",csRsaPemPath);
						}
						else{
							fgets(csPrivKey,PD_TMP_MSG_BUF_LEN,fKey);
							csPrivKey[strlen(csPrivKey) - 1] = '\0';
						}
						fclose(fKey);
					}
					break;
				}
			}
			RecordSet_Destroy(rKeySet);
			FREE_ME(rKeySet);
		}

/*encryptkey*/
		if (iRet==PD_OK && GetField_CString(hRec,"encryptkey",&csPtr)) {
DEBUGLOG(("BreakDownMsg encryptkey = [%s]\n",csPtr));
			BOObjPtr = CreateObj(BOPtr,"BOSecurity","RSADecryptData");
			iRet = (unsigned long)(*BOObjPtr)(csPrivKey,csPtr,csKey,PD_TRUE);
			if(iRet==PD_OK){
DEBUGLOG(("BreakDownMsg key = [%s]\n",csKey));
			}
			else
			{
				iRet = PD_ERR;
DEBUGLOG(("BreakDownMsg encryptkey decrypt failed!!\n"));
			}
        	}
		else{
			iRet = PD_ERR;
DEBUGLOG(("BreakDownMsg encryptkey not found\n"));
		}

/* data */
		if (iRet==PD_OK && GetField_CString(hRec,"data",&csPtr)) {
			PutField_CString(hOut,"private_key",csPrivKey);
                	iRet = DEBlockyeepayData(hOut,(const unsigned char *)csPtr,strlen(csPtr),csKey);
        	}
		else{
			iRet = PD_ERR;
DEBUGLOG(("BreakDownMsg data not found\n"));
		}
	
	}
	else{
DEBUGLOG(("BreakDownMsg() Error\n"));
                iRet = PD_ERR;
	}

	hash_destroy(hRec);
        FREE_ME(hRec);

DEBUGLOG(("BreakDownMsg Exit\n"));
	return	iRet;
}


int DEBlockyeepayData(hash_t *hOut,const unsigned char *inMsg,int inLen, const char* csKey)
{
        int     iRet = PD_OK;
        char    *csTmp=NULL;
        char    *csBuf;
        char    *csDATA;
        char    *csTmpDATA;
        char    *csAuthDATA;
        //char    *p;
        int     iLen;
	char	csTag[PD_TAG_LEN+1];

        csBuf = (char*) malloc (PD_MAX_BUFFER +1);
        csDATA = (char*) malloc (PD_MAX_BUFFER +1);
        csTmpDATA = (char*) malloc (PD_MAX_BUFFER +1);
        csAuthDATA = (char*) malloc (PD_MAX_BUFFER +1);
        memset(csAuthDATA,0,sizeof(csAuthDATA));

        hash_t  *hRec;

        hRec = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hRec,0);

        memcpy(csBuf,inMsg,inLen);
        csBuf[inLen] = '\0';
DEBUGLOG(("\n\nDEBlockData data=[%s]\n\n",csBuf));
        iLen = base64_decode((char *)csBuf,(unsigned char*)csTmpDATA,PD_MAX_BUFFER);
        csTmpDATA[iLen] = '\0';
        if (iLen > 0 ) {
DEBUGLOG(("\n\nDEBlockData data=[%s]\n\n",csTmpDATA));
DEBUGLOG(("iRet = [%d] Temp DATA = [%s]\n",iRet,csTmpDATA));
	}
	else{
		iRet = INT_ERR;
	}

	if(iRet==PD_OK){
		BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESDecryptData");
		iRet = (unsigned long)(*BOObjPtr)(csKey,csTmpDATA,csDATA);
DEBUGLOG(("iRet = [%d] DATA = [%s]\n",csDATA));
	}
	if(iRet==PD_OK){
		strcpy(csDATA,TrimAllChar((const unsigned char*)csDATA,strlen(csDATA),'{'));
		strcpy(csDATA,TrimAllChar((const unsigned char*)csDATA,strlen(csDATA),'}'));
	}
	if(iRet==PD_OK && 
	   Str2Cls(hRec,(const char *)csDATA,MY_YPM_JSON_TOKEN, MY_YPM_JSON_FIELD_TOKEN) == PD_OK){

		sprintf(csTag,"\"amount\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"txn_amt",csTmp);
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"bank\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"bank_name",csTmp);
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"bankcode\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"bank_code",csTmp);
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"cardtype\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"lastno\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"merchantaccount\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"psp_merchant_id",csTmp);
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"orderid\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"txn_seq",csTmp);
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"status\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"status",csTmp);
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"yborderid\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"tid",csTmp);
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

                PutField_CString(hOut,"plainttext_data",csAuthDATA);
                
		sprintf(csTag,"\"sign\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"sign",csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}
        }


        FREE_ME(csBuf);
        FREE_ME(csDATA);
        FREE_ME(csTmpDATA);
        FREE_ME(csAuthDATA);
	FREE_ME(hRec);
DEBUGLOG(("DBlockData Exit\n"));
        return  iRet;
}




int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
	int	iRet = PD_OK;

	return iRet;
}


