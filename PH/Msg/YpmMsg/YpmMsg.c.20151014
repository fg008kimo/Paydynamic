/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version					   2015/08/04              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "YpmMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include <zlib.h>
#include "b64.h"
#include "ObjPtr.h"
#include <time.h>
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"

#define PD_DOUBLE_QUOTE		0x22
#define PD_OPEN_BRACKET		'{'//0x7b
#define PD_CLOSE_BRACKET	'}'//0x7d
#define PD_PRODUCT_CAT		"7"
#define PD_IDENTITY_TYPE	"2"
#define PD_TERMINAL_TYPE	"3"
#define PD_TERMINAL_ID		"T1"
#define	PD_PRODUCT_NAME		"PAY"
#define	PD_DEF_CUST_ID		"0001"

OBJPTR(DB);
OBJPTR(BO);
char	cDebug;
void remove_quote(const char* csValue, const int iType,char* csOut);

void	YpmMsg(char cdebug)
{
	cDebug = cdebug;
}

int FormatMsg(const hash_t* hIn,unsigned char *outMsg,int *outLen)
{
	int	iRet = PD_OK;
	int	iLen = 0;
	char*   csTmp = NULL;
	char*   csPtr = NULL;
	char*   csBuf;
	char*   csMethod = NULL;
	char*   csData;
	char*   csEncrypKey;
	char*   csPspID;
	char*   csTmpData;
	char*   csAESKey;
	char*   csRSAKeyFile;
	double	dTmp;
	char	csTime[PD_DATETIME_LEN];

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1 );
	csTmpData = (char*) malloc (MAX_MSG_SIZE + 1 );
	csData = (char*) malloc (MAX_MSG_SIZE + 1 );
	csEncrypKey = (char*) malloc (MAX_MSG_SIZE + 1 );

	memset(outMsg,0,sizeof(outMsg));
	memset(csTmpData,0,sizeof(csTmpData));
	if (GetField_CString(hIn,"redirect_url",&csPtr)) {
DEBUGLOG(("FormatMsg here\n"));
		strcat((char*)outMsg,csPtr);
		strcat((char*)outMsg,"?");


//////merchantaccount
		if (GetField_CString(hIn,"psp_merchant_id",&csTmp)) {
			strcat((char*)outMsg,"merchantaccount");
			strcat((char*)outMsg,MY_YPM_FIELD_TOKEN);
			strcat((char*)outMsg,csTmp);
			strcat((char*)outMsg,MY_YPM_TOKEN);
DEBUGLOG(("FormatMsg:: merchantaccount = [%s]\n",csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: *** psp_merchant_id is missing\n"));
		}

//////data
		// amount
        	if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("FormatDataMsg:: amount = [%f]\n",dTmp));
                	sprintf((char*)csTmp,"%ld",double2long(dTmp));
DEBUGLOG(("FormatDataMsg:: amount = [%s]\n",csTmp));
			strcat((char*)csTmpData,MY_YPM_JSON_START_TOKEN);
                	strcat((char*)csTmpData,"\"amount\":");
                	strcat((char*)csTmpData,(char*)csTmp);
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
        	}

		//callbackurl
		if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: callbackurl = [%s]\n",csPtr));
                	strcat((char*)csTmpData,"\"callbackurl\":\"");
                	strcat((char*)csTmpData,csPtr);
                	strcat((char*)csTmpData,"\"");
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		//fcallbackurl
		if (GetField_CString(hIn,"fe_url",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: fcallbackurl = [%s]\n",csPtr));
                	strcat((char*)csTmpData,"\"fcallbackurl\":\"");
			strcat((char*)csTmpData,csPtr);
                	strcat((char*)csTmpData,"\"");
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		//identityid
		if (GetField_CString(hIn,"customer_tag",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: identityid = [%s]\n",csPtr));
                	strcat((char*)csTmpData,"\"identityid\":\"");
                	strcat((char*)csTmpData,csPtr);
                	strcat((char*)csTmpData,"\"");
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}
		else{//for mock merchant testing only
DEBUGLOG(("FormatDataMsg:: identityid = [%s]\n",PD_DEF_CUST_ID));
                	strcat((char*)csTmpData,"\"identityid\":\"");
                	strcat((char*)csTmpData,PD_DEF_CUST_ID);
                	strcat((char*)csTmpData,"\"");
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		//identitytype
		//2: cust. id
		strcat((char*)csTmpData,"\"identitytype\":");
		strcat((char*)csTmpData,PD_IDENTITY_TYPE);
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: identitytype = [%s]\n",PD_IDENTITY_TYPE));

		//merchantaccount 
		if (GetField_CString(hIn,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: merchantaccount = [%s]\n",csPtr));
			strcat((char*)csTmpData,"\"merchantaccount\":\"");
                	strcat((char*)csTmpData,csPtr);
                	strcat((char*)csTmpData,"\"");
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		// orderid 
		if (GetField_CString(hIn,"txn_seq",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: orderid = [%s]\n",csPtr));
			strcat((char*)csTmpData,"\"orderid\":\"");
                	strcat((char*)csTmpData,csPtr);
                	strcat((char*)csTmpData,"\"");
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
		}

		//productcatalog
		//20: Other
		strcat((char*)csTmpData,"\"productcatalog\":\"");
		strcat((char*)csTmpData,PD_PRODUCT_CAT);
		strcat((char*)csTmpData,"\"");
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: productcatalog = [%s]\n",PD_PRODUCT_CAT));

		//productname
		//PAY
		strcat((char*)csTmpData,"\"productname\":\"");
		strcat((char*)csTmpData,PD_PRODUCT_NAME);
		strcat((char*)csTmpData,"\"");
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: productname = [%s]\n",PD_PRODUCT_NAME));

		//sign
        	if (GetField_CString(hIn,"sign",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: sign = [%s]\n",csPtr));
			strcat((char*)csTmpData,"\"sign\":\"");
        	        strcat((char*)csTmpData,csPtr);
			strcat((char*)csTmpData,"\"");
			strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
        	}

		//terminalid
		//hardcode, no meaning
		strcat((char*)csTmpData,"\"terminalid\":\"");
		strcat((char*)csTmpData,PD_TERMINAL_ID);
		strcat((char*)csTmpData,"\"");
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: terminalid = [%s]\n",PD_TERMINAL_TYPE));

		//terminaltype
		//3: Other
		strcat((char*)csTmpData,"\"terminaltype\":");
		strcat((char*)csTmpData,PD_TERMINAL_TYPE);
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: terminaltype = [%s]\n",PD_TERMINAL_TYPE));

		//transtime (Unix timestamp) 
		sprintf(csTime,"%d",(int)time(NULL));
		strcat((char*)csTmpData,"\"transtime\":");
		strcat((char*)csTmpData,csTime);
		strcat((char*)csTmpData,MY_YPM_JSON_TOKEN);
DEBUGLOG(("FormatDataMsg:: transtime = [%s]\n",csTime));

		//userip
        	if (GetField_CString(hIn,"userip",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: userip = [%s]\n",csPtr));
			strcat((char*)csTmpData,"\"userip\":\"");
        	        strcat((char*)csTmpData,csPtr);
			strcat((char*)csTmpData,"\"");
			strcat((char*)csTmpData,MY_YPM_JSON_END_TOKEN);
        	}

//
		if (GetField_CString(hIn,"psp_id",&csPspID) &&
		    GetField_CString(hIn,"aes_key",&csAESKey) &&
		    GetField_CString(hIn,"rsa_key",&csRSAKeyFile)){ 
DEBUGLOG(("FormatMsg:: temp data = [%s]\n",csTmpData));
			memset(csData,0,sizeof(csData));
                        BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESEncryptData");
                        iRet = (unsigned long)(*BOObjPtr)(csAESKey,csTmpData,csData,&iLen);
                        if (iRet == PD_OK) {
				char *csEncData = (char*) malloc (MAX_MSG_SIZE + 1 );
				memset(csEncData,0,sizeof(csEncData));
				base64_encode((unsigned char *)csData,iLen,csEncData,PD_MAX_BUFFER);

                                strcat((char*)outMsg,"data");
				strcat((char*)outMsg,MY_YPM_FIELD_TOKEN);
                                strcat((char*)outMsg,url_encode(csEncData));
                                //strcat((char*)outMsg,url_encode(csData));
                                strcat((char*)outMsg,MY_YPM_TOKEN);
DEBUGLOG(("FormatMsg:: data = [%s]\n",csEncData));
//DEBUGLOG(("FormatMsg:: data = [%s]\n",csData));

				//FREE_ME(csEncData);
                        }


			if(iRet == PD_OK){
				memset(csData,0,sizeof(csData));
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","RSAEncryptData");
				iRet = (unsigned long)(*BOObjPtr)(csRSAKeyFile,csAESKey,csData,PD_FALSE,PD_TRUE);
				if (iRet == PD_OK) {
					strcat((char*)outMsg,"encryptkey");
					strcat((char*)outMsg,MY_YPM_FIELD_TOKEN);
					strcat((char*)outMsg,url_encode(csData));
DEBUGLOG(("FormatMsg:: encryptkey = [%s]\n",csData));
//					strcat((char*)outMsg,"J0gbmPJ4s1Czq5ctgAKUN2aNiPSDEziIJTMepyx7hz9tAnAKHJeEyQm7iAph/uD4dV8D97P8i5rwnyS/8zy1IAOgab52AUuzAUTuX46u06ZT98KNGW28GEG5vbPbkxIfIwwZuzm1KLHXCb1Bfr77aKb1Bez9XdycZ4Yp7LZwghE=");
//DEBUGLOG(("FormatMsg:: encryptkey = [J0gbmPJ4s1Czq5ctgAKUN2aNiPSDEziIJTMepyx7hz9tAnAKHJeEyQm7iAph/uD4dV8D97P8i5rwnyS/8zy1IAOgab52AUuzAUTuX46u06ZT98KNGW28GEG5vbPbkxIfIwwZuzm1KLHXCb1Bfr77aKb1Bez9XdycZ4Yp7LZwghE=]\n"));
				}
			}

                }
                else {
                        iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: psp_id/aes_key/rsa_key not found\n"));
ERRLOG("YpmMsg::FormatMsg psp_id/aes_key/rsa_key not found\n");
                }


// url_method
                if (GetField_CString(hIn,"url_method",&csMethod)) {
DEBUGLOG(("FormatMsg:: url_method = [%s]\n",csMethod));
		}


DEBUGLOG(("FormatMsg:: outmsg = [%s]\n",outMsg));

		base64_encode((unsigned char *)outMsg,strlen((const char*)outMsg),csBuf,PD_MAX_BUFFER);
                outMsg[0] = '\0';
                strcat((char*)outMsg,"redirect_url");
                strcat((char*)outMsg,"=");
                strcat((char*)outMsg,csBuf);
		strcat((char*)outMsg,MY_YPM_TOKEN);
		strcat((char*)outMsg,"url_method");
                strcat((char*)outMsg,"=");
                strcat((char*)outMsg,csMethod);
		strcat((char*)outMsg,MY_YPM_TOKEN);
                strcat((char*)outMsg,"ret_status=0");

DEBUGLOG(("FormatMsg:: outMsg = [%s]\n",outMsg));


		*outLen = strlen((const char*)outMsg);
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: Redirct url not found\n"));
	}


	FREE_ME(csBuf);
	FREE_ME(csData);
	FREE_ME(csEncrypKey);
	FREE_ME(csTmpData);
	return 	iRet;
}


int BuildData(hash_t* hIn)
{
        int     iRet = PD_OK;
        char*   csPtr,*csDATA;
        char    csTime[PD_DATETIME_LEN];
	char*	csBuf;
	char	csTmp[PD_AMOUNT_LEN];
        double  dTmp;
        csDATA = (char*) malloc (1024 * 2 +1);
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1 ); 

DEBUGLOG(("BuildData()\n"));

        memset(csDATA,0,sizeof(csDATA));
        

// amount
        if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("BuildData:: amount = [%f]\n",dTmp));
                sprintf((char*)csTmp,"%ld",double2long(dTmp));
DEBUGLOG(("BuildData:: amount = [%s]\n",csTmp));
                strcat((char*)csDATA,(char*)csTmp);
        }

//callbackurl
        if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("BuildData:: callbackurl = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }

//fcallbackurl
        if (GetField_CString(hIn,"fe_url",&csPtr)) {
DEBUGLOG(("BuildData:: fcallbackurl = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }

//identityid
        if (GetField_CString(hIn,"customer_tag",&csPtr)) {
DEBUGLOG(("BuildData:: identityid = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
	}
	else{ //for mock merchant testing only
DEBUGLOG(("BuildData:: identityid = [%s]\n",PD_DEF_CUST_ID));
                strcat((char*)csDATA,PD_DEF_CUST_ID);
	}

//identitytype
	//2: cust. id
	strcat((char*)csDATA,PD_IDENTITY_TYPE);
DEBUGLOG(("BuildData:: identitytype = [%s]\n",PD_IDENTITY_TYPE));

//merchantaccount 
        if (GetField_CString(hIn,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("BuildData:: merchantaccount = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }

// orderid 
        if (GetField_CString(hIn,"txn_seq",&csPtr)) {
DEBUGLOG(("BuildData:: orderid = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }

//productcatalog
	//20: Other
	strcat((char*)csDATA,PD_PRODUCT_CAT);
DEBUGLOG(("BuildData:: productcatalog = [%s]\n",PD_PRODUCT_CAT));

//productname
	//PAY
	strcat((char*)csDATA,PD_PRODUCT_NAME);
DEBUGLOG(("BuildData:: productname = [%s]\n",PD_PRODUCT_NAME));

//terminalid
	//hardcode, no meaning
	strcat((char*)csDATA,PD_TERMINAL_ID);
DEBUGLOG(("BuildData:: terminalid = [%s]\n",PD_TERMINAL_ID));

//terminaltype
	//3: Other
	strcat((char*)csDATA,PD_TERMINAL_TYPE);
DEBUGLOG(("BuildData:: terminaltype = [%s]\n",PD_TERMINAL_TYPE));

//transtime (Unix timestamp) 
	sprintf(csTime,"%d",(int)time(NULL));
	strcat((char*)csDATA,csTime);
DEBUGLOG(("BuildData:: transtime = [%s]\n",csTime));

//userip
        if (GetField_CString(hIn,"userip",&csPtr)) {
DEBUGLOG(("BuildData:: userip = [%s]\n",csPtr));
                strcat((char*)csDATA,csPtr);
        }

        PutField_CString(hIn,"plainttext_data",csDATA);

DEBUGLOG(("BuildData:: DATA = [%s]\n",csDATA));

        FREE_ME(csDATA);
DEBUGLOG(("BuildData() Exit iRet = [%d]\n",iRet));
        return  iRet;
}


int BreakDownMsg(hash_t *hOut,const unsigned char *inMsg,int inLen)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csKey;
	char	*csKeyFile;
	char	*csYPKeyFile;
	//char    csPubKey[PD_TMP_MSG_BUF_LEN+1];
        //char    csRsaPemPath[PD_MAX_FILE_LEN + 1];
	//char    csBuf[PD_TMP_BUF_LEN +1];

        hash_t  *hKey;
        hash_t  *hRec;

        hRec = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hRec,0);

	csKey = (char*) malloc (MAX_MSG_SIZE + 1 );
DEBUGLOG(("BreakDownMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n",inMsg,inLen));

	if (Str2Cls(hRec,(const char *)inMsg,MY_YPM_TOKEN, MY_YPM_FIELD_TOKEN) == PD_OK) {

/*pid*/
		if (GetField_CString(hRec,"pid",&csPtr)) {
			//get private key
			recordset_t     *rKeySet;
			rKeySet = (recordset_t*) malloc (sizeof(recordset_t));
			recordset_init(rKeySet,0);
			DBObjPtr = CreateObj(DBPtr,"DBPspKeys","GetPspKey");
			if (!(*DBObjPtr)(csPtr,PD_PTK_KEY_NAME,rKeySet)) {
				hKey = RecordSet_GetFirst(rKeySet);
				while(hKey){
					if (GetField_CString(hKey,"privatepem",&csKeyFile)) {
DEBUGLOG(("PTK file = [%s]\n",csKeyFile));
					}
					break;
				}
			}
			RecordSet_Destroy(rKeySet);

			//get yeepay public key
			recordset_init(rKeySet,0);
			DBObjPtr = CreateObj(DBPtr,"DBPspKeys","GetPspKey");
			if (!(*DBObjPtr)(csPtr,PD_RSA_KEY_NAME,rKeySet)) {
				hKey = RecordSet_GetFirst(rKeySet);
				while(hKey){
					if (GetField_CString(hKey,"privatepem",&csYPKeyFile)) {
DEBUGLOG(("RSA file = [%s]\n",csYPKeyFile));
					}
					break;
				}
			}
			RecordSet_Destroy(rKeySet);
		}

/*encryptkey*/
		if (iRet==PD_OK && GetField_CString(hRec,"encryptkey",&csPtr)) {
DEBUGLOG(("BreakDownMsg encryptkey = [%s]\n",csPtr));
			BOObjPtr = CreateObj(BOPtr,"BOSecurity","RSAEncryptData");
			iRet = (unsigned long)(*BOObjPtr)(csKeyFile,csPtr,csKey,PD_TRUE,PD_FALSE);
			if(iRet==PD_OK){
DEBUGLOG(("BreakDownMsg key = [%s]\n",csKey));
			}
			else
			{
				iRet = PD_ERR;
DEBUGLOG(("BreakDownMsg encryptkey decrypt failed!!\n"));
			}
        	}
		else{
			iRet = PD_ERR;
DEBUGLOG(("BreakDownMsg encryptkey not found\n"));
		}

/* data */
		if (iRet==PD_OK && GetField_CString(hRec,"data",&csPtr)) {
			PutField_CString(hOut,"psp_key_file",csYPKeyFile);
                	iRet = DEBlockyeepayData(hOut,(const unsigned char *)csPtr,strlen(csPtr),csKey);
        	}
		else{
			iRet = PD_ERR;
DEBUGLOG(("BreakDownMsg data not found\n"));
		}
	
	}
	else{
DEBUGLOG(("BreakDownMsg() Error\n"));
                iRet = PD_ERR;
	}

	hash_destroy(hRec);
        FREE_ME(hRec);
        FREE_ME(csKey);

DEBUGLOG(("BreakDownMsg Exit\n"));
	return	iRet;
}


int DEBlockyeepayData(hash_t *hOut,const unsigned char *inMsg,int inLen, const char* csKey)
{
        int     iRet = PD_OK;
        char    *csTmp=NULL;
        char    *csBuf;
        char    *csDATA;
        char    *csTmpDATA;
        //char    *csTrimDATA;
        char    *csAuthDATA;
        //char    *p;
        int     iLen;
	char	csTag[PD_TAG_LEN+1];
	char *csPara = malloc(PD_MAX_BUFFER+1);

        csTmp = (char*) malloc (PD_MAX_BUFFER +1);
        csBuf = (char*) malloc (PD_MAX_BUFFER +1);
        csDATA = (char*) malloc (PD_MAX_BUFFER +1);
        csTmpDATA = (char*) malloc (PD_MAX_BUFFER +1);
        //csTrimDATA = (char*) malloc (PD_MAX_BUFFER +1);
        csAuthDATA = (char*) malloc (PD_MAX_BUFFER +1);
        memset(csAuthDATA,0,sizeof(csAuthDATA));

        hash_t  *hRec;

        hRec = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hRec,0);

        memcpy(csBuf,inMsg,inLen);
        csBuf[inLen] = '\0';
DEBUGLOG(("\n\nDEBlockData data=[%s]\n\n",csBuf));
        iLen = base64_decode((char *)csBuf,(unsigned char*)csTmpDATA,PD_MAX_BUFFER);
        //csTmpDATA[iLen] = '\0';
        if (iLen > 0 ) {
DEBUGLOG(("iLen = [%d] DATA = [%s]\n",iLen,csTmpDATA));
	}
	else{
		iRet = INT_ERR;
	}

	if(iRet==PD_OK){
		BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESDecryptData");
		iRet = (unsigned long)(*BOObjPtr)(csKey,csTmpDATA,iLen,csDATA);
DEBUGLOG(("iLen = [%d] DATA = [%s]\n",iLen,csDATA));
	}
	if(iRet==PD_OK){
		strcpy(csDATA,TrimAllChar((const unsigned char*)csDATA,strlen(csDATA),PD_OPEN_BRACKET));
		strcpy(csDATA,TrimAllChar((const unsigned char*)csDATA,strlen(csDATA),PD_CLOSE_BRACKET));
	}
	if(iRet==PD_OK && 
	   Str2Cls(hRec,(const char *)csDATA,MY_YPM_JSON_TOKEN, MY_YPM_JSON_FIELD_TOKEN) == PD_OK){

		sprintf(csTag,"\"amount\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"txn_amt",csTmp);
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"bank\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			//PutField_CString(hOut,"bank_name",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"bankcode\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"ret_bank_code",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"cardtype\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"lastno\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"merchantaccount\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"psp_merchant_id",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"orderid\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"txn_seq",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"status\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"status",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"yborderid\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"tid",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

                PutField_CString(hOut,"plainttext_data",csAuthDATA);
                
		sprintf(csTag,"\"sign\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			PutField_CString(hOut,"sign",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}
        }

	FREE_ME(csPara);
	FREE_ME(csTmp);
	FREE_ME(csBuf);
	FREE_ME(csDATA);
	FREE_ME(csTmpDATA);
	FREE_ME(csAuthDATA);
	FREE_ME(hRec);
DEBUGLOG(("DBlockData Exit\n"));
	return  iRet;
}




int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
	int	iRet = PD_OK;

	return iRet;
}



void remove_quote(const char* csValue, const int iType,char* csOut)
{
	int i = 0;
	int cnt = 0;
	for(i=0; i<strlen(csValue);i++){
		if(csValue[i]!=iType){
			csOut[cnt] = csValue[i];
			cnt ++;
		}
		else{
		}
	}
	csOut[cnt]='\0';
}
