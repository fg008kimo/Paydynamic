/*
PDProTech (c)2018. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
 Init Version                                        2018/07/09              Cody Chan
 Add supported type				     2018/07/10		     LokMan Chow
*/

#include "msg.h"
static char	cDebug = 'Y';

/*

void print_json_value(json_object *jobj,const char* key){
	enum json_type type;

  		type = json_object_get_type(jobj);

  		switch (type) {
		case json_type_null:
		case json_type_array:
		case json_type_object:
DEBUGLOG(("unsupported type,[%s] [%d]\n",key,type));
        	break;
    		case json_type_boolean: 
DEBUGLOG(("json_type_boolearn [%s] = %s\n",key,json_object_get_boolean(jobj)? "true": "false"));
                         break;
    		case json_type_double:
DEBUGLOG(("json_type_double [%s] = [%lf]\n",key, json_object_get_double(jobj)));
                         break;
    		case json_type_int:
DEBUGLOG(("json_type_int [%s] = [%d]\n",key, json_object_get_int(jobj)));
                         break;
    		case json_type_string:
DEBUGLOG(("json_type_string [%s]  = [%s]\n",key,json_object_get_string(jobj)));
                         break;
  		}
}
*/


void json_parse_array( json_object *jobj, hash_t* hOut,char *csKey,char* key) {
        enum json_type type;
	char    csNewObj[PD_TMP_BUF_LEN +1];

	//json_bool  tmpJBool;

        json_object *jarray = jobj; /*Simply get the array*/
        if(key) {
                jarray = json_object_object_get(jobj, key); /*Getting the array if it is a key value pair*/

                /*tmpJBool = json_object_object_get_ex(jobj, key, (json_object **) jarray);*/ /*Getting the array if it is a key value pair*/
        }

        int arraylen = json_object_array_length(jarray); /*Getting the length of the array*/
DEBUGLOG(("[%s] Array Length: %d\n",key,arraylen));
DEBUGLOG(("[%s] = [%d]\n",csKey,arraylen));
	PutField_Int(hOut,csKey,arraylen);

        int i;
        json_object * jvalue;

	for (i=0; i< arraylen; i++){
		sprintf(csNewObj,"%s.%d",csKey,i);
                jvalue = json_object_array_get_idx(jarray, i); /*Getting the array element at position i*/
                type = json_object_get_type(jvalue);
DEBUGLOG(("type = [%d]\n",type));
                if (type == json_type_array) {
DEBUGLOG(("*parse_array\n"));
                        json_parse_array(jvalue,hOut, NULL,NULL);
                }
		else if (type == json_type_string) {
			PutField_CString(hOut, csKey, json_object_get_string(jvalue));
DEBUGLOG(("string [%s] = [%s]\n",key,json_object_get_string(jvalue)));
		}
                else if (type != json_type_object) {
DEBUGLOG(("*[%s]value[%d]: \n",i,key));
			ParseJArray(jvalue, hOut,key);
                }
                else {
DEBUGLOG(("*** parse [%s]\n",csNewObj));
			ParseJArray(jvalue, hOut,csNewObj);
                }
        }

}


/*
void json_parse(json_object * jobj, const char* ObjName) {
	enum json_type type;
	char    csKey[PD_TMP_BUF_LEN +1];
  	json_object_object_foreach(jobj, key, val) {
    	type = json_object_get_type(val);

	sprintf(csKey,"%s.%s",ObjName,key);
    	switch (type) {
      		case json_type_null: 
      		case json_type_boolean: 
      		case json_type_double: 
      		case json_type_int: 
      		case json_type_string: 
			   print_json_value(val,csKey);
                           break; 
      		case json_type_object: 
DEBUGLOG(("json_type_object\n"));
                           jobj = json_object_object_get(jobj, key);
                           json_parse(jobj,csKey); 
                           break;
     		 case json_type_array: 
DEBUGLOG(("type: json_type_array, \n"));
                          json_parse_array(jobj, key);
                          break;
    }
  }
} 
*/

int ParseJ(struct json_object * jobj, hash_t* hOut)
{
        enum    json_type type;
        int     iRet = PD_OK;


DEBUGLOG(("ParseJ:: start...\n"));
        if (jobj != NULL) {
//DEBUGLOG(("ParseJ:: jobj is not null\n"));
                json_object_object_foreach(jobj, key, val) {
//DEBUGLOG(("ParseJ:: jobj for each\n"));
                        type = json_object_get_type(val);
                        switch (type) {
                                case json_type_string:
					if(strlen(json_object_get_string(val)) > 0){
						PutField_CString(hOut, key, json_object_get_string(val));
DEBUGLOG(("ParseJ:: supported type,[%d] string [%s] = [%s]\n",type,key,json_object_get_string(val)));
					}
                                break;
                                case json_type_object:
DEBUGLOG(("ParseJ:: type is an object [%s]\n",key));
                                         ParseJ(val, hOut);
                                break;
                                case json_type_null:
DEBUGLOG(("ParseJ:: supported type,[%d] [%s] = NULL\n",type,key));
                                        //iRet = PD_ERR;
                                break;
                                case json_type_boolean:
                                        PutField_Int(hOut, key, json_object_get_int(val));
DEBUGLOG(("ParseJ:: supported type,[%d] boolean [%s] = [%d]\n",type,key,json_object_get_int(val)));
                                break;
                                case json_type_double:
                                        PutField_Double(hOut, key, json_object_get_double(val));
DEBUGLOG(("ParseJ:: supported type,[%d] double [%s] = [%lf]\n",type,key,json_object_get_double(val)));
                                break;
                                case json_type_int:
                                        PutField_Int(hOut, key, json_object_get_int(val));
DEBUGLOG(("ParseJ:: supported type,[%d] int [%s] = [%d]\n",type,key,json_object_get_int(val)));
                                break;
                                case json_type_array:
DEBUGLOG(("ParseJ:: unsupported type,[%d] array [%s]\n",type, key));
					iRet = PD_ERR;
                                break;
                                default:
DEBUGLOG(("ParseJ:: unsupported type,%d\n",type));
                                        iRet = PD_ERR;
                                break;
                        }
                }
        }
        else {
DEBUGLOG(("ParseJ is null\n"));
        }


DEBUGLOG(("ParseJ Exit\n"));

        return  iRet;

}

int ParseJArray(struct json_object * jobj, hash_t* hOut,const char* csObjName)
{
        enum    json_type type;
        int     iRet = PD_OK;
	char   	csKey[PD_TMP_BUF_LEN +1];

DEBUGLOG(("ParseJArray:: start...\n"));
        if (jobj != NULL) {
//DEBUGLOG(("ParseJArray:: jobj is not null\n"));
                json_object_object_foreach(jobj, key, val) {
//DEBUGLOG(("ParseJArray:: jobj for each\n"));
			if (csObjName != NULL) 
				sprintf(csKey,"%s.%s",csObjName,key);
			else
				strcpy(csKey,key);
                        type = json_object_get_type(val);
                        switch (type) {
                                case json_type_string:
                                        PutField_CString(hOut, csKey, json_object_get_string(val));
DEBUGLOG(("ParseJArray:: supported type,[%d] string [%s] = [%s]\n",type,csKey,json_object_get_string(val)));
                                break;
                                case json_type_object:
DEBUGLOG(("ParseJArray:: type is an object [%s]\n",csKey));
                                         ParseJArray(val, hOut,csKey);
                                break;
                                case json_type_null:
DEBUGLOG(("ParseJArray:: supported type,[%d] [%s] = NULL\n",type, csKey));
                                break;
                                case json_type_boolean:
                                        PutField_Int(hOut, csKey, json_object_get_int(val));
DEBUGLOG(("ParseJArray:: supported type,[%d] boolean [%s] = [%d]\n",type,csKey,json_object_get_int(val)));
                                break;
                                case json_type_double:
DEBUGLOG(("ParseJArray:: supported type,[%d] double\n",type));
                                        PutField_Double(hOut, csKey, json_object_get_double(val));
DEBUGLOG(("ParseJArray:: supported type,[%d] double [%s] = [%lf]\n",type,csKey,json_object_get_double(val)));
                                break;
                                case json_type_int:
                                        PutField_Int(hOut, csKey, json_object_get_int(val));
DEBUGLOG(("ParseJArray:: supported type,[%d] int [%s] = [%d]\n",type,csKey,json_object_get_int(val)));
                                break;
                                case json_type_array:
DEBUGLOG(("ParseJArray:: supported type,[%d] array [%s]\n",type, csKey));
					json_parse_array(jobj, hOut,csKey,key);
                                break;
                                default:
DEBUGLOG(("ParseJArray:: unsupported type,%d\n",type));
                                        iRet = PD_ERR;
                                break;
                        }
                }
        }
        else {
DEBUGLOG(("PParseJArray is null\n"));
        }


DEBUGLOG(("ParseJArray Exit\n"));

        return  iRet;

}

