/*
Partnerdelight (c)2015. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/06/16              Cody Chan
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "MmmMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include "internal.h"
#include <zlib.h>
#include "ObjPtr.h"
#include <expat.h>
#include "b64.h"

#define PD_XML_HEADER           "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
#define PD_ROOT_ELEMENT         "PH"
#define	PD_XML_TXN_CODE_TAG	"tc"
#define	PD_TXN_CODE_TAG		"txn_code"
#define	PD_NATURE_GROUP		"nat"
#define	PD_TXN			"txn"
#define	PD_BAL			"bal"
#define	PD_DST_DATA		"dst_data"
#define	PD_SRC_DATA		"src_data"
#define	PD_CONCAT_STR		"."

#ifdef XML_LARGE_SIZE
#if defined(XML_USE_MSC_EXTENSIONS) && _MSC_VER < 1400
#define XML_FMT_INT_MOD "I64"
#else
#define XML_FMT_INT_MOD "ll"
#endif
#else
#define XML_FMT_INT_MOD "l"
#endif

int iIsTag = 0;
char	cDebug;

char	csTmpTag[PD_TMP_BUF_LEN + 1];
char*   csTag[PD_MAX_TAG];
char*   csValue[PD_MAX_TAG];
int	iTotal = 0;

void	MmmMsg(char cdebug)
{
	cDebug = cdebug;
}

/* track the current level in the xml tree */
static int      depth = 0;

static char    *last_content;

/* first when start element is encountered */
void
startElement(void *data, const char *element, const char **attribute)
{
    int             i;

    for (i = 0; i < depth; i++) {
//DEBUGLOG((" \n"));
    }

	if (!strcmp(element,PD_NATURE_GROUP) ||
	   !strcmp(element,PD_TXN) ||
	   !strcmp(element,PD_BAL) ||
	   !strcmp(element,PD_DST_DATA) ||
	   !strcmp(element,PD_SRC_DATA)
	) {
//DEBUGLOG(("start*** depth = [%d]\n",depth));
		if (depth == 1)
			strcpy(csTmpTag,element);
		else {
			strcat(csTmpTag,PD_CONCAT_STR);
			strcat(csTmpTag,element);
		}
	}
//DEBUGLOG(("*START***[%s]\n", element));
	iIsTag=1;

   	for (i = 0; attribute[i]; i += 2) {
		if (!strcmp(attribute[i],"id") ){
			strcat(csTmpTag,PD_CONCAT_STR);
			strcat(csTmpTag,attribute[i+1]);
		}
//DEBUGLOG(("***[%d] %s= '%s'\n",i, attribute[i], attribute[i + 1]));
   	}

//DEBUGLOG(("\n"));
    	depth++;
}

/* decrement the current level of the tree */
void
endElement(void *data, const char *el)
{
    	int             i;
    	for (i = 0; i < depth; i++) {
//        DEBUGLOG((" \n"));
    	}
	if (iIsTag ==1 ) {
		char *csTmp;
        	csTmp = (char*) malloc (PD_TMP_BUF_LEN +1);
		if (depth == 2) {
DEBUGLOG(("[%03d]<%s>%s</%s>\n",iTotal, el, last_content,el));
			sprintf(csTmp,"%s",el);
			csTag[iTotal] = strdup(csTmp);
		}
		else {
DEBUGLOG(("[%03d]<%s.%s>%s</%s.%s>\n",iTotal, csTmpTag,el, last_content,csTmpTag,el));
			sprintf(csTmp,"%s%s%s",csTmpTag,PD_CONCAT_STR,el);
			csTag[iTotal] = strdup(csTmp);
		}
		sprintf(csTmp,"%s",last_content);
		csValue[iTotal] = strdup(csTmp);
		iTotal++;
		FREE_ME(csTmp);
	}

	iIsTag--;
    	depth--;
}

void
handle_data(void *data, const char *content, int length)
{
    char           *tmp = malloc(length);
    strncpy(tmp, content, length);
    tmp[length] = '\0';
    data = (void *) tmp;
    last_content = tmp;         /* TODO: concatenate the text nodes? */
}

int FormatMsg(const hash_t* hIn,unsigned char *outMsg,int *outLen)
{
	int iRet = PD_OK;
	char*	csTxnCode;
	char*	csPtr;
	char*	csBuf,*csTag,*csTmp;

        csBuf = (char*) malloc (PD_MAX_BUFFER +1);
        csTag = (char*) malloc (PD_TMP_BUF_LEN +1);
        csTmp = (char*) malloc (PD_TMP_BUF_LEN +1);

        
        strcpy((char*)outMsg,PD_XML_HEADER);

/* Root Element */
        sprintf(csBuf,"<%s>",PD_ROOT_ELEMENT);
        strcat((char*)outMsg,csBuf);

/* reply_txn_code */
        strcpy(csTag,"reply_txn_code");
        if (GetField_CString(hIn,csTag,&csTxnCode)) {
        	strcpy(csTag,"reply_tc");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csTxnCode));
                sprintf(csBuf,"<%s>%s</%s>",csTag,csTxnCode,csTag);
                strcat((char*)outMsg,csBuf);
        }

/* response_code */
        strcpy(csTag,"response_code");
        if (GetField_CString(hIn,csTag,&csPtr)) {
                strcpy(csTag,"ret");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csPtr));
                sprintf(csBuf,"<%s>%s</%s>",csTag,csPtr,csTag);
                strcat((char*)outMsg,csBuf);
        }

/* txn_seq */
        strcpy(csTag,"txn_seq");
        if (GetField_CString(hIn,csTag,&csPtr)) {
                strcpy(csTag,"ret");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csPtr));
        	strcpy(csTag,"txnid");
                sprintf(csBuf,"<%s>%s</%s>",csTag,csPtr,csTag);
                strcat((char*)outMsg,csBuf);
        }

/* related_txn_seq */
        strcpy(csTag,"related_txn_seq");
        if (GetField_CString(hIn,csTag,&csPtr)) {
                strcpy(csTag,"ret");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csPtr));
        	strcpy(csTag,"fx_txnid");
                sprintf(csBuf,"<%s>%s</%s>",csTag,csPtr,csTag);
                strcat((char*)outMsg,csBuf);
        }

/* adj_code */
        strcpy(csTag,"adj_code");
        if (GetField_CString(hIn,csTag,&csPtr)) {
                strcpy(csTag,"ret");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csPtr));
                sprintf(csBuf,"<%s>%s</%s>",csTag,csPtr,csTag);
                strcat((char*)outMsg,csBuf);
        }


/* Root Element */
        sprintf(csBuf,"</%s>",PD_ROOT_ELEMENT);
        strcat((char*)outMsg,csBuf);
        *outLen = strlen((char*)outMsg);

	FREE_ME(csTag);
	FREE_ME(csBuf);
	FREE_ME(csTmp);
DEBUGLOG(("FormatMsg:: out = [%s]\n",outMsg));
DEBUGLOG(("FormatMsg:: iRet = [%d]\n",iRet));
	return iRet;
}

int BreakDownMsg(hash_t *hOut,const unsigned char *inMsg,int inLen)
{
	int	iRet = PD_OK;
	int	i;
	int     userData = 0;
	int     done = 0;

	XML_Parser parser;

DEBUGLOG(("BreakDownMsg [%s][%d]\n",inMsg,inLen));
DEBUGLOG(("BreakDownMsg Alloced\n"));
	parser = XML_ParserCreate((XML_Char *)"UTF-8");
	XML_SetUserData(parser, &userData);
	XML_SetElementHandler(parser, startElement, endElement);
	XML_SetCharacterDataHandler(parser,handle_data);
	
DEBUGLOG(("BreakDownMsg try to parse\n"));
	if (!XML_Parse(parser, (char*)inMsg, inLen, done)) {
DEBUGLOG(("BreakDownMsg %s at line %d\n", XML_ErrorString(XML_GetErrorCode(parser)), XML_GetCurrentLineNumber(parser)));
ERRLOG("Mmmsg::BreakDownMsg %s at line %d\n", XML_ErrorString(XML_GetErrorCode(parser)), XML_GetCurrentLineNumber(parser));
		return PD_ERR;
	}	
DEBUGLOG(("BreakDownMsg after try to parse\n"));

	XML_ParserFree(parser);

DEBUGLOG(("BreakDownMsg Total Count = [%d]\n",iTotal));
	for (i = 0 ; i < iTotal; i++) {
DEBUGLOG(("BreakDownMsg [%03d] %s=%s\n",i,csTag[i],csValue[i]));
/* txn code  */
		if (!strcmp(csTag[i],PD_XML_TXN_CODE_TAG))
			PutField_CString(hOut,PD_TXN_CODE_TAG,csValue[i]);
/* entity id  */
		else if (!strcmp(csTag[i],"eid"))
			PutField_CString(hOut,"entity_id",csValue[i]);
/* action  */
		else if (!strcmp(csTag[i],"action"))
			PutField_Char(hOut,"action",csValue[i][0]);
		else
			PutField_CString(hOut,csTag[i],csValue[i]);
		FREE_ME(csTag[i]);
		FREE_ME(csValue[i]);
	}

DEBUGLOG(("BreakDownMsg Normal Exit iRet = [%d]\n",iRet));
        return iRet;
}


int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
        int     iRet = PD_OK;
	char	*csPtr;


DEBUGLOG(("initReplyFromRequest()\n"));

        if (GetField_CString(hRequest,"txn_code",&csPtr)) {
DEBUGLOG(("initReplyFromRequest()txn_code = [%s]\n",csPtr));
                PutField_CString(hResponse,"reply_txn_code",csPtr);
        }

        if (GetField_CString(hRequest,"adj_code",&csPtr)) {
DEBUGLOG(("initReplyFromRequest()adj_code = [%s]\n",csPtr));
                PutField_CString(hResponse,"adj_code",csPtr);
        }


DEBUGLOG(("initReplyFromRequest() ret = [%d]\n",iRet));
	return iRet;
}



