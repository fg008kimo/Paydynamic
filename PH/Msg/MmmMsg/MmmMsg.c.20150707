/*
Partnerdelight (c)2015. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/06/16              Cody Chan
Add response <eid>				   2015/07/03		   Dirk Wong
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "MmmMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include "internal.h"
#include <zlib.h>
#include "ObjPtr.h"
#include <expat.h>
#include "b64.h"

#define PD_XML_HEADER           "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
#define PD_ROOT_ELEMENT         "PH"
#define	PD_CONCAT_STR		"."

#ifdef XML_LARGE_SIZE
#if defined(XML_USE_MSC_EXTENSIONS) && _MSC_VER < 1400
#define XML_FMT_INT_MOD "I64"
#else
#define XML_FMT_INT_MOD "ll"
#endif
#else
#define XML_FMT_INT_MOD "l"
#endif

	int iIsTag = 0;
	char	cDebug;

	char	csTmpTag[PD_TMP_BUF_LEN + 1];
	char	csD1TmpTag[PD_TMP_BUF_LEN + 1];
	char	csD2TmpTag[PD_TMP_BUF_LEN + 1];
	char	csD3TmpTag[PD_TMP_BUF_LEN + 1];
	char	csD4TmpTag[PD_TMP_BUF_LEN + 1];
	char*   csTag[PD_MAX_TAG];
	char*   csValue[PD_MAX_TAG];
	int	iTotal = 0;

void	MmmMsg(char cdebug)
{
	cDebug = cdebug;
}

/* track the current level in the xml tree */
static int      depth = 0;

static char    *last_content;

/* first when start element is encountered */
void
startElement(void *data, const char *element, const char **attribute)
{
    	int	i;
	char	csBuf[PD_TMP_BUF_LEN +1];
	

    for (i = 0; i < depth; i++) {
//DEBUGLOG((" \n"));
    }

/* txn_code */
	if (!strcmp(element,"tc"))
		strcpy(csBuf,"txn_code");
/* entity_id */
	else if (!strcmp(element,"eid"))
		strcpy(csBuf,"entity_id");
/* entity_name */
	else if (!strcmp(element,"ename"))
		strcpy(csBuf,"entity_name");
/* client_id */
	else if (!strcmp(element,"cid"))
		strcpy(csBuf,"client_id");
	else 	
		strcpy(csBuf,element);

	if (depth == 1) {
		strcpy(csD1TmpTag,csBuf);
		csD2TmpTag[0] = '\0';
		csD3TmpTag[0] = '\0';
		csD4TmpTag[0] = '\0';
		strcpy(csTmpTag,csD1TmpTag);
	}
	else if (depth == 2) {
		strcpy(csD2TmpTag,csBuf);
		csD3TmpTag[0] = '\0';
		csD4TmpTag[0] = '\0';
		strcpy(csTmpTag,csD1TmpTag);
		strcat(csTmpTag,PD_CONCAT_STR);
		strcat(csTmpTag,csD2TmpTag);
	}
	else if (depth == 3) {
		strcpy(csD3TmpTag,csBuf);
		csD4TmpTag[0] = '\0';

		strcpy(csTmpTag,csD1TmpTag);
		strcat(csTmpTag,PD_CONCAT_STR);
		strcat(csTmpTag,csD2TmpTag);
		strcat(csTmpTag,PD_CONCAT_STR);
		strcat(csTmpTag,csD3TmpTag);
	}
	else if (depth == 4) {
		strcpy(csD4TmpTag,csBuf);
		strcpy(csTmpTag,csD1TmpTag);
		strcat(csTmpTag,PD_CONCAT_STR);
		strcat(csTmpTag,csD2TmpTag);
		strcat(csTmpTag,PD_CONCAT_STR);
		strcat(csTmpTag,csD3TmpTag);
		strcat(csTmpTag,PD_CONCAT_STR);
		strcat(csTmpTag,csD4TmpTag);
	}
	iIsTag=1;

   	for (i = 0; attribute[i]; i += 2) {
		if (!strcmp(attribute[i],"id") ){
			strcat(csTmpTag,PD_CONCAT_STR);
			strcat(csTmpTag,attribute[i+1]);
			if (depth == 1) {
				strcat(csD1TmpTag,PD_CONCAT_STR);
				strcat(csD1TmpTag,attribute[i+1]);
			}
			else if (depth == 2) {
				strcat(csD2TmpTag,PD_CONCAT_STR);
				strcat(csD2TmpTag,attribute[i+1]);
			}
			else if (depth == 3) {
				strcat(csD3TmpTag,PD_CONCAT_STR);
				strcat(csD3TmpTag,attribute[i+1]);
			}
			else if (depth == 4) {
				strcat(csD4TmpTag,PD_CONCAT_STR);
				strcat(csD4TmpTag,attribute[i+1]);
			}
		}
//DEBUGLOG(("***[%d] %s= '%s'\n",i, attribute[i], attribute[i + 1]));
   	}

//DEBUGLOG(("*START***[%s] [%s]\n", element,csTmpTag));
//DEBUGLOG(("*START*********************\n"));
//DEBUGLOG(("\n"));
    	depth++;
}

/* decrement the current level of the tree */
void
endElement(void *data, const char *el)
{
    	int             i;
    	for (i = 0; i < depth; i++) {
//        DEBUGLOG((" \n"));
    	}
	if (iIsTag ==1 ) {
		char *csTmp;
        	csTmp = (char*) malloc (PD_TMP_BUF_LEN +1);
DEBUGLOG(("[%03d]<%s>%s</%s>\n",iTotal, csTmpTag, last_content,csTmpTag));
		csTag[iTotal] = strdup(csTmpTag);

		sprintf(csTmp,"%s",last_content);
		csValue[iTotal] = strdup(csTmp);
		iTotal++;
		FREE_ME(csTmp);
	}

	iIsTag--;
    	depth--;
}

void
handle_data(void *data, const char *content, int length)
{
    char           *tmp = malloc(length);
    strncpy(tmp, content, length);
    tmp[length] = '\0';
    data = (void *) tmp;
    last_content = tmp;         /* TODO: concatenate the text nodes? */
}

int FormatMsg(const hash_t* hIn,unsigned char *outMsg,int *outLen)
{
	int iRet = PD_OK;
	char*	csTxnCode;
	char*	csPtr;
	char*	csBuf,*csTag,*csTmp;

        csBuf = (char*) malloc (PD_MAX_BUFFER +1);
        csTag = (char*) malloc (PD_TMP_BUF_LEN +1);
        csTmp = (char*) malloc (PD_TMP_BUF_LEN +1);

        
        strcpy((char*)outMsg,PD_XML_HEADER);

/* Root Element */
        sprintf(csBuf,"<%s>",PD_ROOT_ELEMENT);
        strcat((char*)outMsg,csBuf);

/* reply_txn_code */
        strcpy(csTag,"reply_txn_code");
        if (GetField_CString(hIn,csTag,&csTxnCode)) {
        	strcpy(csTag,"reply_tc");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csTxnCode));
                sprintf(csBuf,"<%s>%s</%s>",csTag,csTxnCode,csTag);
                strcat((char*)outMsg,csBuf);
        }

/* response_code */
        strcpy(csTag,"response_code");
        if (GetField_CString(hIn,csTag,&csPtr)) {
                strcpy(csTag,"ret");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csPtr));
                sprintf(csBuf,"<%s>%s</%s>",csTag,csPtr,csTag);
                strcat((char*)outMsg,csBuf);
        }

/* txn_seq */
        strcpy(csTag,"txn_seq");
        if (GetField_CString(hIn,csTag,&csPtr)) {
                strcpy(csTag,"ret");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csPtr));
        	strcpy(csTag,"txnid");
                sprintf(csBuf,"<%s>%s</%s>",csTag,csPtr,csTag);
                strcat((char*)outMsg,csBuf);
        }

/* related_txn_seq */
        strcpy(csTag,"related_txn_seq");
        if (GetField_CString(hIn,csTag,&csPtr)) {
                strcpy(csTag,"ret");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csPtr));
        	strcpy(csTag,"fx_txnid");
                sprintf(csBuf,"<%s>%s</%s>",csTag,csPtr,csTag);
                strcat((char*)outMsg,csBuf);
        }

/* adj_code */
        strcpy(csTag,"adj_code");
        if (GetField_CString(hIn,csTag,&csPtr)) {
                strcpy(csTag,"ret");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csPtr));
                sprintf(csBuf,"<%s>%s</%s>",csTag,csPtr,csTag);
                strcat((char*)outMsg,csBuf);
        }

/* eid */
        strcpy(csTag,"eid");
        if (GetField_CString(hIn,csTag,&csPtr)) {
                strcpy(csTag,"eid");
DEBUGLOG(("FormatMsg <%s> = <%s>\n",csTag,csPtr));
                sprintf(csBuf,"<%s>%s</%s>",csTag,csPtr,csTag);
                strcat((char*)outMsg,csBuf);
        }


/* Root Element */
        sprintf(csBuf,"</%s>",PD_ROOT_ELEMENT);
        strcat((char*)outMsg,csBuf);
        *outLen = strlen((char*)outMsg);

	FREE_ME(csTag);
	FREE_ME(csBuf);
	FREE_ME(csTmp);
DEBUGLOG(("FormatMsg:: out = [%s]\n",outMsg));
DEBUGLOG(("FormatMsg:: iRet = [%d]\n",iRet));
	return iRet;
}

int BreakDownMsg(hash_t *hOut,const unsigned char *inMsg,int inLen)
{
	int	iRet = PD_OK;
	int	i;
	int     userData = 0;
	int     done = 0;


	XML_Parser parser;

DEBUGLOG(("BreakDownMsg [%s][%d]\n",inMsg,inLen));
DEBUGLOG(("BreakDownMsg Alloced\n"));
	iIsTag = 0;
	parser = XML_ParserCreate((XML_Char *)"UTF-8");
	XML_SetUserData(parser, &userData);
	XML_SetElementHandler(parser, startElement, endElement);
	XML_SetCharacterDataHandler(parser,handle_data);
	
DEBUGLOG(("BreakDownMsg try to parse\n"));
	if (!XML_Parse(parser, (char*)inMsg, inLen, done)) {
DEBUGLOG(("BreakDownMsg %s at line %d\n", XML_ErrorString(XML_GetErrorCode(parser)), XML_GetCurrentLineNumber(parser)));
ERRLOG("Mmmsg::BreakDownMsg %s at line %d\n", XML_ErrorString(XML_GetErrorCode(parser)), XML_GetCurrentLineNumber(parser));
		return PD_ERR;
	}	
DEBUGLOG(("BreakDownMsg after try to parse\n"));

	XML_ParserFree(parser);

DEBUGLOG(("BreakDownMsg Total Count = [%d]\n",iTotal));
	for (i = 0 ; i < iTotal; i++) {
DEBUGLOG(("BreakDownMsg [%03d] %s=%s\n",i,csTag[i],csValue[i]));
/* action */
		if (!strcmp(csTag[i],"action"))
			PutField_Char(hOut,csTag[i],csValue[i][0]);
		else
			PutField_CString(hOut,csTag[i],csValue[i]);
	}

DEBUGLOG(("BreakDownMsg Normal Exit iRet = [%d]\n",iRet));
        return iRet;
}


int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
        int     iRet = PD_OK;
	char	*csPtr;


DEBUGLOG(("initReplyFromRequest()\n"));

        if (GetField_CString(hRequest,"txn_code",&csPtr)) {
DEBUGLOG(("initReplyFromRequest()txn_code = [%s]\n",csPtr));
                PutField_CString(hResponse,"reply_txn_code",csPtr);
        }

        if (GetField_CString(hRequest,"adj_code",&csPtr)) {
DEBUGLOG(("initReplyFromRequest()adj_code = [%s]\n",csPtr));
                PutField_CString(hResponse,"adj_code",csPtr);
        }


DEBUGLOG(("initReplyFromRequest() ret = [%d]\n",iRet));
	return iRet;
}



