/*
PDProTech (c)2018. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version					   2018/07/18		   David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "ZpqMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include <zlib.h>
#include "b64.h"
#include "ObjPtr.h"
#define __USE_XOPEN
#include <time.h>
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"
#include <json-c/json.h>
#include <openssl/rsa.h>


OBJPTR(DB);
OBJPTR(BO);
static char cDebug;


struct key_value_pair
{
	char key[PD_TMP_BUF_LEN];
	char value[PD_TMP_MSG_BUF_LEN];
};


void ZpqMsg(char cdebug)
{
	cDebug = cdebug;
}


char *str_replace(char *orig, char *rep, char *with);


int FormatMsg(const hash_t *hIn, unsigned char *outMsg, int *outLen)
{
	int	iRet = PD_OK;

	char	*csPtr = NULL;
	char	*csBuf;
	char	*csCodeURL;
	int	iTmp;
	int	iTmpRet;

	hash_t	*hLog;
	hLog = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hLog, 0);

DEBUGLOG(("FormatMsg()\n"));

	outMsg[0] = '\0';

/* return_code */
	if (GetField_CString(hIn, "return_code", &csPtr)) {
DEBUGLOG(("return_code = [%s]\n", csPtr));
		strcat((char*)outMsg, "return_code");
		strcat((char*)outMsg, MY_ZPQ_FIELD_TOKEN);
		if (!strcmp(csPtr, MY_ZPQ_SUCCESS_STATUS))
			strcat((char*)outMsg, "SUCCESS");
		else
			strcat((char*)outMsg, csPtr);
		strcat((char*)outMsg, MY_ZPQ_TOKEN);
	} else {
DEBUGLOG(("return_code is missing\n"));
	}

/* code_url */
	if (GetField_CString(hIn, "code_url", &csPtr)) {
DEBUGLOG(("code_url = [%s]\n", csPtr));
		strcat((char*)outMsg, "code_url");
		strcat((char*)outMsg, MY_ZPQ_FIELD_TOKEN);
		csCodeURL = (char*) malloc (PD_MAX_BUFFER + 1);
		memset(csCodeURL, 0, sizeof(csCodeURL));
		base64_encode((unsigned char*)csPtr, strlen((char*)csPtr), csCodeURL, PD_MAX_BUFFER);
		strcat((char*)outMsg, csCodeURL);
		strcat((char*)outMsg, MY_ZPQ_TOKEN);
		FREE_ME(csCodeURL);
	} else {
DEBUGLOG(("code_url is missing\n"));
	}

/* txn_seq */
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
DEBUGLOG(("txn_seq = [%s]\n", csPtr));
		DBObjPtr = CreateObj(DBPtr, "DBTxnQrRequestLog", "GetByTxnId");
		iTmpRet = (unsigned long int)(*DBObjPtr)(csPtr, hLog);
		if (iTmpRet == PD_FOUND) {
/* time_init */
			if (GetField_CString(hLog, "qrcode_init_timestamp", &csPtr)) {
DEBUGLOG(("time_init = [%s]\n", csPtr));
				strcat((char*)outMsg, "time_init");
				strcat((char*)outMsg, MY_ZPQ_FIELD_TOKEN);
				strcat((char*)outMsg, csPtr);
				strcat((char*)outMsg, MY_ZPQ_TOKEN);
			} else {
DEBUGLOG(("time_init is missing\n"));
			}

/* time_expire */
			if (GetField_Int(hLog, "expiry", &iTmp)) {
				char csTimeExpire[PD_TMP_BUF_LEN + 1];
				sprintf((char*)csTimeExpire, "%d", iTmp);
DEBUGLOG(("time_expire = [%s]\n", csTimeExpire));
				strcat((char*)outMsg, "time_expire");
				strcat((char*)outMsg, MY_ZPQ_FIELD_TOKEN);
				strcat((char*)outMsg, csTimeExpire);
				strcat((char*)outMsg, MY_ZPQ_TOKEN);
			} else {
DEBUGLOG(("time_expire is missing\n"));
			}

/* time_enable */
			if (GetField_Int(hLog, "enable_button", &iTmp)) {
				char csTimeEnable[PD_TMP_BUF_LEN + 1];
				sprintf((char*)csTimeEnable, "%d", iTmp);
DEBUGLOG(("time_enable = [%s]\n", csTimeEnable));
				strcat((char*)outMsg, "time_enable");
				strcat((char*)outMsg, MY_ZPQ_FIELD_TOKEN);
				strcat((char*)outMsg, csTimeEnable);
				strcat((char*)outMsg, MY_ZPQ_TOKEN);
			} else {
DEBUGLOG(("time_enable is missing\n"));
			}

/* time_auto_check */
			if (GetField_Int(hLog, "auto_check_txn_status", &iTmp)) {
				char csTimeAutoCheck[PD_TMP_BUF_LEN + 1];
				sprintf((char*)csTimeAutoCheck, "%d", iTmp);
DEBUGLOG(("time_auto_check = [%s]\n", csTimeAutoCheck));
				strcat((char*)outMsg, "time_auto_check");
				strcat((char*)outMsg, MY_ZPQ_FIELD_TOKEN);
				strcat((char*)outMsg, csTimeAutoCheck);
				strcat((char*)outMsg, MY_ZPQ_TOKEN);
			} else {
DEBUGLOG(("time_auto_check is missing\n"));
			}

/* time_redirect */
			if (GetField_Int(hLog, "redirect", &iTmp)) {
				char csTimeRedirect[PD_TMP_BUF_LEN + 1];
				sprintf((char*)csTimeRedirect, "%d", iTmp);
DEBUGLOG(("time_redirect = [%s]\n", csTimeRedirect));
				strcat((char*)outMsg, "time_redirect");
				strcat((char*)outMsg, MY_ZPQ_FIELD_TOKEN);
				strcat((char*)outMsg, csTimeRedirect);
				strcat((char*)outMsg, MY_ZPQ_TOKEN);
			} else {
DEBUGLOG(("time_redirect is missing\n"));
			}

/* time_curr */
			if (GetField_CString(hLog, "qrcode_curr_timestamp", &csPtr)) {
DEBUGLOG(("time_curr = [%s]\n", csPtr));
				strcat((char*)outMsg, "time_db_local");
				strcat((char*)outMsg, MY_ZPQ_FIELD_TOKEN);
				strcat((char*)outMsg, csPtr);
			} else {
DEBUGLOG(("time_curr is missing\n"));
			}
		}
	} else {
DEBUGLOG(("txn_seq is missing\n"));
	}

DEBUGLOG(("outmsg = [%s]\n", outMsg));

	csBuf = (char*) malloc (PD_MAX_BUFFER + 1);
	memset(csBuf, 0, sizeof(csBuf));
	base64_encode(outMsg, strlen((char*)outMsg), csBuf, PD_MAX_BUFFER);
	outMsg[0] = '\0';
	strcat((char*)outMsg, "qr_parameter");
	strcat((char*)outMsg, "=");
	strcat((char*)outMsg, csBuf);
	FREE_ME(csBuf);
	*outLen = strlen((const char*)outMsg);

DEBUGLOG(("FormatMsg() [%s][%d]\n", outMsg, *outLen));
DEBUGLOG(("FormatMsg() Exit\n"));

	FREE_ME(csPtr);
	hash_destroy(hLog);
	FREE_ME(hLog);

	return iRet;
}


int BuildAuthData(hash_t *hIn)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csBuf;
	double	dTmp;
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

DEBUGLOG(("BuildAuthData()\n"));
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

// Amount
	if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
		char csTmpAmt[PD_TMP_BUF_LEN + 1];
		sprintf((char*)csTmpAmt, "%.2f", dTmp);
		strcat((char*)csBuf, csTmpAmt);
DEBUGLOG(("Amount = [%s]\n", csTmpAmt));
	}
	else {
DEBUGLOG(("psp_txn_amt is missing\n"));
	}

// Currency
	if (GetField_CString(hIn, "psp_txn_ccy", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Currency = [%s]\n", csPtr));
	}
	else {
		strcat((char*)csBuf, MY_ZPQ_CCY_CODE);
DEBUGLOG(("Currency (default) = [%s]\n", MY_ZPQ_CCY_CODE));
	}

// Merchant_Ref
	if (GetField_CString(hIn, "order_num", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Merchant_Ref = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("order_num is missing\n"));
	}

// Merchant_ID
	if (GetField_CString(hIn, "psp_merchant_id", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Merchant_ID = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("psp_merchant_id is missing\n"));
	}

// Mer_txn_date
	if (GetField_CString(hIn, "local_tm_date", &csPtr)) {
		char *csPtr2 = NULL;
		char csDateTime[PD_DATETIME_LEN * 2];
		if (GetField_CString(hIn, "local_tm_time", &csPtr2)) {
			sprintf(csDateTime, "%s%s", csPtr, csPtr2);
			strcat((char*)csBuf, csDateTime);
DEBUGLOG(("Mer_txn_date = [%s]\n", csDateTime));
		}
		else {
DEBUGLOG(("local_tm_time is missing\n"));
		}
	}
	else {
DEBUGLOG(("local_tm_date is missing\n"));
	}

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);

DEBUGLOG(("BuildAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


int BreakDownMsg(hash_t *hOut, const unsigned char *inMsg, int inLen)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	csMsg[PD_MAX_BUFFER + 1];
	char	csTmp[PD_TMP_BUF_LEN + 1];
	hash_t	*hRec;

	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	csMsg[0] = '\0';

DEBUGLOG(("BreakDownMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n", inMsg, inLen));

	struct json_object *jobj;
	enum json_type type;

	jobj = json_tokener_parse((const char *)inMsg);
	if (jobj != NULL) {
		json_object_object_foreach(jobj, key, val) {
			type = json_object_get_type(val);
			switch (type) {
				case json_type_string:
					PutField_CString(hRec, key, json_object_get_string(val));
				break;
				case json_type_int:
					sprintf(csTmp, "%d", json_object_get_int(val));
					PutField_CString(hRec, key, csTmp);
				break;
				case json_type_double:
					sprintf(csTmp, "%.2f", json_object_get_double(val));
					PutField_CString(hRec, key, csTmp);
				break;
				default:
DEBUGLOG(("BreakDownMsg:: unsupported type\n"));
				break;
			}
		}

		if (GetField_CString(hRec, "Merchant_ID", &csPtr)) {
			PutField_CString(hOut, "psp_merchant_id", csPtr);
DEBUGLOG(("Merchant_ID = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Merchant_ID not found\n"));
		}

		if (GetField_CString(hRec, "Merchant_Ref", &csPtr)) {
			PutField_CString(hOut, "txn_seq", csPtr);
DEBUGLOG(("Merchant_Ref = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Merchant_Ref not found\n"));
		}

		if (GetField_CString(hRec, "Mer_txn_date", &csPtr)) {
			PutField_CString(hOut, "Mer_txn_date", csPtr);
DEBUGLOG(("Mer_txn_date = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Mer_txn_date not found\n"));
		}

		if (GetField_CString(hRec, "Order_txn_date", &csPtr)) {
DEBUGLOG(("Order_txn_date = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Order_txn_date not found\n"));
		}

		if (GetField_CString(hRec, "Status", &csPtr)) {
			PutField_CString(hOut, "status", csPtr);
DEBUGLOG(("Status = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Status not found\n"));
		}

		if (GetField_CString(hRec, "Status_Msg", &csPtr)) {
DEBUGLOG(("Status_Msg = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Status_Msg not found\n"));
		}

		if (GetField_CString(hRec, "Order_Ref", &csPtr)) {
			PutField_CString(hOut, "tid", csPtr);
DEBUGLOG(("Order_Ref = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Order_Ref not found\n"));
		}

		if (GetField_CString(hRec, "Currency", &csPtr)) {
			PutField_CString(hOut, "Currency", csPtr);
DEBUGLOG(("Currency = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Currency not found\n"));
		}

		if (GetField_CString(hRec, "Amount", &csPtr)) {
			PutField_CString(hOut, "txn_amt", csPtr);
DEBUGLOG(("Amount = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Amount not found\n"));
		}

		if (GetField_CString(hRec, "Service_Fee", &csPtr)) {
DEBUGLOG(("Service_Fee = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Service_Fee not found\n"));
		}

		if (GetField_CString(hRec, "Signature", &csPtr)) {
			PutField_CString(hOut, "sign", csPtr);
DEBUGLOG(("Signature = [%s]\n", csPtr));
		} else {
DEBUGLOG(("Signature not found\n"));
		}
	} else {
DEBUGLOG(("BreakDownMsg() Error\n"));
		iRet = PD_ERR;
	}

	json_object_put(jobj);

	hash_destroy(hRec);
	FREE_ME(hRec);

DEBUGLOG(("BreakDownMsg() Exit\n"));
	return iRet;
}


int initReplyFromRequest(const hash_t *hRequest, hash_t *hResponse)
{
	int iRet = PD_OK;

	return iRet;
}


int FormatInitMsg(const hash_t *hIn, unsigned char *outMsg, int *outLen)
{
	int	iRet = PD_OK;
	char	*csPtr = NULL;
	char	*csURL = NULL;
	char	*csBuf;
	double	dTmp;
	char	csData[MAX_MSG_SIZE + 1];

DEBUGLOG(("FormatInitMsg()\n"));

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

	outMsg[0] = '\0';

/* psp_url */
	if (GetField_CString(hIn, "psp_url", &csURL)) {
		if (GetField_CString(hIn, "request_function", &csPtr)) {
			strcpy((char*)csBuf, "url");
DEBUGLOG(("psp_url = [%s]\n", csURL));
DEBUGLOG(("request_function = [%s]\n", csPtr));
			strcat((char*)csBuf, MY_ZPQ_FIELD_TOKEN);
			strcat((char*)csBuf, csURL);
			strcat((char*)csBuf, "/");
			strcat((char*)csBuf, csPtr);
DEBUGLOG(("psp_url = [%s]\n", csBuf));
		}

		strcat((char*)csBuf, MY_ZPQ_TOKEN);
		strcat((char*)csBuf, "CURLOPT_HTTPHEADER");
		strcat((char*)csBuf, MY_ZPQ_FIELD_TOKEN);
		strcat((char*)csBuf, "Content-Type: application/json");

		sprintf((char*)outMsg, "%0*d", PD_WEB_HEADER_LEN_LEN, (int)strlen(csBuf));
DEBUGLOG(("outMsg = [%s]\n", outMsg));
		strcat((char*)outMsg, csBuf);
	}
	FREE_ME(csBuf);

	json_object *jobj = json_object_new_object();

// Merchant_ID
	if (GetField_CString(hIn, "psp_merchant_id", &csPtr)) {
DEBUGLOG(("Merchant_ID = [%s]\n", csPtr));
		json_object_object_add(jobj, "Merchant_ID", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("***psp_merchant_id is missing\n"));
	}

// Country
DEBUGLOG(("Country (default) = [%s]\n", MY_ZPQ_COUNTRY));
	json_object_object_add(jobj, "Country", json_object_new_string(MY_ZPQ_COUNTRY));

// Pay_Code
DEBUGLOG(("Pay_Code (default) = [%s]\n", MY_ZPQ_PAYCODE_QR));
	json_object_object_add(jobj, "Pay_Code", json_object_new_string(MY_ZPQ_PAYCODE_QR));

// Merchant_Ref
	if (GetField_CString(hIn, "order_num", &csPtr)) {
DEBUGLOG(("Merchant_Ref = [%s]\n", csPtr));
		json_object_object_add(jobj, "Merchant_Ref", json_object_new_string(csPtr));
	}
	else {  
		iRet = PD_ERR;
DEBUGLOG(("***order_num is missing\n"));
	}

// Mer_txn_date
	if (GetField_CString(hIn, "local_tm_date", &csPtr)) {
		char *csPtr2;
		char csDateTime[PD_DATETIME_LEN * 2];
		if (GetField_CString(hIn, "local_tm_time", &csPtr2)) {
			sprintf(csDateTime, "%s%s", csPtr, csPtr2);
DEBUGLOG(("Mer_txn_date = [%s]\n", csDateTime));
			json_object_object_add(jobj, "Mer_txn_date", json_object_new_string(csDateTime));
		}
		else {
DEBUGLOG(("local_tm_time is missing!!!\n"));
		}
	}
	else {
DEBUGLOG(("local_tm_date is missing!!!\n"));
	}

// Currency
	if (GetField_CString(hIn, "psp_txn_ccy", &csPtr)) {
DEBUGLOG(("Currency = [%s]\n", csPtr));
		json_object_object_add(jobj, "Currency", json_object_new_string(csPtr));
	} else {
DEBUGLOG(("Currency (default) = [%s]\n", MY_ZPQ_CCY_CODE));
		json_object_object_add(jobj, "Currency", json_object_new_string(MY_ZPQ_CCY_CODE));
	}

// Amount
	if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
		char csTmpAmt[PD_TMP_BUF_LEN + 1];
		sprintf((char*)csTmpAmt, "%.2f", dTmp);
DEBUGLOG(("Amount = [%s]\n", csTmpAmt));
		json_object_object_add(jobj, "Amount", json_object_new_string(csTmpAmt));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("***psp_txn_amt is missing\n"));
	}

// Success_URL
	if (GetField_CString(hIn, "fe_url", &csPtr)) {
DEBUGLOG(("Success_URL = [%s]\n", csPtr));
		json_object_object_add(jobj, "Success_URL", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("***fe_url is missing\n"));
	}

// Callback_URL
	if (GetField_CString(hIn, "return_url_only", &csPtr)) {
DEBUGLOG(("Callback_URL = [%s]\n", csPtr));
		json_object_object_add(jobj, "Callback_URL", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("***return_url_only is missing\n"));
	}

// Signature
	if (GetField_CString(hIn, "sign", &csPtr)) {
DEBUGLOG(("Signature = [%s]\n", csPtr));
		json_object_object_add(jobj, "Signature", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("***sign is missing\n"));
	}

// Verno
DEBUGLOG(("Verno (default) = [%s]\n", MY_ZPQ_VERSION));
	json_object_object_add(jobj, "Verno", json_object_new_string(MY_ZPQ_VERSION));

	strcpy((char*)csData, str_replace((char*)(json_object_to_json_string_ext(jobj, JSON_C_TO_STRING_PLAIN)), "\\/", "/"));
	strcat((char*)outMsg, csData);

	*outLen = strlen((const char*)outMsg);
DEBUGLOG(("FormatInitMsg() [%s][%d]\n", outMsg, *outLen));
DEBUGLOG(("FormatInitMsg() Exit\n"));
	FREE_ME(csPtr);
	FREE_ME(csURL);
	json_object_put(jobj);

	return iRet;
}


int BreakDownInitRspMsg(hash_t *hOut, const unsigned char *inMsg, int inLen)
{
	int	iRet = PD_OK;
	char	*csPtr = NULL;
	char	*csReturnCode;
	char	csMsg[PD_MAX_BUFFER + 1];
	char	csTmp[PD_TMP_BUF_LEN + 1];
	hash_t	*hRec;

	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	csMsg[0] = '\0';

DEBUGLOG(("BreakDownInitRspMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n", inMsg, inLen));

	struct json_object *jobj;
	enum json_type type;

	jobj = json_tokener_parse((const char *)inMsg);
	if (jobj != NULL) {
		json_object_object_foreach(jobj, key, val) {
			type = json_object_get_type(val);
			switch (type) {
				case json_type_string:
					PutField_CString(hRec, key, json_object_get_string(val));
				break;
				case json_type_int:
					sprintf(csTmp, "%d", json_object_get_int(val));
					PutField_CString(hRec, key, csTmp);
				break;
				case json_type_double:
					sprintf(csTmp, "%.2f", json_object_get_double(val));
					PutField_CString(hRec, key, csTmp);
				break;
				default:
DEBUGLOG(("unsupported type\n"));
				break;
			}
		}

		if (GetField_CString(hRec, "Status", &csReturnCode)) {
			// return_code
			PutField_CString(hOut, "return_code", csReturnCode);
DEBUGLOG(("Status:return_code = [%s]\n", csReturnCode));

			// return_msg
			if (GetField_CString(hRec, "Error_Msg", &csPtr)) {
				PutField_CString(hOut, "return_msg", csPtr);
DEBUGLOG(("Error_Msg:return_msg = [%s]\n", csPtr));
			}

			if (!strcmp(csReturnCode, MY_ZPQ_SUCCESS_STATUS)) {
				// Merchant_ID
				if (GetField_CString(hRec, "Merchant_ID", &csPtr)) {
					PutField_CString(hOut, "psp_merchant_id", csPtr);
DEBUGLOG(("Merchant_ID:psp_merchant_id = [%s]\n", csPtr));
				}

				// Merchant_Ref
				if (GetField_CString(hRec, "Merchant_Ref", &csPtr)) {
					PutField_CString(hOut, "requestId", csPtr);
DEBUGLOG(("Merchant_Ref:requestId = [%s]\n", csPtr));
				}

				// Mer_txn_date
				if (GetField_CString(hRec, "Mer_txn_date", &csPtr)) {
					PutField_CString(hOut, "Mer_txn_date", csPtr);
DEBUGLOG(("Mer_txn_date = [%s]\n", csPtr));
				}

				// Currency
				if (GetField_CString(hRec, "Currency", &csPtr)) {
					PutField_CString(hOut, "Currency", csPtr);
DEBUGLOG(("Currency = [%s]\n", csPtr));
				}

				// Amount
				if (GetField_CString(hRec, "Amount", &csPtr)) {
					PutField_CString(hOut, "amount", csPtr);
DEBUGLOG(("Amount:amount = [%s]\n", csPtr));
				}

				// Redirect_URL
				if (GetField_CString(hRec, "Redirect_URL", &csPtr)) {
					PutField_CString(hOut, "code_url", csPtr);
DEBUGLOG(("Redirect_URL:code_url = [%s]\n", csPtr));
				}

				// Order_Ref
				if (GetField_CString(hRec, "Order_Ref", &csPtr)) {
					PutField_CString(hOut, "Order_Ref", csPtr);
DEBUGLOG(("Order_Ref = [%s]\n", csPtr));
				}

				// Signature
				if (GetField_CString(hRec, "Signature", &csPtr)) {
					PutField_CString(hOut, "sign", csPtr);
DEBUGLOG(("Signature:sign = [%s]\n", csPtr));
				}
			}
		}
		else {
DEBUGLOG(("BreakDownInitRspMsg() Invalid Response\n"));
			iRet = PD_ERR;
		}
	} else {
DEBUGLOG(("BreakDownInitRspMsg() Error\n"));
		iRet = PD_ERR;
	}

	json_object_put(jobj);

	hash_destroy(hRec);
	FREE_ME(hRec);
DEBUGLOG(("BreakDownInitRspMsg() Exit\n"));
	return iRet;
}


int BuildRspAuthData(hash_t* hIn)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csBuf;
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

DEBUGLOG(("BuildRspAuthData()\n"));
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

// Order_Ref (init rsp)
	if (GetField_CString(hIn, "Order_Ref", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Order_Ref = [%s]\n", csPtr));
	}

// Amount (callback)
	if (GetField_CString(hIn, "txn_amt", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Amount = [%s]\n", csPtr));
	}

// Currency (both)
	if (GetField_CString(hIn, "Currency", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Currency = [%s]\n", csPtr));
	}

// Amount (init rsp)
	if (GetField_CString(hIn, "amount", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Amount = [%s]\n", csPtr));
	}

// Merchant_Ref (callback)
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Merchant_Ref = [%s]\n", csPtr));
	}

// Merchant_Ref (init rsp)
	if (GetField_CString(hIn, "requestId", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Merchant_Ref = [%s]\n", csPtr));
	}

// Merchant_ID (both)
	if (GetField_CString(hIn, "psp_merchant_id", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Merchant_ID = [%s]\n", csPtr));
	}

// Order_Ref (callback)
	if (GetField_CString(hIn, "tid", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Order_Ref = [%s]\n", csPtr));
	}

// Mer_txn_date (init rsp)
	if (GetField_CString(hIn, "Mer_txn_date", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("Mer_txn_date = [%s]\n", csPtr));
	}

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("BuildRspAuthData:: auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);

DEBUGLOG(("BuildRspAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


char *str_replace(char *orig, char *rep, char *with) {
        char *result;   // the return string
        char *ins;      // the next insert point
        char *tmp;      // varies
        int len_rep;    // length of rep (the string to remove)
        int len_with;   // length of with (the string to replace rep with)
        int len_front;  // distance between rep and end of last rep
        int count;      // number of replacements

        if (!orig || !rep)
                return NULL;
        len_rep = strlen(rep);
        if (len_rep == 0)
                return NULL; // empty rep causes infinite loop during count
        if (!with)
                with = "";
        len_with = strlen(with);

        // count the number of replacements needed
        ins = orig;
        for (count = 0; (tmp = strstr(ins, rep)); ++count) {
                ins = tmp + len_rep;
        }

        tmp = result = malloc(strlen(orig) + (len_with - len_rep) * count + 1);

        if (!result)
                return NULL;

        // first time through the loop, all the variable are set correctly
        // from here on,
        //    tmp points to the end of the result string
        //    ins points to the next occurrence of rep in orig
        //    orig points to the remainder of orig after "end of rep"
        while (count--) {
                ins = strstr(orig, rep);
                len_front = ins - orig;
                tmp = strncpy(tmp, orig, len_front) + len_front;
                tmp = strcpy(tmp, with) + len_with;
                orig += len_front + len_rep; // move to next "end of rep"
        }
        strcpy(tmp, orig);
        return result;
}

