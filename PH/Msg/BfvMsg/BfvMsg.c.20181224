/*
PDProTech (c)2018. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2018/04/11              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "BfvMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include <zlib.h>
#include "b64.h"
#include "internal.h"
#include "ObjPtr.h"
#define __USE_XOPEN
#include <time.h>
#include <json-c/json.h>


char cDebug;


struct key_value_pair
{
	char key[PD_TMP_BUF_LEN];
	char value[PD_TMP_MSG_BUF_LEN];
};

OBJPTR(DB);

void BfvMsg(char cdebug)
{
	cDebug = cdebug;
}


int FormatMsg(const hash_t *hIn, unsigned char *outMsg, int *outLen)
{
	int	iRet = PD_OK;
	char	*csTmp = NULL;
	char	*csPtr = NULL;
	char	*csBuf;
	double	dTmp;
	char	*csMethod = NULL;
	char	csTmpAmt[PD_TMP_BUF_LEN + 1];

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

	memset(outMsg, 0, sizeof(outMsg));
	if (GetField_CString(hIn, "redirect_url", &csPtr)) {
DEBUGLOG(("FormatMsg here\n"));
		strcat((char*)outMsg, csPtr);
		strcat((char*)outMsg, "?");

// BANK_ID
		if (GetField_CString(hIn, "bank_code", &csTmp)) {
DEBUGLOG(("BANK_ID = [%s]\n", csTmp));
			strcat((char*)outMsg, "BANK_ID");
			strcat((char*)outMsg, MY_BFV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_BFV_TOKEN);
		} else {
DEBUGLOG(("bank_code is missing\n"));
			iRet = PD_ERR;
		}

// MERCHANT_ID
		if (GetField_CString(hIn, "psp_merchant_id", &csTmp)) {
DEBUGLOG(("MERCHANT_ID = [%s]\n", csTmp));
			strcat((char*)outMsg, "MERCHANT_ID");
			strcat((char*)outMsg, MY_BFV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_BFV_TOKEN);
		} else {
DEBUGLOG(("psp_merchant_id is missing\n"));
			iRet = PD_ERR;
		}

// NO_URL
		if (GetField_CString(hIn, "return_url_only", &csTmp)) {
DEBUGLOG(("NO_URL = [%s]\n", csTmp));
			strcat((char*)outMsg, "NO_URL");
			strcat((char*)outMsg, MY_BFV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_BFV_TOKEN);
		} else {
DEBUGLOG(("return_url_only is missing\n"));
			iRet = PD_ERR;
		}

// REMARK
// optional

// RET_URL
		if (GetField_CString(hIn, "fe_url", &csTmp)) {
DEBUGLOG(("RET_URL = [%s]\n", csTmp));
			strcat((char*)outMsg, "RET_URL");
			strcat((char*)outMsg, MY_BFV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_BFV_TOKEN);
		} else {
DEBUGLOG(("fe_url is missing\n"));
			iRet = PD_ERR;
		}

// SUBMIT_TIME
		if (GetField_CString(hIn, "local_tm_date", &csTmp)) {
			char *csTmp2;
			char csDateTime[PD_DATETIME_LEN * 2];
			if (GetField_CString(hIn, "local_tm_time", &csTmp2)) {
				sprintf(csDateTime, "%s%s", csTmp, csTmp2);
DEBUGLOG(("SUBMIT_TIME = [%s]\n", csDateTime));
				strcat((char*)outMsg, "SUBMIT_TIME");
				strcat((char*)outMsg, MY_BFV_FIELD_TOKEN);
				strcat((char*)outMsg, (char*)csDateTime);
				strcat((char*)outMsg, MY_BFV_TOKEN);
			} else {
DEBUGLOG(("local_tm_time is missing\n"));
				iRet = PD_ERR;
			}
		} else {
DEBUGLOG(("local_tm_date is missing\n"));
			iRet = PD_ERR;
		}

// TRAN_AMT
		if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
DEBUGLOG(("psp_txn_amt = [%f]\n", dTmp));
			sprintf((char*)csTmpAmt, "%ld", double2long(dTmp));
DEBUGLOG(("TRAN_AMT = [%s]\n", csTmpAmt));
			strcat((char*)outMsg, "TRAN_AMT");
			strcat((char*)outMsg, MY_BFV_FIELD_TOKEN);
			strcat((char*)outMsg, (char*)csTmpAmt);
			strcat((char*)outMsg, MY_BFV_TOKEN);
		} else {
DEBUGLOG(("psp_txn_amt is missing\n"));
			iRet = PD_ERR;
		}

// TRAN_CODE
		if (GetField_CString(hIn, "txn_seq", &csTmp)) {
DEBUGLOG(("TRAN_CODE = [%s]\n", csTmp));
			strcat((char*)outMsg, "TRAN_CODE");
			strcat((char*)outMsg, MY_BFV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_BFV_TOKEN);
		} else {
DEBUGLOG(("txn_seq is missing\n"));
			iRet = PD_ERR;
		}

// VERSION
DEBUGLOG(("VERSION = [%s]\n", MY_BFV_VERSION));
		strcat((char*)outMsg, "VERSION");
		strcat((char*)outMsg, MY_BFV_FIELD_TOKEN);
		strcat((char*)outMsg, MY_BFV_VERSION);
		strcat((char*)outMsg, MY_BFV_TOKEN);

// SIGNED_MSG
		if (GetField_CString(hIn, "sign", &csTmp)) {
DEBUGLOG(("SIGNED_MSG = [%s]\n", csTmp));
			strcat((char*)outMsg, "SIGNED_MSG");
			strcat((char*)outMsg, MY_BFV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			//strcat((char*)outMsg, MY_BFV_TOKEN);
		}
		else {
DEBUGLOG(("sign is missing\n"));
			iRet = PD_ERR;
		}

// url_method
		if (GetField_CString(hIn, "url_method", &csMethod)) {
DEBUGLOG(("url_method = [%s]\n", csMethod));
		}
		else
			csMethod = strdup("");

DEBUGLOG(("outmsg = [%s]\n", outMsg));
		base64_encode(outMsg, strlen((char*)outMsg), csBuf, PD_MAX_BUFFER);
DEBUGLOG(("after encode\n"));
		outMsg[0] = '\0';
		strcat((char*)outMsg, "redirect_url");
		strcat((char*)outMsg, "=");
		strcat((char*)outMsg, csBuf);
		strcat((char*)outMsg, MY_BFV_TOKEN);
		strcat((char*)outMsg, "url_method");
		strcat((char*)outMsg, "=");
		strcat((char*)outMsg, csMethod);
		strcat((char*)outMsg, MY_BFV_TOKEN);
		strcat((char*)outMsg, "ret_status=0");
DEBUGLOG(("outMsg = [%s]\n", outMsg));

		*outLen = strlen((const char*)outMsg);
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("***redirect_url is missing\n"));
	}

DEBUGLOG(("FormatMsg:: normal exit iRet = [%d]\n", iRet));
	FREE_ME(csBuf);
	return iRet;
}


int BreakDownMsg(hash_t *hOut, const unsigned char *inMsg, int inLen)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	csMsg[PD_MAX_BUFFER + 1];
	hash_t	*hRec;

	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	csMsg[0] = '\0';

DEBUGLOG(("BreakDownMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n", inMsg, inLen));

	struct json_object *jobj;
	enum json_type type;

	jobj = json_tokener_parse((const char *)inMsg);
	if (jobj != NULL) {
		json_object_object_foreach(jobj, key, val) {
			type = json_object_get_type(val);
			switch (type) {
				case json_type_string:
					strcat((char*)csMsg, key);
					strcat((char*)csMsg, MY_BFV_FIELD_TOKEN);
					strcat((char*)csMsg, json_object_get_string(val));
					strcat((char*)csMsg, MY_BFV_TOKEN);
				break;
				case json_type_int:
					strcat((char*)csMsg, key);
					strcat((char*)csMsg, MY_BFV_FIELD_TOKEN);
					sprintf((char*)csMsg, "%s%d", (char*)csMsg, json_object_get_int(val));
					strcat((char*)csMsg, MY_BFV_TOKEN);
				break;
				default:
DEBUGLOG(("BreakDownMsg:: unsupported type\n"));
				break;
			}
		}
	}

	if (Str2Cls(hRec, (char *)csMsg, MY_BFV_TOKEN, MY_BFV_FIELD_TOKEN) == PD_OK) {
// inMsg
		PutField_CString(hOut, "in_msg", (char *)csMsg);

// MERCHANT_ID
		if (GetField_CString(hRec, "MERCHANT_ID", &csPtr)) {
DEBUGLOG(("MERCHANT_ID:psp_merchant_id = [%s]\n", csPtr));
			PutField_CString(hOut, "psp_merchant_id", csPtr);
		} else {
DEBUGLOG(("MERCHANT_ID:psp_merchant_id not found\n"));
		}

// TRAN_CODE
		if (GetField_CString(hRec, "TRAN_CODE", &csPtr)) {
DEBUGLOG(("TRAN_CODE:txn_seq = [%s]\n", csPtr));
			PutField_CString(hOut, "txn_seq", csPtr);
		} else {
DEBUGLOG(("TRAN_CODE:txn_seq not found\n"));
		}

// SYS_CODE
		if (GetField_CString(hRec, "SYS_CODE", &csPtr)) {
DEBUGLOG(("SYS_CODE:tid = [%s]\n", csPtr));
			PutField_CString(hOut, "tid", csPtr);
		} else {
DEBUGLOG(("SYS_CODE:tid not found\n"));
		}

// TRAN_AMT
		if (GetField_CString(hRec, "TRAN_AMT", &csPtr)) {
DEBUGLOG(("TRAN_AMT:txn_amt = [%s]\n", csPtr));
			PutField_CString(hOut, "txn_amt", csPtr);
		} else {
DEBUGLOG(("TRAN_AMT:txn_amt not found\n"));
		}

// STATUS
		if (GetField_CString(hRec, "STATUS", &csPtr)) {
DEBUGLOG(("STATUS:status = [%s]\n", csPtr));
			PutField_CString(hOut, "status", csPtr);
		} else {
DEBUGLOG(("STATUS:status not found\n"));
		}

// PAY_TIME
		if (GetField_CString(hRec, "PAY_TIME", &csPtr)) {
			char csTxnDate[PD_DATE_LEN + 1];
			strncpy(csTxnDate, csPtr, PD_DATE_LEN);
			csTxnDate[PD_DATE_LEN] = '\0';

DEBUGLOG(("PAY_TIME:fundin_date = [%s]\n", csPtr));
			PutField_CString(hOut, "fundin_date", csPtr);
			PutField_CString(hOut, "txn_date", csTxnDate);
		} else {
DEBUGLOG(("PAY_TIME:fundin_date not found\n"));
		}

// SIGNED_MSG
		if (GetField_CString(hRec, "SIGNED_MSG", &csPtr)) {
DEBUGLOG(("SIGNED_MSG:sign = [%s]\n", csPtr));
			PutField_CString(hOut, "sign", csPtr);
		} else {
DEBUGLOG(("SIGNED_MSG:sign not found\n"));
			PutField_CString(hOut, "sign", " ");
		}
	} else {
DEBUGLOG(("BreakDownMsg() Error\n"));
		iRet = PD_ERR;
	}

	hash_destroy(hRec);
	FREE_ME(hRec);

DEBUGLOG(("BreakDownMsg Exit\n"));
	return iRet;
}


int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
	int	iRet = PD_OK;

	return iRet;
}


int BuildAuthData(hash_t *hIn)
{
	int	iRet = PD_OK;
	char	*csPtr, *csBuf;
	char	csTmpAmt[PD_TMP_BUF_LEN + 1];
	double	dTmp;
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

DEBUGLOG(("BuildAuthData()\n"));
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

// BANK_ID
	if (GetField_CString(hIn, "bank_code", &csPtr)) {
DEBUGLOG(("BANK_ID = [%s]\n", csPtr));
		strcat((char*)csBuf, "BANK_ID");
		strcat((char*)csBuf, MY_BFV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_BFV_TOKEN);
	} else {
DEBUGLOG(("bank_code is missing\n"));
		iRet = PD_ERR;
	}

// MERCHANT_ID
	if (GetField_CString(hIn, "psp_merchant_id", &csPtr)) {
DEBUGLOG(("MERCHANT_ID = [%s]\n", csPtr));
		strcat((char*)csBuf, "MERCHANT_ID");
		strcat((char*)csBuf, MY_BFV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_BFV_TOKEN);
	} else {
DEBUGLOG(("psp_merchant_id is missing\n"));
		iRet = PD_ERR;
	}

// NO_URL
	if (GetField_CString(hIn, "return_url_only", &csPtr)) {
DEBUGLOG(("NO_URL = [%s]\n", csPtr));
		strcat((char*)csBuf, "NO_URL");
		strcat((char*)csBuf, MY_BFV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_BFV_TOKEN);
	} else {
DEBUGLOG(("return_url_only is missing\n"));
		iRet = PD_ERR;
	}

// REMARK
// optional

// RET_URL
	if (GetField_CString(hIn, "fe_url", &csPtr)) {
DEBUGLOG(("RET_URL = [%s]\n", csPtr));
		strcat((char*)csBuf, "RET_URL");
		strcat((char*)csBuf, MY_BFV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_BFV_TOKEN);
	} else {
DEBUGLOG(("fe_url is missing\n"));
		iRet = PD_ERR;
	}

// SUBMIT_TIME
	if (GetField_CString(hIn, "local_tm_date", &csPtr)) {
		char *csPtr2;
		char csDateTime[PD_DATETIME_LEN * 2];
		if (GetField_CString(hIn, "local_tm_time", &csPtr2)) {
			sprintf(csDateTime, "%s%s", csPtr, csPtr2);
DEBUGLOG(("SUBMIT_TIME = [%s]\n", csDateTime));
			strcat((char*)csBuf, "SUBMIT_TIME");
			strcat((char*)csBuf, MY_BFV_FIELD_TOKEN);
			strcat((char*)csBuf, (char*)csDateTime);
			strcat((char*)csBuf, MY_BFV_TOKEN);
		} else {
DEBUGLOG(("local_tm_time is missing\n"));
			iRet = PD_ERR;
		}
	} else {
DEBUGLOG(("local_tm_date is missing\n"));
		iRet = PD_ERR;
	}

// TRAN_AMT
	if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
DEBUGLOG(("psp_txn_amt = [%f]\n", dTmp));
		sprintf((char*)csTmpAmt, "%ld", double2long(dTmp));
DEBUGLOG(("TRAN_AMT = [%s]\n", csTmpAmt));
		strcat((char*)csBuf, "TRAN_AMT");
		strcat((char*)csBuf, MY_BFV_FIELD_TOKEN);
		strcat((char*)csBuf, (char*)csTmpAmt);
		strcat((char*)csBuf, MY_BFV_TOKEN);
	} else {
DEBUGLOG(("psp_txn_amt is missing\n"));
		iRet = PD_ERR;
	}

// TRAN_CODE
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
DEBUGLOG(("TRAN_CODE = [%s]\n", csPtr));
		strcat((char*)csBuf, "TRAN_CODE");
		strcat((char*)csBuf, MY_BFV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_BFV_TOKEN);
	} else {
DEBUGLOG(("txn_seq is missing\n"));
		iRet = PD_ERR;
	}

// VERSION
DEBUGLOG(("VERSION = [%s]\n", MY_BFV_VERSION));
	strcat((char*)csBuf, "VERSION");
	strcat((char*)csBuf, MY_BFV_FIELD_TOKEN);
	strcat((char*)csBuf, MY_BFV_VERSION);
	//strcat((char*)csBuf, MY_BFV_TOKEN);

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);
        
DEBUGLOG(("BuildAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


void Insert2KVPair(struct key_value_pair k_v_pair[], int *iPairCnt, const char *inMsg, const char *FD)
{
	char *csTag;
	char *csValue;
	char *csTmp;
	char *p;

	csTmp = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
	strcpy(csTmp, inMsg);

	p = strstr(csTmp, FD);
	if (p) {
		//if (strlen(p) > strlen(FD)) {
			csTag = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
			csValue = strdup(p + 1);
			memcpy(csTag, inMsg, strlen(inMsg) - strlen(p));
			csTag[strlen(inMsg) - strlen(p)] = '\0';
//DEBUGLOG(("Insert2KVPair:: iPairCnt = [%d], Tag = [%s], Value = [%s]\n", *iPairCnt, csTag, csValue));
			strcpy(k_v_pair[*iPairCnt].key, csTag);
			strcpy(k_v_pair[*iPairCnt].value, csValue);
			*iPairCnt = *iPairCnt + 1;
			free(csTag);
			csTag = NULL;
			free(csValue);
			csValue = NULL;
		//}
	}
	free(csTmp);
	csTmp = NULL;
}


int Str2KVPair(struct key_value_pair k_v_pair[], int *iPairCnt, const char *inMsg, const char *DL, const char *FD)
{
	char *csBuf;
	char *p;

	int inLen = strlen(inMsg);
	csBuf = (char*) malloc (inLen + 1);
	memcpy(csBuf, inMsg, inLen);
	csBuf[inLen] = '\0';

	p = strtok(csBuf, DL);
	if (p != NULL) {
		if (strlen(p) > 1) {
			if (p[strlen(p) - 1] == 0x0d)
				p[strlen(p) - 1] = '\0';
			else
				p[strlen(p)] = '\0';
			Insert2KVPair(k_v_pair, iPairCnt, p, FD);
		}
	}

	while ((p = strtok(NULL, DL)) != NULL) {
		if (strlen(p) > 1) {
			if (p[strlen(p) - 1] == 0x0d)
				p[strlen(p) - 1] = '\0';
			else
				p[strlen(p)] = '\0';
			Insert2KVPair(k_v_pair, iPairCnt, p, FD);
		}
	}

//DEBUGLOG(("Str2KVPair:: iPairCnt = [%d]\n", *iPairCnt));

	free(csBuf);
	csBuf = NULL;
	return 0;
}


int string_sort_func(const void *a1, const void *b1)
{
	const char *a = (const char *)a1;
	const char *b = (const char *)b1;
	return(strcmp(a, b));
}


int BuildRspAuthData(hash_t *hIn)
{
	int iRet = PD_OK;
	char *csBuf;
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

	char *inMsg;
	int iTmp;

	struct key_value_pair k_v_pair[50];
	int iPairCnt = 0;

DEBUGLOG(("BuildRspAuthData()\n"));
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

	if (GetField_CString(hIn, "in_msg", &inMsg)) {
		if (Str2KVPair(k_v_pair, &iPairCnt, inMsg, MY_BFV_TOKEN, MY_BFV_FIELD_TOKEN) == PD_OK) {
//DEBUGLOG(("iPairCnt = [%d]\n", iPairCnt));
			qsort(k_v_pair, iPairCnt, sizeof(struct key_value_pair), string_sort_func);
			for (iTmp = 0; iTmp < iPairCnt; iTmp++) {
DEBUGLOG(("key = [%s], value = [%s]\n", k_v_pair[iTmp].key, k_v_pair[iTmp].value));
				// exclude sign
				if (strcmp(k_v_pair[iTmp].key, "SIGNED_MSG")) {
					strcat(csBuf, k_v_pair[iTmp].key);
					strcat(csBuf, MY_BFV_FIELD_TOKEN);
					strcat(csBuf, k_v_pair[iTmp].value);
					strcat(csBuf, MY_BFV_TOKEN);
				}
			}
		}
	}

	// special handling:
	// remove the last &
	csBuf[strlen(csBuf) - 1] = '\0';

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("BuildRspAuthData:: auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);

DEBUGLOG(("BuildRspAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}

