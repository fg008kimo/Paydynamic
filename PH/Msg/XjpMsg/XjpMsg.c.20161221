/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version					   2015/08/04              LokMan Chow
Fix for removing '{' and '}'			   2015/10/14		   LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "XjpMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include <zlib.h>
#include "b64.h"
#include "ObjPtr.h"
#include <time.h>
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"

#define PD_DOUBLE_QUOTE		0x22
#define PD_OPEN_BRACKET_H	0x7b
#define PD_CLOSE_BRACKET_H	0x7d
#define PD_OPEN_BRACKET		'{'//0x7b
#define PD_CLOSE_BRACKET	'}'//0x7d
#define	PD_PRODUCT_NAME		"PAY"
#define PD_PRODUCT_QUANTITY	"1"
#define PD_CLIENT_IP		"127.0.0.1"

#define PD_PRODUCT_CAT          "1"
#define PD_IDENTITY_TYPE        "2"
#define PD_TERMINAL_TYPE        "3"
#define PD_TERMINAL_ID          "T1"
#define PD_DEF_CUST_ID          "0001"

OBJPTR(DB);
OBJPTR(BO);
char	cDebug;
void remove_quote(const char* csValue, const int iType,char* csOut);

void	XjpMsg(char cdebug)
{
	cDebug = cdebug;
}

int FormatMsg(const hash_t* hIn,unsigned char *outMsg,int *outLen)
{
	int	iRet = PD_OK;
	char	csTmp[PD_AMOUNT_LEN];
	char*   csPtr = NULL;
	char*   csBuf;
	char*   csMethod = NULL;
	char*   csData;
	double	dTmp = 0.0;

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1 );
	csData = (char*) malloc (MAX_MSG_SIZE + 1 );

	memset(outMsg,0,sizeof(outMsg));
	if (GetField_CString(hIn,"redirect_url",&csPtr)) {
DEBUGLOG(("FormatMsg here\n"));
		strcat((char*)outMsg,csPtr);
		strcat((char*)outMsg,"?");

		strcat((char*)outMsg,MY_XJP_JSON_START_TOKEN);

// merchantId
		if (GetField_CString(hIn,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("FormatMsg:: merchantId = [%s]\n",csPtr));
			strcat((char*)outMsg,"\"merchantId\":\"");
			strcat((char*)outMsg,csPtr);
			strcat((char*)outMsg,"\"");
			strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: *** psp_merchant_id is missing\n"));
		}

// orderAmount
        	if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("FormatDataMsg:: psp_txn_amt = [%f]\n",dTmp));
                	sprintf((char*)csTmp,"%ld",double2long(dTmp));
DEBUGLOG(("FormatDataMsg:: orderAmount = [%s]\n",csTmp));
                	strcat((char*)outMsg,"\"orderAmount\":\"");
                	strcat((char*)outMsg,(char*)csTmp);
			strcat((char*)outMsg,"\"");
			strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
        	}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: *** psp_txn_amt is missing\n"));
		}

// orderCurrency
DEBUGLOG(("FormatDataMsg:: orderAmount[DEFAULT] = [%s]\n",PD_CCY_ISO_CNY));
		strcat((char*)outMsg,"\"orderCurrency\":\"");
		strcat((char*)outMsg,PD_CCY_ISO_CNY);
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);

// requestId
		if (GetField_CString(hIn,"txn_seq",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: requestId = [%s]\n",csPtr));
			strcat((char*)outMsg,"\"requestId\":\"");
                	strcat((char*)outMsg,csPtr);
                	strcat((char*)outMsg,"\"");
			strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: *** txn_seq is missing\n"));
		}

// notifyUrl
		if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: notifyUrl = [%s]\n",csPtr));
			strcat((char*)outMsg,"\"notifyUrl\":\"");
			strcat((char*)outMsg,csPtr);
			strcat((char*)outMsg,"\"");
			strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: *** return_url_only is missing\n"));
		}

// callbackUrl
		if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: callbackUrl = [%s]\n",csPtr));
			strcat((char*)outMsg,"\"callbackUrl\":\"");
			strcat((char*)outMsg,csPtr);
			strcat((char*)outMsg,"fe/");
			strcat((char*)outMsg,"\"");
			strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: *** return_url_only is missing\n"));
		}

/*
// remark
		strcat((char*)outMsg,"\"remark\":\"");
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
*/

// paymentModeCode
		if (GetField_CString(hIn,"bank_code",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: paymentModeCode = [%s]\n",csPtr));
			strcat((char*)outMsg,"\"paymentModeCode\":\"");
			strcat((char*)outMsg,csPtr);
			strcat((char*)outMsg,"\"");
			strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
		}

// start of productDetails
		strcat((char*)outMsg,"\"productDetails\":");
		strcat((char*)outMsg,MY_XJP_JSON_START_TOKEN_2);
		strcat((char*)outMsg,MY_XJP_JSON_START_TOKEN);

//// name
DEBUGLOG(("FormatDataMsg:: name[DEFAULT] = [%s]\n",PD_PRODUCT_NAME));
                strcat((char*)outMsg,"\"name\":\"");
                strcat((char*)outMsg,PD_PRODUCT_NAME);
                strcat((char*)outMsg,"\"");
                strcat((char*)outMsg,MY_XJP_JSON_TOKEN);

//// quantity
DEBUGLOG(("FormatDataMsg:: quantity[DEFAULT] = [%s]\n",PD_PRODUCT_QUANTITY));
		strcat((char*)outMsg,"\"quantity\":\"");
		strcat((char*)outMsg,PD_PRODUCT_QUANTITY);
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);

//// amount
		if (dTmp > 0.0) {
DEBUGLOG(("FormatDataMsg:: amount = [%s]\n",csTmp));
			strcat((char*)outMsg,"\"amount\":\"");
			strcat((char*)outMsg,(char*)csTmp);
			strcat((char*)outMsg,"\"");
			//strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: *** psp_txn_amt is missing\n"));
		}

/*
//// receiver
		strcat((char*)outMsg,"\"receiver\":\"");
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
*/

/*
//// description
		strcat((char*)outMsg,"\"description\":\"");
		strcat((char*)outMsg,"\"");
*/

// end of productDetails
		strcat((char*)outMsg,MY_XJP_JSON_END_TOKEN);
		strcat((char*)outMsg,MY_XJP_JSON_END_TOKEN_2);
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);

/*
// start of payer
		strcat((char*)outMsg,"\"payer\":\"");
		//strcat((char*)outMsg,MY_XJP_JSON_START_TOKEN_2);
		strcat((char*)outMsg,MY_XJP_JSON_START_TOKEN);

//// name
		strcat((char*)outMsg,"\"name\":\"");
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);

//// phoneNum
		strcat((char*)outMsg,"\"phoneNum\":\"");
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);

//// idType
		strcat((char*)outMsg,"\"idType\":\"");
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);

//// idNum 
		strcat((char*)outMsg,"\"idNum\":\"");
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);

//// bankCardNum
		strcat((char*)outMsg,"\"bankCardNum\":\"");
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);

//// email
		strcat((char*)outMsg,"\"email\":\"");
		strcat((char*)outMsg,"\"");

// end of payer
		strcat((char*)outMsg,MY_XJP_JSON_END_TOKEN);
		//strcat((char*)outMsg,MY_XJP_JSON_END_TOKEN_2);
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
*/

// clientIp
		if (GetField_CString(hIn,"userip",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: clientIp = [%s]\n",csPtr));
			strcat((char*)outMsg,"\"clientIp\":\"");
			strcat((char*)outMsg,csPtr);
			strcat((char*)outMsg,"\"");
			strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
		}
		else {
/*
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: *** userip is missing\n"));
*/
DEBUGLOG(("FormatDataMsg:: clientIp[DEFAULT] = [%s]\n",PD_CLIENT_IP));
			strcat((char*)outMsg,"\"clientIp\":\"");
			strcat((char*)outMsg,PD_CLIENT_IP);
			strcat((char*)outMsg,"\"");
			strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
		}

/*
// timeout
		strcat((char*)outMsg,"\"timeout\":\"");
		strcat((char*)outMsg,"\"");
		strcat((char*)outMsg,MY_XJP_JSON_TOKEN);
*/

// hmac
		if (GetField_CString(hIn,"sign",&csPtr)) {
DEBUGLOG(("FormatDataMsg:: hmac = [%s]\n",csPtr));
			strcat((char*)outMsg,"\"hmac\":\"");
			strcat((char*)outMsg,csPtr);
			strcat((char*)outMsg,"\"");
		}

		strcat((char*)outMsg,MY_XJP_JSON_END_TOKEN);

// url_method
                if (GetField_CString(hIn,"url_method",&csMethod)) {
DEBUGLOG(("FormatMsg:: url_method = [%s]\n",csMethod));
		}

DEBUGLOG(("FormatMsg:: outmsg = [%s]\n",outMsg));

		base64_encode((unsigned char *)outMsg,strlen((const char*)outMsg),csBuf,PD_MAX_BUFFER);
                outMsg[0] = '\0';
                strcat((char*)outMsg,"redirect_url");
                strcat((char*)outMsg,"=");
                strcat((char*)outMsg,csBuf);
		strcat((char*)outMsg,MY_XJP_TOKEN);
		strcat((char*)outMsg,"url_method");
                strcat((char*)outMsg,"=");
                strcat((char*)outMsg,csMethod);
		strcat((char*)outMsg,MY_XJP_TOKEN);
                strcat((char*)outMsg,"ret_status=0");

DEBUGLOG(("FormatMsg:: outMsg = [%s]\n",outMsg));

		*outLen = strlen((const char*)outMsg);
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: Redirct url not found\n"));
	}

	FREE_ME(csBuf);
	FREE_ME(csData);
	return 	iRet;
}


int BuildData(hash_t* hIn)
{
        int     iRet = PD_OK;
        char*   csPtr,*csDATA;
	char*	csBuf;
	char	csTmp[PD_AMOUNT_LEN];
        double  dTmp;
        csDATA = (char*) malloc (1024 * 2 +1);
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1 );

DEBUGLOG(("BuildData()\n"));

        memset(csDATA,0,sizeof(csDATA));

// merchantId
	if (GetField_CString(hIn,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("BuildData:: merchantId = [%s]\n",csPtr));
		strcat((char*)csDATA,csPtr);
	}

// orderAmount
	if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("BuildData:: psp_txn_amt = [%f]\n",dTmp));
		sprintf((char*)csTmp,"%ld",double2long(dTmp));
DEBUGLOG(("BuildData:: orderAmount = [%s]\n",csTmp));
		strcat((char*)csDATA,(char*)csTmp);
	}

// orderCurrency
	strcat((char*)csDATA,PD_CCY_ISO_CNY);

// requestId
	if (GetField_CString(hIn,"txn_seq",&csPtr)) {
DEBUGLOG(("BuildData:: requestId = [%s]\n",csPtr));
		strcat((char*)csDATA,csPtr);
	}

// notifyUrl
	if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("BuildData:: notifyUrl = [%s]\n",csPtr));
		strcat((char*)csDATA,csPtr);
	}

// callbackUrl
	if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("BuildData:: callbackUrl = [%s]\n",csPtr));
		strcat((char*)csDATA,csPtr);
		strcat((char*)csDATA,"fe/");
	}

// paymentModeCode
	if (GetField_CString(hIn,"bank_code",&csPtr)) {
DEBUGLOG(("BuildData:: paymentModeCode = [%s]\n", csPtr));
		strcat((char*)csDATA,csPtr);
	}

// productDetails.name
	strcat((char*)csDATA,PD_PRODUCT_NAME);

// productDetails.quantity
	strcat((char*)csDATA,PD_PRODUCT_QUANTITY);

// productDetails.amount
	if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("BuildData:: psp_txn_amt = [%f]\n",dTmp));
		sprintf((char*)csTmp,"%ld",double2long(dTmp));
DEBUGLOG(("BuildData:: amount = [%s]\n",csTmp));
		strcat((char*)csDATA,(char*)csTmp);
	}

// clientIp
	if (GetField_CString(hIn,"userip",&csPtr)) {
DEBUGLOG(("BuildData:: clientIp = [%s]\n",csPtr));
		strcat((char*)csDATA,csPtr);
	}
	else {
DEBUGLOG(("BuildData:: clientIp[DEFAULT] = [%s]\n",PD_CLIENT_IP));
		strcat((char*)csDATA,PD_CLIENT_IP);
	}

	PutField_CString(hIn,"auth_data",csDATA);

DEBUGLOG(("BuildData:: DATA = [%s]\n",csDATA));

        FREE_ME(csDATA);
DEBUGLOG(("BuildData() Exit iRet = [%d]\n",iRet));
        return  iRet;
}


int BreakDownMsg(hash_t *hOut,const unsigned char *inMsg,int inLen)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csKey;
	char	*csKeyFile;
	char	*csYPKeyFile;
	//char    csPubKey[PD_TMP_MSG_BUF_LEN+1];
        //char    csRsaPemPath[PD_MAX_FILE_LEN + 1];
	//char    csBuf[PD_TMP_BUF_LEN +1];

        hash_t  *hKey;
        hash_t  *hRec;

        hRec = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hRec,0);

	csKey = (char*) malloc (MAX_MSG_SIZE + 1 );
DEBUGLOG(("BreakDownMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n",inMsg,inLen));

	if (Str2Cls(hRec,(const char *)inMsg,MY_XJP_TOKEN, MY_XJP_FIELD_TOKEN) == PD_OK) {

/*pid*/
		if (GetField_CString(hRec,"pid",&csPtr)) {
			//get private key
			recordset_t     *rKeySet;
			rKeySet = (recordset_t*) malloc (sizeof(recordset_t));
			recordset_init(rKeySet,0);
			DBObjPtr = CreateObj(DBPtr,"DBPspKeys","GetPspKey");
			if (!(*DBObjPtr)(csPtr,PD_PTK_KEY_NAME,rKeySet)) {
				hKey = RecordSet_GetFirst(rKeySet);
				while(hKey){
					if (GetField_CString(hKey,"privatepem",&csKeyFile)) {
DEBUGLOG(("PTK file = [%s]\n",csKeyFile));
					}
					break;
				}
			}
			RecordSet_Destroy(rKeySet);

			//get yeepay public key
			recordset_init(rKeySet,0);
			DBObjPtr = CreateObj(DBPtr,"DBPspKeys","GetPspKey");
			if (!(*DBObjPtr)(csPtr,PD_RSA_KEY_NAME,rKeySet)) {
				hKey = RecordSet_GetFirst(rKeySet);
				while(hKey){
					if (GetField_CString(hKey,"privatepem",&csYPKeyFile)) {
DEBUGLOG(("RSA file = [%s]\n",csYPKeyFile));
					}
					break;
				}
			}
			RecordSet_Destroy(rKeySet);
		}

/*encryptkey*/
		if (iRet==PD_OK && GetField_CString(hRec,"encryptkey",&csPtr)) {
DEBUGLOG(("BreakDownMsg encryptkey = [%s]\n",csPtr));
			BOObjPtr = CreateObj(BOPtr,"BOSecurity","RSAEncryptData");
			iRet = (unsigned long)(*BOObjPtr)(csKeyFile,csPtr,csKey,PD_TRUE,PD_FALSE);
			if(iRet==PD_OK){
DEBUGLOG(("BreakDownMsg key = [%s]\n",csKey));
			}
			else
			{
				iRet = PD_ERR;
DEBUGLOG(("BreakDownMsg encryptkey decrypt failed!!\n"));
			}
        	}
		else{
			iRet = PD_ERR;
DEBUGLOG(("BreakDownMsg encryptkey not found\n"));
		}

/* data */
		if (iRet==PD_OK && GetField_CString(hRec,"data",&csPtr)) {
			PutField_CString(hOut,"psp_key_file",csYPKeyFile);
                	iRet = DEBlockXjpData(hOut,(const unsigned char *)csPtr,strlen(csPtr),csKey);
        	}
		else{
			iRet = PD_ERR;
DEBUGLOG(("BreakDownMsg data not found\n"));
		}

	}
	else{
DEBUGLOG(("BreakDownMsg() Error\n"));
                iRet = PD_ERR;
	}

	hash_destroy(hRec);
        FREE_ME(hRec);
        FREE_ME(csKey);

DEBUGLOG(("BreakDownMsg Exit\n"));
	return	iRet;
}


int DEBlockXjpData(hash_t *hOut,const unsigned char *inMsg,int inLen, const char* csKey)
{
        int     iRet = PD_OK;
        char    *csTmp=NULL;
        char    *csBuf;
        char    *csDATA;
        char    *csTmpDATA;
        //char    *csTrimDATA;
        char    *csAuthDATA;
        //char    *p;
        int     iLen;
	char	csTag[PD_TAG_LEN+1];
	char *csPara = malloc(PD_MAX_BUFFER+1);

        csTmp = (char*) malloc (PD_MAX_BUFFER +1);
        csBuf = (char*) malloc (PD_MAX_BUFFER +1);
        csDATA = (char*) malloc (PD_MAX_BUFFER +1);
        csTmpDATA = (char*) malloc (PD_MAX_BUFFER +1);
        //csTrimDATA = (char*) malloc (PD_MAX_BUFFER +1);
        csAuthDATA = (char*) malloc (PD_MAX_BUFFER +1);
        memset(csAuthDATA,0,sizeof(csAuthDATA));

        hash_t  *hRec;

        hRec = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hRec,0);

        memcpy(csBuf,inMsg,inLen);
        csBuf[inLen] = '\0';
DEBUGLOG(("\n\nDEBlockData data=[%s]\n\n",csBuf));
        iLen = base64_decode((char *)csBuf,(unsigned char*)csTmpDATA,PD_MAX_BUFFER);
        //csTmpDATA[iLen] = '\0';
        if (iLen > 0 ) {
DEBUGLOG(("iLen = [%d] DATA = [%s]\n",iLen,csTmpDATA));
	}
	else{
		iRet = INT_ERR;
	}

	if(iRet==PD_OK){
		BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESDecryptData");
		iRet = (unsigned long)(*BOObjPtr)(csKey,csTmpDATA,iLen,csDATA);
DEBUGLOG(("iLen = [%d] DATA = [%s]\n",iLen,csDATA));
	}


	if(iRet==PD_OK){
		csPara[0]='\0';
		remove_quote(csDATA,PD_OPEN_BRACKET_H,csPara);
		strcpy(csDATA,csPara);

		csPara[0]='\0';
		remove_quote(csDATA,PD_CLOSE_BRACKET_H,csPara);
		strcpy(csDATA,csPara);
		//strcpy(csDATA,TrimAllChar((const unsigned char*)csDATA,strlen(csDATA),PD_OPEN_BRACKET));
		//strcpy(csDATA,TrimAllChar((const unsigned char*)csDATA,strlen(csDATA),PD_CLOSE_BRACKET));
	}
	if(iRet==PD_OK &&
	   Str2Cls(hRec,(const char *)csDATA,MY_XJP_JSON_TOKEN, MY_XJP_JSON_FIELD_TOKEN) == PD_OK){

		sprintf(csTag,"\"amount\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			PutField_CString(hOut,"txn_amt",csTmp);
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"bank\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			//PutField_CString(hOut,"bank_name",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"bankcode\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"ret_bank_code",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"cardtype\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			strcat(csAuthDATA,csTmp);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csTmp));
		}

		sprintf(csTag,"\"lastno\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"merchantaccount\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"psp_merchant_id",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"orderid\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"txn_seq",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"status\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"status",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

		sprintf(csTag,"\"yborderid\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			strcat(csAuthDATA,csPara);
			PutField_CString(hOut,"tid",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}

                PutField_CString(hOut,"plainttext_data",csAuthDATA);

		sprintf(csTag,"\"sign\"");
		if(GetField_CString(hRec,csTag,&csTmp)){
			csPara[0]='\0';
			remove_quote(csTmp,PD_DOUBLE_QUOTE,csPara);
			csPara[strlen(csPara)]='\0';
			PutField_CString(hOut,"sign",csPara);
DEBUGLOG(("DBlockData [%s] = [%s]\n",csTag,csPara));
		}
        }

	FREE_ME(csPara);
	FREE_ME(csTmp);
	FREE_ME(csBuf);
	FREE_ME(csDATA);
	FREE_ME(csTmpDATA);
	FREE_ME(csAuthDATA);
	FREE_ME(hRec);
DEBUGLOG(("DBlockData Exit\n"));
	return  iRet;
}




int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
	int	iRet = PD_OK;

	return iRet;
}



void remove_quote(const char* csValue, const int iType,char* csOut)
{
	int i = 0;
	int cnt = 0;
	for(i=0; i<strlen(csValue);i++){
//DEBUGLOG(("%x \n",csValue[i]));
		if(csValue[i]!=iType){
			csOut[cnt] = csValue[i];
			cnt ++;
		}
		else{
		}
	}
	csOut[cnt]='\0';
}
