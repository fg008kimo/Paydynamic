/*
PDProTech (c)2017. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version					   2017/04/18              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "XjwMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include <zlib.h>
#include "b64.h"
#include "ObjPtr.h"
#include <time.h>
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"
#include <json-c/json.h>

#define PD_DOUBLE_QUOTE		0x22
#define PD_OPEN_BRACKET_H	0x7b
#define PD_CLOSE_BRACKET_H	0x7d
#define PD_OPEN_BRACKET		'{'//0x7b
#define PD_CLOSE_BRACKET	'}'//0x7d
#define	PD_PRODUCT_NAME		"PAY"
#define PD_PRODUCT_QUANTITY	"1"
#define PD_PAYMENT_MODE_CODE	"SCANCODE-WEIXIN_PAY-P2P"

OBJPTR(DB);
OBJPTR(BO);
char	cDebug;
void remove_quote(const char* csValue, const int iType,char* csOut);
char *str_replace(char *orig, char *rep, char *with); 

void	XjwMsg(char cdebug)
{
	cDebug = cdebug;
}


int FormatMsg(const hash_t* hIn,unsigned char *outMsg,int *outLen)
{
	int	iRet = PD_OK;

	char*	csPtr = NULL;
	char*	csBuf;
	char*	csCodeURL= NULL;
	int	iTmp;
	int	iTmpRet;

	hash_t	*hLog;
	hLog = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hLog,0);

DEBUGLOG(("FormatMsg()\n"));

	csCodeURL = (char*) malloc (PD_TMP_MSG_BUF_LEN+1);
	memset(csCodeURL,0,sizeof(csCodeURL));

	outMsg[0]= '\0';

//return_code
	if (GetField_CString(hIn,"return_code",&csPtr)) {
DEBUGLOG(("FormatMsg:: return_code = [%s]\n",csPtr));
		strcat((char*)outMsg,"return_code");
		strcat((char*)outMsg,MY_XJW_FIELD_TOKEN);
		strcat((char*)outMsg,csPtr);
		strcat((char*)outMsg,MY_XJW_TOKEN);
	} else {
DEBUGLOG(("FormatMsg:: return_code is missing\n"));
	}

//code_url
	if (GetField_CString(hIn,"code_url",&csPtr)) {
DEBUGLOG(("FormatMsg:: code_url = [%s]\n",csPtr));


		strcat((char*)outMsg,"code_url");
		strcat((char*)outMsg,MY_XJW_FIELD_TOKEN);
		base64_encode((unsigned char *)csPtr,strlen((char*)csPtr),csCodeURL,PD_MAX_BUFFER);
		strcat((char*)outMsg,csCodeURL);
		strcat((char*)outMsg,MY_XJW_TOKEN);
	} else {
DEBUGLOG(("FormatMsg:: code_url is missing\n"));
	}

//txn_seq
	if (GetField_CString(hIn,"txn_seq",&csPtr)) {
DEBUGLOG(("FormatMsg:: txn_seq = [%s]\n",csPtr));
		DBObjPtr = CreateObj(DBPtr,"DBTxnQrRequestLog","GetByTxnId");
		iTmpRet = (unsigned long int)(*DBObjPtr)(csPtr,hLog);
		if (iTmpRet == PD_FOUND) {
//time_init
			if (GetField_CString(hLog,"qrcode_init_timestamp",&csPtr)) {
DEBUGLOG(("FormatMsg:: time_init = [%s]\n",csPtr));
				strcat((char*)outMsg,"time_init");
				strcat((char*)outMsg,MY_XJW_FIELD_TOKEN);
				strcat((char*)outMsg,csPtr);
				strcat((char*)outMsg,MY_XJW_TOKEN);
			} else {
DEBUGLOG(("FormatMsg:: time_init is missing\n"));
			}

//time_expire
			if (GetField_Int(hLog,"expiry",&iTmp)) {
				char csTimeExpire[PD_TMP_BUF_LEN + 1];
				sprintf((char*)csTimeExpire,"%d",iTmp);
DEBUGLOG(("FormatMsg:: time_expire = [%s]\n",csTimeExpire));
				strcat((char*)outMsg,"time_expire");
				strcat((char*)outMsg,MY_XJW_FIELD_TOKEN);
				strcat((char*)outMsg,csTimeExpire);
				strcat((char*)outMsg,MY_XJW_TOKEN);
			} else {
DEBUGLOG(("FormatMsg:: time_expire is missing\n"));
			}

//time_enable
			if (GetField_Int(hLog,"enable_button",&iTmp)) {
				char csTimeEnable[PD_TMP_BUF_LEN + 1];
				sprintf((char*)csTimeEnable,"%d",iTmp);
DEBUGLOG(("FormatMsg:: time_enable = [%s]\n",csTimeEnable));
				strcat((char*)outMsg,"time_enable");
				strcat((char*)outMsg,MY_XJW_FIELD_TOKEN);
				strcat((char*)outMsg,csTimeEnable);
				strcat((char*)outMsg,MY_XJW_TOKEN);
			} else {
DEBUGLOG(("FormatMsg:: time_enable is missing\n"));
			}

//time_auto_check
			if (GetField_Int(hLog,"auto_check_txn_status",&iTmp)) {
				char csTimeAutoCheck[PD_TMP_BUF_LEN + 1];
				sprintf((char*)csTimeAutoCheck,"%d",iTmp);
DEBUGLOG(("FormatMsg:: time_auto_check = [%s]\n",csTimeAutoCheck));
				strcat((char*)outMsg,"time_auto_check");
				strcat((char*)outMsg,MY_XJW_FIELD_TOKEN);
				strcat((char*)outMsg,csTimeAutoCheck);
				strcat((char*)outMsg,MY_XJW_TOKEN);
			} else {
DEBUGLOG(("FormatMsg:: time_auto_check is missing\n"));
			}

//time_redirect
			if (GetField_Int(hLog,"redirect",&iTmp)) {
				char csTimeRedirect[PD_TMP_BUF_LEN + 1];
				sprintf((char*)csTimeRedirect,"%d",iTmp);
DEBUGLOG(("FormatMsg:: time_redirect = [%s]\n",csTimeRedirect));
				strcat((char*)outMsg,"time_redirect");
				strcat((char*)outMsg,MY_XJW_FIELD_TOKEN);
				strcat((char*)outMsg,csTimeRedirect);
				strcat((char*)outMsg,MY_XJW_TOKEN);
			} else {
DEBUGLOG(("FormatMsg:: time_redirect is missing\n"));
			}

//time_curr
			if (GetField_CString(hLog,"qrcode_curr_timestamp",&csPtr)) {
DEBUGLOG(("FormatMsg:: time_curr = [%s]\n",csPtr));
				strcat((char*)outMsg,"time_db_local");
				strcat((char*)outMsg,MY_XJW_FIELD_TOKEN);
				strcat((char*)outMsg,csPtr);
			} else {
DEBUGLOG(("FormatMsg:: time_curr is missing\n"));
			}
		}
	} else {
DEBUGLOG(("FormatMsg:: txn_seq is missing\n"));
	}

DEBUGLOG(("outmsg = [%s]\n",outMsg));

	csBuf = (char*) malloc (PD_MAX_BUFFER +1);
	base64_encode(outMsg,strlen((char*)outMsg),csBuf,PD_MAX_BUFFER);
	outMsg[0] = '\0';
	strcat((char*)outMsg,"qr_parameter");
	strcat((char*)outMsg,"=");
	strcat((char*)outMsg,csBuf);
	FREE_ME(csBuf);
	*outLen = strlen((const char*)outMsg);

DEBUGLOG(("FormatMsg() [%s][%d]\n",outMsg,*outLen));
DEBUGLOG(("FormatMsg() Exit\n"));
	FREE_ME(csPtr);

	hash_destroy(hLog);
	FREE_ME(hLog);

	return 	iRet;
}


int BuildAuthData(hash_t* hIn)
{
	int	iRet = PD_OK;
	int	iTmp;
	char	*csPtr,*csDATA;
	//char	*csReplaced;
	char	csTmpAmt[PD_TMP_BUF_LEN + 1];
	char	csTimeExpire[PD_TMP_BUF_LEN + 1];
	double	dTmp;
	csDATA = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);

DEBUGLOG(("BuildAuthData()\n"));
	memset(csDATA,0,sizeof(csDATA));

// merchantId
	if (GetField_CString(hIn,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("BuildAuthData:: merchantId = [%s]\n",csPtr));
		strcat((char*)csDATA,csPtr);
	} else {
DEBUGLOG(("BuildAuthData:: psp_merchant_id is missing!!\n"));
	}

// orderAmount
	if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("BuildAuthData:: psp_txn_amt = [%f]\n",dTmp));
		sprintf((char*)csTmpAmt,"%ld",double2long(dTmp));
DEBUGLOG(("BuildAuthData:: orderAmount = [%s]\n",csTmpAmt));
		strcat((char*)csDATA,(char*)csTmpAmt);
	} else {
DEBUGLOG(("BuildAuthData:: psp_txn_amt is missing!!\n"));
	}

// orderCurrency
	strcat((char*)csDATA,PD_CCY_ISO_CNY);

// requestId
	if (GetField_CString(hIn,"order_num",&csPtr)) {
DEBUGLOG(("BuildAuthData:: requestId = [%s]\n",csPtr));
		strcat((char*)csDATA,csPtr);
	} else {
DEBUGLOG(("BuildAuthData:: order_num is missing!!\n"));
	}

// notifyUrl
	if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("BuildAuthData:: notifyUrl = [%s]\n",csPtr));
		//csReplaced = str_replace(csPtr, "/", "\\/");
		//strcat((char*)csDATA,csReplaced);
		strcat((char*)csDATA,csPtr);
	} else {
DEBUGLOG(("BuildAuthData:: return_url_only is missing!!\n"));
	}

// callbackUrl
	if (GetField_CString(hIn,"fe_url",&csPtr)) {
DEBUGLOG(("BuildAuthData:: callbackUrl = [%s]\n",csPtr));
		//csReplaced = str_replace(csPtr, "/", "\\/");
		//strcat((char*)csDATA,csReplaced);
		strcat((char*)csDATA,csPtr);
	} else {
DEBUGLOG(("BuildAuthData:: fe_url is missing!!\n"));
	}

// paymentModeCode
	strcat((char*)csDATA,PD_PAYMENT_MODE_CODE);

// productDetails.name
	strcat((char*)csDATA,PD_PRODUCT_NAME);

// productDetails.quantity
	strcat((char*)csDATA,PD_PRODUCT_QUANTITY);

// productDetails.amount
	if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("BuildAuthData:: psp_txn_amt = [%f]\n",dTmp));
		sprintf((char*)csTmpAmt,"%ld",double2long(dTmp));
DEBUGLOG(("BuildAuthData:: amount = [%s]\n",csTmpAmt));
		strcat((char*)csDATA,(char*)csTmpAmt);
	} else {
DEBUGLOG(("BuildAuthData:: psp_txn_amt is missing!!\n"));
	}

// clientIp
	if (GetField_CString(hIn,"org_ip_addr",&csPtr)) {
DEBUGLOG(("BuildAuthData:: clientIp = [%s]\n", csPtr));
		strcat((char*)csDATA,csPtr);
	} else {
DEBUGLOG(("BuildAuthData:: org_ip_addr is missing!!\n"));
	}

// timeout
	if (GetField_Int(hIn,"time_expire",&iTmp)) {
DEBUGLOG(("BuildAuthData:: time_expire = [%d]\n",iTmp));
		sprintf((char*)csTimeExpire,"%d",iTmp/60);
DEBUGLOG(("BuildAuthData:: timeout = [%s]\n",csTimeExpire));
		strcat((char*)csDATA,(char*)csTimeExpire);
	} else {
DEBUGLOG(("BuildAuthData:: time_expire is missing!!\n"));
	}

	PutField_CString(hIn,"auth_data",csDATA);

DEBUGLOG(("BuildAuthData:: DATA = [%s]\n",csDATA));

        FREE_ME(csDATA);
DEBUGLOG(("BuildAuthData() Exit iRet = [%d]\n",iRet));
        return  iRet;
}


int BreakDownMsg(hash_t *hOut, const unsigned char *inMsg, int inLen)
{
	int	iRet = PD_OK;
	char	*csTmp = NULL;
	hash_t *hRec;

	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

DEBUGLOG(("BreakDownMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n",inMsg,inLen));

	struct json_object *jobj;
	enum json_type type;

	jobj = json_tokener_parse((const char *)inMsg);
	if (jobj != NULL) {
		json_object_object_foreach(jobj, key, val) {
			type = json_object_get_type(val);
			switch (type) {
				case json_type_string:
					PutField_CString(hRec, key, json_object_get_string(val));
				break;
				default:
DEBUGLOG(("BreakDownInitRspMsg:: unsupported type\n"));
				break;
			}
		}

		//merchantId
		if (GetField_CString(hRec, "merchantId", &csTmp)) {
			PutField_CString(hOut, "mid", csTmp);
DEBUGLOG(("BreakDownMsg:: merchantId = [%s]\n", csTmp));
		}

		//requestId
		if (GetField_CString(hRec, "requestId", &csTmp)) {
			PutField_CString(hOut, "txn_seq", csTmp);
DEBUGLOG(("BreakDownMsg:: requestId = [%s]\n", csTmp));
		}

		//serialNumber
		if (GetField_CString(hRec, "serialNumber", &csTmp)) {
			PutField_CString(hOut, "tid", csTmp);
DEBUGLOG(("BreakDownMsg:: serialNumber = [%s]\n", csTmp));
		}

		//totalRefundCount
		if (GetField_CString(hRec, "totalRefundCount", &csTmp)) {
			PutField_CString(hOut, "totalRefundCount", csTmp);
DEBUGLOG(("BreakDownMsg:: totalRefundCount = [%s]\n", csTmp));
		}

		//totalRefundAmount
		if (GetField_CString(hRec, "totalRefundAmount", &csTmp)) {
			PutField_CString(hOut, "totalRefundAmount", csTmp);
DEBUGLOG(("BreakDownMsg:: totalRefundAmount = [%s]\n", csTmp));
		}

		//orderCurrency
		if (GetField_CString(hRec, "orderCurrency", &csTmp)) {
			PutField_CString(hOut, "orderCurrency", csTmp);
DEBUGLOG(("BreakDownMsg:: orderCurrency = [%s]\n", csTmp));
		}

		//orderAmount
		if (GetField_CString(hRec, "orderAmount", &csTmp)) {
			PutField_CString(hOut, "txn_amt", csTmp);
DEBUGLOG(("BreakDownMsg:: orderAmount = [%s]\n", csTmp));
		}

		//status
		if (GetField_CString(hRec, "status", &csTmp)) {
			PutField_CString(hOut, "status", csTmp);
DEBUGLOG(("BreakDownMsg:: status = [%s]\n", csTmp));
		}

		//completeDateTime
		if (GetField_CString(hRec, "completeDateTime", &csTmp)) {
			PutField_CString(hOut, "completeDateTime", csTmp);

			char csTxnDate[PD_DATE_LEN + 1];
			sprintf(csTxnDate, "%.*s%.*s%.*s",
				PD_YYYY_LEN, csTmp,
				PD_MM_LEN, &csTmp[PD_YYYY_LEN + 1],
				PD_DD_LEN, &csTmp[PD_YYYYMM_LEN + 2]);
			PutField_CString(hOut, "txn_date", csTxnDate);

			char csTxnDateTime[PD_DATETIME_LEN + 1];
			sprintf(csTxnDateTime, "%.*s%.*s%.*s%.*s%.*s%.*s",
				PD_YYYY_LEN, csTmp,
				PD_MM_LEN, &csTmp[PD_YYYY_LEN + 1],
				PD_DD_LEN, &csTmp[PD_YYYYMM_LEN + 2],
				2, &csTmp[11],
				2, &csTmp[14],
				2, &csTmp[17]);
			PutField_CString(hOut, "fundin_date", csTxnDateTime);

			PutField_CString(hOut, "completeDateTime", csTmp);
DEBUGLOG(("BreakDownMsg:: completeDateTime = [%s]\n", csTmp));
DEBUGLOG(("BreakDownMsg:: txn_date = [%s]\n", csTxnDate));
DEBUGLOG(("BreakDownMsg:: fundin_date = [%s]\n", csTxnDateTime));
		}

		//remark
		if (GetField_CString(hRec, "remark", &csTmp)) {
			PutField_CString(hOut, "remark", csTmp);
DEBUGLOG(("BreakDownMsg:: remark = [%s]\n", csTmp));
		}

		//hmac
		if (GetField_CString(hRec, "hmac", &csTmp)) {
			PutField_CString(hOut, "sign", csTmp);
DEBUGLOG(("BreakDownMsg:: hmac = [%s]\n", csTmp));
		}
	} else {
DEBUGLOG(("BreakDownMsg() Error\n"));
		iRet = PD_ERR;
	}

	FREE_ME(csTmp);
	FREE_ME(hRec);
DEBUGLOG(("DBlockData Exit\n"));
	return iRet;
}


int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
	int	iRet = PD_OK;

	return iRet;
}


void remove_quote(const char* csValue, const int iType, char* csOut)
{
	int i = 0;
	int cnt = 0;
	for(i = 0; i < strlen(csValue); i++) {
//DEBUGLOG(("%x\n", csValue[i]));
		if (csValue[i] != iType) {
			csOut[cnt] = csValue[i];
			cnt++;
		}
		else {
		}
	}
	csOut[cnt] = '\0';
}


int FormatInitMsg(const hash_t* hIn,unsigned char *outMsg,int *outLen)
{
	int	iRet = PD_OK;
	int	iTmp;
	char	csTmpAmt[PD_TMP_BUF_LEN + 1];
	char	csTimeExpire[PD_TMP_BUF_LEN + 1];
	char*	csPtr = NULL;
	char*   csURL = NULL;
	char*	csBuf;
	char*	csTmp;
	double	dTmp = 0.0;

DEBUGLOG(("FormatInitMsg()\n"));

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1 );
	csTmp = (char*) malloc (MAX_MSG_SIZE + 1 );

	memset(outMsg,0,sizeof(outMsg));

// psp_url
	if (GetField_CString(hIn,"psp_url",&csURL)) {
		if (GetField_CString(hIn,"request_function",&csPtr)) {
			strcpy((char*)csBuf,"url");
DEBUGLOG(("FormatInitMsg:: psp_url = [%s]\n",csURL));
DEBUGLOG(("FormatInitMsg:: request function = [%s]\n",csPtr));
			strcat((char*)csBuf,MY_XJW_FIELD_TOKEN);
			strcat((char*)csBuf,csURL);
			strcat((char*)csBuf,"/");
			strcat((char*)csBuf,csPtr);
DEBUGLOG(("FormatInitMsg:: psp_url = [%s]\n",csBuf));
		}

		strcat((char*)csBuf,MY_XJW_TOKEN);
		strcat((char*)csBuf,"CURLOPT_HTTPHEADER");
		strcat((char*)csBuf,MY_XJW_FIELD_TOKEN);
		strcat((char*)csBuf,"Content-Type: application/vnd.ehking-v1.0+json");

		sprintf((char*)outMsg,"%0*d",PD_WEB_HEADER_LEN_LEN,(int)strlen(csBuf));
DEBUGLOG(("FormatInitMsg:: outMsg = [%s]\n",outMsg));
		strcat((char*)outMsg,csBuf);
	}
	FREE_ME(csBuf);

	json_object *jobj = json_object_new_object();

// merchantId
	if (GetField_CString(hIn,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("FormatInitMsg:: merchantId = [%s]\n",csPtr));
		json_object_object_add(jobj, "merchantId", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatInitMsg:: *** psp_merchant_id is missing\n"));
	}

// orderAmount
       	if (GetField_Double(hIn,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("FormatInitMsg:: psp_txn_amt = [%f]\n",dTmp));
               	sprintf((char*)csTmpAmt,"%ld",double2long(dTmp));
DEBUGLOG(("FormatInitMsg:: orderAmount = [%s]\n",csTmpAmt));
		json_object_object_add(jobj, "orderAmount", json_object_new_string(csTmpAmt));
       	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatInitMsg:: *** psp_txn_amt is missing\n"));
	}

// orderCurrency
DEBUGLOG(("FormatInitMsg:: orderCurrency[DEFAULT] = [%s]\n",PD_CCY_ISO_CNY));
	json_object_object_add(jobj, "orderCurrency", json_object_new_string(PD_CCY_ISO_CNY));

// requestId
	if (GetField_CString(hIn,"order_num",&csPtr)) {
DEBUGLOG(("FormatInitMsg:: requestId = [%s]\n",csPtr));
		json_object_object_add(jobj, "requestId", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatInitMsg:: *** order_num is missing\n"));
	}

// notifyUrl
	if (GetField_CString(hIn,"return_url_only",&csPtr)) {
DEBUGLOG(("FormatInitMsg:: notifyUrl = [%s]\n",csPtr));
		json_object_object_add(jobj, "notifyUrl", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatInitMsg:: *** return_url_only is missing\n"));
	}

// callbackUrl
	if (GetField_CString(hIn,"fe_url",&csPtr)) {
DEBUGLOG(("FormatInitMsg:: callbackUrl = [%s]\n",csPtr));
		json_object_object_add(jobj, "callbackUrl", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatInitMsg:: *** fe_url is missing\n"));
	}

// paymentModeCode
DEBUGLOG(("FormatInitMsg:: paymentModeCode = [%s]\n",PD_PAYMENT_MODE_CODE));
	json_object_object_add(jobj, "paymentModeCode", json_object_new_string(PD_PAYMENT_MODE_CODE));

// start of productDetails
	json_object *jarray = json_object_new_array();
	json_object *jobj2 = json_object_new_object();

//// name
DEBUGLOG(("FormatInitMsg:: name[DEFAULT] = [%s]\n",PD_PRODUCT_NAME));
	json_object_object_add(jobj2, "name", json_object_new_string(PD_PRODUCT_NAME));

//// quantity
DEBUGLOG(("FormatInitMsg:: quantity[DEFAULT] = [%s]\n",PD_PRODUCT_QUANTITY));
	json_object_object_add(jobj2, "quantity", json_object_new_string(PD_PRODUCT_QUANTITY));

//// amount
	if (dTmp > 0.0) {
DEBUGLOG(("FormatInitMsg:: amount = [%s]\n",csTmpAmt));
		json_object_object_add(jobj2, "amount", json_object_new_string(csTmpAmt));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatInitMsg:: *** psp_txn_amt is missing\n"));
	}

	json_object_array_add(jarray, jobj2);
	json_object_object_add(jobj, "productDetails", jarray);
// end of productDetails

// start of payer
	json_object *jobj3 = json_object_new_object();
	json_object_object_add(jobj, "payer", jobj3);
// end of payer

// clientIp
	if (GetField_CString(hIn,"org_ip_addr",&csPtr)) {
DEBUGLOG(("FormatInitMsg:: clientIp = [%s]\n",csPtr));
		json_object_object_add(jobj, "clientIp", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatInitMsg:: *** org_ip_addr is missing\n"));
	}

// timeout
	if (GetField_Int(hIn,"time_expire",&iTmp)) {
DEBUGLOG(("FormatInitMsg:: time_expire = [%d]\n",iTmp));
		sprintf((char*)csTimeExpire,"%d",iTmp/60);
DEBUGLOG(("FormatInitMsg:: timeout = [%s]\n",csTimeExpire));
		json_object_object_add(jobj, "timeout", json_object_new_string(csTimeExpire));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatInitMsg:: *** time_expire is missing\n"));
	}

// hmac
	if (GetField_CString(hIn,"sign",&csPtr)) {
DEBUGLOG(("FormatInitMsg:: hmac = [%s]\n",csPtr));
		json_object_object_add(jobj, "hmac", json_object_new_string(csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatInitMsg:: *** sign is missing\n"));
	}

	//strcat((char*)outMsg, json_object_to_json_string_ext(jobj, JSON_C_TO_STRING_PLAIN));
	strcpy((char*)csTmp, json_object_to_json_string_ext(jobj, JSON_C_TO_STRING_PLAIN));
	strcat((char*)outMsg, str_replace((char*)csTmp, "\\/", "/"));

	FREE_ME(csTmp);

DEBUGLOG(("FormatInitMsg:: outmsg = [%s]\n",outMsg));

	*outLen = strlen((const char*)outMsg);
DEBUGLOG(("FormatInitMsg() [%s][%d]\n",outMsg,*outLen));
DEBUGLOG(("FormatInitMsg() Exit\n"));
	FREE_ME(csPtr);
	FREE_ME(csURL);

	json_object_put(jarray);
	json_object_put(jobj3);
	json_object_put(jobj2);
	json_object_put(jobj);

	return 	iRet;
}


int BreakDownInitRspMsg(hash_t *hOut,const unsigned char *inMsg,int inLen)
{
	int	iRet = PD_OK;
	char	*csPtr = NULL;
	hash_t	*hRec;

	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec,0);

DEBUGLOG(("BreakDownInitRspMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n",inMsg,inLen));

	struct json_object *jobj;
	enum json_type type;

	jobj = json_tokener_parse((const char *)inMsg);
	if (jobj != NULL) {
		json_object_object_foreach(jobj, key, val) {
			type = json_object_get_type(val);
			switch (type) {
				case json_type_string:
					PutField_CString(hRec, key, json_object_get_string(val));
				break;
				default:
DEBUGLOG(("BreakDownInitRspMsg:: unsupported type\n"));
				break;
			}
		}

		//merchantId
		if (GetField_CString(hRec,"merchantId",&csPtr)) {
			PutField_CString(hOut,"merchantId",csPtr);
DEBUGLOG(("BreakDownInitRspMsg:: merchantId = [%s]\n",csPtr));
		}

		//requestId
		if (GetField_CString(hRec,"requestId",&csPtr)) {
			PutField_CString(hOut,"requestId",csPtr);
DEBUGLOG(("BreakDownInitRspMsg:: requestId = [%s]\n",csPtr));
		}

		//return_code
		if (GetField_CString(hRec,"status",&csPtr)) {
			PutField_CString(hOut,"return_code",csPtr);
DEBUGLOG(("BreakDownInitRspMsg:: return_code = [%s]\n",csPtr));
		}

		//code_url
		if (GetField_CString(hRec,"scanCode",&csPtr)) {
			PutField_CString(hOut,"code_url",csPtr);
DEBUGLOG(("BreakDownInitRspMsg:: code_url = [%s]\n",csPtr));
		}

		//redirectUrl
		if (GetField_CString(hRec,"redirectUrl",&csPtr)) {
			PutField_CString(hOut,"redirectUrl",csPtr);
DEBUGLOG(("BreakDownInitRspMsg:: redirectUrl = [%s]\n",csPtr));
		}
	} else {
DEBUGLOG(("BreakDownInitRspMsg() Error\n"));
		iRet = PD_ERR;
	}

	hash_destroy(hRec);
	FREE_ME(hRec);
DEBUGLOG(("BreakDownInitRspMsg Exit\n"));
	return iRet;
}


int BuildRspAuthData(hash_t* hIn)
{
	int     iRet = PD_OK;
	char*   csPtr;
	char*   csBuf;
	char    csTag[PD_TAG_LEN + 1];
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

DEBUGLOG(("BuildRspAuthData()\n"));
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

/* merchantId */
	strcpy(csTag, "merchantId");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	} else {
		strcpy(csTag, "mid");
		if (GetField_CString(hIn, csTag, &csPtr)) {
			strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
		}
	}

/* requestId */
	strcpy(csTag, "requestId");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	} else {
		strcpy(csTag, "txn_seq");
		if (GetField_CString(hIn, csTag, &csPtr)) {
			strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
		}
	}

/* serialNumber */
	strcpy(csTag, "tid");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

/* totalRefundCount */
	strcpy(csTag, "totalRefundCount");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

/* totalRefundAmount */
	strcpy(csTag, "totalRefundAmount");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

/* orderCurrency */
	strcpy(csTag, "orderCurrency");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

/* orderAmount */
	strcpy(csTag, "txn_amt");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

/* status */
	strcpy(csTag, "status");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

/* completeDateTime */
	strcpy(csTag, "completeDateTime");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

/* remark */
	strcpy(csTag, "remark");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

/* scanCode */
	strcpy(csTag, "scanCode");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

/* redirectUrl */
	strcpy(csTag, "redirectUrl");
	if (GetField_CString(hIn, csTag, &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: %s = [%s]\n", csTag, csPtr));
	}

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("BuildRspAuthData:: auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);

DEBUGLOG(("BuildRspAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


char *str_replace(char *orig, char *rep, char *with) {
	char *result;	// the return string
	char *ins;	// the next insert point
	char *tmp;	// varies
	int len_rep;	// length of rep (the string to remove)
	int len_with;	// length of with (the string to replace rep with)
	int len_front;	// distance between rep and end of last rep
	int count;	// number of replacements

	if (!orig || !rep)
		return NULL;
	len_rep = strlen(rep);
	if (len_rep == 0)
		return NULL; // empty rep causes infinite loop during count
	if (!with)
		with = "";
	len_with = strlen(with);

	// count the number of replacements needed
	ins = orig;
	for (count = 0; (tmp = strstr(ins, rep)); ++count) {
		ins = tmp + len_rep;
	}

	tmp = result = malloc(strlen(orig) + (len_with - len_rep) * count + 1);

	if (!result)
		return NULL;

	// first time through the loop, all the variable are set correctly
	// from here on,
	//    tmp points to the end of the result string
	//    ins points to the next occurrence of rep in orig
	//    orig points to the remainder of orig after "end of rep"
	while (count--) {
		ins = strstr(orig, rep);
		len_front = ins - orig;
		tmp = strncpy(tmp, orig, len_front) + len_front;
		tmp = strcpy(tmp, with) + len_with;
		orig += len_front + len_rep; // move to next "end of rep"
	}
	strcpy(tmp, orig);
	return result;
}

