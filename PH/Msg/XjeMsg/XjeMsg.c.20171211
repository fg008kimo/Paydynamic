/*
PDProTech (c)2017. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2017/11/28              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "XjeMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include <zlib.h>
#include "b64.h"
#include "internal.h"
#include "ObjPtr.h"
#define __USE_XOPEN
#include <time.h>
#include <json-c/json.h>
#include "myrecordset.h"

char cDebug;
OBJPTR(BO);
OBJPTR(DB);


void XjeMsg(char cdebug)
{
	cDebug = cdebug;
}


char *str_replace(char *orig, char *rep, char *with);
int DEBlockXjeData(hash_t *hOut, const unsigned char *inMsg, int inLen, const char *csKey);


int FormatMsg(const hash_t *hIn, unsigned char *outMsg, int *outLen)
{
	int	iRet = PD_OK;
	int	iLen = 0;
	char	*csTmp = NULL;
	char	*csPtr = NULL;
	char	*csBuf;
	char	*csMethod = NULL;
	char	*csData;
	char	*csEncrypKey;
	char	*csTmpData;
	char	*csAESKey;
	char	*csRSAKeyFile;
	double	dTmp;
	char	csTmpAmt[PD_TMP_BUF_LEN + 1];

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);
	csData = (char*) malloc (MAX_MSG_SIZE + 1);
	csEncrypKey = (char*) malloc (MAX_MSG_SIZE + 1);
	csTmpData = (char*) malloc (MAX_MSG_SIZE + 1);

	memset(outMsg, 0, sizeof(outMsg));
	memset(csTmpData, 0, sizeof(csTmpData));
	if (GetField_CString(hIn, "redirect_url", &csPtr)) {
DEBUGLOG(("FormatMsg here\n"));
		strcat((char*)outMsg, csPtr);
		strcat((char*)outMsg, "?");

		json_object *jobj = json_object_new_object();

// callbackUrl
		if (GetField_CString(hIn, "fe_url", &csTmp)) {
DEBUGLOG(("FormatMsg:: callbackUrl = [%s]\n", csTmp));
			json_object_object_add(jobj, "callbackUrl", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: ***callbackUrl is missing\n"));
		}

// clientIp
		if (GetField_CString(hIn, "user_ip", &csTmp)) {
DEBUGLOG(("FormatMsg:: clientIp = [%s]\n", csTmp));
			json_object_object_add(jobj, "clientIp", json_object_new_string(csTmp));
		}
        	else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: ***clientIp is missing\n"));
		}

// hmac
		if (GetField_CString(hIn, "sign", &csTmp)) {
DEBUGLOG(("FormatMsg:: hmac = [%s]\n", csTmp));
			json_object_object_add(jobj, "hmac", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: ***hmac is missing\n"));
		}

// merchantId
		if (GetField_CString(hIn, "psp_merchant_id", &csTmp)) {
DEBUGLOG(("FormatMsg:: merchantId = [%s]\n", csTmp));
			json_object_object_add(jobj, "merchantId", json_object_new_string(csTmp));

			strcat((char*)outMsg, "merchantId");
			strcat((char*)outMsg, MY_XJE_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_XJE_TOKEN);
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: ***merchantId is missing\n"));
		}

// notifyUrl
		if (GetField_CString(hIn, "return_url_only", &csTmp)) {
DEBUGLOG(("FormatMsg:: notifyUrl = [%s]\n", csTmp));
			json_object_object_add(jobj, "notifyUrl", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: ***notifyUrl is missing\n"));
		}

// orderAmount
		if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
			sprintf((char*)csTmpAmt, "%ld", double2long(dTmp));
DEBUGLOG(("FormatMsg:: orderAmount = [%s]\n", csTmpAmt));
			json_object_object_add(jobj, "orderAmount", json_object_new_string(csTmpAmt));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: ***orderAmount is missing\n"));
		}

// orderCurrency
DEBUGLOG(("FormatMsg:: orderCurrency = [%s]\n", MY_XJE_CCY));
			json_object_object_add(jobj, "orderCurrency", json_object_new_string(MY_XJE_CCY));

// start of payer
		json_object *jobj2 = json_object_new_object();
		json_object_object_add(jobj, "payer", jobj2);
// end of payer

// paymentModeCode
		if (GetField_CString(hIn, "bank_code", &csTmp)) {
DEBUGLOG(("FormatMsg:: paymentModeCode = [%s]\n", csTmp));
			json_object_object_add(jobj, "paymentModeCode", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: paymentModeCode is missing\n"));
		}

// start of productDetails
		json_object *jarray = json_object_new_array();
		json_object *jobj3 = json_object_new_object();

//// amount
		if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
			sprintf((char*)csTmpAmt, "%ld", double2long(dTmp));
DEBUGLOG(("FormatMsg:: productDetails.amount = [%s]\n", csTmpAmt));
			json_object_object_add(jobj3, "amount", json_object_new_string(csTmpAmt));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: productDetails.amount is missing\n"));
		}

//// name
DEBUGLOG(("FormatMsg:: productDetails.name = [%s]\n", MY_XJE_PRODUCT_NAME));
		json_object_object_add(jobj3, "name", json_object_new_string(MY_XJE_PRODUCT_NAME));

//// quantity
DEBUGLOG(("FormatMsg:: productDetails.quantity = [%s]\n", MY_XJE_PRODUCT_QUANTITY));
		json_object_object_add(jobj3, "quantity", json_object_new_string(MY_XJE_PRODUCT_QUANTITY));

		json_object_array_add(jarray, jobj3);
		json_object_object_add(jobj, "productDetails", jarray);
// end of productDetails

// requestId
		if (GetField_CString(hIn, "txn_seq", &csTmp)) {
DEBUGLOG(("FormatMsg:: requestId = [%s]\n", csTmp));
			json_object_object_add(jobj, "requestId", json_object_new_string(csTmp));

			strcat((char*)outMsg, "requestId");
			strcat((char*)outMsg, MY_XJE_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_XJE_TOKEN);
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: ***requestId is missing\n"));
		}

		strcpy((char*)csTmpData, str_replace((char*)(json_object_to_json_string_ext(jobj, JSON_C_TO_STRING_PLAIN)), "\\/", "/"));

		if (GetField_CString(hIn, "aes_key", &csAESKey) &&
			GetField_CString(hIn, "rsa_key", &csRSAKeyFile))
		{
DEBUGLOG(("FormatMsg:: temp data = [%s]\n", csTmpData));
			memset(csData, 0, sizeof(csData));
			BOObjPtr = CreateObj(BOPtr, "BOSecurity", "AESEncryptData");
			iRet = (unsigned long)(*BOObjPtr)(csAESKey, csTmpData, csData, &iLen);
			if (iRet == PD_OK) {
				char *csEncData = (char*) malloc (MAX_MSG_SIZE + 1);
				memset(csEncData, 0, sizeof(csEncData));
				base64_encode((unsigned char *)csData, iLen, csEncData, PD_MAX_BUFFER);

				strcat((char*)outMsg, "data");
				strcat((char*)outMsg, MY_XJE_FIELD_TOKEN);
				strcat((char*)outMsg, url_encode(csEncData));
				strcat((char*)outMsg, MY_XJE_TOKEN);
DEBUGLOG(("FormatMsg:: data = [%s]\n", csEncData));
			}

			if (iRet == PD_OK) {
				memset(csData, 0, sizeof(csData));
				BOObjPtr = CreateObj(BOPtr, "BOSecurity", "RSAEncryptData");
				iRet = (unsigned long)(*BOObjPtr)(csRSAKeyFile, csAESKey, csData, PD_FALSE, PD_TRUE);
				if (iRet == PD_OK) {
					strcat((char*)outMsg, "encryptKey");
					strcat((char*)outMsg, MY_XJE_FIELD_TOKEN);
					strcat((char*)outMsg, url_encode(csData));
					strcat((char*)outMsg, MY_XJE_TOKEN);
DEBUGLOG(("FormatMsg:: encryptKey = [%s]\n", csData));
				}
			}
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: ***aes_key/rsa_key not found\n"));
ERRLOG("XjeMsg:: FormatMsg:: ***aes_key/rsa_key not found\n");
		}

// version
DEBUGLOG(("FormatMsg:: version = [%s]\n", MY_XJE_VERSION));
		strcat((char*)outMsg, "version");
		strcat((char*)outMsg, MY_XJE_FIELD_TOKEN);
		strcat((char*)outMsg, MY_XJE_VERSION);
		//strcat((char*)outMsg, MY_XJE_TOKEN);

// url_method
		if (GetField_CString(hIn, "url_method", &csMethod)) {
DEBUGLOG(("FormatMsg:: url_method = [%s]\n", csMethod));
		}
		else
			csMethod = strdup("");

DEBUGLOG(("FormatMsg:: outmsg = [%s]\n", outMsg));
		base64_encode(outMsg, strlen((char*)outMsg), csBuf, PD_MAX_BUFFER);
DEBUGLOG(("FormatMsg:: after encode\n"));
		outMsg[0] = '\0';
		strcat((char*)outMsg, "redirect_url");
		strcat((char*)outMsg, "=");
		strcat((char*)outMsg, csBuf);
		strcat((char*)outMsg, MY_XJE_TOKEN);
		strcat((char*)outMsg, "url_method");
		strcat((char*)outMsg, "=");
		strcat((char*)outMsg, csMethod);
		strcat((char*)outMsg, MY_XJE_TOKEN);
		strcat((char*)outMsg, "ret_status=0");
DEBUGLOG(("FormatMsg:: outMsg = [%s]\n", outMsg));

		*outLen = strlen((const char*)outMsg);

		json_object_put(jarray);
		json_object_put(jobj3);
		json_object_put(jobj2);
		json_object_put(jobj);
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("FormatMsg:: ***redirect_url is missing\n"));
	}

DEBUGLOG(("FormatMsg:: normal exit iRet = [%d]\n", iRet));
	FREE_ME(csBuf);
	FREE_ME(csData);
	FREE_ME(csEncrypKey);
	FREE_ME(csTmpData);

	return iRet;
}


int BreakDownMsg(hash_t *hOut, const unsigned char *inMsg, int inLen)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csKey;
	hash_t 	*hRec;

	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	csKey = (char*) malloc (MAX_MSG_SIZE + 1);

DEBUGLOG(("BreakDownMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n", inMsg, inLen));

	if (Str2Cls(hRec, (char*)inMsg, MY_XJE_TOKEN, MY_XJE_FIELD_TOKEN) == PD_OK) {
// pid
		if (GetField_CString(hRec, "pid", &csPtr)) {
DEBUGLOG(("BreakDownMsg:: pid = [%s]\n", csPtr));
			// get aes key
			recordset_t *rKeySet;
			rKeySet = (recordset_t*) malloc (sizeof(recordset_t));
			recordset_init(rKeySet, 0);
			DBObjPtr = CreateObj(DBPtr, "DBPspKeys", "GetPspKey");
			if (!(*DBObjPtr)(csPtr, PD_AES_KEY_NAME, rKeySet)) {
				hash_t *hKey;
				hKey = RecordSet_GetFirst(rKeySet);
				if (GetField_CString(hKey, "key_value", &csKey)) {
DEBUGLOG(("BreakDownMsg:: key = [%s]\n", csKey));
				}
			}
			RecordSet_Destroy(rKeySet);
			FREE_ME(rKeySet);
		}
		else {
DEBUGLOG(("BreakDownMsg:: pid not found\n"));
			iRet = PD_ERR;
		}

// json
		if (GetField_CString(hRec, "json", &csPtr)) {
DEBUGLOG(("BreakDownMsg:: json = [%s]\n", csPtr));
			struct json_object *jobj;
			enum json_type type;

			jobj = json_tokener_parse((const char *)csPtr);
			if (jobj != NULL) {
				json_object_object_foreach(jobj, key, val) {
					type = json_object_get_type(val);
					switch (type) {
						case json_type_string:
							PutField_CString(hRec, key, json_object_get_string(val));
						break;
						default:
DEBUGLOG(("BreakDownMsg:: unsupported type\n"));
						break;
					}
				}
			} else {
DEBUGLOG(("BreakDownMsg() Error\n"));
				iRet = PD_ERR;
			}

			if (GetField_CString(hRec, "data", &csPtr)) {
DEBUGLOG(("BreakDownMsg:: data = [%s]\n", csPtr));
				iRet = DEBlockXjeData(hOut, (const unsigned char *)csPtr, strlen(csPtr), csKey);
			}
		}
		else {
DEBUGLOG(("BreakDownMsg:: json not found\n"));
			iRet = PD_ERR;
		}
	}
	else {
DEBUGLOG(("BreakDownMsg() Error\n"));
		iRet = PD_ERR;
	}

	hash_destroy(hRec);
	FREE_ME(hRec);
	FREE_ME(csKey);

DEBUGLOG(("BreakDownMsg Exit\n"));
	return iRet;
}


int DEBlockXjeData(hash_t *hOut, const unsigned char *inMsg, int inLen, const char *csKey)
{
	int iRet = PD_OK;
	char *csPtr = NULL;
	char *csBuf;
	char *csDATA;
	char *csTmpDATA;
	int iLen;

	csBuf = (char*) malloc (PD_MAX_BUFFER + 1);
	csDATA = (char*) malloc (PD_MAX_BUFFER + 1);
	csTmpDATA = (char*) malloc (PD_MAX_BUFFER + 1);

	hash_t *hRec;
	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	memcpy(csBuf, inMsg, inLen);
	csBuf[inLen] = '\0';
	iLen = base64_decode((char *)csBuf, (unsigned char*)csTmpDATA, PD_MAX_BUFFER);
	if (iLen > 0) {
DEBUGLOG(("DEBlockXjeData:: base64_decoded\n"));
	}
	else {
		iRet = INT_ERR;
	}

	if (iRet == PD_OK) {
		BOObjPtr = CreateObj(BOPtr, "BOSecurity", "AESDecryptData");
		iRet = (unsigned long)(*BOObjPtr)(csKey, csTmpDATA, iLen, csDATA);
DEBUGLOG(("DEBlockXjeData:: iLen = [%d] DATA = [%s]\n", iLen, csDATA));
	}

	if (iRet == PD_OK) {
		struct json_object *jobj;
		enum json_type type;

		jobj = json_tokener_parse((const char *)csDATA);
		if (jobj != NULL) {
			json_object_object_foreach(jobj, key, val) {
				type = json_object_get_type(val);
				switch (type) {
					case json_type_string:
						PutField_CString(hRec, key, json_object_get_string(val));
					break;
					default:
DEBUGLOG(("DEBlockXjeData:: unsupported type\n"));
					break;
				}
			}

			// merchantId
			if (GetField_CString(hRec, "merchantId", &csPtr)) {
				PutField_CString(hOut, "mid", csPtr);
DEBUGLOG(("DEBlockXjeData:: merchantId = [%s]\n", csPtr));
			}

			// requestId
			if (GetField_CString(hRec, "requestId", &csPtr)) {
				PutField_CString(hOut, "txn_seq", csPtr);
DEBUGLOG(("DEBlockXjeData:: requestId = [%s]\n", csPtr));
			}

			// serialNumber
			if (GetField_CString(hRec, "serialNumber", &csPtr)) {
				PutField_CString(hOut, "tid", csPtr);
DEBUGLOG(("DEBlockXjeData:: serialNumber = [%s]\n", csPtr));
			}

			// totalRefundCount
			if (GetField_CString(hRec, "totalRefundCount", &csPtr)) {
				PutField_CString(hOut, "totalRefundCount", csPtr);
DEBUGLOG(("DEBlockXjeData:: totalRefundCount = [%s]\n", csPtr));
			}

			// totalRefundAmount
			if (GetField_CString(hRec, "totalRefundAmount", &csPtr)) {
				PutField_CString(hOut, "totalRefundAmount", csPtr);
DEBUGLOG(("DEBlockXjeData:: totalRefundAmount = [%s]\n", csPtr));
			}

			// orderCurrency
			if (GetField_CString(hRec, "orderCurrency", &csPtr)) {
				PutField_CString(hOut, "orderCurrency", csPtr);
DEBUGLOG(("DEBlockXjeData:: orderCurrency = [%s]\n", csPtr));
			}

			// orderAmount
			if (GetField_CString(hRec, "orderAmount", &csPtr)) {
				PutField_CString(hOut, "txn_amt", csPtr);
DEBUGLOG(("DEBlockXjeData:: orderAmount = [%s]\n", csPtr));
			}

			// status
			if (GetField_CString(hRec, "status", &csPtr)) {
				PutField_CString(hOut, "status", csPtr);
DEBUGLOG(("DEBlockXjeData:: status = [%s]\n", csPtr));
			}

			// completeDateTime
			if (GetField_CString(hRec, "completeDateTime", &csPtr)) {
				PutField_CString(hOut, "completeDateTime", csPtr);

				char csTxnDate[PD_DATE_LEN + 1];
				sprintf(csTxnDate, "%.*s%.*s%.*s",
						PD_YYYY_LEN, csPtr,
						PD_MM_LEN, &csPtr[PD_YYYY_LEN + 1],
						PD_DD_LEN, &csPtr[PD_YYYYMM_LEN + 2]);
				PutField_CString(hOut, "txn_date", csTxnDate);

				char csTxnDateTime[PD_DATETIME_LEN + 1];
				sprintf(csTxnDateTime, "%.*s%.*s%.*s%.*s%.*s%.*s",
						PD_YYYY_LEN, csPtr,
						PD_MM_LEN, &csPtr[PD_YYYY_LEN + 1],
						PD_DD_LEN, &csPtr[PD_YYYYMM_LEN + 2],
						2, &csPtr[11],
						2, &csPtr[14],
						2, &csPtr[17]);
				PutField_CString(hOut, "fundin_date", csTxnDateTime);

DEBUGLOG(("DEBlockXjeData:: completeDateTime = [%s]\n", csPtr));
DEBUGLOG(("DEBlockXjeData:: txn_date = [%s]\n", csTxnDate));
DEBUGLOG(("DEBlockXjeData:: fundin_date = [%s]\n", csTxnDateTime));
			}

			// remark
			if (GetField_CString(hRec, "remark", &csPtr)) {
				PutField_CString(hOut, "remark", csPtr);
DEBUGLOG(("DEBlockXjeData:: remark = [%s]\n", csPtr));
			}

			// hmac
			if (GetField_CString(hRec, "hmac", &csPtr)) {
				PutField_CString(hOut, "sign", csPtr);
DEBUGLOG(("DEBlockXjeData:: hmac = [%s]\n", csPtr));
			}
		}
		else {
DEBUGLOG(("DEBlockXjeData() Error\n"));
			iRet = INT_ERR;
		}
	}

	FREE_ME(csBuf);
	FREE_ME(csDATA);
	FREE_ME(csTmpDATA);
	FREE_ME(hRec);
DEBUGLOG(("DEBlockXjeData Exit\n"));
	return iRet;
}


int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
	int	iRet = PD_OK;

	return iRet;
}


int BuildAuthData(hash_t *hIn)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csBuf;
	double	dTmp;
	char	csTmpAmt[PD_TMP_BUF_LEN + 1];
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

DEBUGLOG(("BuildAuthData()\n"));
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

// callbackUrl
	if (GetField_CString(hIn, "fe_url", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: callbackUrl = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("BuildAuthData:: callbackUrl is missing\n"));
	}

// clientIp
	if (GetField_CString(hIn, "user_ip", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: clientIp = [%s]\n", csPtr));
	}
        else {
		iRet = PD_ERR;
DEBUGLOG(("BuildAuthData:: clientIp is missing\n"));
	}

// merchantId
	if (GetField_CString(hIn, "psp_merchant_id", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: merchantId = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("BuildAuthData:: merchantId is missing\n"));
	}

// notifyUrl
	if (GetField_CString(hIn, "return_url_only", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: notifyUrl = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("BuildAuthData:: notifyUrl is missing\n"));
	}

// orderAmount
	if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
		sprintf((char*)csTmpAmt, "%ld", double2long(dTmp));
		strcat((char*)csBuf, csTmpAmt);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: orderAmount = [%s]\n", csTmpAmt));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("BuildAuthData:: orderAmount is missing\n"));
	}

// orderCurrency
	strcat((char*)csBuf, MY_XJE_CCY);
	strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: orderCurrency = [%s]\n", MY_XJE_CCY));

// paymentModeCode
	if (GetField_CString(hIn, "bank_code", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: paymentModeCode = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("BuildAuthData:: paymentModeCode is missing\n"));
	}

// productDetails.amount
	if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
		sprintf((char*)csTmpAmt, "%ld", double2long(dTmp));
		strcat((char*)csBuf, csTmpAmt);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: productDetails.amount = [%s]\n", csTmpAmt));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("BuildAuthData:: productDetails.amount is missing\n"));
	}

// productDetails.name
	strcat((char*)csBuf, MY_XJE_PRODUCT_NAME);
	strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: productDetails.name = [%s]\n", MY_XJE_PRODUCT_NAME));

// productDetails.quantity
	strcat((char*)csBuf, MY_XJE_PRODUCT_QUANTITY);
	strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: productDetails.quantity = [%s]\n", MY_XJE_PRODUCT_QUANTITY));

// requestId
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildAuthData:: requestId = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("BuildAuthData:: requestId is missing\n"));
	}

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("BuildAuthData:: auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);

DEBUGLOG(("BuildAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


int BuildRspAuthData(hash_t *hIn)
{
	int iRet = PD_OK;
	char *csPtr;
	char *csBuf;
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

DEBUGLOG(("BuildRspAuthData()\n"));
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

// completeDateTime
	if (GetField_CString(hIn, "completeDateTime", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: completeDateTime = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("BuildRspAuthData:: completeDateTime is missing\n"));
	}

// merchantId
	if (GetField_CString(hIn, "mid", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: merchantId = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("BuildRspAuthData:: merchantId is missing\n"));
	}

// orderAmount
	if (GetField_CString(hIn, "txn_amt", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: orderAmount = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("BuildRspAuthData:: orderAmount is missing\n"));
	}

// orderCurrency
	if (GetField_CString(hIn, "orderCurrency", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: orderCurrency = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("BuildRspAuthData:: orderCurrency is missing\n"));
	}

// remark
	if (GetField_CString(hIn, "remark", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: remark = [%s]\n", csPtr));
	}

// requestId
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: requestId = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("BuildRspAuthData:: requestId is missing\n"));
	}

// serialNumber
	if (GetField_CString(hIn, "tid", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: serialNumber = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("BuildRspAuthData:: serialNumber is missing\n"));
	}

// status
	if (GetField_CString(hIn, "status", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: status = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("BuildRspAuthData:: status is missing\n"));
	}

// totalRefundAmount
	if (GetField_CString(hIn, "totalRefundAmount", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: totalRefundAmount = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("BuildRspAuthData:: totalRefundAmount is missing\n"));
	}

// totalRefundCount
	if (GetField_CString(hIn, "totalRefundCount", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_XJE_SIGN_TOKEN);
DEBUGLOG(("BuildRspAuthData:: totalRefundCount = [%s]\n", csPtr));
	}
	else {
DEBUGLOG(("BuildRspAuthData:: totalRefundCount is missing\n"));
	}

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("BuildRspAuthData:: auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);

DEBUGLOG(("BuildRspAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


char *str_replace(char *orig, char *rep, char *with) {
	char *result;	// the return string
	char *ins;	// the next insert point
	char *tmp;	// varies
	int len_rep;	// length of rep (the string to remove)
	int len_with;	// length of with (the string to replace rep with)
	int len_front;	// distance between rep and end of last rep
	int count;	// number of replacements

	if (!orig || !rep)
		return NULL;
	len_rep = strlen(rep);
	if (len_rep == 0)
		return NULL; // empty rep causes infinite loop during count
	if (!with)
		with = "";
	len_with = strlen(with);

	// count the number of replacements needed
	ins = orig;
	for (count = 0; (tmp = strstr(ins, rep)); ++count) {
		ins = tmp + len_rep;
	}

	tmp = result = malloc(strlen(orig) + (len_with - len_rep) * count + 1);

	if (!result)
		return NULL;

	// first time through the loop, all the variable are set correctly
	// from here on,
	//    tmp points to the end of the result string
	//    ins points to the next occurrence of rep in orig
	//    orig points to the remainder of orig after "end of rep"
	while (count--) {
		ins = strstr(orig, rep);
		len_front = ins - orig;
		tmp = strncpy(tmp, orig, len_front) + len_front;
		tmp = strcpy(tmp, with) + len_with;
		orig += len_front + len_rep; // move to next "end of rep"
	}
	strcpy(tmp, orig);
	return result;
}

