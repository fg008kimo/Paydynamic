/*
PDProTech (c)2019. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version					   2019/09/05              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "HdvMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include <zlib.h>
#include "b64.h"
#include "ObjPtr.h"
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"
#define __USE_XOPEN
#include <time.h>
#include <json-c/json.h>


OBJPTR(DB);

static char	cDebug;

void	HdvMsg(char cdebug)
{
	cDebug = cdebug;
}

char *str_replace(char *orig, char *rep, char *with);
void remove_quote(const char *csValue, const int iType, char *csOut);

int FormatMsg(const hash_t *hIn, unsigned char *outMsg, int *outLen)
{
	int	iRet = PD_OK;
	char	*csTmp = NULL;
	char	*csPtr = NULL;
	char	*csBuf;
	char	*csMethod = NULL;

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

	memset(outMsg, 0, sizeof(outMsg));
	if (GetField_CString(hIn, "redirect_url", &csPtr)) {
DEBUGLOG(("FormatMsg here\n"));
		strcat((char*)outMsg, csPtr);
		strcat((char*)outMsg, "?");

		if (GetField_CString(hIn, "data_string", &csTmp)) {
			strcat((char*)outMsg, csTmp);
DEBUGLOG(("data_string = [%s]\n", csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("data_string is missing\n"));
		}

		if (GetField_CString(hIn, "sign", &csTmp)) {
			strcat((char*)outMsg, "signature");
			strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
DEBUGLOG(("signature = [%s]\n", csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("sign is missing\n"));
		}

		if (GetField_CString(hIn, "url_method", &csMethod)) {
DEBUGLOG(("url_method = [%s]\n", csMethod));
		}
		else
			csMethod = strdup("");

DEBUGLOG(("outmsg = [%s]\n", outMsg));
		base64_encode(outMsg, strlen((char*)outMsg), csBuf, PD_MAX_BUFFER);
DEBUGLOG(("after encode\n"));
		outMsg[0] = '\0';
		strcat((char*)outMsg, "redirect_url");
		strcat((char*)outMsg, "=");
		strcat((char*)outMsg, csBuf);
		strcat((char*)outMsg, MY_HDV_TOKEN);
		strcat((char*)outMsg, "url_method");
		strcat((char*)outMsg, "=");
		strcat((char*)outMsg, csMethod);
		strcat((char*)outMsg, MY_HDV_TOKEN);
		strcat((char*)outMsg, "ret_status=0");
DEBUGLOG(("outMsg = [%s]\n", outMsg));

		*outLen = strlen((const char*)outMsg);
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("***redirect_url is missing\n"));
	}

DEBUGLOG(("FormatMsg:: normal exit iRet = [%d]\n", iRet));
	FREE_ME(csBuf);
	return iRet;
}


int BuildAuthData(hash_t *hIn)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csBuf;
	double	dTmp;
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);
	char	cTmp;
	int	iIsMobile = PD_FALSE;
	int	iForEnquiry = PD_FALSE;
	int	iForEnquiryRsp = PD_FALSE;

DEBUGLOG(("BuildAuthData()\n"));

	GetField_Int(hIn, "for_enquiry_use", &iForEnquiry);
	if (iForEnquiry) {
		return BuildInqAuthData(hIn);
	}

	GetField_Int(hIn, "for_enquiry_rsp_use", &iForEnquiryRsp);
	if (iForEnquiryRsp) {
		return BuildCallbackAuthData(hIn);
	}

	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

// signType
	strcat((char*)csBuf, "signType");
	strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
	strcat((char*)csBuf, MY_HDV_SIGN_TYPE);
	strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("signType = [%s]\n", MY_HDV_SIGN_TYPE));

// encoding
	strcat((char*)csBuf, "encoding");
	strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
	strcat((char*)csBuf, MY_HDV_ENCODING);
	strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("encoding = [%s]\n", MY_HDV_ENCODING));

// version
	strcat((char*)csBuf, "version");
	strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
	strcat((char*)csBuf, MY_HDV_VERSION);
	strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("version = [%s]\n", MY_HDV_VERSION));

// insCode
	if (GetField_CString(hIn, "psp_merchant_id", &csPtr)) {
		strcat((char*)csBuf, "insCode");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("insCode = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("psp_merchant_id is missing\n"));
	}

// insMerchantCode
	if (GetField_CString(hIn, "psp_key_id", &csPtr)) {
		strcat((char*)csBuf, "insMerchantCode");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("insMerchantCode = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("psp_key_id is missing\n"));
	}

// hpMerCode
	if (GetField_CString(hIn, "psp_passphrase", &csPtr)) {
		strcat((char*)csBuf, "hpMerCode");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("hpMerCode = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("psp_passphrase is missing\n"));
	}

// nonceStr
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
		strcat((char*)csBuf, "nonceStr");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("nonceStr = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("txn_seq is missing\n"));
	}

// orderNo
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
		strcat((char*)csBuf, "orderNo");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("orderNo = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("txn_seq is missing\n"));
	}

// orderDate
	if (GetField_CString(hIn, "local_tm_date", &csPtr)) {
		strcat((char*)csBuf, "orderDate");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("orderDate = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("local_tm_date is missing\n"));
	}

// orderTime
	if (GetField_CString(hIn, "local_tm_date", &csPtr)) {
		char *csPtr2 = NULL;
		char csDateTime[PD_DATETIME_LEN * 2];
		if (GetField_CString(hIn, "local_tm_time", &csPtr2)) {
			sprintf(csDateTime, "%s%s", csPtr, csPtr2);
			strcat((char*)csBuf, "orderTime");
			strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
			strcat((char*)csBuf, csDateTime);
			strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("orderTime = [%s]\n", csDateTime));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("local_tm_time is missing\n"));
		}
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("local_tm_date is missing\n"));
	}

// orderAmount
	if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
		char csTmpAmt[PD_TMP_BUF_LEN + 1];
		sprintf((char*)csTmpAmt, "%ld", double2long(dTmp));
		strcat((char*)csBuf, "orderAmount");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		strcat((char*)csBuf, csTmpAmt);
		strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("orderAmount = [%s]\n", csTmpAmt));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("psp_txn_amt is missing\n"));
	}

// currencyCode
	strcat((char*)csBuf, "currencyCode");
	strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
	strcat((char*)csBuf, MY_HDV_CURRENCY_CODE);
	strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("currencyCode = [%s]\n", MY_HDV_CURRENCY_CODE));

// paymentChannel
	if (GetField_CString(hIn, "bank_code", &csPtr)) {
		strcat((char*)csBuf, "paymentChannel");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		DBObjPtr = CreateObj(DBPtr, "DBMobBankMap", "IsMobileOption");
		int iOpt = (unsigned long)(*DBObjPtr)(csPtr);
		if (!iOpt && iOpt != INT_ERR) {
			strcat((char*)csBuf, csPtr);
DEBUGLOG(("paymentChannel = [%s]\n", csPtr));
		} else {
			iIsMobile = PD_TRUE;
		}
		strcat((char*)csBuf, MY_HDV_TOKEN);
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("bank_code is missing\n"));
	}

// frontUrl
	if (GetField_CString(hIn, "fe_url", &csPtr)) {
		strcat((char*)csBuf, "frontUrl");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("frontUrl = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("fe_url is missing\n"));
	}

// backUrl
	if (GetField_CString(hIn, "return_url_only", &csPtr)) {
		strcat((char*)csBuf, "backUrl");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("backUrl = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("return_url_only is missing\n"));
	}

// merReserve
	strcat((char*)csBuf, "merReserve");
	strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
	strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("merReserve is not necessary\n"));

// ledger
	strcat((char*)csBuf, "ledger");
	strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
	strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("ledger is not necessary\n"));

// riskArea
	strcat((char*)csBuf, "riskArea");
	strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
	strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("riskArea is not necessary\n"));

// gatewayProductType
	strcat((char*)csBuf, "gatewayProductType");
	strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
	strcat((char*)csBuf, MY_HDV_GATEWAY_PROD_TYPE);
	strcat((char*)csBuf, MY_HDV_TOKEN);
DEBUGLOG(("gatewayProductType = [%s]\n", MY_HDV_GATEWAY_PROD_TYPE));

// accNoType
	if (GetField_Char(hIn, "card_type", &cTmp)) {
DEBUGLOG(("card_type = [%c]\n", cTmp));
		strcat((char*)csBuf, "accNoType");
		strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
		if (cTmp == PD_DEPOSIT_CARD_TYPE_CREDIT) {
			strcat((char*)csBuf, MY_HDV_ACC_NO_TYPE_CREDIT);
DEBUGLOG(("accNoType = [%s]\n", MY_HDV_ACC_NO_TYPE_CREDIT));
		}
		else {
			strcat((char*)csBuf, MY_HDV_ACC_NO_TYPE_DEBIT);
DEBUGLOG(("accNoType = [%s]\n", MY_HDV_ACC_NO_TYPE_DEBIT));
		}
		strcat((char*)csBuf, MY_HDV_TOKEN);
	}

// clientType
	strcat((char*)csBuf, "clientType");
	strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
	if (!iIsMobile) {
		strcat((char*)csBuf, MY_HDV_CLIENT_TYPE_PC);
DEBUGLOG(("clientType = [%s]\n", MY_HDV_CLIENT_TYPE_PC));
	}
	else {
		strcat((char*)csBuf, MY_HDV_CLIENT_TYPE_MOBILE);
DEBUGLOG(("clientType = [%s]\n", MY_HDV_CLIENT_TYPE_MOBILE));
	}
	strcat((char*)csBuf, MY_HDV_TOKEN);

	PutField_CString(hIn, "data_string", csBuf);

	strcat((char*)csBuf, "signKey=");

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("BuildAuthData:: auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);

DEBUGLOG(("BuildAuthData() Exit iRet = [%d]\n", iRet));
        return iRet;
}


int BreakDownMsg(hash_t *hOut, const unsigned char *inMsg, int inLen)
{
	int	iRet = PD_OK;
	int	iTmpRet = PD_OK;
	char	*csDATA = malloc (PD_MAX_BUFFER + 1);
	char	*csPara = malloc (PD_MAX_BUFFER + 1);
	char	*csTmp;
	char	csTag[PD_TAG_LEN + 1];
	char	csMsg[PD_MAX_BUFFER + 1];
	csMsg[0] = '\0';
	int	iIsTraceReturn = PD_FALSE;
	char	*p;

	hash_t *hRec;
	hRec = (hash_t *) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	memcpy(csDATA, inMsg, inLen);
	csDATA[inLen] = '\0';

DEBUGLOG(("BreakDownMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n", inMsg, inLen));

	char	csDst[PD_MAX_BUFFER + 1];
	int	iLen = 0;
	urldecode((const unsigned char*)csDATA, strlen(csDATA), (unsigned char *)csDst, &iLen);
	strcpy(csDATA, csDst);

	// remove '{'
	csPara[0] = '\0';
	remove_quote(csDATA, PD_OPEN_BRACKET_H, csPara);
	csPara[strlen(csPara)] = '\0';
	strcpy(csDATA, csPara);

	// remove '}'
	csPara[0] = '\0';
	remove_quote(csDATA, PD_CLOSE_BRACKET_H, csPara);
	csPara[strlen(csPara)] = '\0';
	strcpy(csDATA, csPara);

	p = strstr(csPara, "transStatus");
	if (p) {
		iIsTraceReturn = PD_TRUE;
		iTmpRet = Str2Cls(hRec, (const char *)csDATA, MY_HDV_JSON_TOKEN, MY_HDV_JSON_FIELD_TOKEN);
	} else {
		iIsTraceReturn = PD_FALSE;
		iTmpRet = Str2Cls(hRec, (const char *)csDATA, MY_HDV_TOKEN, MY_HDV_FIELD_TOKEN);
	}

	if (iTmpRet == PD_OK) {
		if (!iIsTraceReturn) {
			sprintf(csTag, "signType");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("signType = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "signType", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("signType not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "encoding");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("encoding = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "encoding", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("encoding not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "version");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("version = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "version", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("version not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		}

		if (iIsTraceReturn) {
			sprintf(csTag, "\"insCode\"");
		} else {
			sprintf(csTag, "insCode");
		}
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("insCode = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "insCode", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("insCode not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		if (iIsTraceReturn) {
			sprintf(csTag, "\"insMerchantCode\"");
		} else {
			sprintf(csTag, "insMerchantCode");
		}
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("insMerchantCode = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "insMerchantCode", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("insMerchantCode not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		if (iIsTraceReturn) {
			sprintf(csTag, "\"hpMerCode\"");
		} else {
			sprintf(csTag, "hpMerCode");
		}
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("hpMerCode = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "hpMerCode", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("hpMerCode not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		if (!iIsTraceReturn) {
			sprintf(csTag, "nonceStr");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("nonceStr = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "nonceStr", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("nonceStr not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		}

		if (iIsTraceReturn) {
			sprintf(csTag, "\"signature\"");
		} else {
			sprintf(csTag, "signature");
		}
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("signature = [%s]\n", csPara));
			PutField_CString(hOut, "signature", csPara);
			PutField_CString(hOut, "sign", csPara);
		} else {
DEBUGLOG(("signature not found\n"));
		}

		if (iIsTraceReturn) {
			sprintf(csTag, "\"orderNo\"");
		} else {
			sprintf(csTag, "orderNo");
		}
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("orderNo = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "orderNo", csPara);
				PutField_CString(hOut, "txn_seq", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("orderNo not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		if (!iIsTraceReturn) {
			sprintf(csTag, "orderDate");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("orderDate = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "orderDate", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("orderDate not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "orderTime");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("orderTime = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "orderTime", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("orderTime not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "orderAmount");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("orderAmount = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "orderAmount", csPara);
					PutField_CString(hOut, "txn_amt", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("orderAmount not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "currencyCode");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("currencyCode = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "currencyCode", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("currencyCode not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
			sprintf(csTag, "\"transDate\"");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("transDate = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "transDate", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("transDate not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "\"transStatus\"");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("transStatus = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "transStatus", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("transStatus not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "\"transAmount\"");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("transAmount = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "transAmount", csPara);
					PutField_CString(hOut, "txn_amt", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}       
			} else {
DEBUGLOG(("transAmount not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "\"actualAmount\"");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("actualAmount = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "actualAmount", csPara);
					PutField_CString(hOut, "txn_amt", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("actualAmount not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		}

		if (iIsTraceReturn) {
			sprintf(csTag, "\"transSeq\"");
		} else {
			sprintf(csTag, "transSeq");
		}
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("transSeq = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "transSeq", csPara);
				PutField_CString(hOut, "tid", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("transSeq not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		if (!iIsTraceReturn) {
			sprintf(csTag, "transCharge");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("transCharge = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "transCharge", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("transCharge not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "settleDate");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("settleDate = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "settleDate", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("settleDate not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}

			sprintf(csTag, "merReserved");
			if (GetField_CString(hRec, csTag, &csTmp)) {
				csPara[0] = '\0';
				remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
				csPara[strlen(csPara)] = '\0';
DEBUGLOG(("merReserved = [%s]\n", csPara));
				if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
					PutField_CString(hOut, "merReserved", csPara);
					strcat((char*)csMsg, csPara);
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				} else {
					strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
				}
			} else {
DEBUGLOG(("merReserved not found\n"));
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		}

		if (iIsTraceReturn) {
			sprintf(csTag, "\"statusCode\"");
		} else {
			sprintf(csTag, "statusCode");
		}
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("statusCode = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "statusCode", csPara);
				PutField_CString(hOut, "status", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("statusCode not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		if (iIsTraceReturn) {
			sprintf(csTag, "\"statusMsg\"");
		} else {
			sprintf(csTag, "statusMsg");
		}
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("statusMsg = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "statusMsg", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("statusMsg not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

/*
		sprintf(csTag, "\"statusMsg\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("statusMsg = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				csPara[0] = '\0';
				sprintf(csPara, "{%s:%s}", csTag, csTmp);
				struct json_object *jobj;
				enum json_type type;
				jobj = json_tokener_parse((const char *)csPara);
				if (jobj != NULL) {
					json_object_object_foreach(jobj, key, val) {
						type = json_object_get_type(val);
						switch (type) {
							case json_type_string:
								PutField_CString(hOut, "statusMsg", json_object_get_string(val));
								strcat((char*)csMsg, json_object_get_string(val));
								strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("converted statusMsg = [%s]\n", json_object_get_string(val)));
							break;
							default:
DEBUGLOG(("unsupported type\n"));
							break;
						}
					}
				}
				json_object_put(jobj);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("statusMsg not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}
*/

		PutField_CString(hOut, "data_string", csMsg);
	} else {
DEBUGLOG(("BreakDownMsg() Error\n"));
		iRet = PD_ERR;
	}

	FREE_ME(csDATA);
	FREE_ME(csPara);
	hash_destroy(hRec);
	FREE_ME(hRec);

DEBUGLOG(("BreakDownMsg Exit\n"));
	return iRet;
}


int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
	int	iRet = PD_OK;

	return iRet;
}


int BuildRspAuthData(hash_t *hIn)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csBuf;
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

DEBUGLOG(("BuildRspAuthData()\n"));

	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

	if (GetField_CString(hIn, "data_string", &csPtr)) {
		strcat((char*)csBuf, csPtr);
DEBUGLOG(("BuildRspAuthData:: data_string = [%s]\n", csPtr));
	}

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("BuildRspAuthData:: auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);

DEBUGLOG(("BuildRspAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


char *str_replace(char *orig, char *rep, char *with) {
        char *result;   // the return string
        char *ins;      // the next insert point
        char *tmp;      // varies
        int len_rep;    // length of rep (the string to remove)
        int len_with;   // length of with (the string to replace rep with)
        int len_front;  // distance between rep and end of last rep
        int count;      // number of replacements

        if (!orig || !rep)
                return NULL;
        len_rep = strlen(rep);
        if (len_rep == 0)
                return NULL; // empty rep causes infinite loop during count
        if (!with)
                with = "";
        len_with = strlen(with);

        // count the number of replacements needed
        ins = orig;
        for (count = 0; (tmp = strstr(ins, rep)); ++count) {
                ins = tmp + len_rep;
        }

        tmp = result = malloc(strlen(orig) + (len_with - len_rep) * count + 1);

        if (!result)
                return NULL;

        // first time through the loop, all the variable are set correctly
        // from here on,
        //    tmp points to the end of the result string
        //    ins points to the next occurrence of rep in orig
        //    orig points to the remainder of orig after "end of rep"
        while (count--) {
                ins = strstr(orig, rep);
                len_front = ins - orig;
                tmp = strncpy(tmp, orig, len_front) + len_front;
                tmp = strcpy(tmp, with) + len_with;
                orig += len_front + len_rep; // move to next "end of rep"
        }
        strcpy(tmp, orig);
        return result;
}


void remove_quote(const char *csValue, const int iType, char *csOut)
{
	int i = 0;
	int cnt = 0;
	for (i = 0; i < strlen(csValue); i++) {
		if (csValue[i] != iType) {
			csOut[cnt] = csValue[i];
			cnt++;
		} else {
		}
	}
	csOut[cnt] = '\0';
}


int BuildInqAuthData(hash_t *hIn)
{
	int	iRet = PD_OK;
	char	*csBuf;
	char	*csPtr = NULL;

DEBUGLOG(("BuildInqAuthData() Start\n"));

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

// insCode
	if (GetField_CString(hIn, "psp_merchant_id", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("insCode = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("psp_merchant_id is missing\n"));
	}

// insMerchantCode
	if (GetField_CString(hIn, "psp_key_id", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("insMerchantCode = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("psp_key_id is missing\n"));
	}

// hpMerCode
	if (GetField_CString(hIn, "psp_passphrase", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("hpMerCode = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("psp_passphrase is missing\n"));
	}

// orderNo
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("orderNo = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("txn_seq is missing\n"));
	}

// transDate
	if (GetField_CString(hIn, "txn_datetime", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("transDate = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("txn_datetime is missing\n"));
	}

// transSeq
	strcat((char*)csBuf, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("transSeq is NULL\n"));

// productType
	strcat((char*)csBuf, MY_HDV_PROD_TYPE);
	strcat((char*)csBuf, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("productType = [%s]\n", MY_HDV_PROD_TYPE));

// paymentType
	strcat((char*)csBuf, MY_HDV_GATEWAY_PROD_TYPE);
	strcat((char*)csBuf, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("paymentType = [%s]\n", MY_HDV_GATEWAY_PROD_TYPE));

// nonceStr
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_HDV_SIGN_TOKEN);
DEBUGLOG(("nonceStr = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("txn_seq is missing\n"));
	}

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("BuildInqAuthData() auth_data = [%s]\n", csBuf));
DEBUGLOG(("BuildInqAuthData() Exit iRet = [%d]\n", iRet));
	FREE_ME(csBuf);
	return iRet;
}


int FormatInqMsg(const hash_t* hIn, unsigned char *outMsg, int *outLen)
{
	int	iRet = PD_OK;
	char	*csBuf;
	char	*csURL = NULL;
	char	*csPtr = NULL;
	char	*csTmp = NULL;

DEBUGLOG(("FormatInqMsg() Start\n"));

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);
	memset(outMsg,0,sizeof(outMsg));

	if (GetField_CString(hIn, "psp_url", &csURL)) {
		if (GetField_CString(hIn, "request_function", &csPtr)) {
			strcpy((char*)csBuf, "url");
			strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
			strcat((char*)csBuf, csURL);
			strcat((char*)csBuf, "/");
			strcat((char*)csBuf, csPtr);

			/* added for gw to identify the request */
			strcat((char*)csBuf, MY_HDV_TOKEN);
			strcat((char*)csBuf, "enq");
			strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
			strcat((char*)csBuf, "1");

			strcat((char*)csBuf, MY_HDV_TOKEN);
			strcat((char*)csBuf, "METHOD");
			strcat((char*)csBuf, MY_HDV_FIELD_TOKEN);
			if (GetField_CString(hIn, "url_method", &csPtr)) {
				strcat((char*)csBuf, csPtr);
			}
			else {
				strcat((char*)csBuf, PD_DEFAULT_METHOD);
			}
		}

		sprintf((char*)outMsg, "%0*d", PD_WEB_HEADER_LEN_LEN, (int)strlen(csBuf));
		strcat((char*)outMsg, csBuf);
DEBUGLOG(("outMsg = [%s]\n", outMsg));

// insCode
		if (GetField_CString(hIn, "psp_merchant_id", &csTmp)) {
			strcat((char*)outMsg, "insCode");
			strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("insCode = [%s]\n", csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***psp_merchant_id is missing\n"));
		}

// insMerchantCode
		if (GetField_CString(hIn, "psp_key_id", &csTmp)) {
			strcat((char*)outMsg, "insMerchantCode");
			strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("insMerchantCode = [%s]\n", csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***psp_key_id is missing\n"));
		}

// hpMerCode
		if (GetField_CString(hIn, "psp_passphrase", &csTmp)) {
			strcat((char*)outMsg, "hpMerCode");
			strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("hpMerCode = [%s]\n", csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***psp_passphrase is missing\n"));
		}

// orderNo
		if (GetField_CString(hIn, "txn_seq", &csTmp)) {
			strcat((char*)outMsg, "orderNo");
			strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("orderNo = [%s]\n", csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***txn_seq is missing\n"));
		}

// transDate
		if (GetField_CString(hIn, "txn_datetime", &csTmp)) {
			strcat((char*)outMsg, "transDate");
			strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("transDate = [%s]\n", csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***txn_datetime is missing\n"));
		}

// transSeq
		strcat((char*)outMsg, "transSeq");
		strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
		strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("transSeq is NULL\n"));

// productType
		strcat((char*)outMsg, "productType");
		strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
		strcat((char*)outMsg, MY_HDV_PROD_TYPE);
		strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("productType = [%s]\n", MY_HDV_PROD_TYPE));

// paymentType
		strcat((char*)outMsg, "paymentType");
		strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
		strcat((char*)outMsg, MY_HDV_GATEWAY_PROD_TYPE);
		strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("paymentType = [%s]\n", MY_HDV_GATEWAY_PROD_TYPE));

// nonceStr
		if (GetField_CString(hIn, "txn_seq", &csTmp)) {
			strcat((char*)outMsg, "nonceStr");
			strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("nonceStr = [%s]\n", csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***txn_seq is missing\n"));
		}

// signature
		if (GetField_CString(hIn, "sign", &csTmp)) {
			strcat((char*)outMsg, "signature");
			strcat((char*)outMsg, MY_HDV_FIELD_TOKEN);
			strcat((char*)outMsg, csTmp);
			//strcat((char*)outMsg, MY_HDV_TOKEN);
DEBUGLOG(("signature = [%s]\n", csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***sign is missing\n"));
		}
	}
	else {
DEBUGLOG(("***psp_url is missing\n"));
		iRet = PD_ERR;
	}

	*outLen = strlen((const char*)outMsg);
DEBUGLOG(("FormatInqMsg() [%s][%d]\n", outMsg, *outLen));
DEBUGLOG(("FormatInqMsg() Exit iRet = [%d]\n", iRet));
	FREE_ME(csBuf);
	return iRet;
}


int BreakDownInqRspMsg(hash_t *hContext, hash_t *hOut, const unsigned char *inMsg, int inLen)
{
	int iRet = PD_OK;
	char *csDATA = malloc (PD_MAX_BUFFER + 1);
	char *csPara = malloc (PD_MAX_BUFFER + 1);
	char *csTmp;
	char csTag[PD_TAG_LEN + 1];
	char csMsg[PD_MAX_BUFFER + 1];
	csMsg[0] = '\0';

	hash_t *hRec;
	hRec = (hash_t *) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	memcpy(csDATA, inMsg, inLen);
	csDATA[inLen] = '\0';

DEBUGLOG(("BreakDownInqRspMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n", inMsg, inLen));

	PutField_CString(hOut, "orig_msg", (const char *)inMsg);

	// remove '{'
	csPara[0] = '\0';
	remove_quote(csDATA, PD_OPEN_BRACKET_H, csPara);
	csPara[strlen(csPara)] = '\0';
	strcpy(csDATA, csPara);

	// remove '}'
	csPara[0] = '\0';
	remove_quote(csDATA, PD_CLOSE_BRACKET_H, csPara);
	csPara[strlen(csPara)] = '\0';
	strcpy(csDATA, csPara);

	if (Str2Cls(hRec, (const char *)csDATA, MY_HDV_JSON_TOKEN, MY_HDV_JSON_FIELD_TOKEN) == PD_OK) {

		sprintf(csTag, "\"insCode\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("insCode = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("insCode not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"insMerchantCode\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("insMerchantCode = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("insMerchantCode not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"hpMerCode\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("hpMerCode = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("hpMerCode not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"orderNo\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("orderNo = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "txn_seq", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("orderNo not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"transDate\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("transDate = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("transDate not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"transStatus\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("transStatus = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("transStatus not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"transAmount\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("transAmount = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "txn_amt", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("transAmount not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"actualAmount\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("actualAmount = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("actualAmount not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"transSeq\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("transSeq = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("transSeq not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"statusCode\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("statusCode = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "status", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("statusCode not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"statusMsg\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("statusMsg = [%s]\n", csPara));
			if (strcmp(csPara, MY_HDV_NULL_VALUE)) {
				PutField_CString(hOut, "fail_reason", csPara);
				strcat((char*)csMsg, csPara);
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			} else {
				strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
			}
		} else {
DEBUGLOG(("statusMsg not found\n"));
			strcat((char*)csMsg, MY_HDV_SIGN_TOKEN);
		}

		sprintf(csTag, "\"signature\"");
		if (GetField_CString(hRec, csTag, &csTmp)) {
			csPara[0] = '\0';
			remove_quote(csTmp, PD_DOUBLE_QUOTE, csPara);
			csPara[strlen(csPara)] = '\0';
DEBUGLOG(("signature = [%s]\n", csPara));
			PutField_CString(hOut, "sign", csPara);
		} else {
DEBUGLOG(("signature not found\n"));
		}

		PutField_CString(hOut, "data_string", csMsg);
	} else {
DEBUGLOG(("BreakDownInqRspMsg() Error\n"));
		iRet = PD_ERR;
	}

	FREE_ME(csDATA);
	FREE_ME(csPara);
	hash_destroy(hRec);
	FREE_ME(hRec);
DEBUGLOG(("BreakDownInqRspMsg Exit\n"));
	return iRet;
}


int BuildInqRspAuthData(hash_t *hIn)
{
	int iRet = PD_OK;

DEBUGLOG(("BuildInqRspAuthData() Start\n"));
DEBUGLOG(("BuildInqRspAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


int BuildCallbackAuthData(hash_t *hIn)
{
	int iRet = PD_OK;

DEBUGLOG(("BuildCallbackAuthData() Start\n"));

	PutField_CString(hIn, "auth_data", "dummy");
DEBUGLOG(("BuildCallbackAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


int FormatCallbackMsg(hash_t *hContext, hash_t *hIn, unsigned char *outMsg, int *outLen)
{
	int iRet = PD_OK;
	char *csPtr = NULL;

DEBUGLOG(("FormatCallbackMsg() Start\n"));

	memset(outMsg, 0, sizeof(outMsg));

	GetField_CString(hIn, "orig_msg", &csPtr);
	strcat((char*)outMsg, csPtr);

	*outLen = strlen((const char*)outMsg);
DEBUGLOG(("FormatCallbackMsg() [%s][%d]\n", outMsg, *outLen));
DEBUGLOG(("FormatCallbackMsg() Exit iRet = [%d]\n", iRet));
	return iRet;
}

