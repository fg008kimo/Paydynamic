/*
PDProTech (c)2017. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2018/02/06              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "SfeMsg.h"
#include "common.h"
#include "utilitys.h"
#include "queue_defs.h"
#include <zlib.h>
#include "b64.h"
#include "internal.h"
#include "ObjPtr.h"
#define __USE_XOPEN
#include <time.h>
#include <json-c/json.h>

char cDebug;


struct key_value_pair
{
	char key[PD_TMP_BUF_LEN];
	char value[PD_TMP_MSG_BUF_LEN];
};

OBJPTR(DB);

void SfeMsg(char cdebug)
{
	cDebug = cdebug;
}

char *str_replace(char *orig, char *rep, char *with);

int FormatMsg(const hash_t *hIn, unsigned char *outMsg, int *outLen)
{
	int	iRet = PD_OK;
	char	*csTmp = NULL;
	char	*csPtr = NULL;
	char	*csBuf;
	double	dTmp;
	char	*csMethod = NULL;
	char	csData[MAX_MSG_SIZE + 1];

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);
	//csBuf = (char*) malloc (PD_MAX_BUFFER + 1);

	memset(outMsg, 0, sizeof(outMsg));
	if (GetField_CString(hIn, "redirect_url", &csPtr)) {
DEBUGLOG(("FormatMsg here\n"));
		strcat((char*)outMsg, csPtr);
		strcat((char*)outMsg, "?");

		json_object *jobj = json_object_new_object();

// mchNo
		if (GetField_CString(hIn, "psp_merchant_id", &csTmp)) {
DEBUGLOG(("mchNo = [%s]\n", csTmp));
			json_object_object_add(jobj, "mchNo", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***psp_merchant_id is missing\n"));
		}

// transId
DEBUGLOG(("transId = [%s]\n", MY_SFE_TRANS_ID_EC));
		json_object_object_add(jobj, "transId", json_object_new_string(MY_SFE_TRANS_ID_EC));

// orderNo
		if (GetField_CString(hIn, "txn_seq", &csTmp)) {
DEBUGLOG(("orderNo = [%s]\n", csTmp));
			json_object_object_add(jobj, "orderNo", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***txn_seq is missing\n"));
		}

// cardholderPhoneNo
		if (GetField_CString(hIn, "customer_tel", &csTmp)) {
DEBUGLOG(("cardholderPhoneNo = [%s]\n", csTmp));
			json_object_object_add(jobj, "cardholderPhoneNo", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***customer_tel is missing\n"));
		}

// productName
DEBUGLOG(("productName = [%s]\n", MY_SFE_PRODUCT_NAME));
		json_object_object_add(jobj, "productName", json_object_new_string(MY_SFE_PRODUCT_NAME));

// transAmt
		if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
			char csTmpAmt[PD_TMP_BUF_LEN + 1];
			sprintf((char*)csTmpAmt, "%ld", double2long(dTmp));
DEBUGLOG(("transAmt = [%s]\n", csTmpAmt));
			json_object_object_add(jobj, "transAmt", json_object_new_string(csTmpAmt));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***psp_txn_amt is missing\n"));
		}

// successUrl
		if (GetField_CString(hIn, "fe_url", &csTmp)) {
DEBUGLOG(("successUrl = [%s]\n", csTmp));
			json_object_object_add(jobj, "successUrl", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***fe_url is missing\n"));
		}

// failUrl
		if (GetField_CString(hIn, "fe_url", &csTmp)) {
DEBUGLOG(("failUrl = [%s]\n", csTmp));
			json_object_object_add(jobj, "failUrl", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***fe_url is missing\n"));
		}

// notifyUrl
		if (GetField_CString(hIn, "return_url_only", &csTmp)) {
DEBUGLOG(("notifyUrl = [%s]\n", csTmp));
			json_object_object_add(jobj, "notifyUrl", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***return_url_only is missing\n"));
		}

// pageUrl
		if (GetField_CString(hIn, "fe_url", &csTmp)) {
DEBUGLOG(("pageUrl = [%s]\n", csTmp));
			json_object_object_add(jobj, "pageUrl", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***fe_url is missing\n"));
		}

// sign
		if (GetField_CString(hIn, "sign", &csTmp)) {
DEBUGLOG(("sign = [%s]\n", csTmp));
			json_object_object_add(jobj, "sign", json_object_new_string(csTmp));
		}
		else {
			iRet = PD_ERR;
DEBUGLOG(("***sign is missing\n"));
		}

		strcpy((char*)csData, str_replace((char*)(json_object_to_json_string_ext(jobj, JSON_C_TO_STRING_PLAIN)), "\\/", "/"));
		strcat((char*)outMsg, "orderStr=");
		strcat((char*)outMsg, csData);

// url_method
		if (GetField_CString(hIn, "url_method", &csMethod)) {
DEBUGLOG(("url_method = [%s]\n", csMethod));
		}
		else
			csMethod = strdup("");

DEBUGLOG(("outmsg = [%s]\n", outMsg));
		base64_encode(outMsg, strlen((char*)outMsg), csBuf, PD_MAX_BUFFER);
DEBUGLOG(("after encode\n"));
		outMsg[0] = '\0';
		strcat((char*)outMsg, "redirect_url");
		strcat((char*)outMsg, "=");
		strcat((char*)outMsg, csBuf);
		strcat((char*)outMsg, MY_SFE_TOKEN);
		strcat((char*)outMsg, "url_method");
		strcat((char*)outMsg, "=");
		strcat((char*)outMsg, csMethod);
		strcat((char*)outMsg, MY_SFE_TOKEN);
		strcat((char*)outMsg, "ret_status=0");
DEBUGLOG(("outMsg = [%s]\n", outMsg));

		*outLen = strlen((const char*)outMsg);

		json_object_put(jobj);
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("***redirect_url is missing\n"));
	}

DEBUGLOG(("FormatMsg:: normal exit iRet = [%d]\n", iRet));
	FREE_ME(csBuf);
	return iRet;
}


int BreakDownMsg(hash_t *hOut, const unsigned char *inMsg, int inLen)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	csMsg[PD_MAX_BUFFER + 1];
	hash_t 	*hRec;

	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	csMsg[0] = '\0';

DEBUGLOG(("BreakDownMsg()\n"));
DEBUGLOG(("DATA = [%s][%d]\n", inMsg, inLen));

	struct json_object *jobj;
	enum json_type type;

	jobj = json_tokener_parse((const char *)inMsg);
	if (jobj != NULL) {
		json_object_object_foreach(jobj, key, val) {
			type = json_object_get_type(val);
			switch (type) {
				case json_type_string:
					strcat((char*)csMsg, key);
					strcat((char*)csMsg, MY_SFE_FIELD_TOKEN);
					strcat((char*)csMsg, json_object_get_string(val));
					strcat((char*)csMsg, MY_SFE_TOKEN);
				break;
				case json_type_int:
					strcat((char*)csMsg, key);
					strcat((char*)csMsg, MY_SFE_FIELD_TOKEN);
					sprintf((char*)csMsg, "%s%d", (char*)csMsg, json_object_get_int(val));
					strcat((char*)csMsg, MY_SFE_TOKEN);
				break;
				default:
DEBUGLOG(("BreakDownMsg:: unsupported type\n"));
				break;
			}
		}
	}

	if (Str2Cls(hRec, (char *)csMsg, MY_SFE_TOKEN, MY_SFE_FIELD_TOKEN) == PD_OK) {
// inMsg
		PutField_CString(hOut, "in_msg", (char *)csMsg);

// retCode
		if (GetField_CString(hRec, "retCode", &csPtr)) {
DEBUGLOG(("retCode = [%s]\n", csPtr));
			if (!strcmp(csPtr, "0000")) {
// retMsg

// resultCode
				if (GetField_CString(hRec, "resultCode", &csPtr)) {
					PutField_CString(hOut, "status", csPtr);
DEBUGLOG(("resultCode:status = [%s]\n", csPtr));
				}
				else {
DEBUGLOG(("resultCode:status not found\n"));
				}

// resultDesc

// transAmt
				if (GetField_CString(hRec, "transAmt", &csPtr)) {
					PutField_CString(hOut, "txn_amt", csPtr);
DEBUGLOG(("transAmt:txn_amt = [%s]\n", csPtr));
				}
				else {
DEBUGLOG(("transAmt:txn_amt not found\n"));
				}

// orderNo
				if (GetField_CString(hRec, "orderNo", &csPtr)) {
					PutField_CString(hOut, "txn_seq", csPtr);
DEBUGLOG(("orderNo:txn_seq = [%s]\n", csPtr));
				}
				else {
DEBUGLOG(("orderNo:txn_seq not found\n"));
				}

// mchNo
				if (GetField_CString(hRec, "mchNo", &csPtr)) {
					PutField_CString(hOut, "psp_merchant_id", csPtr);
DEBUGLOG(("mchNo:psp_merchant_id = [%s]\n", csPtr));
				}
				else {
DEBUGLOG(("mchNo:psp_merchant_id not found\n"));
				}

// nonceStr

// payTime
				if (GetField_CString(hRec, "payTime", &csPtr)) {
					char csRaw[PD_DATETIME_LEN * 2];
					char csConverted[PD_DATETIME_LEN * 2];
					char csTxnDate[PD_DATE_LEN + 1];
					struct tm tm;
					strcpy(csRaw, csPtr);
					strptime((const char*)csRaw, "%Y-%m-%d %H:%M:%S", &tm);
					strftime(csConverted, sizeof(csConverted), "%Y%m%d%H%M%S", &tm);
					strncpy(csTxnDate, csConverted, PD_DATE_LEN);
					csTxnDate[PD_DATE_LEN] = '\0';

					PutField_CString(hOut, "fundin_date", csConverted);
					PutField_CString(hOut, "txn_date", csTxnDate);
DEBUGLOG(("payTime:fundin_date = [%s]\n", csPtr));
				}
				else {
DEBUGLOG(("payTime:fundin_date not found\n"));
				}

// sign
				if (GetField_CString(hRec, "sign", &csPtr)) {
					PutField_CString(hOut, "sign", csPtr);
DEBUGLOG(("sign:sign = [%s]\n", csPtr));
				}
				else {
					PutField_CString(hOut, "sign", " ");
DEBUGLOG(("sign:sign not found\n"));
				}
			} else {
DEBUGLOG(("retCode returns non-success\n"));
			}
		} else {
DEBUGLOG(("retCode not found\n"));
		}
	}
	else {
DEBUGLOG(("BreakDownMsg() Error\n"));
		iRet = PD_ERR;
	}

	hash_destroy(hRec);
	FREE_ME(hRec);

DEBUGLOG(("BreakDownMsg Exit\n"));
	return	iRet;
}


int initReplyFromRequest(const hash_t* hRequest, hash_t* hResponse)
{
	int	iRet = PD_OK;

	return iRet;
}


int BuildAuthData(hash_t *hIn)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csBuf;
	double	dTmp;
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

DEBUGLOG(("BuildAuthData()\n"));
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

// cardholderPhoneNo
	if (GetField_CString(hIn, "customer_tel", &csPtr)) {
		strcat((char*)csBuf, "cardholderPhoneNo");
		strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("cardholderPhoneNo = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("customer_tel is missing\n"));
	}

// failUrl
	if (GetField_CString(hIn, "fe_url", &csPtr)) {
		strcat((char*)csBuf, "failUrl");
		strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("failUrl = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("fe_url is missing\n"));
	}

// mchNo
	if (GetField_CString(hIn, "psp_merchant_id", &csPtr)) {
		strcat((char*)csBuf, "mchNo");
		strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("mchNo = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("psp_merchant_id is missing\n"));
	}

// notifyUrl
	if (GetField_CString(hIn, "return_url_only", &csPtr)) {
		strcat((char*)csBuf, "notifyUrl");
		strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("notifyUrl = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("return_url_only is missing\n"));
	}

// orderNo
	if (GetField_CString(hIn, "txn_seq", &csPtr)) {
		strcat((char*)csBuf, "orderNo");
		strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("orderNo = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("txn_seq is missing\n"));
	}

// pageUrl
	if (GetField_CString(hIn, "fe_url", &csPtr)) {
		strcat((char*)csBuf, "pageUrl");
		strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("pageUrl = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("fe_url is missing\n"));
	}

// productName
	strcat((char*)csBuf, "productName");
	strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
	strcat((char*)csBuf, MY_SFE_PRODUCT_NAME);
	strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("productName = [%s]\n", MY_SFE_PRODUCT_NAME));

// successUrl
	if (GetField_CString(hIn, "fe_url", &csPtr)) {
		strcat((char*)csBuf, "successUrl");
		strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
		strcat((char*)csBuf, csPtr);
		strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("successUrl = [%s]\n", csPtr));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("fe_url is missing\n"));
	}

// transAmt
	if (GetField_Double(hIn, "psp_txn_amt", &dTmp)) {
		char csTmpAmt[PD_TMP_BUF_LEN + 1];
		sprintf((char*)csTmpAmt, "%ld", double2long(dTmp));
		strcat((char*)csBuf, "transAmt");
		strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
		strcat((char*)csBuf, csTmpAmt);
		strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("transAmt = [%s]\n", csTmpAmt));
	}
	else {
		iRet = PD_ERR;
DEBUGLOG(("psp_txn_amt is missing\n"));
	}

// transId
	strcat((char*)csBuf, "transId");
	strcat((char*)csBuf, MY_SFE_FIELD_TOKEN);
	strcat((char*)csBuf, MY_SFE_TRANS_ID_EC);
	strcat((char*)csBuf, MY_SFE_TOKEN);
DEBUGLOG(("transId = [%s]\n", MY_SFE_TRANS_ID_EC));

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);
        
DEBUGLOG(("BuildAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


void Insert2KVPair(struct key_value_pair k_v_pair[], int *iPairCnt, const char *inMsg, const char *FD)
{
	char *csTag;
	char *csValue;
	char *csTmp;
	char *p;

	csTmp = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
	strcpy(csTmp, inMsg);

	p = strstr(csTmp, FD);
	if (p) {
		if (strlen(p) > strlen(FD)) {
			csTag = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
			csValue = strdup(p + 1);
			memcpy(csTag, inMsg, strlen(inMsg) - strlen(p));
			csTag[strlen(inMsg) - strlen(p)] = '\0';
//DEBUGLOG(("Insert2KVPair:: iPairCnt = [%d], Tag = [%s], Value = [%s]\n", *iPairCnt, csTag, csValue));
			strcpy(k_v_pair[*iPairCnt].key, csTag);
			strcpy(k_v_pair[*iPairCnt].value, csValue);
			*iPairCnt = *iPairCnt + 1;
			free(csTag);
			csTag = NULL;
			free(csValue);
			csValue = NULL;
		}
	}
	free(csTmp);
	csTmp = NULL;
}


int Str2KVPair(struct key_value_pair k_v_pair[], int *iPairCnt, const char *inMsg, const char *DL, const char *FD)
{
	char *csBuf;
	char *p;

	int inLen = strlen(inMsg);
	csBuf = (char*) malloc (inLen + 1);
	memcpy(csBuf, inMsg, inLen);
	csBuf[inLen] = '\0';

	p = strtok(csBuf, DL);
	if (p != NULL) {
		if (strlen(p) > 1) {
			if (p[strlen(p) - 1] == 0x0d)
				p[strlen(p) - 1] = '\0';
			else
				p[strlen(p)] = '\0';
			Insert2KVPair(k_v_pair, iPairCnt, p, FD);
		}
	}

	while ((p = strtok(NULL, DL)) != NULL) {
		if (strlen(p) > 1) {
			if (p[strlen(p) - 1] == 0x0d)
				p[strlen(p) - 1] = '\0';
			else
				p[strlen(p)] = '\0';
			Insert2KVPair(k_v_pair, iPairCnt, p, FD);
		}
	}

//DEBUGLOG(("Str2KVPair:: iPairCnt = [%d]\n", *iPairCnt));

	free(csBuf);
	csBuf = NULL;
	return 0;
}


int string_sort_func(const void *a1, const void *b1)
{
	const char *a = (const char *)a1;
	const char *b = (const char *)b1;
	return(strcmp(a, b));
}


int BuildRspAuthData(hash_t *hIn)
{
	int iRet = PD_OK;
	char *csBuf;
	csBuf = (char*) malloc (MAX_MSG_SIZE + 1);

	char *inMsg;
	int iTmp;

	struct key_value_pair k_v_pair[50];
	int iPairCnt = 0;

DEBUGLOG(("BuildRspAuthData()\n"));
	memset(csBuf, 0, MAX_MSG_SIZE);
	csBuf[0] = '\0';

	if (GetField_CString(hIn, "in_msg", &inMsg)) {
		if (Str2KVPair(k_v_pair, &iPairCnt, inMsg, MY_SFE_TOKEN, MY_SFE_FIELD_TOKEN) == PD_OK) {
//DEBUGLOG(("iPairCnt = [%d]\n", iPairCnt));
			qsort(k_v_pair, iPairCnt, sizeof(struct key_value_pair), string_sort_func);
			for (iTmp = 0; iTmp < iPairCnt; iTmp++) {
DEBUGLOG(("key = [%s], value = [%s]\n", k_v_pair[iTmp].key, k_v_pair[iTmp].value));
				// exclude sign
				if (strcmp(k_v_pair[iTmp].key, "sign")) {
					strcat(csBuf, k_v_pair[iTmp].key);
					strcat(csBuf, MY_SFE_FIELD_TOKEN);
					strcat(csBuf, k_v_pair[iTmp].value);
					strcat(csBuf, MY_SFE_TOKEN);
				}
			}
		}
	}

	PutField_CString(hIn, "auth_data", csBuf);
DEBUGLOG(("BuildRspAuthData:: auth_data = [%s]\n", csBuf));
	FREE_ME(csBuf);

DEBUGLOG(("BuildRspAuthData() Exit iRet = [%d]\n", iRet));
	return iRet;
}


char *str_replace(char *orig, char *rep, char *with) {
        char *result;   // the return string
        char *ins;      // the next insert point
        char *tmp;      // varies
        int len_rep;    // length of rep (the string to remove)
        int len_with;   // length of with (the string to replace rep with)
        int len_front;  // distance between rep and end of last rep
        int count;      // number of replacements

        if (!orig || !rep)
                return NULL;
        len_rep = strlen(rep);
        if (len_rep == 0)
                return NULL; // empty rep causes infinite loop during count
        if (!with)
                with = "";
        len_with = strlen(with);

        // count the number of replacements needed
        ins = orig;
        for (count = 0; (tmp = strstr(ins, rep)); ++count) {
                ins = tmp + len_rep;
        }

        tmp = result = malloc(strlen(orig) + (len_with - len_rep) * count + 1);

        if (!result)
                return NULL;

        // first time through the loop, all the variable are set correctly
        // from here on,
        //    tmp points to the end of the result string
        //    ins points to the next occurrence of rep in orig
        //    orig points to the remainder of orig after "end of rep"
        while (count--) {
                ins = strstr(orig, rep);
                len_front = ins - orig;
                tmp = strncpy(tmp, orig, len_front) + len_front;
                tmp = strcpy(tmp, with) + len_with;
                orig += len_front + len_rep; // move to next "end of rep"
        }
        strcpy(tmp, orig);
        return result;
}

