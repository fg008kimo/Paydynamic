/*
PDProTech (c)2020. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2020/03/03              [WMC]
Add function SendToQueue			   2020/04/01		   [MSN]
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "TxnBalOnUsCOM.h"
#include "myrecordset.h"
#include "dbutility.h"
#include "queue_utility.h"
#include "mq_db.h"


static char cDebug;
OBJPTR(DB);
OBJPTR(BO);
OBJPTR(Msg);

void TxnBalOnUsCOM(char    cdebug)
{
        cDebug = cdebug;
}

int	CheckAmount(const char* csCcy, const char* csType, const char* csAmt);

int     Authorize(hash_t* hContext,
                        const hash_t* hRequest,
                        hash_t* hResponse)
{
        int     iRet = PD_OK;

	double	dPtr = 0.0;

	char	*csMid = NULL;
	char	*csCcy = NULL;
	char	*csPspId = NULL;
	char	*csPspCcy = NULL;
	char	*csPtr = NULL;
	
	char	csTag[PD_TAG_LEN+1];
	
	recordset_t     *rRecordSet;
	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordSet,0);

DEBUGLOG(("Authroize()\n"));

/* balcode */
	if (GetField_CString(hRequest,"balcode",&csPtr)) {
DEBUGLOG((" balcode = [%s]\n",csPtr));
		PutField_CString(hContext,"balcode",csPtr);	
        } else {
DEBUGLOG((" balcode is missing\n"));
ERRLOG("TxnBalOnUsCOM:: Authorize:: balcode is missing\n");			
                iRet =  INT_ERR;
                PutField_Int(hContext,"internal_error",iRet);
        }

/* txnid */
	if (iRet == PD_OK) {
                if (GetField_CString(hRequest,"txnid",&csPtr)) {
DEBUGLOG((" txnid = [%s]\n",csPtr));
                        PutField_CString(hContext,"txnid",csPtr);   
                }
        }

/* txncode */
        if (iRet == PD_OK) {
                if (GetField_CString(hRequest,"txncode",&csPtr)) {
DEBUGLOG((" txncode = [%s]\n",csPtr));
                        PutField_CString(hContext,"txncode",csPtr);
                }
        }

/* country */
	if (iRet == PD_OK) {
                if (GetField_CString(hRequest,"country",&csPtr)) {
DEBUGLOG((" country = [%s]\n",csPtr));
                        PutField_CString(hContext,"country",csPtr);
                }
        }

/* mid */
	if (iRet == PD_OK) {
		if (GetField_CString(hRequest,"mid",&csMid)) {
DEBUGLOG((" mid = [%s]\n",csMid));
         	       	DBObjPtr = CreateObj(DBPtr,"DBMerchDetail","GetMerchant");
         	       	if ((*DBObjPtr)(csMid, rRecordSet) == PD_OK) {
				PutField_CString(hContext,"mid",csMid);
			} else {
DEBUGLOG((" mid not found\n"));
ERRLOG("TxnBalOnUsCOM:: Authorize:: mid not found\n");
         	               	iRet = INT_MERCHANT_ID_NOT_FOUND;
				PutField_Int(hContext,"internal_error",iRet);
			}
		}
	}

/* ccy */
	if (iRet == PD_OK) {
		if (GetField_CString(hRequest,"ccy",&csCcy)) {
DEBUGLOG((" ccy = [%s]\n",csCcy));
			DBObjPtr = CreateObj(DBPtr,"DBCurrency","FindCurrency");
                  	if ((unsigned long)(DBObjPtr)(csCcy) == FOUND) {
                            	PutField_CString(hContext,"ccy",csCcy);
                      	} else {
DEBUGLOG((" ccy invalid\n"));
ERRLOG("TxnBalOnUsCOM:: Authorize:: ccy invalid\n");
                             	iRet = INT_INVALID_CURRENCY_CODE;
				PutField_Int(hContext,"internal_error",iRet);
                  	}
                }
	}

/* service_code */
	if (iRet == PD_OK) {
                if (GetField_CString(hRequest,"service_code",&csPtr)) {
DEBUGLOG((" service_code = [%s]\n",csPtr));
			PutField_CString(hContext,"service_code",csPtr);
                }
	}

/* bal */
	if (iRet == PD_OK) {
		sprintf(csTag, "bal");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
                        iRet = CheckAmount(csCcy, csTag, csPtr);
			if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"bal",dPtr);
DEBUGLOG((" bal = [%lf]\n",dPtr));
			}
                }
	}

/* float */
	if (iRet == PD_OK) {
		sprintf(csTag, "float");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
                        iRet = CheckAmount(csCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"float",dPtr);
DEBUGLOG((" float = [%lf]\n",dPtr));
			}
                }
        }

/* holdback */
	if (iRet == PD_OK) {
		sprintf(csTag, "holdback");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
                        iRet = CheckAmount(csCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"holdback",dPtr);
DEBUGLOG((" holdback = [%lf]\n",dPtr));
			}
                }
        }

/* hold */
	if (iRet == PD_OK) {
		sprintf(csTag, "hold");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
                        iRet = CheckAmount(csCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"hold",dPtr);
DEBUGLOG((" hold = [%lf]\n",dPtr));
			}
                }
        }

/* bal_sett */
	if (iRet == PD_OK) {
		sprintf(csTag, "bal_sett");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
                        iRet = CheckAmount(csCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"bal_sett",dPtr);
DEBUGLOG((" bal_sett = [%lf]\n",dPtr));
			}
                }
        }

/* float_sett */
	if (iRet == PD_OK) {
		sprintf(csTag, "float_sett");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
                        iRet = CheckAmount(csCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"float_sett",dPtr);
DEBUGLOG((" float_sett = [%lf]\n",dPtr));
			}
                }
        }

/* hold_sett */
	if (iRet == PD_OK) {
		sprintf(csTag, "hold_sett");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
                        iRet = CheckAmount(csCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"hold_sett",dPtr);
DEBUGLOG((" hold_sett = [%lf]\n",dPtr));
			}
                }
        }

/* fundin_po */
	if (iRet == PD_OK) {
		sprintf(csTag, "fundin_po");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
                        iRet = CheckAmount(csCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"fundin_po",dPtr);
DEBUGLOG((" fundin_po = [%lf]\n",dPtr));
			}
                }
        }

/* resv_po */
	if (iRet == PD_OK) {
		sprintf(csTag, "resv_po");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
                        iRet = CheckAmount(csCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"resv_po",dPtr);
DEBUGLOG((" resv_po = [%lf]\n",dPtr));
			}
                }
        }

/* afpo_float */
	if (iRet == PD_OK) {
		sprintf(csTag, "afpo_float");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
			iRet = CheckAmount(csCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"afpo_float",dPtr);
DEBUGLOG((" afpo_float = [%lf]\n",dPtr));
			}
                }
        }

/* psp_id */
	if (iRet == PD_OK) {
		if (GetField_CString(hRequest,"psp_id",&csPspId)) {
DEBUGLOG((" psp_id = [%s]\n",csPspId));

			RecordSet_Destroy(rRecordSet);
			recordset_init(rRecordSet,0);

                        DBObjPtr = CreateObj(DBPtr,"DBPspDetail","GetPspDetail");
                        if ((*DBObjPtr)(csPspId, rRecordSet) == PD_OK) {
                                PutField_CString(hContext,"psp_id",csPspId);
                        } else {
DEBUGLOG((" psp_id not found\n"));
ERRLOG("TxnBalOnUsCOM:: Authorize:: psp_id not found\n");
                                iRet = INT_PSP_ID_NOT_FOUND;
                                PutField_Int(hContext,"internal_error",iRet);
                        }
                }
        }	

/* psp_ccy */
	 if (iRet == PD_OK) {
                if (GetField_CString(hRequest,"psp_ccy",&csPspCcy)) {
DEBUGLOG((" psp_ccy = [%s]\n",csPspCcy));
                        DBObjPtr = CreateObj(DBPtr,"DBCurrency","FindCurrency");
                        if ((unsigned long)(DBObjPtr)(csPspCcy) == FOUND) {
                                PutField_CString(hContext,"psp_ccy",csPspCcy);
                        } else {
DEBUGLOG((" psp_ccy invalid\n"));
ERRLOG("TxnBalOnUsCOM:: Authorize:: psp_ccy invalid\n");
                                iRet = INT_INVALID_CURRENCY_CODE;
                                PutField_Int(hContext,"internal_error",iRet);
                        }
                }
        }	

/* psp_bal */
        if (iRet == PD_OK) {
		sprintf(csTag, "psp_bal");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
			iRet = CheckAmount(csPspCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"psp_bal",dPtr);
DEBUGLOG((" psp_bal = [%lf]\n",dPtr));
			}
                }
        }

/* psp_float */
        if (iRet == PD_OK) {
		sprintf(csTag, "psp_float");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
			iRet = CheckAmount(csPspCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
                        	PutField_Double(hContext,"psp_float",dPtr);
DEBUGLOG((" psp_float = [%lf]\n",dPtr));
			}
                }
        }

/* psp_hold */
        if (iRet == PD_OK) {
		sprintf(csTag, "psp_hold");
                if (GetField_CString(hRequest, csTag, &csPtr)) {
			iRet = CheckAmount(csPspCcy, csTag, csPtr);
                        if (iRet == PD_OK) {
				dPtr = newround(string2double((const unsigned char *)csPtr), PD_DECIMAL_LEN);
	                	PutField_Double(hContext,"psp_hold",dPtr);
DEBUGLOG((" psp_hold = [%lf]\n",dPtr));
			}
                }
        }

	RecordSet_Destroy(rRecordSet);
	FREE_ME(rRecordSet);

DEBUGLOG(("Authroize() iRet = [%d]\n",iRet));	
	return iRet;
}

int     CheckAmount(const char* csCcy, const char* csType, const char* csAmt)
{
        int     iRet = PD_OK;

        double  dValue = 0.0;

        char    *csValue;
        char    *csPtr;
	
        csValue = (char*) malloc (PD_TMP_BUF_LEN + 1);

        memset(csValue, 0, sizeof(csValue));

        strcpy(csValue, csAmt);

	csPtr = mystrtok(csValue, ".");
        if (csPtr == NULL) {
                iRet = INT_ERR;
        } else {
                if (is_numeric(csPtr) != PD_TRUE) {
                        iRet = INT_INVALID_PAY_AMOUNT;
DEBUGLOG((" [%s] Invalid [%s]\n", csType, csValue));
                } else {
                        csPtr = mystrtok(NULL, ".");
                        if (csPtr == NULL) {
                                iRet = INT_ERR;
                        } else if (is_numeric(csPtr) != PD_TRUE || strlen(csPtr) != PD_DECIMAL_LEN) {
                                iRet = INT_INVALID_PAY_AMOUNT;
DEBUGLOG((" [%s] Invalid [%s]\n", csType, csValue));
                        }

                        while( (csPtr = mystrtok(NULL, ".")) != NULL) {
                                iRet = INT_ERR;
                                break;
                        }
                }
        }

	if (iRet == PD_OK) {

                dValue = newround(string2double((const unsigned char *)csValue), PD_DECIMAL_LEN);

		if ((!strcmp(csType, "txn_amt"))
		   || (!strcmp(csType, "net_amt"))
		)
		{
			if (dValue <= 0.0) {
DEBUGLOG((" [%s][%lf] <= 0.0, invalid\n", csType, dValue));
				iRet =  INT_INVALID_PAY_AMOUNT;
			}
		}
	}

	if (iRet == PD_OK) {

		if (csCcy != NULL) {
                
                	DBObjPtr = CreateObj(DBPtr,"DBCurrency","FindCurrency");
                	if ((unsigned long)(DBObjPtr)(csCcy) == FOUND) {

                        	DBObjPtr = CreateObj(DBPtr,"DBCurrency","IsSupportDecimal");
                        	if ((unsigned long)((DBObjPtr)(csCcy)) != PD_TRUE) {

					long lTmp;
                                	lTmp = (long) dValue;
                                	if (dValue > lTmp) {
                                        	iRet = INT_INVALID_PAY_AMOUNT;
DEBUGLOG((" currency[%s] does not support decimal\n", csCcy));
                                	}
                        	}
                	} else {
DEBUGLOG((" currency[%s] not found\n", csCcy));
				iRet = INT_INVALID_CURRENCY_CODE;
                	}
        	}
	}

        FREE_ME(csValue);

        return iRet;
}


int	SendToQueue(hash_t *hMsg)
{
	int	iRet = PD_OK;
	hex_t   *h_msg;
	struct  msg_t *msg;
	int     iSendLen;
	long    lKey;
	char	*csPtr = NULL;
	char	*csTxnSeq = NULL;

DEBUGLOG(("SendToQueue() Start\n"));


/* balcode */
	if(GetField_CString(hMsg, "balcode", &csPtr)){
DEBUGLOG((" balcode = [%s]\n", csPtr));
	}
	else{
		iRet = INT_ERR;
DEBUGLOG((" balcode is missing!!\n"));
ERRLOG("TxnBalOnUsCOM::SendToQueue() balcode is missing!!\n");
	}

/* txn_seq */
	if(GetField_CString(hMsg, "org_txn_seq", &csTxnSeq)){
DEBUGLOG((" org_txn_seq = [%s]\n", csTxnSeq));
	}
	else if(GetField_CString(hMsg, "txn_seq", &csTxnSeq)){
DEBUGLOG((" txn_seq = [%s]\n", csTxnSeq));
	}
	else{
		iRet = INT_ERR;
DEBUGLOG((" txn_seq is missing!!\n"));
ERRLOG("TxnBalOnUsCOM::SendToQueue() txn_seq is missing!!\n");
	}


/* Format Queue message */
	if(iRet == PD_OK){
DEBUGLOG(("Call BalMsg::FormatMsg()\n"));
		MsgObjPtr = CreateObj(MsgPtr, "BalMsg", "FormatMsg");
		h_msg = (hex_t*) malloc (sizeof(hex_t));
		if ((*MsgObjPtr)(hMsg, h_msg->msg, &h_msg->len) == PD_OK) {

/* send to Queue*/
			lKey = GetMQKey((const unsigned char *)"BALREQQ");

			msg = (struct msg_t*)malloc(sizeof(struct msg_t) + MAX_MSG_SIZE);
			msg->mtype  = ctol((const unsigned char *)csTxnSeq, strlen(csTxnSeq));
			memset(msg->mtext, 0, sizeof(msg->mtext));
			MQ_build_header((unsigned char*)msg->mtext,
					MQ_REQ,
					PD_CHANNEL_BAL,
					0,
					NULL,
					0);
			memcpy(&msg->mtext[MQ_HEADER_LEN], h_msg->msg, h_msg->len);
			msg->mtext[MQ_HEADER_LEN + h_msg->len] = '\0';
			iSendLen = MQ_HEADER_LEN + h_msg->len;
DEBUGLOG(("send msg = [%s] send len = [%d]\n", msg->mtext, iSendLen));
DEBUGLOG(("key = [%ld][%ld]\n", lKey, msg->mtype));

			if (MQSend(lKey, msg, iSendLen) != MQ_OK ) {
				iRet = INT_ERR;
DEBUGLOG(("MQSend failed!!\n"));
ERRLOG("TxnBalOnUsCOM::SendToQueue() MQSend failed!!\n");
			}

			FREE_ME(msg);
		} else {
			iRet = INT_ERR;
DEBUGLOG(("FormatMsg failed\n"));
		}

		FREE_ME(h_msg);
	}

DEBUGLOG(("SendToQueue() iRet = [%d]\n",iRet));	
	return iRet;
}
