/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/07/15              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "TxnOmtByUsOPR.h"
#include "myrecordset.h"
#include "queue_utility.h"
#include "mq_db.h"

char cDebug;
OBJPTR(DB);
OBJPTR(BO);
OBJPTR(Txn);
OBJPTR(Channel);

int	isAllowProcess(hash_t *hContext);
int	UpdatePayoutGenerateTxn(hash_t *hUpdateTxn);


void TxnOmtByUsOPR(char cdebug)
{
	cDebug = cdebug;
}

int Authorize(hash_t* hContext,
		hash_t* hRequest,
		hash_t* hResponse)
{
	int	iRet = PD_OK;
	char	*csOPATxnId = NULL;
	char	*csOPGTxnId = NULL;
	char	*csUser = NULL;
	char	*csRemark = NULL;
//	char	*csOrgTxnSeq;
	char	*csTxnSeq;
//	char	*csOrgGenTxnSeq;
//	char	csNewTxnSeq[PD_TXN_SEQ_LEN + 1];
	char	*csTmp;
//	char	*csPHDate;
//	char	*csOrgPostDate;
	char	csTag[PD_TAG_LEN+1];
//	double	dTmp;
//	double	dPreFee = 0.0;
//	int	iStatus;
	int	i = 0;
	int	iInputPairCnt = 0;
	int	iReconPairCnt = 0;
//	int	iSameDate = PD_TRUE; //always put back to ava po
	int	iReturnFee = PD_FALSE;
	int	iReturnPspFee = PD_FALSE;
//	int	iRefundParty = 0;
//	char	*csHandler;

	char	*csInputStmtTxnId = NULL;
	char	*csInputReturnStmtTxnId = NULL;
	char	*csInputBankCode = NULL;
	char	*csReconStmtTxnId = NULL;
	char	*csReconBankCode = NULL;

	double	dInputTxnAmt = 0.0;
	double	dReconTxnAmt = 0.0;

	hash_t	*hRec, *hTxn;

//	char	cTmp;
//	int	iTmp;

	recordset_t *rRecordSet;
	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordSet, 0);

	recordset_t *rReconPattern;
	rReconPattern = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rReconPattern, 0);

	hTxn = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hTxn, 0);

DEBUGLOG(("TxnOmtByUsOPR: Authroize()\n"));

	if (GetField_CString(hContext, "txn_seq", &csTxnSeq)) {
		// new txn id of OPA
DEBUGLOG(("Authroize:: txn seq = [%s]\n", csTxnSeq));
	}

	//	get merchant payout txn id
	if (GetField_CString(hRequest, "org_txn_seq", &csOPATxnId)) {
DEBUGLOG(("Authroize:: Merchant Payout Txn ID = [%s]\n", csOPATxnId));
		PutField_CString(hTxn, "upload_txn_id", csOPATxnId);

		//	find original psp payout transaction(s) in TEMP
		//		check - split payout?
		//		check - multi recon?
		//			if multi recon come from same merchant payout transaction, allow to process
		// 			if multi recon come from diff merchant payout transactions, reject
DEBUGLOG(("Authorize:: call DBOLPayoutGeneratedFileDT: GetFileDetailByUploadTxnId()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLPayoutGeneratedFileDT", "GetFileDetailByUploadTxnId");
		iRet = (unsigned long)(*DBObjPtr)(hTxn, rRecordSet);
		if (iRet == PD_OK) {
			hRec = RecordSet_GetFirst(rRecordSet);
			while (hRec) {
				if (GetField_CString(hRec, "txn_id", &csOPGTxnId)) {
DEBUGLOG(("Authorize:: PSP Payout Txn ID = [%s]\n", csOPGTxnId));

DEBUGLOG(("Authorize:: call DBOLPayoutReturn: CheckPayoutReconMulti()\n"));
					DBObjPtr = CreateObj(DBPtr, "DBOLPayoutReturn", "CheckPayoutReconMulti");
					iRet = (unsigned long)(*DBObjPtr)(csOPGTxnId);
					if (iRet == PD_OK) {
DEBUGLOG(("Authorize:: not multi recon, allow to return payout\n"));
					} else {
						iRet = INT_ERR;
						PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: multi recon, not allow to return payout\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: multi recon, not allow to return payout\n");
						break;
					}
				} else {
					iRet = INT_TXN_ID_MISSING;
					PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: PSP Payout Txn ID not found\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: PSP Payout Txn ID not found\n");
					break;
				}

				hRec = RecordSet_GetNext(rRecordSet);
			}
		} else {
			iRet = INT_ERR;
			PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: call DBOLPayoutGeneratedFileDT: GetFileDetailByUploadTxnId() failed\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: call DBOLPayoutGeneratedFileDT: GetFileDetailByUploadTxnId() failed\n");
		}

		if (iRet == PD_OK) {
			//	find the latest recon patten
			//		number of bank statement reconciled with the PSP payout transaction(s)
DEBUGLOG(("Authorize:: call DBOLPayoutReturn: GetReconPattern()\n"));
			DBObjPtr = CreateObj(DBPtr, "DBOLPayoutReturn", "GetReconPattern");
			iRet = (unsigned long)(*DBObjPtr)(hTxn, rReconPattern);
			if (iRet == PD_OK) {
				//
				//	TODO: special handling for recon_pair_cnt:
				//	      1 statement recon multiple transactions
				//
				if (GetField_Int(hTxn, "recon_pair_cnt", &iReconPairCnt)) {
DEBUGLOG(("Authorize:: recon_pair_cnt = [%d]\n", iReconPairCnt));
				} else {
					iRet = INT_ERR;
					PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: cannot get recon_pair_cnt\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: cannot get recon_pair_cnt\n");
				}
			} else {
				iRet = INT_ERR;
				PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: call DBOLPayoutReturn: GetReconPattern() failed\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: call DBOLPayoutReturn: GetReconPattern() failed\n");
			}
		}
	} else {
		iRet = INT_TXN_ID_MISSING;
		PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: Merchant Payout Txn ID not found\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: Merchant Payout Txn ID not found\n");
	}

	if (iRet == PD_OK) {
		//	get input pair cnt
		if (GetField_Int(hContext, "total_cnt", &iInputPairCnt)) {
DEBUGLOG(("Authorize:: number of input pair = [%d]\n", iInputPairCnt));

			//	check input pair count = system pair count
			if (iInputPairCnt != iReconPairCnt) {
				iRet = INT_ERR;
				PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: statement pair count not match, input[iInputPairCnt], system[iReconPairCnt]\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: statement pair count not match, input[iInputPairCnt], system[iReconPairCnt]\n");
			}
		} else {
			iRet = INT_ERR;
			PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: statement pair count not found\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: statement pair count not found\n");
		}
	}

	if (iRet == PD_OK) {
		hRec = RecordSet_GetFirst(rReconPattern);
		while (hRec) {
DEBUGLOG(("Authorize:: ==============================\n"));

			if (GetField_CString(hRec, "stmt_txn_seq", &csReconStmtTxnId)) {
DEBUGLOG(("Authorize:: System Payout Statement Txn ID = [%s]\n", csReconStmtTxnId));
			} else {
				iRet = INT_TXN_ID_MISSING;
				PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: cannot get system stmt_txn_seq\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: cannot get system stmt_txn_seq\n");
				break;
			}

			if (GetField_CString(hRec, "bank_code", &csReconBankCode)) {
DEBUGLOG(("Authorize:: System Bank Code = [%s]\n", csReconBankCode));
			} else {
				iRet = INT_ERR;
				PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: cannot get system bank_code\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: cannot get system bank_code\n");
				break;
			}

			if (GetField_Double(hRec, "txn_amt", &dReconTxnAmt)) {
DEBUGLOG(("Authorize:: System Transaction Amount = [%lf]\n", dReconTxnAmt));
			} else {
				iRet = INT_ERR;
				PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: cannot get system txn_amt\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: cannot get systemtxn_amt\n");
				break;
			}

DEBUGLOG(("Authorize:: --------------------\n"));

			for (i = 1; i <= iInputPairCnt; i++) {
				sprintf(csTag, "dt_obp_txnid_%d", i);
				if (GetField_CString(hRequest, csTag, &csInputStmtTxnId)) {
					//	Statement Txn ID (Classicfied as Payout and Reconciled)
DEBUGLOG(("Authorize:: Input Payout Statement Txn ID [%d] = [%s]\n", i, csInputStmtTxnId));

					if (!strcmp(csReconStmtTxnId, csInputStmtTxnId)) {
						sprintf(csTag, "dt_ubc_txnid_%d", i);
						if (GetField_CString(hRequest, csTag, &csInputReturnStmtTxnId)) {
							//	Unknown Credit Statement Txn ID
DEBUGLOG(("Authorize:: Input Unknown Credit Statement Txn ID [%d] = [%s]\n", i, csInputReturnStmtTxnId));

							hash_destroy(hTxn);
							hash_init(hTxn, 0);
DEBUGLOG(("Authorize:: call DBOLStatement: GetStmtDtl()\n"));
							DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetStmtDtl");
							iRet = (unsigned long)(*DBObjPtr)(csInputReturnStmtTxnId, hTxn);
							if (iRet == PD_OK) {
								//	check same bank account
								if (GetField_CString(hTxn, "int_bank_code", &csInputBankCode)) {
DEBUGLOG(("Authorize:: Input Unknown Credit Statement Bank Code [%d] = [%s]\n", i, csInputBankCode));
									if (strcmp(csReconBankCode, csInputBankCode)) {
										iRet = INT_ERR;
										PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: bank account not match\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: bank account not match\n");
										break;
									}
								} else {
									iRet = INT_ERR;
									PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: cannot get input unknown credit stmt bank code\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: cannot get input unknown credit stmt bank code\n");
									break;
								}

								//	check same transaction amount
								if (GetField_CString(hTxn, "txn_amount", &csTmp)) {
									dInputTxnAmt = string2double((const unsigned char *)csTmp);
DEBUGLOG(("Authorize:: Input Unknown Credit Statement Transaction Amount [%d] = [%lf]\n", i, dInputTxnAmt));
									if (newround(dReconTxnAmt, 2) != newround(dInputTxnAmt, 2)) {
										iRet = INT_ERR;
										PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: transaction amount not match\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: transaction amount not match\n");
										break;
									}
								} else {
									iRet = INT_ERR;
									PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: cannot get input unknown credit stmt txn amt\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: cannot get input unknown credit stmt txn amt\n");
									break;
								}

								//	update matched indicator
								PutField_Int(hRec, "matched", PD_TRUE);
								break;
							} else {
								iRet = INT_ERR;
								PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: call DBOLStatement: GetStmtDtl() failed\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: call DBOLStatement: GetStmtDtl() failed\n");
								break;
							}
						} else {
							iRet = INT_ERR;
							PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: cannot get input unknown credit stmt txn id\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: cannot get input unknown credit stmt txn id\n");
							break;
						}
					}
				} else {
					iRet = INT_TXN_ID_MISSING;
					PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("Authorize:: cannot get input payout stmt txn id\n"));
ERRLOG("TxnOmtByUsOPR:: Authorize:: cannot get input payout stmt txn id\n");
					break;
				}
			}

			hRec = RecordSet_GetNext(rReconPattern);
		}

DEBUGLOG(("Authorize:: ==============================\n"));

		//	should not have amount difference with the recon patten
	}

	if(GetField_CString(hContext,"update_user",&csUser)){
DEBUGLOG(("Authorize::update_user= [%s]\n",csUser));
        }

	if(GetField_CString(hRequest,"remark",&csRemark)){
DEBUGLOG(("Authorize::remark= [%s]\n",csRemark));
        }

	if(GetField_Int(hRequest,"return_pspfee",&iReturnPspFee)){
DEBUGLOG(("Authorize::return psp fee = [%d]\n",iReturnPspFee));
	}

	if(GetField_Int(hRequest,"return_mfee",&iReturnFee)){
DEBUGLOG(("Authorize::return merchant fee = [%d]\n",iReturnFee));
	}

/*
	if(iRet==PD_OK){
		PutField_Int(hContext,"same_date_cancel",PD_TRUE);
		BOObjPtr = CreateObj(BOPtr,"BOOLTxnElements","VoidOrgTxnElements");
		iRet = (unsigned long)(*BOObjPtr)(hContext,hRequest);
DEBUGLOG(("Authorize:: BOOLTxnElements:VoidOrgTxnElements iRet = [%d]\n",iRet));

		PutField_CString(hContext,"txn_code",PD_OL_PAYOUT_VOID_MERCHANT);
		PutField_Int(hContext,"do_logging",PD_NO_LOG);

		csHandler = (char*) malloc (20);
		sprintf(csHandler,"TxnOmtByUs%s",PD_PAYOUT_VOID);
DEBUGLOG(("Authorize:: Create Txn Object [%s]\n",csHandler));
		TxnObjPtr = CreateObj(TxnPtr,csHandler,"Authorize");
		iRet = (unsigned long)(*TxnObjPtr)(hContext,hRequest,hResponse);
		FREE_ME(csHandler);

		//TODO:
		//get the created PSP Return Payout transaction(s)
		//follow the recon patten to pass return transation(s) and unknown CR stmt(s) pair to the API "REC"

	}

	if(iRet==PD_OK){
		PutField_CString(hContext,"sub_status",PD_REFUND_APPROVED);
        }
*/

	hash_destroy(hTxn);
	RecordSet_Destroy(rRecordSet);
	RecordSet_Destroy(rReconPattern);
        FREE_ME(hTxn);
	FREE_ME(rRecordSet);
	FREE_ME(rReconPattern);

DEBUGLOG(("Normal exit iRet = [%d]\n",iRet));	
	return iRet;
}
