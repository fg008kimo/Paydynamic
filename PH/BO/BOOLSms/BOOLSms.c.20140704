/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/07/26              David Wong
Call OLAcctStatusAction.GetAllowActionFlag()       2014/04/22              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "dbutility.h"
#include "BOOLSms.h"
#include "myrecordset.h"
#include "myhash.h"
#include "math.h"
#include <time.h>

char cDebug;
OBJPTR(DB);
OBJPTR(BO);

#define DELIMITER_DELIMITER "|"
#define DEPOSIT_BANK_ACCT_TYPE "DSI"

void BOOLSms(char cdebug)
{
	cDebug = cdebug;
}

int ValidateField(const char* csDesc, char* csValue)
{
	int i = 0;
DEBUGLOG(("ValidateField:: csDesc = [%s]\n", csDesc));
DEBUGLOG(("ValidateField:: csValue = [%s]\n", csValue));

	if (!strcmp(csDesc, "req_bank_acc") || !strcmp(csDesc, "req_bank_year") || !strcmp(csDesc, "req_payer_acc")) {
		// 4 digits
		if (strlen(csValue) != 4) {
DEBUGLOG(("ValidateField:: length != 4\n"));
			return PD_FALSE;
		} else {
			for (i = 0; i < strlen(csValue); i++) {
				if ((csValue[i] < '0') || (csValue[i] > '9')) {
DEBUGLOG(("ValidateField:: contains non-digit character\n"));
					return PD_FALSE;
				}
			}
		}
	} else if (!strcmp(csDesc, "req_bank_month")) {
		// 01-12
		if (strlen(csValue) == 1) {
			sprintf(csValue, "0%c", csValue[0]);
DEBUGLOG(("ValidateField:: new csValue = [%s]\n", csValue));
		}

		if (strlen(csValue) != 2) {
DEBUGLOG(("ValidateField:: length != 2\n"));
			return PD_FALSE;
		} else {
			if (csValue[0] == '0') {
				// 01-09
				if ((csValue[1] < '1') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid month\n"));
					return PD_FALSE;
				}
			} else if (csValue[0] == '1') {
				// 10-12
				if ((csValue[1] < '0') || (csValue[1] > '2')) {
DEBUGLOG(("ValidateField:: invalid month\n"));
					return PD_FALSE;
				}
			} else {
DEBUGLOG(("ValidateField:: invalid month\n"));
				return PD_FALSE;
			}
		}
	} else if (!strcmp(csDesc, "req_bank_day")) {
		// 01-31
		if (strlen(csValue) == 1) {
			sprintf(csValue, "0%c", csValue[0]);
DEBUGLOG(("ValidateField:: new csValue = [%s]\n", csValue));
		}

		if (strlen(csValue) != 2) {
DEBUGLOG(("ValidateField:: length != 2\n"));
			return PD_FALSE;
		} else {
			if (csValue[0] == '0') {
				// 01-09
				if ((csValue[1] < '1') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid day\n"));
					return PD_FALSE;
				}
			} else if ((csValue[0] == '1') || (csValue[0] == '2')) {
				// 10-19, 20-29
				if ((csValue[1] < '0') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid day\n"));
					return PD_FALSE;
				}
			} else if (csValue[0] == '3') {
				// 30-31
				if ((csValue[1] < '0') || (csValue[1] > '1')) {
DEBUGLOG(("ValidateField:: invalid day\n"));
					return PD_FALSE;
				}
			} else {
DEBUGLOG(("ValidateField:: invalid day\n"));
				return PD_FALSE;
			}
		}
	} else if (!strcmp(csDesc, "req_bank_hour")) {
		// 00-23
		if (strlen(csValue) == 1) {
			sprintf(csValue, "0%c", csValue[0]);
DEBUGLOG(("ValidateField:: new csValue = [%s]\n", csValue));
		}

		if (strlen(csValue) != 2) {
DEBUGLOG(("ValidateField:: length != 2\n"));
			return PD_FALSE;
		} else {
			if ((csValue[0] == '0') || (csValue[0] == '1')) {
				// 00-09, 10-19
				if ((csValue[1] < '0') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid hour\n"));
					return PD_FALSE;
				}
			} else if (csValue[0] == '2') {
				// 20-23
				if ((csValue[1] < '0') || (csValue[1] > '3')) {
DEBUGLOG(("ValidateField:: invalid hour\n"));
					return PD_FALSE;
				}
			} else {
DEBUGLOG(("ValidateField:: invalid hour\n"));
				return PD_FALSE;
			}
		}
	} else if (!strcmp(csDesc, "req_bank_minute")) {
		// 00-59
		if (strlen(csValue) == 1) {
			sprintf(csValue, "0%c", csValue[0]);
DEBUGLOG(("ValidateField:: new csValue = [%s]\n", csValue));
		}

		if (strlen(csValue) != 2) {
DEBUGLOG(("ValidateField:: length != 2\n"));
			return PD_FALSE;
		} else {
			if ((csValue[0] >= '0') && (csValue[0] <= '5')) {
				if ((csValue[1] < '0') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid minute\n"));
					return PD_FALSE;
				}
			} else {
DEBUGLOG(("ValidateField:: invalid minute\n"));
				return PD_FALSE;
			}
		}
	} else if (!strcmp(csDesc, "req_bank_date")) {
		if (strlen(csValue) != 8) {
DEBUGLOG(("ValidateField:: length != 8\n"));
			return PD_FALSE;
		} else {
			for (i = 0; i < strlen(csValue); i++) {
				if ((csValue[i] < '0') || (csValue[i] > '9')) {
DEBUGLOG(("ValidateField:: contains non-digit character\n"));
					return PD_FALSE;
				}
			}
		}
	} else if (!strcmp(csDesc, "req_bank_amount") || !strcmp(csDesc, "req_bank_bal")) {
		for (i = 0; i < strlen(csValue); i++) {
			if ((csValue[i] < '0') || (csValue[i] > '9')) {
				if ((csValue[i] != '+') && (csValue[i] != ',') && (csValue[i] != '.') && (csValue[i] != ' ')) {
DEBUGLOG(("ValidateField:: contains non-digit character or negative sign\n"));
					return PD_FALSE;
				}
			}
		}
DEBUGLOG(("ValidateField:: orig csValue = [%s]\n", csValue));
		deleteCharacters(csValue, ",");
DEBUGLOG(("ValidateField:: new csValue = [%s]\n", csValue));
	}

	//req_bank_channel
	//req_bank_city
	//req_bank_fee
	//req_bank_name
	//req_payee
	//req_payer
	//req_usage

	return PD_TRUE;
}

int ProcessSmsText(const hash_t* hTxn, hash_t* hText)
{
	int iRet = PD_OK;
	int iTmpRet;
	char *csSender;
	char *csText;
	char csStatus[PD_SMS_REQ_STATUS_LEN] = "INT_ERR";
	char csTmpText[PD_MAX_BUFFER];
	char *csFormatId;
	char *csIntBankCode;
	char *csBankName;
	int iContentCnt;
	char *csDelimiter;
	int iIsGeneric;
	char csGenDelim[PD_MAX_BUFFER];
	char *csDelimiterDesc;
	char *csSubDelimiter;
	char *csDesc;
	char csValue[PD_MAX_BUFFER];
	char csTmp[PD_SP_VALUE_LEN];
	char *csBankAcctNum;
	int iSysSwitchEnabled;
	int iSupportSmsStmt;
	char *csAcctCcy;
	char *csFullBankAcctNum;
	char *csBaid;
	char *csPspId;
//	char *csStatusType;
	int iAllowFlag = 0;
	char *csTmpReqBankDate;
	char csReqBankDate[PD_DATE_LEN];
	char *csReqBankYear;
	char *csReqBankMonth;
	char *csReqBankDay;
	char csReqBankTime[PD_TIME_LEN];
	char *csReqBankHour;
	char *csReqBankMinute;

	int i, iPos, iValid, iDupCnt = 0;
	char *csTagDelimiter = (char*) malloc (64);
	char *csTagIsGeneric = (char*) malloc (64);
	char *csTagDelimiterDesc = (char*) malloc (64);
	char *csTagDesc = (char*) malloc (64);
	char *pch;

	recordset_t *rRecordFormat;
	rRecordFormat = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordFormat, 0);

	hash_t *hFormat;

	time_t tNow;
	struct tm * tStruct;
	char csBuf[PD_TMP_BUF_LEN];

	tNow = time(0);
	tStruct = localtime(&tNow);

	hash_t *hRec;
	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	// get sender
	if (iRet == PD_OK) {
		if (!GetField_CString(hTxn, "sender", &csSender)) {
DEBUGLOG(("ProcessSmsText:: sender not found\n"));
			iRet = PD_ERR;
		}
	}

	// get text
	if (iRet == PD_OK) {
		if (!GetField_CString(hTxn, "text", &csText)) {
DEBUGLOG(("ProcessSmsText:: text not found\n"));
			iRet = PD_ERR;
		}
	}

	// check empty text
	if (iRet == PD_OK) {
		if (strlen(csText) == 0) {
DEBUGLOG(("ProcessSmsText:: empty text\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "EMPTY_TEXT");
		}
	}

	// check sender
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::CheckSender()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLSmsFormat", "CheckSender");
		iTmpRet = (unsigned long)(*DBObjPtr)(csSender);
		if (iTmpRet != PD_FOUND) {
DEBUGLOG(("ProcessSmsText:: untrusted sender\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "UNTRUSTED_SENDER");
		}
	}

	// check bank
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::CheckBank()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLSmsFormat", "CheckBank");
		iTmpRet = (unsigned long)(*DBObjPtr)(csText);
		if (iTmpRet != PD_FOUND) {
DEBUGLOG(("ProcessSmsText:: unsupported bank\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "UNSUPPORTED_BANK");
		}
	}

	// get all supported format
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::GetFormat()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLSmsFormat", "GetFormat");
		iTmpRet = (unsigned long)(*DBObjPtr)(csSender, csText, rRecordFormat);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::GetFormat() failed\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "FORMAT_NOT_FOUND");
		}
	}

	// digest text
	if (iRet == PD_OK) {
		// loop all supported format
		hFormat = RecordSet_GetFirst(rRecordFormat);
		while (hFormat) {

			strcpy(csTmpText, csText);
DEBUGLOG(("ProcessSmsText:: csTmpText = [%s]\n", csTmpText));

			// get format id
			if (GetField_CString(hFormat, "id", &csFormatId)) {
DEBUGLOG(("ProcessSmsText:: format id = [%s]\n", csFormatId));
			} else {
DEBUGLOG(("ProcessSmsText:: format id not found\n"));
				iRet = PD_ERR;
				break;
			}

			// get int_bank_code
			if (GetField_CString(hFormat, "int_bank_code", &csIntBankCode)) {
DEBUGLOG(("ProcessSmsText:: int_bank_code = [%s]\n", csIntBankCode));
				PutField_CString(hText, "int_bank_code", csIntBankCode);
			} else {
DEBUGLOG(("ProcessSmsText:: int_bank_code not found\n"));
				iRet = PD_ERR;
				break;
			}

			// get bank_name
			if (GetField_CString(hFormat, "bank_name", &csBankName)) {
DEBUGLOG(("ProcessSmsText:: bank_name = [%s]\n", csBankName));
				PutField_CString(hText, "req_bank_name", csBankName);
			} else {
DEBUGLOG(("ProcessSmsText:: bank_name not found\n"));
				iRet = PD_ERR;
				break;
			}

			// get content count
			if (GetField_Int(hFormat, "content_cnt", &iContentCnt)) {
				if (iContentCnt <= 0) {
DEBUGLOG(("ProcessSmsText:: content count <= 0\n"));
					iRet = PD_ERR;
					break;
				}
DEBUGLOG(("ProcessSmsText:: content count = [%d]\n", iContentCnt));
			} else {
DEBUGLOG(("ProcessSmsText:: content count not found\n"));
				iRet = PD_ERR;
				break;
			}

			// start tokenize sms text
			for (i = 1; i <= iContentCnt; i++) {
				sprintf(csTagDelimiter, "content_delimiter_%d", i);
				if (GetField_CString(hFormat, csTagDelimiter, &csDelimiter)) {
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csTagDelimiter, csDelimiter));

					// check whether it is generic delimiter
					sprintf(csTagIsGeneric, "content_is_generic_%d", i);
					if (!GetField_Int(hFormat, csTagIsGeneric, &iIsGeneric)) {
						// set to 0 if not found
						iIsGeneric = 0;
					}

					if (iIsGeneric) {
DEBUGLOG(("ProcessSmsText:: is generic delimiter\n"));
						iRet = PD_ERR;
						if (strcmp(csDelimiter, "[NON-DIGIT]") == 0) {
							iPos = 0;
							while (csTmpText[iPos] < '0' || csTmpText[iPos] > '9') {
								iPos++;
							}
							strncpy(csGenDelim, csTmpText, iPos);
							csGenDelim[iPos] = '\0';

							sprintf(csTagDelimiterDesc, "content_delimiter_desc_%d", i);
							if (GetField_CString(hFormat, csTagDelimiterDesc, &csDelimiterDesc)) {
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csTagDelimiterDesc, csDelimiterDesc));

DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csDelimiterDesc, csGenDelim));
								PutField_CString(hText, csDelimiterDesc, csGenDelim);
							}

							// remove the delimiter from sms text
							strcpy(csTmpText, csTmpText+strlen(csGenDelim));
DEBUGLOG(("ProcessSmsText:: after %s = [%s]\n", csTagDelimiter, csTmpText));
							iRet = PD_OK;
						}
					} else {
						// loop all sub-delimiter
						iRet = PD_ERR;
						csSubDelimiter = strtok(csDelimiter, DELIMITER_DELIMITER);
						while (csSubDelimiter != NULL) {
DEBUGLOG(("ProcessSmsText:: sub-%s = [%s]\n", csTagDelimiter, csSubDelimiter));

							pch = strstr(csTmpText, csSubDelimiter);
							if (pch != NULL) {
								iValid = PD_FALSE;

								sprintf(csTagDesc, "content_desc_%d", i);
								if (GetField_CString(hFormat, csTagDesc, &csDesc)) {
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csTagDesc, csDesc));

									strncpy(csValue, csTmpText, strlen(csTmpText)-strlen(pch));
									csValue[strlen(csTmpText)-strlen(pch)] = '\0';
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csDesc, csValue));

									// field validation
									iValid = ValidateField(csDesc, csValue);

									if (iValid) {
										PutField_CString(hText, csDesc, csValue);
									}
								} else {
									if (strncmp(csTmpText, csSubDelimiter, strlen(csSubDelimiter)) == 0) {
										iValid = PD_TRUE;
									}
								}

								if (iValid) {
									sprintf(csTagDelimiterDesc, "content_delimiter_desc_%d", i);
									if (GetField_CString(hFormat, csTagDelimiterDesc, &csDelimiterDesc)) {
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csTagDelimiterDesc, csDelimiterDesc));

DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csDelimiterDesc, csSubDelimiter));
										PutField_CString(hText, csDelimiterDesc, csSubDelimiter);
									}

									// remove the delimiter from sms text
									strcpy(csTmpText, pch+strlen(csSubDelimiter));
DEBUGLOG(("ProcessSmsText:: after %s = [%s]\n", csTagDelimiter, csTmpText));
									iRet = PD_OK;
									break;
								}
							} else {
DEBUGLOG(("ProcessSmsText:: sub-%s not match, continue\n", csTagDelimiter));
							}

							csSubDelimiter = strtok(NULL, DELIMITER_DELIMITER);
						}
					}

					if (iRet == PD_ERR) {
DEBUGLOG(("ProcessSmsText:: %s not match, check next format\n", csTagDelimiter));
						break;
					}
				} else {
DEBUGLOG(("ProcessSmsText:: %s not found, check next format\n", csTagDelimiter));
					iRet = PD_ERR;
					break;
				}
			}

			if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: format matched\n"));
				break;
			}

			hash_destroy(hText);
			hash_init(hText, 0);

			hFormat = RecordSet_GetNext(rRecordFormat);
		}

		if (iRet != PD_OK) {
DEBUGLOG(("ProcessSmsText:: no format matched\n"));
			strcpy(csStatus, "INVALID_FORMAT");
		}
	}

	// lock bank acct
	if (iRet == PD_OK) {
		// get bank acct num
		if (!GetField_CString(hText, "req_bank_acc", &csBankAcctNum)) {
DEBUGLOG(("ProcessSmsText:: bank acct num not found\n"));
			iRet = PD_ERR;
		}

		if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLResourceLock::GetBankAcctForUpdate()\n"));
			DBObjPtr = CreateObj(DBPtr, "DBOLResourceLock", "GetBankAcctForUpdate");
			iTmpRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csBankAcctNum);
			if (iTmpRet != PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLResourceLock::GetBankAcctForUpdate() failed\n"));
				iRet = PD_ERR;
				strcpy(csStatus, "BANK_ACCT_NOT_AVAIL");
			}
		}
	}

	// check duplicate
	if (iRet == PD_OK) {
// DEBUGLOG(("ProcessSmsText:: call DBSystemParameter::FindCode()\n"));
		// DBObjPtr = CreateObj(DBPtr, "DBSystemParameter", "FindCode");
		// iTmpRet = (unsigned long)(*DBObjPtr)(PD_SMS_DEDUP_RANGE, csTmp);
		// if (iTmpRet != PD_FOUND) {
// DEBUGLOG(("ProcessSmsText:: find code error\n"));
			// iRet = PD_ERR;
		// } else {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsTxnLog::CheckDuplicate()\n"));
			strcpy(csTmp, "366");
			DBObjPtr = CreateObj(DBPtr, "DBOLSmsTxnLog", "CheckDuplicate");
			iDupCnt = (unsigned long)(*DBObjPtr)(csTmp, csSender, csText);

			if (iDupCnt < 0) {
DEBUGLOG(("ProcessSmsText:: check duplicate error\n"));
				iRet = PD_ERR;
				strcpy(csStatus, "CHECK_DUP_ERROR");
			} else if (iDupCnt != 0) {
DEBUGLOG(("ProcessSmsText:: found [%d] duplicate sms within [%s] minutes\n", iDupCnt, csTmp));
				iRet = PD_ERR;
				strcpy(csStatus, "DUPLICATED_SMS");
			}
		// }
	}

	// check whether all bank accts support sms stmt
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBSystemParameter::FindCode()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBSystemParameter", "FindCode");
		iTmpRet = (unsigned long)(*DBObjPtr)(PD_SMS_STMT_UPL, csTmp);
		if (iTmpRet != PD_FOUND) {
DEBUGLOG(("ProcessSmsText:: find code error\n"));
			iRet = PD_ERR;
		} else if (csTmp[0] != '1') {
DEBUGLOG(("ProcessSmsText:: all bank acct does not support sms stmt\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "ALL_DISABLED_SMS");
		}
	}

	// check whether this bank acct supports sms stmt
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLBankAccts::GetBankAccts()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLBankAccts", "GetBankAccts");
		iTmpRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csBankAcctNum, hRec);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::GetBankAccts() failed\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "BANK_ACCT_NOT_FOUND");
		} else if (!GetField_Int(hRec, "sys_switch_enabled", &iSysSwitchEnabled)) {
DEBUGLOG(("ProcessSmsText:: sys_switch_enabled not found\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "SYS_SWITCH_DISABLED");
		} else if (iSysSwitchEnabled == 0) {
DEBUGLOG(("ProcessSmsText:: bank acct system switch disabled\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "SYS_SWITCH_DISABLED");
		} else if (!GetField_Int(hRec, "support_sms_stmt", &iSupportSmsStmt)) {
DEBUGLOG(("ProcessSmsText:: support_sms_stmt not found\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "ACCT_DISABLED_SMS");
		} else if (iSupportSmsStmt == 0) {
DEBUGLOG(("ProcessSmsText:: bank acct does not support sms stmt\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "ACCT_DISABLED_SMS");
/*
		} else if (!GetField_CString(hRec, "status_type", &csStatusType)) {
DEBUGLOG(("ProcessSmsText:: status_type not found\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "ACCT_INACTIVE");
		} else if ((strcmp(csStatusType, "A") != 0) && (strcmp(csStatusType, "F") != 0)) {
DEBUGLOG(("ProcessSmsText:: bank acct is inactive\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "ACCT_INACTIVE");
*/
		} else {
			GetField_CString(hRec, "acct_ccy", &csAcctCcy);
			PutField_CString(hText, "acct_ccy", csAcctCcy);

			GetField_CString(hRec, "full_bank_acct_num", &csFullBankAcctNum);
			PutField_CString(hText, "full_bank_acct_num", csFullBankAcctNum);
		}
	}

	// check bank acct status
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLAcctStatusAction::GetAllowActionFlag()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLAcctStatusAction", "GetAllowActionFlag");
		iTmpRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csFullBankAcctNum, PD_AC_ACTION_SMS_POST, &iAllowFlag);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLAcctStatusAction::GetAllowActionFlag() failed\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "INVALID_ACCT_STATUS");
		} else {
DEBUGLOG(("ProcessSmsText:: iAllowFlag = [%d]\n", iAllowFlag));
			if (!iAllowFlag) {
DEBUGLOG(("ProcessSmsText:: invalid acct status\n"));
				iRet = PD_ERR;
				strcpy(csStatus, "INVALID_ACCT_STATUS");
			}
		}
	}

	// check baid
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLBankAcctId::GetBaidByBankAcct()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLBankAcctId", "GetBaidByBankAcct");
		iTmpRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csBankAcctNum, DEPOSIT_BANK_ACCT_TYPE, hText);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLBankAcctId::GetBaidByBankAcct() failed\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "BAID_NOT_FOUND");
		} else {
			GetField_CString(hText, "baid", &csBaid);
DEBUGLOG(("ProcessSmsText:: baid = [%s]\n", csBaid));
			GetField_CString(hText, "psp_id", &csPspId);
DEBUGLOG(("ProcessSmsText:: psp_id = [%s]\n", csPspId));
		}
	}

	// check whether sms date is today or not
	if (iRet == PD_OK) {
		if (GetField_CString(hText, "req_bank_date", &csTmpReqBankDate)) {
DEBUGLOG(("ProcessSmsText:: req_bank_date = [%s]\n", csTmpReqBankDate));
			strcpy(csReqBankDate, csTmpReqBankDate);
		} else {
			if (GetField_CString(hText, "req_bank_year", &csReqBankYear)) {
DEBUGLOG(("req_bank_year = [%s]\n", csReqBankYear));
				strcpy(csReqBankDate, csReqBankYear);
			} else {
				strftime(csBuf, sizeof(csBuf), "%Y", tStruct);
				strcpy(csReqBankDate, csBuf);
			}
			if (GetField_CString(hText, "req_bank_month", &csReqBankMonth)) {
				strcat(csReqBankDate, csReqBankMonth);
			} else {
				strftime(csBuf, sizeof(csBuf), "%m", tStruct);
				strcat(csReqBankDate, csBuf);
			}
			if (GetField_CString(hText, "req_bank_day", &csReqBankDay)) {
				strcat(csReqBankDate, csReqBankDay);
			} else {
				strftime(csBuf, sizeof(csBuf), "%d", tStruct);
				strcat(csReqBankDate, csBuf);
			}
DEBUGLOG(("ProcessSmsText:: req_bank_year+req_bank_month+req_bank_day = [%s]\n", csReqBankDate));
			PutField_CString(hText, "req_bank_date", csReqBankDate);
		}

		strftime(csBuf, sizeof(csBuf), "%Y%m%d", tStruct);
		if (strcmp(csReqBankDate, csBuf) != 0) {
DEBUGLOG(("ProcessSmsText:: sms date is not today\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "NON_SAME_DAY");
		}

		if (GetField_CString(hText, "req_bank_hour", &csReqBankHour)) {
			if (GetField_CString(hText, "req_bank_minute", &csReqBankMinute)) {
				strcpy(csReqBankTime, csReqBankHour);
				strcat(csReqBankTime, csReqBankMinute);
				strcat(csReqBankTime, "00");
				PutField_CString(hText, "req_bank_time", csReqBankTime);
DEBUGLOG(("ProcessSmsText: req_bank_time = [%s]\n", csReqBankTime));
			}
		}
	}

	// check any bank stmt found
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLStatement::MatchStmt()\n"));
		PutField_CString(hText, "amt_type", PD_CR);
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "MatchStmt");
		iTmpRet = (unsigned long)(*DBObjPtr)(hText);
		if (iTmpRet != PD_NOT_FOUND) {
DEBUGLOG(("ProcessSmsText:: bank statement found\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "AMOUNT_FOUND");
		}
	}

	if (iRet == PD_OK) {
		PutField_CString(hText, "req_status", "UPLOADED");
	} else {
		PutField_CString(hText, "req_status", csStatus);
	}

	free(csTagDelimiter);
	free(csTagIsGeneric);
	free(csTagDelimiterDesc);
	free(csTagDesc);

	hash_destroy(hRec);
	FREE_ME(hRec);
	// hash_destroy(hFormat);
	// FREE_ME(hFormat);
	RecordSet_Destroy(rRecordFormat);
	FREE_ME(rRecordFormat);

DEBUGLOG(("ProcessSmsText() iRet = [%d]\n", iRet));
	return iRet;
}
