/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/07/26              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "dbutility.h"
#include "BOOLSms.h"
#include "myrecordset.h"
#include "myhash.h"
#include "math.h"
#include <time.h>

char cDebug;
OBJPTR(DB);
OBJPTR(BO);

#define DELIMITER_DELIMITER "|"


void BOOLSms(char cdebug)
{
	cDebug = cdebug;
}


int ValidateField(const char* csDesc, char* csValue)
{
	int i = 0;
DEBUGLOG(("ValidateField:: csDesc = [%s]\n", csDesc));
DEBUGLOG(("ValidateField:: csValue = [%s]\n", csValue));

	if (!strcmp(csDesc, "req_bank_acc") || !strcmp(csDesc, "req_bank_year") || !strcmp(csDesc, "req_payer_acc")) {
		// 4 digits
		if (strlen(csValue) != 4) {
DEBUGLOG(("ValidateField:: length != 4\n"));
			return PD_FALSE;
		} else {
			for (i = 0; i < strlen(csValue); i++) {
				if ((csValue[i] < '0') || (csValue[i] > '9')) {
DEBUGLOG(("ValidateField:: contains non-digit character\n"));
					return PD_FALSE;
				}
			}
		}
	} else if (!strcmp(csDesc, "req_bank_month")) {
		// 01-12
		if (strlen(csValue) == 1) {
			sprintf(csValue, "0%c", csValue[0]);
DEBUGLOG(("ValidateField:: new csValue = [%s]\n", csValue));
		}

		if (strlen(csValue) != 2) {
DEBUGLOG(("ValidateField:: length != 2\n"));
			return PD_FALSE;
		} else {
			if (csValue[0] == '0') {
				// 01-09
				if ((csValue[1] < '1') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid month\n"));
					return PD_FALSE;
				}
			} else if (csValue[0] == '1') {
				// 10-12
				if ((csValue[1] < '0') || (csValue[1] > '2')) {
DEBUGLOG(("ValidateField:: invalid month\n"));
					return PD_FALSE;
				}
			} else {
DEBUGLOG(("ValidateField:: invalid month\n"));
				return PD_FALSE;
			}
		}
	} else if (!strcmp(csDesc, "req_bank_day")) {
		// 01-31
		if (strlen(csValue) == 1) {
			sprintf(csValue, "0%c", csValue[0]);
DEBUGLOG(("ValidateField:: new csValue = [%s]\n", csValue));
		}

		if (strlen(csValue) != 2) {
DEBUGLOG(("ValidateField:: length != 2\n"));
			return PD_FALSE;
		} else {
			if (csValue[0] == '0') {
				// 01-09
				if ((csValue[1] < '1') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid day\n"));
					return PD_FALSE;
				}
			} else if ((csValue[0] == '1') || (csValue[0] == '2')) {
				// 10-19, 20-29
				if ((csValue[1] < '0') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid day\n"));
					return PD_FALSE;
				}
			} else if (csValue[0] == '3') {
				// 30-31
				if ((csValue[1] < '0') || (csValue[1] > '1')) {
DEBUGLOG(("ValidateField:: invalid day\n"));
					return PD_FALSE;
				}
			} else {
DEBUGLOG(("ValidateField:: invalid day\n"));
				return PD_FALSE;
			}
		}
	} else if (!strcmp(csDesc, "req_bank_hour")) {
		// 00-23
		if (strlen(csValue) == 1) {
			sprintf(csValue, "0%c", csValue[0]);
DEBUGLOG(("ValidateField:: new csValue = [%s]\n", csValue));
		}

		if (strlen(csValue) != 2) {
DEBUGLOG(("ValidateField:: length != 2\n"));
			return PD_FALSE;
		} else {
			if ((csValue[0] == '0') || (csValue[0] == '1')) {
				// 00-09, 10-19
				if ((csValue[1] < '0') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid hour\n"));
					return PD_FALSE;
				}
			} else if (csValue[0] == '2') {
				// 20-23
				if ((csValue[1] < '0') || (csValue[1] > '3')) {
DEBUGLOG(("ValidateField:: invalid hour\n"));
					return PD_FALSE;
				}
			} else {
DEBUGLOG(("ValidateField:: invalid hour\n"));
				return PD_FALSE;
			}
		}
	} else if (!strcmp(csDesc, "req_bank_minute")) {
		// 00-59
		if (strlen(csValue) == 1) {
			sprintf(csValue, "0%c", csValue[0]);
DEBUGLOG(("ValidateField:: new csValue = [%s]\n", csValue));
		}

		if (strlen(csValue) != 2) {
DEBUGLOG(("ValidateField:: length != 2\n"));
			return PD_FALSE;
		} else {
			if ((csValue[0] >= '0') && (csValue[0] <= '5')) {
				if ((csValue[1] < '0') || (csValue[1] > '9')) {
DEBUGLOG(("ValidateField:: invalid minute\n"));
					return PD_FALSE;
				}
			} else {
DEBUGLOG(("ValidateField:: invalid minute\n"));
				return PD_FALSE;
			}
		}
	} else if (!strcmp(csDesc, "req_bank_date")) {
		if (strlen(csValue) != 8) {
DEBUGLOG(("ValidateField:: length != 8\n"));
			return PD_FALSE;
		} else {
			for (i = 0; i < strlen(csValue); i++) {
				if ((csValue[i] < '0') || (csValue[i] > '9')) {
DEBUGLOG(("ValidateField:: contains non-digit character\n"));
					return PD_FALSE;
				}
			}
		}
	} else if (!strcmp(csDesc, "req_bank_amount") || !strcmp(csDesc, "req_bank_bal")) {
		for (i = 0; i < strlen(csValue); i++) {
			if ((csValue[i] < '0') || (csValue[i] > '9')) {
				if ((csValue[i] != '+') && (csValue[i] != '-') && (csValue[i] != ',') && (csValue[i] != '.') && (csValue[i] != ' ')) {
DEBUGLOG(("ValidateField:: contains non-digit character\n"));
					return PD_FALSE;
				}
			}
		}
	}

	//req_bank_channel
	//req_bank_city
	//req_bank_fee
	//req_bank_name
	//req_payee
	//req_payer
	//req_usage

	return PD_TRUE;
}


int ProcessSmsText(const char* csSender, const char* csSmsText, const char* csScts, hash_t* hText)
{
	int iRet = PD_OK;
	char csTmpSmsText[PD_MAX_BUFFER];
	char *csFormatId;
	char *csContentCnt;
	int iContentCnt = 0;
	char *csDelimiter;
	int iIsGeneric = 0;
	char *csSubDelimiter;
	char *csDesc;
	char csValue[PD_MAX_BUFFER];
	char *csDelimiterDesc;
	char csGenDelim[PD_MAX_BUFFER];
	char *csBankName;
	char *csIntBankCode;
	char *csBankAcctNum;
	char csStatus[PD_SMS_REQ_STATUS_LEN];
	char csTmp[PD_SP_VALUE_LEN];
	int iSupportSmsStmt;
	char *csStatusType;
	char *csReqBankDate;
	char *csReqBankYear;
	char *csReqBankMonth;
	char *csReqBankDay;

	int i = 0, iPos = 0, iValid = PD_FALSE, iDupCnt = 0;
	char *csTagDelimiter = (char*) malloc (64);
	char *csTagIsGeneric = (char*) malloc (64);
	char *csTagDesc = (char*) malloc (64);
	char *csTagDelimiterDesc = (char*) malloc (64);
	char *pch;

	recordset_t *rRecordFormat;
	rRecordFormat = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordFormat, 0);

	hash_t *hFormat;

	time_t tNow;
	struct tm tStruct;
	char csBuf[PD_TMP_BUF_LEN];

	tNow = time(0);
	tStruct = *localtime(&tNow);

	hash_t *hRec;
	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec, 0);

	/* check empty text */
	if (strlen(csSmsText) == 0) {
DEBUGLOG(("ProcessSmsText:: sms text is empty\n"));
		iRet = PD_ERR;
		strcpy(csStatus, "EMPTY_TEXT");
	}

	/* check sender */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::CheckSender()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLSmsFormat", "CheckSender");
		iRet = (unsigned long)(*DBObjPtr)(csSender);

		if (iRet == PD_FOUND) {
DEBUGLOG(("ProcessSmsText:: trusted sender\n"));
			iRet = PD_OK;
		} else {
DEBUGLOG(("ProcessSmsText:: untrusted sender\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "UNTRUSTED_SENDER");
		}
	}

	/* check bank */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::CheckBank()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLSmsFormat", "CheckBank");
		iRet = (unsigned long)(*DBObjPtr)(csSmsText);

		if (iRet == PD_FOUND) {
DEBUGLOG(("ProcessSmsText:: supported bank\n"));
			iRet = PD_OK;
		} else {
DEBUGLOG(("ProcessSmsText:: unsupported bank\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "UNSUPPORTED_BANK");
		}
	}

	/* get all supported format */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::GetFormat()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLSmsFormat", "GetFormat");
		iRet = (unsigned long)(*DBObjPtr)(csSender, csSmsText, rRecordFormat);

		if (iRet != PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::GetFormat() failed!!!\n"));
ERRLOG("BOOLSms:: ProcessSmsText:: call DBOLSmsFormat::GetFormat() failed!!!\n");
			iRet = PD_ERR;
			strcpy(csStatus, "INVALID_FORMAT");
		}
	}

	if (iRet == PD_OK) {

		/* loop all supported format until found */
		hFormat = RecordSet_GetFirst(rRecordFormat);
		while (hFormat) {

			strcpy(csTmpSmsText, csSmsText);
DEBUGLOG(("ProcessSmsText:: csTmpSmsText = [%s]\n", csTmpSmsText));

			/* get int bank code */
			if (GetField_CString(hFormat, "int_bank_code", &csIntBankCode)) {
DEBUGLOG(("ProcessSmsText:: int bank code = [%s]\n", csIntBankCode));
				PutField_CString(hText, "int_bank_code", csIntBankCode);
			} else {
DEBUGLOG(("ProcessSmsText:: int bank code not found, check next format\n"));
				iRet = PD_ERR;
				hFormat = RecordSet_GetNext(rRecordFormat);
				continue;
			}

			/* get bank name */
			if (GetField_CString(hFormat, "bank_name", &csBankName)) {
DEBUGLOG(("ProcessSmsText:: bank name = [%s]\n", csBankName));
				PutField_CString(hText, "req_bank_name", csBankName);
			} else {
DEBUGLOG(("ProcessSmsText:: bank name not found, check next format\n"));
				iRet = PD_ERR;
				hFormat = RecordSet_GetNext(rRecordFormat);
				continue;
			}

			/* get format id */
			if (GetField_CString(hFormat, "id", &csFormatId)) {
DEBUGLOG(("ProcessSmsText:: format id = [%s]\n", csFormatId));
			} else {
DEBUGLOG(("ProcessSmsText:: format id not found, check next format\n"));
				iRet = PD_ERR;
				hFormat = RecordSet_GetNext(rRecordFormat);
				continue;
			}

			/* get content count */
			if (GetField_CString(hFormat, "content_cnt", &csContentCnt)) {
				iContentCnt = atoi(csContentCnt);
				if (iContentCnt <= 0) {
DEBUGLOG(("ProcessSmsText:: content count <= 0, check next format\n"));
					iRet = PD_ERR;
					hFormat = RecordSet_GetNext(rRecordFormat);
					continue;
				}
DEBUGLOG(("ProcessSmsText:: content count = [%d]\n", iContentCnt));
			} else {
DEBUGLOG(("ProcessSmsText:: content count not found, check next format\n"));
				iRet = PD_ERR;
				hFormat = RecordSet_GetNext(rRecordFormat);
				continue;
			}

			/* start tokenize sms text */
			for (i = 1; i <= iContentCnt; i++) {
				sprintf(csTagDelimiter, "content_delimiter_%d", i);
				if (GetField_CString(hFormat, csTagDelimiter, &csDelimiter)) {
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csTagDelimiter, csDelimiter));

					/* check whether it is generic delimiter */
					sprintf(csTagIsGeneric, "content_is_generic_%d", i);
					if (GetField_Int(hFormat, csTagIsGeneric, &iIsGeneric)) {
DEBUGLOG(("ProcessSmsText:: %s = [%i]\n", csTagIsGeneric, iIsGeneric));
					}

					if (iIsGeneric) {
						iRet = PD_ERR;
						if (strcmp(csDelimiter, "[NON-DIGIT]") == 0) {
							iPos = 0;
							while (csTmpSmsText[iPos] < '0' || csTmpSmsText[iPos] > '9') {
								iPos++;
							}
							strncpy(csGenDelim, csTmpSmsText, iPos);
							csGenDelim[iPos] = '\0';

							sprintf(csTagDelimiterDesc, "content_delimiter_desc_%d", i);
							if (GetField_CString(hFormat, csTagDelimiterDesc, &csDelimiterDesc)) {
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csTagDelimiterDesc, csDelimiterDesc));

DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csDelimiterDesc, csGenDelim));
								PutField_CString(hText, csDelimiterDesc, csGenDelim);
							}

							/* remove the delimiter from sms text */
							strcpy(csTmpSmsText, csTmpSmsText+strlen(csGenDelim));
DEBUGLOG(("ProcessSmsText:: after %s = [%s]\n", csTagDelimiter, csTmpSmsText));
							iRet = PD_OK;
						}
					} else {
						/* loop all sub-delimiter */
						iRet = PD_ERR;
						csSubDelimiter = strtok(csDelimiter, DELIMITER_DELIMITER);
						while (csSubDelimiter != NULL) {
DEBUGLOG(("ProcessSmsText:: sub-%s = [%s]\n", csTagDelimiter, csSubDelimiter));

							pch = strstr(csTmpSmsText, csSubDelimiter);
							if (pch != NULL) {
								iValid = PD_FALSE;

								sprintf(csTagDesc, "content_desc_%d", i);
								if (GetField_CString(hFormat, csTagDesc, &csDesc)) {
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csTagDesc, csDesc));

									strncpy(csValue, csTmpSmsText, strlen(csTmpSmsText)-strlen(pch));
									csValue[strlen(csTmpSmsText)-strlen(pch)] = '\0';
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csDesc, csValue));

									/* field validation */
									iValid = ValidateField(csDesc, csValue);

									if (iValid) {
										PutField_CString(hText, csDesc, csValue);
									}
								} else {
									if (strncmp(csTmpSmsText, csSubDelimiter, strlen(csSubDelimiter)) == 0) {
										iValid = PD_TRUE;
									}
								}

								if (iValid) {
									sprintf(csTagDelimiterDesc, "content_delimiter_desc_%d", i);
									if (GetField_CString(hFormat, csTagDelimiterDesc, &csDelimiterDesc)) {
DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csTagDelimiterDesc, csDelimiterDesc));

DEBUGLOG(("ProcessSmsText:: %s = [%s]\n", csDelimiterDesc, csSubDelimiter));
										PutField_CString(hText, csDelimiterDesc, csSubDelimiter);
									}

									/* remove the delimiter from sms text */
									strcpy(csTmpSmsText, pch+strlen(csSubDelimiter));
DEBUGLOG(("ProcessSmsText:: after %s = [%s]\n", csTagDelimiter, csTmpSmsText));
									iRet = PD_OK;
									break;
								}
							} else {
DEBUGLOG(("ProcessSmsText:: sub-%s not match, continue\n", csTagDelimiter));
								// iRet = PD_ERR;
							}

							csSubDelimiter = strtok(NULL, DELIMITER_DELIMITER);
						}
					}

					if (iRet == PD_ERR) {
DEBUGLOG(("ProcessSmsText:: %s not match, check next format\n", csTagDelimiter));
						// iRet = PD_ERR;
						break;
					}
				} else {
DEBUGLOG(("ProcessSmsText:: %s not found, check next format\n", csTagDelimiter));
					iRet = PD_ERR;
					break;
				}
			}

			if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: format found, stop checking remaining format\n"));
				break;
			}

			hash_destroy(hText);
			hash_init(hText, 0);

			hFormat = RecordSet_GetNext(rRecordFormat);
		}

		if (iRet != PD_OK) {
			strcpy(csStatus, "INVALID_FORMAT");
		}
	}

	/* check duplicate */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBSystemParameter::FindCode()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBSystemParameter", "FindCode");
		iRet = (unsigned long)(*DBObjPtr)(PD_SMS_DEDUP_RANGE, csTmp);

		if (iRet != PD_FOUND) {
DEBUGLOG(("ProcessSmsText:: find code error\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "DUPLICATED");
		} else {
DEBUGLOG(("ProcessSmsText:: de-duplication time range = [%s]\n", csTmp));
			iRet = PD_OK;
		}

		if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsTxnLog::CheckDuplicate()\n"));
			DBObjPtr = CreateObj(DBPtr, "DBOLSmsTxnLog", "CheckDuplicate");
			iDupCnt = (unsigned long)(*DBObjPtr)(csTmp, csSender, csSmsText, csScts);

			if (iDupCnt < 0) {
DEBUGLOG(("ProcessSmsText:: check duplicate error\n"));
				iRet = PD_ERR;
				strcpy(csStatus, "DUPLICATED");
			} else if (iDupCnt != 0) {
DEBUGLOG(("ProcessSmsText:: found [%d] duplicate sms within [%s] minutes\n", iDupCnt, csTmp));
				iRet = PD_ERR;
				strcpy(csStatus, "DUPLICATED");
			}
		}
	}

	/* check whether system supports sms stmt */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBSystemParameter::FindCode()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBSystemParameter", "FindCode");
		iRet = (unsigned long)(*DBObjPtr)(PD_SMS_STMT_UPL, csTmp);

		if (iRet != PD_FOUND) {
DEBUGLOG(("ProcessSmsText:: find code error\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "SYS_DISABLED_SMS");
		} else if (csTmp[0] != '1') {
DEBUGLOG(("ProcessSmsText:: system does not support sms stmt\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "SYS_DISABLED_SMS");
		} else {
			iRet = PD_OK;
		}
	}

	/* check whether this bank acct is inactive and supports sms stmt */
	if (iRet == PD_OK) {
		/* get bank acct num */
		if (GetField_CString(hText, "req_bank_acc", &csBankAcctNum)) {
DEBUGLOG(("ProcessSmsText:: bank acct num = [%s]\n", csBankAcctNum));
		} else {
DEBUGLOG(("ProcessSmsText:: bank acct num not found\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "ACCT_INACTIVE");
		}

		if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLBankAccts::GetBankAccts()\n"));
			DBObjPtr = CreateObj(DBPtr, "DBOLBankAccts", "GetBankAccts");
			iRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csBankAcctNum, hRec);

			if (iRet != PD_OK) {
DEBUGLOG(("ProcessSmsText:: get bank acct error\n"));
				iRet = PD_ERR;
				strcpy(csStatus, "ACCT_INACTIVE");
			} else {
				if (GetField_CString(hRec, "status_type", &csStatusType)) {
DEBUGLOG(("ProcessSmsText:: status type = [%s]\n", csStatusType));
					if (strcmp(csStatusType, "I") == 0) {
DEBUGLOG(("ProcessSmsText:: bank acct is inactive\n"));
						iRet = PD_ERR;
						strcpy(csStatus, "ACCT_INACTIVE");
					}
				} else {
DEBUGLOG(("ProcessSmsText:: status type not found\n"));
					iRet = PD_ERR;
					strcpy(csStatus, "ACCT_INACTIVE");
				}

				if (iRet == PD_OK) {
					if (GetField_Int(hRec, "support_sms_stmt", &iSupportSmsStmt)) {
DEBUGLOG(("ProcessSmsText:: support sms stmt = [%d]\n", iSupportSmsStmt));
						if (iSupportSmsStmt == 0) {
DEBUGLOG(("ProcessSmsText:: bank acct does not support sms stmt\n"));
							iRet = PD_ERR;
							strcpy(csStatus, "ACCT_DISABLED_SMS");
						}
					} else {
DEBUGLOG(("ProcessSmsText:: support sms stmt not found\n"));
						iRet = PD_ERR;
						strcpy(csStatus, "ACCT_DISABLED_SMS");
					}
				}
			}
		}
	}

	/* check whether sms date is today or not */
	if (iRet == PD_OK) {
		if (GetField_CString(hText, "req_bank_date", &csReqBankDate)) {
DEBUGLOG(("ProcessSmsText:: req_bank_date = [%s]\n", csReqBankDate));
		} else {
			if (GetField_CString(hText, "req_bank_year", &csReqBankYear)) {
				strcpy(csReqBankDate, csReqBankYear);
			} else {
				strftime(csBuf, sizeof(csBuf), "%Y", &tStruct);
				strcpy(csReqBankDate, csBuf);
			}
			if (GetField_CString(hText, "req_bank_month", &csReqBankMonth)) {
				strcat(csReqBankDate, csReqBankMonth);
			} else {
				strftime(csBuf, sizeof(csBuf), "%m", &tStruct);
				strcat(csReqBankDate, csBuf);
			}
			if (GetField_CString(hText, "req_bank_day", &csReqBankDay)) {
				strcat(csReqBankDate, csReqBankDay);
			} else {
				strftime(csBuf, sizeof(csBuf), "%d", &tStruct);
				strcat(csReqBankDate, csBuf);
			}
DEBUGLOG(("ProcessSmsText:: req_bank_year+req_bank_month+req_bank_day = [%s]\n", csReqBankDate));
			PutField_CString(hText, "req_bank_date", csReqBankDate);
		}

		strftime(csBuf, sizeof(csBuf), "%Y%m%d", &tStruct);
		if (strcmp(csReqBankDate, csBuf) != 0) {
DEBUGLOG(("ProcessSmsText:: sms date is not today\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "NON_SAME_DAY");
		}
	}

	/* check any bank stmt found */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLStatement::MatchStmt()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "MatchStmt");
		iRet = (unsigned long)(*DBObjPtr)(hText);

		if (iRet != PD_NOT_FOUND) {
DEBUGLOG(("ProcessSmsText:: bank statement found\n"));
			iRet = PD_ERR;
			strcpy(csStatus, "AMOUNT_FOUND");
		} else {
			iRet = PD_OK;
		}
	}

	if (iRet == PD_OK) {
		PutField_CString(hText, "req_status", "UPLOADED");
	} else {
		PutField_CString(hText, "req_status", csStatus);
	}

	free(csTagDelimiter);
	free(csTagIsGeneric);
	free(csTagDesc);
	free(csTagDelimiterDesc);

DEBUGLOG(("ProcessSmsText() iRet = [%d]\n", iRet));
	return iRet;
}
