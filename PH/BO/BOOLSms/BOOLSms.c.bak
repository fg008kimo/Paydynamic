/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/07/26              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "dbutility.h"
#include "BOOLSms.h"
#include "myrecordset.h"
#include "myhash.h"
#include "math.h"

char cDebug;
OBJPTR(DB);
OBJPTR(BO);

#define DELIMITER_DELIMITER "|"

void BOOLSms(char cdebug)
{
	cDebug = cdebug;
}

int ProcessSmsText(const char* csSender, const char* csSmsText, hash_t* hText)
{
	int iRet = PD_OK;
	char csTmpSmsText[PD_MAX_BUFFER];
	char *csContentCnt;
	int iContentCnt;
	char *csDelimiter;
	char *csSubDelimiter;
	char *csDesc;
	char csValue[PD_MAX_BUFFER];
	char *csDelimiterDesc;

	int i;
	char *csTagDelimiter = (char*) malloc (64);
	char *csTagDesc = (char*) malloc (64);
	char *csTagDelimiterDesc = (char*) malloc (64);
	char *pch;

	recordset_t *rRecordFormat;
	rRecordFormat = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordFormat, 0);

	hash_t *hFormat;

	if (iRet == PD_OK) {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::GetFormat()\n"));
                DBObjPtr = CreateObj(DBPtr, "DBOLSmsFormat", "GetFormat");
                iRet = (unsigned long)(*DBObjPtr)(csSender, csSmsText, rRecordFormat);
	} else {
DEBUGLOG(("ProcessSmsText:: call DBOLSmsFormat::GetFormat() failed!!!\n"));
ERRLOG("BOOLSms:: ProcessSmsText:: call DBOLSmsFormat::GetFormat() failed!!!\n");
	}

	if (iRet == PD_OK) {

		hFormat = RecordSet_GetFirst(rRecordFormat);
		while (hFormat) {

			strcpy(csTmpSmsText, csSmsText);
DEBUGLOG(("ProcessStmtFile:: csTmpSmsText = [%s]\n", csTmpSmsText));

			if (GetField_CString(hFormat, "content_cnt", &csContentCnt)) {
				iContentCnt = atoi(csContentCnt);
DEBUGLOG(("ProcessStmtFile:: content_cnt = [%d]\n", iContentCnt));
			} else {
DEBUGLOG(("ProcessStmtFile:: content_cnt not found, stop!!!\n"));
ERRLOG("BOOLSms:: ProcessStmtFile:: content_cnt not found, stop!!!\n");
				iRet = PD_ERR;
				break;
			}

			/* start tokenize sms text */
			// to be implemented : special handling of bank channel as bank name
			for (i = 1; i <= iContentCnt; i++) {
				sprintf(csTagDelimiter, "content_delimiter_%d", i);
				if (GetField_CString(hFormat, csTagDelimiter, &csDelimiter)) {
DEBUGLOG(("ProcessStmtFile:: %s = [%s]\n", csTagDelimiter, csDelimiter));

					/* loop all sub-delimiter */
					csSubDelimiter = strtok(csDelimiter, DELIMITER_DELIMITER);
					while (csSubDelimiter != NULL) {
DEBUGLOG(("ProcessStmtFile:: sub-%s = [%s]\n", csTagDelimiter, csSubDelimiter));

						pch = strstr(csTmpSmsText, csSubDelimiter);
						if (pch != NULL) {
							sprintf(csTagDesc, "content_desc_%d", i);
							if (GetField_CString(hFormat, csTagDesc, &csDesc)) {
DEBUGLOG(("ProcessStmtFile:: %s = [%s]\n", csTagDesc, csDesc));

								strncpy(csValue, csTmpSmsText, strlen(csTmpSmsText)-strlen(pch));
								csValue[strlen(csTmpSmsText)-strlen(pch)] = '\0';
DEBUGLOG(("ProcessStmtFile:: %s value = [%s]\n", csTagDesc, csValue));
								PutField_CString(hText, csDesc, csValue);
							}

							sprintf(csTagDelimiterDesc, "content_delimiter_desc_%d", i);
							if (GetField_CString(hFormat, csTagDelimiterDesc, &csDelimiterDesc)) {
DEBUGLOG(("ProcessStmtFile:: %s = [%s]\n", csTagDelimiterDesc, csDelimiterDesc));

DEBUGLOG(("ProcessStmtFile:: %s value = [%s]\n", csTagDelimiterDesc, csSubDelimiter));
								PutField_CString(hText, csDelimiterDesc, csSubDelimiter);
							}

							/* remove the delimiter from sms text */
							strcpy(csTmpSmsText, pch+strlen(csSubDelimiter));
DEBUGLOG(("ProcessStmtFile:: after %s = [%s]\n", csTagDelimiter, csTmpSmsText));
							iRet = PD_OK;
							break;
						} else {
DEBUGLOG(("ProcessStmtFile:: sub-%s not match, continue\n", csTagDelimiter));
							iRet = PD_ERR;
						}

						csSubDelimiter = strtok(NULL, DELIMITER_DELIMITER);
					}

					if (iRet == PD_ERR) {
DEBUGLOG(("ProcessStmtFile:: %s not match, stop!!!\n", csTagDelimiter));
						break;
					}
				} else {
DEBUGLOG(("ProcessStmtFile:: %s not found, stop!!!\n", csTagDelimiter));
ERRLOG("BOOLSms:: ProcessStmtFile:: %s not found, stop!!!\n", csTagDelimiter);
					iRet = PD_ERR;
					break;
				}
			}

			if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile:: format found, stop looping\n"));
				break;
			}

			hash_destroy(hText);
			hash_init(hText, 0);

			hFormat = RecordSet_GetNext(rRecordFormat);
		}
	}

	free(csTagDelimiter);
	free(csTagDesc);
	free(csTagDelimiterDesc);

DEBUGLOG(("ProcessSmsText() iRet = [%d]\n", iRet));
	return iRet;
}
