/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/07/26              David Wong
Add ProcessStmtFile
 (encoding,multi-format,field checking)		   2013/07/29              Stan Poon
Add ProcessStmtFile running balance checking       2013/08/06              David Wong
Add ProcessStmtFile de-duplication                 2013/08/15              David Wong
Add ProcessStmtFile error table                    2013/09/17              Stan Poon
Add ProcessAuxStmtFile                             2013/10/??              David Wong
Add ProcessStmtFile BAID and update BAID balance   2014/01/09		   Stan Poon
Add ProcessStmtFile Txn Code Keywords Mapping	   2014/01/09		   Stan Poon
Add ProcessStmtFile Add Txn Level		   2014/01/09		   Stan Poon
Add ProcessStmtFile Table Lock			   2014/01/09		   Stan Poon
Add ProcessStmtFile Add BAID Txn Level		   2014/02/21		   Stan Poon
Add ProcessStmtFile to BOOLBankStmtMatch	   2014/02/21		   Stan Poon
Add ProcessStmtFile Void and change Txn Code	   2014/02/21		   Stan Poon
Add ProcessStmtFile Auto Post Deposit Txn	   2014/02/21		   Stan Poon
Add ProcessStmtFile Sort Bank Stmt		   2014/03/05		   Stan Poon
Add Merge Column in template			   2014/06/16		   Stan Poon
Add update_bal indicator			   2014/07/21		   David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#define __USE_XOPEN
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "BOOLBankStmt.h"
#include "myrecordset.h"
#include "myhash.h"
#include "math.h"

#define	IN_FILE_EXT_DELIMITER	"."
#define	EXCEL_CONVERT_SCRIPT	"xls2txt"
#define	TEXT_CONVERT_SCRIPT	"iconv"
#define	OUT_FILE_ENCODING	"UTF-8"

#define PD_DEFAULT_DATE_FORMAT		"%Y%m%d"
#define PD_DEFAULT_TIME_FORMAT		"%H%M%S"
#define PD_DEFAULT_DATETIME_FORMAT	"%Y%m%d%H%M%S"

char cDebug;
OBJPTR(DB);
OBJPTR(BO);

void BOOLBankStmt(char cdebug)
{
	cDebug = cdebug;
}


int ProcessAuxStmtFile(hash_t *hContext, hash_t *hRequest, recordset_t* rRecordFormat)
{
	int iRet = PD_OK;

	FILE *fin;
	char *csInFileName, *csInFilePath;
	char csFileName[PD_TMP_BUF_LEN];

/* in_file_name */
	if (GetField_CString(hContext, "in_file_name", &csInFileName)) {
DEBUGLOG(("ProcessAuxStmtFile() in_file_name = [%s]\n", csInFileName));
	}

/* in_file_path */
	if (GetField_CString(hContext, "in_file_path", &csInFilePath)) {
DEBUGLOG(("ProcessAuxStmtFile() in_file_path = [%s]\n", csInFilePath));
	}

/* open file */
	if (iRet == PD_OK) {
		snprintf(csFileName, sizeof(csFileName), "%s/%s", csInFilePath, csInFileName);
DEBUGLOG(("ProcessAuxStmtFile() ready to open file [%s]\n", csFileName));
		fin = fopen(csFileName, "r");
		if (fin == NULL) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessAuxStmtFile() cannot open file [%s]\n", csFileName));
ERRLOG("BOOLBankStmt::ProcessAuxStmtFile() cannot open file [%s]\n", csFileName);
		}
	}

	return iRet;
}


int ConvertStmtFile(hash_t* hContext)
{
	int iRet = PD_OK;
	int iCnt = 0;
	char csTmpForStrtok[PD_TMP_BUF_LEN];
	char *csTmp = NULL;
	char *csInFileName = NULL, *csIntBankCode = NULL;
	char csInFileExt[PD_TMP_BUF_LEN];
	char csScriptName[PD_TMP_BUF_LEN];
	char csInFileEncoding[PD_TMP_BUF_LEN];
	char csInFilePrefix[PD_TMP_BUF_LEN];
	char csInFileCountry[PD_TMP_BUF_LEN];
	char *csNewFullName = NULL;
	char *csConvertedFullName = NULL;
	char csSysCmd[PD_TMP_BUF_LEN*3];

/* in_file_name */
	if (GetField_CString(hContext, "in_file_name", &csInFileName)) {
DEBUGLOG(("ConvertStmtFile in_file_name = [%s]\n", csInFileName));
	}

/* new_file */
	if (GetField_CString(hContext, "new_file", &csNewFullName)) {
DEBUGLOG(("ConvertStmtFile new_file = [%s]\n", csNewFullName));
	}

/* converted_file */
	if (GetField_CString(hContext, "converted_file", &csConvertedFullName)) {
DEBUGLOG(("ConvertStmtFile converted_file = [%s]\n", csConvertedFullName));
	}

/* int_bank_code */
	if (GetField_CString(hContext, "int_bank_code", &csIntBankCode)) {
DEBUGLOG(("ConvertStmtFile int_bank_code = [%s]\n", csIntBankCode));
	}

/* get in_file_ext */
	if (iRet == PD_OK) {
		iCnt = 0;
		strcpy(csTmpForStrtok, csInFileName);
		csTmp = strtok(csTmpForStrtok, IN_FILE_EXT_DELIMITER);
		while (csTmp != NULL) {
// DEBUGLOG(("ConvertStmtFile in_file_name token: [%s]\n", csTmp));
			iCnt++;
			//strcpy(csInFileExt, csTmp);
			U2L(csTmp,strlen(csTmp),csInFileExt);
			csTmp = strtok(NULL, IN_FILE_EXT_DELIMITER);
		}

		if (iCnt > 0) {
// DEBUGLOG(("ConvertStmtFile in_file_ext = [%s]\n", csInFileExt));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("ConvertStmtFile in_file_ext is missing!!!\n"));
ERRLOG("BOOLBankStmt::ConvertStmtFile in_file_ext is missing!!!\n");
		}
	}

/* get convert info */
	if (iRet == PD_OK) {
DEBUGLOG(("ConvertStmtFile call OLStmtConvertScript::GetConvertInfo()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtConvertScript", "GetConvertInfo");
		iRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csInFileExt, csScriptName, csInFileEncoding, csInFilePrefix, csInFileCountry);

		if (iRet != PD_OK) {
			iRet = PD_ERR;
DEBUGLOG(("ConvertStmtFile call OLStmtConvertScript::GetConvertInfo() FAILURE!!!\n"));
ERRLOG("BOOLBankStmt::ConvertStmtFile call OLStmtConvertScript::GetConvertInfo() FAILURE!!!\n");
		}
	}

/* do the conversion
example: xls2csv -x "spreadsheet.xls" -b WINDOWS-1252 -c "csvfile.csv" -a UTF-8
example: iconv -f WINDOWS-1252 -t UTF-8 "spreadsheet.xls"
example: xls2txt "spreadsheet.xls"
*/
	if (iRet == PD_OK) {
		if (!strcmp(csScriptName, EXCEL_CONVERT_SCRIPT)) {
			snprintf(csSysCmd, sizeof(csSysCmd), "%s \"%s\" > \"%s\"", EXCEL_CONVERT_SCRIPT, csNewFullName, csConvertedFullName);
		} else if (!strcmp(csScriptName, TEXT_CONVERT_SCRIPT)) {
			snprintf(csSysCmd, sizeof(csSysCmd), "%s -f \"%s\" -t \"%s\" \"%s\" > \"%s\"", TEXT_CONVERT_SCRIPT, csInFileEncoding, OUT_FILE_ENCODING, csNewFullName, csConvertedFullName);
		} else {
			snprintf(csSysCmd, sizeof(csSysCmd), "%s \"%s\" \"%s\" \"%s\" \"%s\" \"%s\"", csScriptName, csInFileEncoding, OUT_FILE_ENCODING, csNewFullName, csConvertedFullName, csInFileExt);
		}

DEBUGLOG(("ConvertStmtFile call system command [%s][%d]\n", csSysCmd, strlen(csSysCmd)));
		int status = system(csSysCmd);

		iRet = WEXITSTATUS(status);
		if (iRet != PD_OK) {
DEBUGLOG(("ConvertStmtFile conversion FAILURE!!! Ret = [%d][%d]\n",status,iRet));
ERRLOG("BOOLBankStmt::ConvertStmtFile conversion FAILURE!!!\n");
			iRet = PD_ERR;
		}
	}

DEBUGLOG(("ConvertStmtFile Normal Exit! iRet = [%d]\n", iRet));

	return iRet;
}


char *csDetailTag[14] = {"statement_date","statement_time","tfr_bank_name","tfr_bank_acct_num","tfr_type","tfr_channel","tfr_text","tfr_customer_text","sender_name","txn_ref_num","balance","amt_type","txn_amount","txn_ccy"};
int iDetailMaxLength[14]     = { 8, 6,-1,-1,-1,-1,-1,-1,-1,-1,15, 2,13, 3};
int iDetailMaxUTF8Length[14] = {-1,-1,50,50,50,50,50,50,50,50,-1,-1,-1,-1};

char *csCompareKeyWithTime[6] = {"statement_date", "statement_time", "txn_ccy", "txn_amount", "amt_type", "balance"};
char *csCompareKeyWithoutTime[5] = {"statement_date", "txn_ccy", "txn_amount", "amt_type", "balance"};

int splitLineByhFormat(const char *csLine, const char *csFormatId, const hash_t *hFormat, hash_t *hRec);
int CheckDetail(const hash_t *hContext, hash_t *hRls, char* cs_err_msg_buf);
int GetCompareKey(const hash_t *hContext, char *csTag[], int iArraySize, char *csCompareKey);
int MultiKeywordsSearch(const char *csLine, char *csTemplate, int iFullMatch);

struct node {
	hash_t *hDtl;
	struct node *next;
};

struct node *list_switch(struct node *l1, struct node *l2)
{
    l1->next = l2->next;
    l2->next = l1;
    return l2;
}

int strlen_utf8(char *s) 
{
	int i = 0, j = 0;
	while (s[i]) 
	{
		if ((s[i] & 0xc0) != 0x80) j++;
		i++;
	}
	return j;
}

int strlen_content(char *s) 
{
	int i = 0, j = 0;
	while (s[i]) 
	{
		if ((s[i] & 0xc0) == 0x00 || (s[i] & 0xc0) == 0x40) {
			if ((s[i] >= '0' && s[i] <= '9') ||
			    (s[i] >= 'A' && s[i] <= 'Z') ||
			    (s[i] >= 'a' && s[i] <= 'z')) {
				j++;
			}
		} else if ((s[i] & 0xc0) == 0xc0) {
			j++;
		}
		i++;
	}
	return j;
}

char *mystrtok_r(char *string, const char *seps, char **context)
{
	char *head; /* Start of word */
	char *tail; /* End of word */

	/* If we're starting up, initialize context */
	if (string) {
		*context = string;
	}

	/* Get potential start of this next word */
	head = *context;
	if (head == NULL) {
		return NULL;
	}

	/* Skip any leading separators
	while (*head && strchr(seps, *head)) {
		head++;
	}*/

	/* Did we hit the end? */
	if (*head == 0) {
		/* Nothing left */
		*context = NULL;
		return NULL;
	}

	/* Skip over word */
	tail = head;
	while (*tail && !strchr(seps, *tail)) {
		tail++;
	}

	/* Save head for next time in context */
	if (*tail == 0) {
		*context = NULL;
	} else {
		*tail = 0;
		tail++;
		*context = tail;
	}

	/* Return current word */
	return head;
}

int FindDecimalPlaces(const char *csAmt)
{
	int i=0;
	int iDp=0, iZero=0, iStarted=0;
	while (csAmt[i]) {
		if (csAmt[i] >= '0' && csAmt[i] <= '9') {
			if (iStarted == 1) {
				if (csAmt[i] == '0') {
					iZero++;
				} else {
					iDp += iZero + 1;
					iZero=0;
				}
			}
		} else if (csAmt[i] == '.') {
			if (iStarted == 1) return iDp;
			iStarted++;
		} else {
			return iDp;
		}
		i++;
	}
	return iDp;
}

char* ChangeDateTimeFormat(const char* csDateTime, int iStartYear, const char* csTemplate, const char* csOutTemplate)
{
	static char csOutDateTime[(PD_DATETIME_LEN)*2 + 1];
	int nDays[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
        struct tm tStruct = { 0, 0, 0, 1, 0, 0, 0, 0, -1 };

	strptime(csDateTime, csTemplate, &tStruct);

	if (iStartYear > 0) tStruct.tm_year+=iStartYear;
	if (isleap(tStruct.tm_year+1900)) nDays[1]=29;

	if (tStruct.tm_mday > nDays[tStruct.tm_mon]) tStruct.tm_mday=0;
	if (tStruct.tm_sec > 59) tStruct.tm_sec=0;

	strftime(csOutDateTime, sizeof(csOutDateTime), csOutTemplate, &tStruct);

// DEBUGLOG(("ChangeDateTimeFormat: [%s](%s) to [%s](%s)\n",csDateTime,csTemplate,csOutDateTime,csOutTemplate));
        return csOutDateTime;
}

char* ChangeTimeZone(const char* csDateTime, const char* csTemplate, const char* csSrcTimeZone, const char* csDstTimeZone)
{
        static char csLocalDateTime[(PD_DATETIME_LEN)*2 + 1];
        struct tm tStruct = { 0, 0, 0, 1, 0, 0, 0, 0, -1 };
        time_t time;

        strptime(csDateTime, csTemplate, &tStruct);

        putenv((char*)csSrcTimeZone);
        time = mktime(&tStruct);

        putenv((char*)csDstTimeZone);
        tStruct = *localtime(&time);

        strftime(csLocalDateTime, sizeof(csLocalDateTime), csTemplate, &tStruct);

// DEBUGLOG(("ChangeTimeZone: [%s] to [%s]\n",csDateTime,csLocalDateTime));
        return csLocalDateTime;
}

int ProcessStmtFile(hash_t *hContext, hash_t *hRequest, recordset_t *rRecordFormat)
{
	int iRet = PD_OK, iDtlRet = PD_OK;

	char *csInFileName = NULL, *csInFilePath = NULL, *csFileId = NULL;
	char *csConvertedFileName = NULL, *csConvertedFullName = NULL;
	char *csPspId = NULL, *csBAID = NULL, *csIntBankCode = NULL, *csBankAcctNum = NULL;
	char *csPhDate = NULL, *csCountry = NULL, *csAcctCcy = NULL, *csAcctType = NULL, *csUser = NULL;
	char *csAmtType = NULL;
	char *csTimeZone = NULL;
	int /*iSupportDecimal = 1,*/ iRestricted = 0, iRunningBal = 1;
	int iValidateAcctNum = 1, iValidateRunningBal = 1, iValidateIntoTable = 1;
	char *csFormatId = NULL, csDelimiter[2];
	int iBankAcctRow, iStartYear, iReverse, iTotalField, iStartRow, iEndRow, iNegAmount, iNegBalance, iTolDateTime;

	int iCurrLine = 0, iTotalLine = 0, iSBlankLine = 0, iEBlankLine = 0;
	int iFormatMatched = 0, iDetailRow = 0, iArraySize = 0;
	int iFieldCount = 0, iErrorCount = 0, iRowCount = 0, iRecordCount = 0;
	int iMatchCount = 0, iNotMatchCount = 0;
	int iToMatchCount = 0, iMatchNow = 0;

	int iTotalCount = 0, iTotalExtraCount = 0, iSmsCount = 0, iSkipCount = 0, iAcceptCount = 0, iHoldCount = 0, iPostCount = 0;

	char *csDesc=NULL, *csTxnCode=NULL, *csTemplate=NULL, *csField=NULL;
	char *csTxnAmt=NULL, *csBankCharge=NULL, *csBalance, *csTxnSeq=NULL;
	int iFullMatch=0, iHoldCreditSide=0, iRealTimePost=0, iDefault=0, iUpdateBal=0;
	double dMinAmt=0, dMaxAmt=0;
	int iMinDp=0, iMaxDp=0, iDisplayOrder=0;

	double dLastFileBal=0.0, dCurrFileBal=0.0, dOpenFileBal=0.0, dTxnAmt=0.0;
	double dLastTxnAmt=0.0, d2ndLastTxnAmt=0.0;

	char *csPrevDate=NULL, *csPrevTime=NULL, *csDate=NULL, *csTime=NULL, *csOutDateTime=NULL;
	char csSysDate[PD_DATE_LEN + 1], csSysTime[PD_TIME_LEN + 1];
	char csDateTime[PD_DATETIME_LEN + 1];

	char cs_input_buf[PD_TMP_MSG_BUF_LEN], cs_tmp_input_buf[PD_TMP_MSG_BUF_LEN], cs_err_desc_buf[PD_TMP_BUF_LEN];
	char *csPrevFileCompareKey=NULL, csFileCompareKey[PD_TMP_BUF_LEN]=""/*, csDbCompareKey[PD_TMP_BUF_LEN]=""*/;
	char csKeywordsMapping[PD_KEYWORDS_MAPPING_LEN + 1];

	char *csTmp = NULL;
	int iTmp;
	char *csTag = (char*) malloc (64);
	char *csCmd = (char *) malloc (PD_TMP_BUF_LEN + 64);
	FILE *fin = NULL;
	FILE *stream = NULL;

	struct node *head = NULL, *tail = NULL, *p = NULL, *q = NULL, *top = NULL, *currentNode;
	char csCurrNodeDateTime[PD_DATETIME_LEN + 1], csNextNodeDateTime[PD_DATETIME_LEN + 1];

	recordset_t *myFile, *myRec, *myRecDb;
	myFile = (recordset_t*) malloc (sizeof(recordset_t));
	myRec = (recordset_t*) malloc (sizeof(recordset_t));
	myRecDb = (recordset_t*) malloc (sizeof(recordset_t));

	hash_t *hFormat = NULL, *hFile = NULL, *hPrevFile = NULL, *hRec = NULL, *hRec2 = NULL, *hRecDb = NULL;

	recordset_init(myFile, 0);

/* in_file_name */
	if (GetField_CString(hContext, "in_file_name", &csInFileName)) {
DEBUGLOG(("ProcessStmtFile() in_file_name = [%s]\n", csInFileName));
	} else {
DEBUGLOG(("ProcessStmtFile() in_file_name NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* in_file_path */
	if (GetField_CString(hContext, "in_file_path", &csInFilePath)) {
DEBUGLOG(("ProcessStmtFile() in_file_path = [%s]\n", csInFilePath));
	} else {
DEBUGLOG(("ProcessStmtFile() in_file_path NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* converted_file_name */
	if (GetField_CString(hContext, "converted_file_name", &csConvertedFileName)) {
DEBUGLOG(("ProcessStmtFile() converted_file_name = [%s]\n", csConvertedFileName));
	} else {
DEBUGLOG(("ProcessStmtFile() converted_file_name NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* converted_file */
	if (GetField_CString(hContext, "converted_file", &csConvertedFullName)) {
DEBUGLOG(("ProcessStmtFile() converted_file = [%s]\n", csConvertedFullName));
	} else {
DEBUGLOG(("ProcessStmtFile() converted_file NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* file_id */
	if (GetField_CString(hContext, "file_id", &csFileId)) {
DEBUGLOG(("ProcessStmtFile() file_id = [%s]\n", csFileId));
	} else {
DEBUGLOG(("ProcessStmtFile() file_id NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* psp_id */
	if (GetField_CString(hContext, "psp_id", &csPspId)) {
DEBUGLOG(("ProcessStmtFile() psp_id = [%s]\n", csPspId));
	} else {
DEBUGLOG(("ProcessStmtFile() psp_id NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* baid */
	if (GetField_CString(hContext, "baid", &csBAID)) {
DEBUGLOG(("ProcessStmtFile() baid = [%s]\n", csBAID));
	} else {
DEBUGLOG(("ProcessStmtFile() baid NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* int_bank_code */
	if (GetField_CString(hContext, "int_bank_code", &csIntBankCode)) {
DEBUGLOG(("ProcessStmtFile() int_bank_code = [%s]\n", csIntBankCode));
	} else {
DEBUGLOG(("ProcessStmtFile() int_bank_code NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* bank_acct_num */
	if (GetField_CString(hContext, "bank_acct_num", &csBankAcctNum)) {
DEBUGLOG(("ProcessStmtFile() bank_acct_num = [%s]\n", csBankAcctNum));
	} else {
DEBUGLOG(("ProcessStmtFile() bank_acct_num NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* PHDATE */
	if (GetField_CString(hContext,"PHDATE",&csPhDate)) {
DEBUGLOG(("ProcessStmtFile() PHDATE = [%s]\n", csPhDate));
	} else {
DEBUGLOG(("ProcessStmtFile() PHDATE NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* country */
	if (GetField_CString(hContext, "country", &csCountry)) {
DEBUGLOG(("ProcessStmtFile() country = [%s]\n", csCountry));
	} else {
DEBUGLOG(("ProcessStmtFile() country NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* acct_ccy */
	if (GetField_CString(hContext, "acct_ccy", &csAcctCcy)) {
DEBUGLOG(("ProcessStmtFile() ccy = [%s]\n", csAcctCcy));
	} else {
DEBUGLOG(("ProcessStmtFile() ccy NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* acct_type */
	if (GetField_CString(hContext, "bank_acct_type", &csAcctType)) {
DEBUGLOG(("ProcessStmtFile() type = [%s]\n", csAcctType));
	} else {
DEBUGLOG(("ProcessStmtFile() type NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* user */
	if (GetField_CString(hContext, "create_user", &csUser)) {
DEBUGLOG(("ProcessStmtFile() user = [%s]\n", csUser));
	} else {
DEBUGLOG(("ProcessStmtFile() user NOT FOUND!!!\n"));
		iRet = PD_ERR;
	}

/* restricted */
	iRestricted = 0;
DEBUGLOG(("ProcessStmtFile() restricted = [%d]\n", iRestricted));

/* supportDecimal */
/*	if (iRet == PD_OK) {
		DBObjPtr = CreateObj(DBPtr,"DBCurrency","IsSupportDecimal");
		if ((unsigned long)((DBObjPtr)(csAcctCcy)) != PD_TRUE){
			iSupportDecimal = 0;
		}

		if(!strcmp(csCountry,PD_TAIWAN)) {
			iSupportDecimal = 0;
		}
DEBUGLOG(("ProcessStmtFile() [%s][%s] support decimal=[%d]\n",csAcctCcy,csCountry,iSupportDecimal));
	}
*/

/* timezone */
	if (iRet == PD_OK) {
		if (!strcmp(csCountry,PD_JAPAN)) {
			PutField_CString(hContext,"TIMEZONE",PD_DESTZONE_JP);
DEBUGLOG(("ProcessStmtFile() TIMEZONE [%s]\n",PD_DESTZONE_JP));
		} else if (!strcmp(csCountry,PD_INDIA)) {
			PutField_CString(hContext,"TIMEZONE",PD_DESTZONE_IN);
DEBUGLOG(("ProcessStmtFile() TIMEZONE [%s]\n",PD_DESTZONE_IN));
		}
	}

/* validate_acct_num */
	if (GetField_CString(hContext, "validate_acct_num", &csTmp)) {
		if (csTmp[0] == 'N') {
			iValidateAcctNum = 0;
		}
DEBUGLOG(("ProcessStmtFile() ** validate_acct_num = [%s]\n", csTmp));
	}

/* validate_running_balance */
	if (GetField_CString(hContext, "validate_running_bal", &csTmp)) {
		if (csTmp[0] == 'N') {
			iValidateRunningBal = 0;
		}
DEBUGLOG(("ProcessStmtFile() ** validate_running_balance = [%s]\n", csTmp));
	}

/* validate_into_table */
	if (GetField_CString(hContext, "validate_into_table", &csTmp)) {
		if (csTmp[0] == 'N') {
			iValidateIntoTable = 0;
		}
DEBUGLOG(("ProcessStmtFile() ** validate_into_table = [%s]\n", csTmp));
	}


/* file */
	fin = fopen(csConvertedFullName, "r");
	if (fin == NULL) {
		iRet = INT_ERR;
		PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("ProcessStmtFile() cannot open file [%s]!!!\n", csConvertedFileName));
ERRLOG("BOOLBankStmt::ProcessStmtFile() cannot open file [%s]!!!\n", csConvertedFileName);
	} else {
		while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
			if (strlen_content(cs_input_buf) == 0) {
				iSBlankLine++;
			} else {
				break;
			}
		}
		rewind(fin);
		while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
			if (strlen_content(cs_input_buf) == 0) {
				iEBlankLine++;
			} else {
				iEBlankLine = 0;
			}
		}
DEBUGLOG(("ProcessStmtFile() iSBlankLine = [%d]\n",iSBlankLine));
DEBUGLOG(("ProcessStmtFile() iEBlankLine = [%d]\n",iEBlankLine));
	}


/*
 * Support Multi format
 */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile() Start Checking Format...\n"));

		hFormat = RecordSet_GetFirst(rRecordFormat);
		while (hFormat) {
/* format_id */
			if (!GetField_CString(hFormat, "format_id", &csFormatId)) {
				iRet = INT_FORMAT_TEMPLATE_ERROR;
				PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("ProcessStmtFile() Format ID NOT FOUND!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() Format ID NOT FOUND!!!\n");
				break;
			} else {
/* delimiter */
				sprintf(csTag, "delimiter_%s", csFormatId);
				if (!GetField_CString(hFormat, csTag, &csTmp)) {
					iRet = INT_FORMAT_TEMPLATE_ERROR;
					PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("ProcessStmtFile() Delimiter NOT FOUND!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() Delimiter NOT FOUND!!!\n");
					break;
				} else {
					sprintf(csDelimiter,"%c",atoi(csTmp));
				}
			}
/* row_bank_acct */
			if (!GetField_CString(hFormat, "row_bank_acct", &csTmp)) {
				iBankAcctRow = 0;
			} else {
				iBankAcctRow = atoi(csTmp);
				if (iBankAcctRow > 0) {
					iBankAcctRow += iSBlankLine;
				}
			}
/* neg_amount */
			if (!GetField_CString(hFormat, "neg_amount", &csTmp)) {
				iNegAmount = 0;
			} else {
				iNegAmount = atoi(csTmp);
			}
/* neg_balance */
			if (!GetField_CString(hFormat, "neg_balance", &csTmp)) {
				iNegBalance = 0;
			} else {
				iNegBalance = atoi(csTmp);
			}
/* reverse */
			if (!GetField_CString(hFormat, "reverse", &csTmp)) {
				iReverse = 0;
			} else if (!strcmp(csTmp, "1")) {
				iReverse = 1;
			} else {
				iReverse = 0;
			}
/* row_start */
			if (!GetField_CString(hFormat, "row_start", &csTmp)) {
				iStartRow = 1;
			} else {
				iStartRow = atoi(csTmp) + iSBlankLine;
			}
/* row_end */
			if (!GetField_CString(hFormat, "row_end", &csTmp)) {
				iEndRow = 1;
			} else {
				iEndRow = atoi(csTmp) + iEBlankLine;
			}
/* start_year */
			if (!GetField_CString(hFormat, "start_year", &csTmp)) {
				iStartYear = 0;
			} else {
				iStartYear = atoi(csTmp);
			}
/* tol_datetime */
			if (!GetField_CString(hFormat, "tol_datetime", &csTmp)) {
				iTolDateTime = 2;
			} else {
				iTolDateTime = atoi(csTmp);
			}
/* total_field */
			if (!GetField_CString(hFormat, "total_field", &csTmp)) {
				iTotalField = 0;
			} else {
				iTotalField = atoi(csTmp);
			}

			iCurrLine = 0;
			iFieldCount = 0;
			iTotalLine = 0;
			rewind(fin);

		/* Count Total Field */
			while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
				iCurrLine++;
				if (iCurrLine == iStartRow) {
					if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0A) cs_input_buf[strlen(cs_input_buf)-1] = '\0';
					if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0D) cs_input_buf[strlen(cs_input_buf)-1] = '\0';
					strcpy(cs_tmp_input_buf,cs_input_buf);
					csTmp = mystrtok(cs_tmp_input_buf, csDelimiter);
					while (csTmp != NULL) {
						iFieldCount++;
						csTmp = mystrtok(NULL, csDelimiter);
					}
DEBUGLOG(("ProcessStmtFile() format_id[%s] delimiter[%s]\n",csFormatId,csDelimiter));
DEBUGLOG(("ProcessStmtFile() line %d count[%d]/total_field[%d] [%s]\n",iCurrLine,iFieldCount,iTotalField,cs_input_buf));
				/* Total Field Matched */
					if (iFieldCount == iTotalField) {
						iFormatMatched = 1;
						PutField_CString(hContext,"format_id",csFormatId);
DEBUGLOG(("ProcessStmtFile() picked format_id[%s]\n",csFormatId));
				/* Not Matched */
					} else {
						break;
					}
				}
				iTotalLine++;
			}

			if (iFormatMatched == 1) break;

			hFormat = RecordSet_GetNext(rRecordFormat);
		} // hFormat

		if (iRet == PD_OK) {
		/* SUCCEED */
			if (iFormatMatched == 1) {
DEBUGLOG(("ProcessStmtFile() Summary: Total Line = [%d]\n",iTotalLine));
				iTotalCount = iTotalLine - iStartRow - iEndRow + 2;
				if (iTotalCount < 0) iTotalCount = 0;
				PutField_Int(hContext, "neg_amount", iNegAmount);
				PutField_Int(hContext, "neg_balance", iNegBalance);
				PutField_Int(hContext, "reverse", iReverse);
				PutField_Int(hContext, "start_year", iStartYear);
				PutField_Int(hContext, "tol_datetime", iTolDateTime);
		/* FAIL */
			} else {
				iRet = INT_INVALID_FILE_FORMAT;
				PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("ProcessStmtFile() No format matches!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() No format matches!!!\n");
			}
		}
	}


/* DateTime */
	if (iRet == PD_OK) {
	/* System date time */
		time_t	tNow = time(NULL);
		struct	tm tStruct = *localtime(&tNow);

		strftime(csSysDate, sizeof(csSysDate), PD_DEFAULT_DATE_FORMAT, &tStruct);
		strftime(csSysTime, sizeof(csSysTime), PD_DEFAULT_TIME_FORMAT, &tStruct);
		strftime(csDateTime, sizeof(csDateTime), PD_DEFAULT_DATETIME_FORMAT, &tStruct);
DEBUGLOG(("ProcessStmtFile() System datetime = [%s %s]\n",csSysDate,csSysTime));

		if (GetField_CString(hContext,"TIMEZONE",&csTimeZone)) {
			csOutDateTime = ChangeTimeZone(csDateTime,PD_DEFAULT_DATETIME_FORMAT,PD_DESTZONE,csTimeZone); //

			strcpy(csSysTime,&csOutDateTime[PD_DATE_LEN]);
			csOutDateTime[PD_DATE_LEN]='\0';
			strcpy(csSysDate,csOutDateTime);
DEBUGLOG(("ProcessStmtFile() System Datetime = [%s %s] at %s %s\n",csSysDate,csSysTime,csCountry,csTimeZone));
		}

		PutField_CString(hContext, "SYS_DATE", csSysDate);
		PutField_CString(hContext, "SYS_TIME", csSysTime);

	/* Tolerance date time */
		tStruct.tm_hour += iTolDateTime;

		strftime(csSysDate, sizeof(csSysDate), PD_DEFAULT_DATE_FORMAT, &tStruct);
		strftime(csSysTime, sizeof(csSysTime), PD_DEFAULT_TIME_FORMAT, &tStruct);
		strftime(csDateTime, sizeof(csDateTime), PD_DEFAULT_DATETIME_FORMAT, &tStruct);
DEBUGLOG(("ProcessStmtFile() Tolerance datetime = [%s %s]\n",csSysDate,csSysTime));

		if (GetField_CString(hContext,"TIMEZONE",&csTimeZone)) {
			csOutDateTime = ChangeTimeZone(csDateTime,PD_DEFAULT_DATETIME_FORMAT,PD_DESTZONE,csTimeZone); //

			strcpy(csSysTime,&csOutDateTime[PD_DATE_LEN]);
			csOutDateTime[PD_DATE_LEN]='\0';
			strcpy(csSysDate,csOutDateTime);
DEBUGLOG(("ProcessStmtFile() Tolerance Datetime = [%s %s] at %s %s\n",csSysDate,csSysTime,csCountry,csTimeZone));
		}

		PutField_CString(hContext, "TOL_DATE", csSysDate);
		PutField_CString(hContext, "TOL_TIME", csSysTime);
	}



/*
 * Statement Detail Preparation
 */
	if (iRet == PD_OK) {
		iCurrLine = 0;
		rewind(fin);
		iMatchCount=0;

DEBUGLOG(("ProcessStmtFile() Start Reading File...\n"));
		while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
			iCurrLine++;

			if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0A) cs_input_buf[strlen(cs_input_buf)-1] = '\0';
			if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0D) cs_input_buf[strlen(cs_input_buf)-1] = '\0';

		/* leading and trailing rows */
			if (iCurrLine < iStartRow || iCurrLine > iTotalLine - iEndRow + 1) {
				iDetailRow = 0;
			} else {
				iDetailRow = 1;
			}
// DEBUGLOG(("ProcessStmtFile() iDetailRow = [%d]\n",iDetailRow));

		/* Check bank account number */
			if (iCurrLine <= iBankAcctRow) {
				strcpy(cs_tmp_input_buf,cs_input_buf);
				deleteCharacters(cs_tmp_input_buf,"-");
				csTmp = strstr(cs_tmp_input_buf, csBankAcctNum);
				if (csTmp == NULL) {
					if (iCurrLine == iBankAcctRow && iMatchCount != 1) { //
DEBUGLOG(("ProcessStmtFile() Bank Account Number NOT MATCH!!!\n"));
DEBUGLOG(("ProcessStmtFile() line %d Bank Account Number[%s] NOT MATCH [%s]\n",iCurrLine,csBankAcctNum,cs_input_buf));
						if (iValidateAcctNum == 0) {
DEBUGLOG(("ProcessStmtFile() ** No Bank Account Validation\n"));
						} else {
							iRet = INT_BANK_ACCT_NOT_MATCH;
							PutField_Int(hContext, "internal_error", iRet);
							break;
						}
					}
				} else {
					iMatchCount=1;
DEBUGLOG(("ProcessStmtFile() line %d Bank Account Number[%s] Matched [%s]\n",iCurrLine,csBankAcctNum,cs_input_buf));
				}
			} else if (iCurrLine == 1 && iBankAcctRow < 1) {
DEBUGLOG(("ProcessStmtFile() ** No Bank Account Validation for this bank\n"));
			}

			/*
			if (!strcmp(cs_input_buf,"")) {
				if (iDetailRow == 1) {
					iTotalCount--;
				}
				continue;
			}
			*/
			if (strlen_content(cs_input_buf) == 0) {
				if (iDetailRow == 1) {
					iTotalCount--;
DEBUGLOG(("ProcessStmtFile() line %d skipped  [%s]\n",iCurrLine,cs_input_buf));
				} else {
DEBUGLOG(("ProcessStmtFile() line %d ignore  [%s]\n",iCurrLine,cs_input_buf));
				}
				continue;
			}

		/* Process */
			hRec = (hash_t*) malloc (sizeof(hash_t));
			hash_init(hRec, 0);
			if (splitLineByhFormat(cs_input_buf, csFormatId, hFormat, hRec) != PD_OK) {
				iRet = INT_FORMAT_TEMPLATE_ERROR;
				PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("ProcessStmtFile() FORMAT ERROR!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() FORMAT ERROR!!!\n");
				break;
			}

		/* Check Field */
			PutField_Int(hRec, "detail_row", iDetailRow);
			//output log at leading and tailing rows
			if (iCurrLine == iStartRow || iCurrLine == iTotalLine - iEndRow + 1)
				PutField_Int(hRec, "sample_row", 1);
			else
				PutField_Int(hRec, "sample_row", 0);
			PutField_Int(hRec, "line", iCurrLine);

			iDtlRet = CheckDetail(hContext, hRec, cs_err_desc_buf);

		/* Check Length */
			if (iDtlRet == PD_OK) {
				char cs_tmp_buf[PD_TMP_BUF_LEN];
				strcpy(cs_err_desc_buf,"");
				iArraySize = (int)sizeof(csDetailTag) / (int)sizeof(*csDetailTag);

				for (iTmp=0;iTmp<iArraySize;iTmp++) {
					csTmp = NULL;
					if (GetField_CString(hRec,csDetailTag[iTmp],&csTmp)) {
						if (iDetailMaxLength[iTmp] != -1) {
							if (strlen(csTmp) > iDetailMaxLength[iTmp]) {
								snprintf(cs_tmp_buf,sizeof(cs_tmp_buf),"[%s Too Long]",csDetailTag[iTmp]);
								strncat(cs_err_desc_buf,cs_tmp_buf,sizeof(cs_err_desc_buf)-strlen(cs_err_desc_buf)-1);
								iDtlRet = PD_OTHER_ERR;
DEBUGLOG(("ProcessStmtFile() %s [%s] TOO LONG!!!\n",csDetailTag[iTmp],csTmp));
							} else {
// DEBUGLOG(("ProcessStmtFile() %s [%s] length okay\n",csDetailTag[iTmp],csTmp));
							}
						}
						if (iDetailMaxUTF8Length[iTmp] != -1) {
							if (strlen_utf8(csTmp) > iDetailMaxUTF8Length[iTmp]) {
								snprintf(cs_tmp_buf,sizeof(cs_tmp_buf),"[%s Too Long]",csDetailTag[iTmp]);
								strncat(cs_err_desc_buf,cs_tmp_buf,sizeof(cs_err_desc_buf)-strlen(cs_err_desc_buf)-1);
								iDtlRet = PD_OTHER_ERR;
DEBUGLOG(("ProcessStmtFile() %s UTF8[%s] TOO LONG!!!\n",csDetailTag[iTmp],csTmp));
							} else {
// DEBUGLOG(("ProcessStmtFile() %s UTF8[%s] length okay\n",csDetailTag[iTmp],csTmp));
							}
						}
					}
				}
			}

		/* Finish */
			if (iDtlRet != PD_OK) {
				if (iDetailRow == 1 || iDtlRet == PD_OTHER_ERR) { //
				/* FAIL */
					iRet = INT_DETAIL_FIELD_ERROR;
					PutField_Int(hContext, "internal_error", iRet);
					iErrorCount++;
					PutField_Int(hContext, "result_cnt", iErrorCount);
					sprintf(csTag, "desc_%d", iErrorCount);
					PutField_CString(hContext, csTag, cs_err_desc_buf);
					sprintf(csTag, "line_%d", iErrorCount);
					PutField_CString(hContext, csTag, cs_input_buf);
DEBUGLOG(("ProcessStmtFile() CheckDetail() FAILURE!!!\n"));
DEBUGLOG(("ProcessStmtFile() line %d FAIL [%s]\n",iCurrLine,cs_input_buf));
				} else {
				/* SUCCEED */
DEBUGLOG(("ProcessStmtFile() line %d ignore [%s]\n",iCurrLine,cs_input_buf));
				}

				hash_destroy(hRec);
				FREE_ME(hRec);
			} else {

				if (iDetailRow == 1) {
				/* SUCCEED */
					//output log at leading and tailing rows
					if (iCurrLine == iStartRow || iCurrLine == iTotalLine - iEndRow + 1) {
DEBUGLOG(("ProcessStmtFile() line %d success [%s]\n",iCurrLine,cs_input_buf));
					} else if (iCurrLine == iStartRow + 1 || iCurrLine == iTotalLine - iEndRow){
DEBUGLOG(("ProcessStmtFile() line %d success ...\n",iCurrLine,cs_input_buf));
					} else {
// DEBUGLOG(("ProcessStmtFile() line %d success [%s]\n",iCurrLine,cs_input_buf));
					}
				} else {
				/* SUCCEED */
					iTotalExtraCount++;
DEBUGLOG(("ProcessStmtFile() line %d success (Extra) [%s]\n",iCurrLine,cs_input_buf));
				}

				/* bank_charge */
				if (GetField_CString(hRec,"bank_charge",&csBankCharge)) {
					hRec2 = (hash_t*) malloc (sizeof(hash_t));
					hash_init(hRec2, 0);
					for (iTmp=0;iTmp<iArraySize;iTmp++) {
						csTmp = NULL;
						if (GetField_CString(hRec,csDetailTag[iTmp],&csTmp)) {
							PutField_CString(hRec2,csDetailTag[iTmp],csTmp);
						}
					}

					GetField_CString(hRec,"balance",&csBalance);
					sprintf(csTag,"%.2lf",atof(csBalance)+atof(csBankCharge));
					PutField_CString(hRec,"balance",csTag);

					PutField_CString(hRec2,"txn_amount",csBankCharge);
					PutField_CString(hRec2,"override_txn_code",PD_BANK_CHARGE_TXN_CODE);

					currentNode = (struct node*) malloc (sizeof(struct node));
					if (iReverse == 1) {
						currentNode->hDtl = hRec2;
					} else {
						currentNode->hDtl = hRec;
						hRec = hRec2;
					}
					if (head == NULL) {
						head = currentNode;
						head->next = NULL;
						tail = head;
					} else if (iReverse == 1) {
						currentNode->next = head;
						head = currentNode;
					} else {
						tail->next = currentNode;
						tail = currentNode;
						tail->next = NULL;
					}

					iTotalExtraCount++;
				}

				/* other */
				currentNode = (struct node*) malloc (sizeof(struct node));
				currentNode->hDtl = hRec;
				if (head == NULL) {
					head = currentNode;
					head->next = NULL;
					tail = head;
				} else if (iReverse == 1) {
					currentNode->next = head;
					head = currentNode;
				} else {
					tail->next = currentNode;
					tail = currentNode;
					tail->next = NULL;
				}

			}
		} // fgets()

	/* Sorting */
DEBUGLOG(("ProcessStmtFile() Sort\n"));
		int changed=1;
		top = (struct node*) malloc (sizeof(struct node));
		top->next = head;
		if (head != NULL && head->next != NULL) {
			while (changed) {
// DEBUGLOG(("ProcessStmtFile() while(changed)\n"));
				changed = 0;
				q = top;
				p = top->next;
				while( p->next != NULL ) {
// DEBUGLOG(("ProcessStmtFile() while(p)\n"));
					GetField_CString(p->hDtl,"statement_date",&csTmp);
					snprintf(csCurrNodeDateTime,sizeof(csCurrNodeDateTime),"%s",csTmp);
					GetField_CString(p->next->hDtl,"statement_date",&csTmp);
					snprintf(csNextNodeDateTime,sizeof(csNextNodeDateTime),"%s",csTmp);

					GetField_CString(p->hDtl,"statement_time",&csTmp);
					strncat(csCurrNodeDateTime,csTmp,sizeof(csCurrNodeDateTime)-strlen(csCurrNodeDateTime)-1);
					GetField_CString(p->next->hDtl,"statement_time",&csTmp);
					strncat(csNextNodeDateTime,csTmp,sizeof(csNextNodeDateTime)-strlen(csNextNodeDateTime)-1);

// DEBUGLOG(("ProcessStmtFile() curr[%s] next[%s]\n",csCurrNodeDateTime,csNextNodeDateTime));
					if (strcmp(csCurrNodeDateTime,csNextNodeDateTime) > 0) {
						q->next = list_switch( p, p->next );
						changed = 1;
DEBUGLOG(("ProcessStmtFile() curr[%s] next[%s] sorted\n",csCurrNodeDateTime,csNextNodeDateTime));
					}
					q = p;
					if( p->next != NULL )
						p = p->next;
					else
						tail = p;
				}
			}
		}
		head = top->next;
		FREE_ME(top);

	/* RecordSet */
		while (head != NULL) {
			hRec = head->hDtl;
			RecordSet_Add(myFile, hRec);
			/* delete */
			top = head;
			head = head->next;
			FREE_ME(top);
		}
DEBUGLOG(("ProcessStmtFile() Summary: [%d] records at Recordset\n",iTotalCount+iTotalExtraCount));
	}



/*
 * Keywords Search - STMT_TYPE
 */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile() Start Txn Code Keywords Matching...\n"));

		recordset_init(myRec, 0); // olsd_keywords_mapping
		recordset_init(myRecDb, 0); // Format Keywords

DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetTxnCodeKeywords() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtFormat", "GetTxnCodeKeywords");
		iDtlRet = (unsigned long)(*DBObjPtr)(csIntBankCode,csFormatId,csAcctType,csAcctCcy,myRecDb);
		if (iDtlRet == PD_FOUND) {
			hRecDb = RecordSet_GetFirst(myRecDb);
			while (hRecDb) {
			/* olsd_keywords_mapping */
				if (GetField_CString(hRecDb,"cont_desc",&csDesc)) {
					iMatchCount = 0;
					hRec = RecordSet_GetFirst(myRec);
					while(hRec) {
						GetField_CString(hRec,"cont_desc",&csTmp);
						if (!strcmp(csTmp,csDesc)) {
							iMatchCount = 1;
							break;
						}
						hRec = RecordSet_GetNext(myRec);
					}
					if (iMatchCount == 0) {
						hRec = (hash_t*) malloc (sizeof(hash_t));
						hash_init(hRec, 0);
						PutField_CString(hRec,"cont_desc",csDesc);
DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetTxnCodeKeywords() cont_desc [%s] added\n",csDesc));
						RecordSet_Add(myRec,hRec);
					}
				}
				hRecDb = RecordSet_GetNext(myRecDb);
			} // hRecDb

		} else {
			iRet = INT_FORMAT_KEYWORDS_ERROR;
			PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetTxnCodeKeywords() FAILURE!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() DBOLStmtFormat::GetTxnCodeKeywords() FAILURE!!!\n");
		}

		if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetTxnCodeKeywords() FOUND\n"));

			hFile = RecordSet_GetFirst(myFile); // File Records
			while (hFile) {
				iMatchCount = 0;
				iToMatchCount = 0;

				GetField_Int(hFile, "line", &iCurrLine);
				GetField_CString(hFile,"amt_type",&csAmtType);
				GetField_CString(hFile,"txn_amount",&csTxnAmt);
				dTxnAmt = atof(csTxnAmt);

				//override_txn_code
				if (GetField_CString(hFile,"override_txn_code",&csTxnCode)) {
					hRecDb = (hash_t*) malloc (sizeof(hash_t));
					hash_init(hRecDb,0);
					DBObjPtr = CreateObj(DBPtr, "DBOLBAIDTxnCode", "GetDetail");
					iDtlRet = (unsigned long)(*DBObjPtr)(csTxnCode,csAcctType,hRecDb);
					if (iDtlRet == PD_FOUND) {
						GetField_Int(hRecDb,"real_time_post",&iRealTimePost);
						//iRealTimePost = 1;
						
						PutField_CString(hFile,"format_txn_code",csTxnCode);

						if (iRealTimePost == 1) {
							PutField_Int(hFile,"to_post",1);
						}
DEBUGLOG(("ProcessStmtFile() line %d txn_code [%s]%s%s\n",iCurrLine,csTxnCode," override",(iRealTimePost?" post":"")));

						GetField_Int(hRecDb,"update_bal",&iUpdateBal);
						if (iUpdateBal == 1) {
							PutField_Int(hFile,"to_update_bal",1);
						}
					} else {
						iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile() DBOLBAIDTxnCode::GetDetail() FAILURE!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() DBOLBAIDTxnCode::GetDetail() FAILURE!!!\n");
					}
					hash_destroy(hRecDb);
					FREE_ME(hRecDb);

				//keywords txn_code
				} else {
					hRecDb = RecordSet_GetFirst(myRecDb); // Format Keywords
					while (hRecDb) {
						dMinAmt = -1.0;
						dMaxAmt = -1.0;
						iMinDp = -1;
						iMaxDp = -1;
						GetField_CString(hRecDb,"txn_code",&csTxnCode);
						GetField_CString(hRecDb,"amt_type",&csTmp);
						if (strcmp(csTmp,csAmtType)) {
							hRecDb = RecordSet_GetNext(myRecDb);
							continue;
						}
						GetField_Int(hRecDb,"full_match",&iFullMatch);
						GetField_Int(hRecDb,"hold_credit_side",&iHoldCreditSide);
						GetField_Int(hRecDb,"real_time_post",&iRealTimePost);
						//iRealTimePost = 1;
						GetField_Int(hRecDb,"update_bal",&iUpdateBal);
						GetField_Int(hRecDb,"default",&iDefault);
						GetField_Double(hRecDb,"min_amt",&dMinAmt);
						GetField_Double(hRecDb,"max_amt",&dMaxAmt);
						GetField_Int(hRecDb,"min_dp",&iMinDp);
						GetField_Int(hRecDb,"max_dp",&iMaxDp);
						GetField_Int(hRecDb,"display_order",&iDisplayOrder);

					/* Keywords Matching */
						if (iDefault == 1) {
							iMatchCount = 1;
							iToMatchCount = 1;
							iMatchNow = 1;
						} else {
							GetField_CString(hRecDb,"cont_desc",&csDesc);
							GetField_CString(hRecDb,"format_template",&csTemplate);
							if (GetField_CString(hFile,csDesc,&csField)) {
// DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetTxnCodeKeywords() (%s)[%s] / [%s]\n",csDesc,csField,csTemplate));
// DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetTxnCodeKeywords() %s / %.2lf %.2lf %d %d\n",csTxnAmt,dMinAmt,dMaxAmt,iMinDp,iMaxDp));
								if (MultiKeywordsSearch(csField,csTemplate,iFullMatch) == FOUND) {
									if (dMinAmt > -1.0 && dMinAmt > dTxnAmt + 1E-9) {
										hRecDb = RecordSet_GetNext(myRecDb);
										continue;
									}
									if (dMaxAmt > -1.0 && dMaxAmt < dTxnAmt - 1E-9) {
										hRecDb = RecordSet_GetNext(myRecDb);
										continue;
									}
									if (iMinDp > -1 && iMinDp > FindDecimalPlaces(csTxnAmt)) {
										hRecDb = RecordSet_GetNext(myRecDb);
										continue;
									}
									if (iMaxDp > -1 && iMaxDp < FindDecimalPlaces(csTxnAmt)) {
										hRecDb = RecordSet_GetNext(myRecDb);
										continue;
									}
									iMatchCount++;
								}
							}

							iToMatchCount++;

							hRecDb = RecordSet_GetNext(myRecDb);
							if (hRecDb != NULL) {
								GetField_CString(hRecDb,"txn_code",&csTmp);
								GetField_Int(hRecDb,"display_order",&iTmp);
								if (strcmp(csTmp,csTxnCode) || iTmp != iDisplayOrder) {
									iMatchNow = 1;
								} else {
									iMatchNow = 0;
								}
							} else {
								iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetTxnCodeKeywords() No Default Rules\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() DBOLStmtFormat:: GetTxnCodeKeywords() No Default Rules\n");
							}
						}
// DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetTxnCodeKeywords() iMatchNow[%d] iMatchCount[%d] iToMatchCount[%d]\n",iMatchNow,iMatchCount,iToMatchCount));

					/* Keywords Matched */
						if (iMatchCount == iToMatchCount && iMatchNow == 1) {
							PutField_CString(hFile,"format_txn_code",csTxnCode);

							if (iHoldCreditSide == 1) {
								PutField_CString(hFile,"to_hold",PD_CR);
							}
							if (iRealTimePost == 1) {
								PutField_Int(hFile,"to_post",1);
							}
							if (iUpdateBal == 1) {
								PutField_Int(hFile,"to_update_bal",1);
							}

DEBUGLOG(("ProcessStmtFile() line %d txn_code [%s]%s%s%s\n",iCurrLine,csTxnCode,(iDefault?" (default)":""),(iHoldCreditSide?" to_hold":""),(iRealTimePost?" post":"")));
							break;
						}

						//Reset Count
						if (iMatchNow == 1) {
							iMatchCount = 0;
							iToMatchCount = 0;
						}
					} // while (hRecDb)
				}

				if (!GetField_CString(hFile,"format_txn_code",&csTmp)) {
					iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile() line %d format_txn_code FAILURE!!!\n",iCurrLine));
ERRLOG("BOOLBankStmt::ProcessStmtFile() line %d format_txn_code FAILURE!!!\n",iCurrLine);
				}

			/* olsd_keywords_mapping */
				iRowCount=0;
				strcpy(csKeywordsMapping,"");
				hRec = RecordSet_GetFirst(myRec);
				while (hRec) {
					if (iRowCount > 0) {
						strncat(csKeywordsMapping,",",sizeof(csKeywordsMapping)-strlen(csKeywordsMapping)-1);
					}
					GetField_CString(hRec,"cont_desc",&csDesc);
					if (GetField_CString(hFile,csDesc,&csTmp)) {
						strncat(csKeywordsMapping,csTmp,sizeof(csKeywordsMapping)-strlen(csKeywordsMapping)-1);
					}
					hRec = RecordSet_GetNext(myRec);
					iRowCount++;
				}
				PutField_CString(hFile,"keywords_mapping",csKeywordsMapping);
// DEBUGLOG(("ProcessStmtFile() keywords_mapping = [%s]\n",csKeywordsMapping));

				hFile = RecordSet_GetNext(myFile);
			} // while (hFile)
		}

		RecordSet_Destroy(myRec);
		RecordSet_Destroy(myRecDb);
	}



/*
 * ResourceLock
 */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile() DBOLResourceLock::GetBankAcctForUpdate() called\n")); 
		DBObjPtr = CreateObj(DBPtr, "DBOLResourceLock", "GetBankAcctForUpdate");
		if ((unsigned long)(*DBObjPtr)(csIntBankCode,csBankAcctNum) == PD_OK) {
DEBUGLOG(("ProcessStmtFile() DBOLResourceLock::GetBankAcctForUpdate() SUCCESS\n")); 
		} else {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile() DBOLResourceLock::GetBankAcctForUpdate() FAILURE!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() DBOLResourceLock::GetBankAcctForUpdate() FAILURE!!!\n");
		}
	}



/*
 * Duplication and Running Balance Check
 */
	if (iRet == PD_OK) {
	/* Last Balance */
DEBUGLOG(("ProcessStmtFile() Start Duplication and Balance Check...\n"));

		recordset_init(myRec, 0); // File Records DeDup Key

DEBUGLOG(("ProcessStmtFile() DBOLStatement::GetLastBalance() called\n")); 
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetLastBalance");
		iDtlRet = (unsigned long)(*DBObjPtr)(hContext);
		if (iDtlRet == FOUND) {
			if (GetField_CString(hContext,"last_txn_id",&csTxnSeq)) {
DEBUGLOG(("ProcessStmtFile() DBOLStatement::GetLastBalance() last_txn_id [%s]\n",csTxnSeq));
			}
			if (GetField_Double(hContext,"last_balance",&dLastFileBal)) {
DEBUGLOG(("ProcessStmtFile() DBOLStatement::GetLastBalance() last_balance [%.2f] FOUND\n",dLastFileBal)); 
			}
			if (GetField_CString(hContext,"last_statement_date",&csPrevDate)) {
DEBUGLOG(("ProcessStmtFile() DBOLStatement::GetLastBalance() last_statement_date [%s]\n",csPrevDate));
			}
			if (GetField_CString(hContext,"last_statement_time",&csPrevTime)) {
DEBUGLOG(("ProcessStmtFile() DBOLStatement::GetLastBalance() last_statement_time [%s]\n",csPrevTime));
			}
			if (GetField_CString(hContext,"last_amt_type",&csTmp) &&
			    GetField_Double(hContext,"last_txn_amount",&dLastTxnAmt)) {
DEBUGLOG(("ProcessStmtFile() DBOLStatement::GetLastBalance() last_txn_amount [%s %.2lf]\n",csTmp,dLastTxnAmt));
				if (!strcmp(csTmp,PD_DR)) dLastTxnAmt *= -1.0;
			}
			if (GetField_CString(hContext,"2nd_last_amt_type",&csTmp) &&
			    GetField_Double(hContext,"2nd_last_txn_amount",&d2ndLastTxnAmt)) {
DEBUGLOG(("ProcessStmtFile() DBOLStatement::GetLastBalance() 2nd_last_txn_amount [%s %.2lf]\n",csTmp,d2ndLastTxnAmt));
				if (!strcmp(csTmp,PD_DR)) d2ndLastTxnAmt *= -1.0;
			}
			iRunningBal = 1;
		} else if (iDtlRet == NOT_FOUND) {
			iRunningBal = 0;
DEBUGLOG(("ProcessStmtFile() DBOLStatement::GetLastBalance() NOT FOUND\n")); 
		} else {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile() DBOLStatement::GetLastBalance() FAILURE!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() DBOLStatement::GetLastBalance() FAILURE!!!\n");
		}

	/* Process */
		if (iRet == PD_OK) {
			hFile = RecordSet_GetFirst(myFile); // File Records
			while (hFile) {
				if (GetField_Int(hFile, "new_stmt_time", &iTmp)) {
					iArraySize = (int)sizeof(csCompareKeyWithoutTime) / (int)sizeof(*csCompareKeyWithoutTime);
					GetCompareKey(hFile, csCompareKeyWithoutTime, iArraySize, csFileCompareKey);
				} else {
					iArraySize = (int)sizeof(csCompareKeyWithTime) / (int)sizeof(*csCompareKeyWithTime);
					GetCompareKey(hFile, csCompareKeyWithTime, iArraySize, csFileCompareKey);
				}

				GetField_Int(hFile,"line",&iCurrLine);

			/* DB deuplication */
				PutField_CString(hFile, "int_bank_code", csIntBankCode);
				PutField_CString(hFile, "bank_acct_num", csBankAcctNum);

				DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "CheckBankStmtRecord");
				iDtlRet = (unsigned long)(*DBObjPtr)(hFile);
				if (iDtlRet == FOUND) {
DEBUGLOG(("ProcessStmtFile() line %d DBOLStatement::CheckBankStmtRecord() file[%s] FOUND\n",iCurrLine,csFileCompareKey));
					PutField_CString(hFile, "as_ind", "skip");
					iSkipCount++;
				} else if (iDtlRet == NOT_FOUND) {
// DEBUGLOG(("ProcessStmtFile() line %d DBOLStatement::CheckBankStmtRecord() file[%s] NOT FOUND\n",iCurrLine,csFileCompareKey));
				} else {
					iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile() DBOLStatement::CheckBankStmtRecord() FAILURE!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() DBOLStatement::CheckBankStmtRecord() FAILURE!!!\n");
				}

			/* Self duplication */
				iRowCount = 0;
				if (!GetField_CString(hFile,"as_ind",&csTmp)) {
					hRec = RecordSet_GetFirst(myRec);
					while (hRec) {
						GetField_CString(hRec,"compare_key",&csPrevFileCompareKey);

						if (!strcmp(csFileCompareKey, csPrevFileCompareKey)) {
							PutField_CString(hFile, "as_ind", "skip");
							iSkipCount++;
DEBUGLOG(("ProcessStmtFile() line %d file[%s] prev_file[%s] FOUND\n",iCurrLine,csFileCompareKey,csPrevFileCompareKey));
							break;
						}
						hRec = RecordSet_GetNext(myRec);
						iRowCount++;
					}
					if (iRowCount > 0) {
// DEBUGLOG(("ProcessStmtFile() line %d file[%s] prev_file[%s] total[%d]\n",iCurrLine,csFileCompareKey,csPrevFileCompareKey,iRowCount));
					} // hRec
				}

				GetField_CString(hFile,"statement_date",&csDate);
				GetField_CString(hFile,"statement_time",&csTime);
				GetField_CString(hFile,"balance",&csTmp);
				dCurrFileBal = atof(csTmp);
				GetField_CString(hFile,"txn_amount",&csTmp);
				dTxnAmt = atof(csTmp);
				GetField_CString(hFile,"amt_type",&csAmtType);
				if (!strcmp(csAmtType, PD_DR)) dTxnAmt *= -1.0;

			/* Credit Debit Credit with Debit Keywords Match */
				if (GetField_CString(hFile,"as_ind",&csTmp)) {
					if (dTxnAmt == -1.0*dLastTxnAmt &&
					    dTxnAmt == d2ndLastTxnAmt) {
DEBUGLOG(("ProcessStmtFile() line %d [%.2lf] [%.2lf] [%.2lf] Match\n",iCurrLine,d2ndLastTxnAmt,dLastTxnAmt,dTxnAmt));
						/* VOD */
						csTxnCode = NULL;
						if (hPrevFile == NULL) {
DEBUGLOG(("ProcessStmtFile() DBOLBAIDTxn::GetBaidTxn() called\n"));
							hPrevFile = (hash_t*) malloc (sizeof(hash_t));
							hash_init(hPrevFile,0);
							DBObjPtr = CreateObj(DBPtr, "DBOLBAIDTxn", "GetBaidTxn");
							if ((unsigned long)(*DBObjPtr)(csTxnSeq,hPrevFile) == PD_OK) {
								GetField_CString(hPrevFile,"txn_code",&csTxnCode);
							} else {
								iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile() DBOLBAIDTxn::GetBaidTxn() NOT FOUND!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() DBOLBAIDTxn::GetBaidTxn() NOT FOUND!!!\n");
							}
							hash_destroy(hPrevFile);
							FREE_ME(hPrevFile);
						} else {
							GetField_CString(hPrevFile,"format_txn_code",&csTxnCode);
						}
						if (!strcmp(csTxnCode,PD_BANK_RETURN_DEPOSIT_TXN_CODE)) {
							RemoveField_CString(hFile,"as_ind");
							iSkipCount--;
DEBUGLOG(("ProcessStmtFile() line %d Prev txn_code [%s] -> accept\n",iCurrLine,csTxnCode));
						} else {
DEBUGLOG(("ProcessStmtFile() line %d Prev txn_code [%s] -> skip\n",iCurrLine,csTxnCode));
						}
					} else {
 DEBUGLOG(("ProcessStmtFile() line %d [%.2lf] [%.2lf] [%.2lf] not Match -> skip\n",iCurrLine,d2ndLastTxnAmt,dLastTxnAmt,dTxnAmt));
					}
				}

			/* File Balance */
				if (!GetField_CString(hFile,"as_ind",&csTmp) && iRecordCount > 0) {

					if (fabs(dOpenFileBal + dTxnAmt - dCurrFileBal) > 1E-9) {
DEBUGLOG(("ProcessStmtFile() File Balance Error!!!\n"));
DEBUGLOG(("ProcessStmtFile() line %d File[%.2lf] + [%.2lf] != [%.2lf]\n",iCurrLine,dOpenFileBal,dTxnAmt,dCurrFileBal));
						sprintf(cs_err_desc_buf,"[Last File Balance:%.2f]", dOpenFileBal);
						iRet = INT_RUNNING_BALANCE_ERROR;
						PutField_Int(hContext, "internal_error", iRet);
						break;
					} else {
DEBUGLOG(("ProcessStmtFile() line %d File[%.2lf] + [%.2lf]=[%.2lf]\n",iCurrLine,dOpenFileBal,dTxnAmt,dCurrFileBal));
					}

				}

			/* Running Balance */
				if (!GetField_CString(hFile,"as_ind",&csTmp) && iRecordCount <= 0) {
					if (iRunningBal == 1) {
					/* Balance */
						if (fabs(dLastFileBal + dTxnAmt - dCurrFileBal) > 1E-9) {
DEBUGLOG(("ProcessStmtFile() Running Balance Error!!!\n"));
DEBUGLOG(("ProcessStmtFile() line %d Running Balance:[%.2f] Curr Txn Amount:[%.2f] Curr Balance:[%.2f]\n",iCurrLine,dLastFileBal,dTxnAmt,dCurrFileBal));
							if (iValidateRunningBal == 0) {
DEBUGLOG(("ProcessStmtFile() ** No Running Balance Validation\n"));
							} else {
								sprintf(cs_err_desc_buf,"[Last Running Balance:%.2f]", dLastFileBal);
								iRet = INT_RUNNING_BALANCE_ERROR;
								PutField_Int(hContext, "internal_error", iRet);
								break;
							}
						} else {
DEBUGLOG(("ProcessStmtFile() line %d Running[%.2lf] + [%.2lf]=[%.2lf]\n",iCurrLine,dLastFileBal,dTxnAmt,dCurrFileBal));
						}

					/* Date Time */
						if ((strcmp(csDate,csPrevDate) == 0 && strcmp(csTime,csPrevTime) < 0) ||
						     strcmp(csDate,csPrevDate) < 0) {
DEBUGLOG(("ProcessStmtFile() Running Date Time Error!!!\n"));
DEBUGLOG(("ProcessStmtFile() line %d Running Date Time [%s][%s] Curr Date Time [%s][%s]\n",iCurrLine,csPrevDate,csPrevTime,csDate,csTime));
							if (iValidateRunningBal == 0) {
DEBUGLOG(("ProcessStmtFile() ** No Running Balance Validation\n"));
							} else {
								sprintf(cs_err_desc_buf,"[Last Running Date Time:%s %s]",csPrevDate,csPrevTime);
								iRet = INT_RUNNING_BALANCE_ERROR;
								PutField_Int(hContext, "internal_error", iRet);
								break;
							}
						} else {
DEBUGLOG(("ProcessStmtFile() line %d Running Date curr[%s] >= last[%s]\n",iCurrLine,csDate,csPrevDate));
						}
					}

					iRecordCount++;
				}


				if (!GetField_CString(hFile, "as_ind", &csTmp)) {
					dOpenFileBal = dCurrFileBal;
					PutField_CString(hFile, "as_ind", "accept");

					/* Credit Debit Credit Exceptional */
					d2ndLastTxnAmt = dLastTxnAmt;
					dLastTxnAmt = dTxnAmt;

					hPrevFile = hFile;

					/* Self duplication */
					hRec = (hash_t*) malloc (sizeof(hash_t));
					hash_init(hRec, 0);
					PutField_CString(hRec,"compare_key",csFileCompareKey);
					RecordSet_Add(myRec, hRec);
				}
				hFile = RecordSet_GetNext(myFile);
			} // hFile

		/* FAIL */
			if (iRet != PD_OK) {
				PutField_Int(hContext, "result_cnt", 1);
				PutField_CString(hContext, "desc_1", cs_err_desc_buf);

				sprintf(csCmd,"sed -n '%dp' %s",iCurrLine,csConvertedFullName);
				stream = popen(csCmd, "r");
				if (fgets(cs_input_buf, sizeof(cs_input_buf), stream) != NULL) {
					if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0A) cs_input_buf[strlen(cs_input_buf)-1] = '\0';
					if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0D) cs_input_buf[strlen(cs_input_buf)-1] = '\0';
					PutField_CString(hContext, "line_1", cs_input_buf);
DEBUGLOG(("ProcessStmtFile() line %d FAIL [%s]\n",iCurrLine,cs_input_buf));
				}
				pclose(stream);
			}
		}

		hRec = RecordSet_GetFirst(myRec);
		while(hRec != NULL) {
			hash_destroy(hRec);
			FREE_ME(hRec);
			hRec = RecordSet_GetNext(myRec);
		}
		recordset_destroy(myRec);
DEBUGLOG(("ProcessStmtFile() Summary: [%d] records skipped\n",iSkipCount));
	}



/*
 * Keywords Search - RESTRICT
 */
	if (iRet == PD_OK) {
		recordset_init(myRecDb, 0);

		if (iRestricted == 1) {
DEBUGLOG(("ProcessStmtFile() Restricted Merchant\n"));

DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetRestrictKeywords() called\n"));
			DBObjPtr = CreateObj(DBPtr, "DBOLStmtFormat", "GetRestrictKeywords");
			iDtlRet = (unsigned long)(*DBObjPtr)(csIntBankCode,csFormatId,myRecDb);
			if (iDtlRet == PD_FOUND) {
DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetRestrictKeywords() FOUND\n"));
			} else if (iDtlRet == PD_NOT_FOUND) {
DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetRestrictKeywords() NOT FOUND!!!\n"));
			} else {
				iRet = INT_FORMAT_KEYWORDS_ERROR;
				PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetRestrictKeywords() FAILURE!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() DBOLStmtFormat::GetRestrictKeywords() FAILURE!!!\n");
			}
		} else {
			iDtlRet = PD_NOT_FOUND;
DEBUGLOG(("ProcessStmtFile() Non-Restricted Merchant\n"));
		}

		if (iRet == PD_OK && iDtlRet == PD_FOUND) {
DEBUGLOG(("ProcessStmtFile() Start Restrict Keywords Matching...\n"));
			char *csDesc, *csTemplate, *csField;

			hFile = RecordSet_GetFirst(myFile);
			while (hFile) {
				GetField_Int(hFile, "line", &iCurrLine);

				GetField_CString(hFile, "as_ind", &csTmp);
				if (!strcmp(csTmp, "accept")) {
					iMatchCount=0;
					iNotMatchCount=0;

					hRecDb = RecordSet_GetFirst(myRecDb);
					while (hRecDb) {
						GetField_CString(hRecDb,"cont_desc",&csDesc);
						GetField_CString(hRecDb,"format_template",&csTemplate);

						if (GetField_CString(hFile,csDesc,&csField)) {
							if (MultiKeywordsSearch(csField,csTemplate,1) != FOUND) {
								iNotMatchCount++;
							}
						} else {
							iNotMatchCount++;
						}
						hRecDb = RecordSet_GetNext(myRecDb);
					}

					if (iNotMatchCount > 0) PutField_Int(hFile, "sys_match_ind", 0);
					else  PutField_Int(hFile, "sys_match_ind", 1);
// DEBUGLOG(("ProcessStmtFile() DBOLStmtFormat::GetRestrictKeywords() line %d [%d][%d]\n",iCurrLine,iMatchCount,iNotMatchCount));
				}
				hFile = RecordSet_GetNext(myFile);
			}
		}

		RecordSet_Destroy(myRecDb);
	}


/*
 * Match
 */
	if (iRet == PD_OK) {
		char *csValueTmp = (char*) malloc (128);	
DEBUGLOG(("ProcessStmtFile() DBSystemParameter::FindCode() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBSystemParameter", "FindCode");
		if ((unsigned long)(*DBObjPtr)("OFL_SMS_MATCH_THRESHOLD", csValueTmp) != FOUND) {
			PutField_Int(hContext,"sms_match_threshold",720);
DEBUGLOG(("ProcessStmtFile() OFL_SMS_MATCH_THRESHOLD = [%d] (default)\n",720));
		} else {
			PutField_Int(hContext,"sms_match_threshold",atoi(csValueTmp));
DEBUGLOG(("ProcessStmtFile() OFL_SMS_MATCH_THRESHOLD = [%d]\n",atoi(csValueTmp)));
		}
		FREE_ME(csValueTmp);
	}
	if (iRet == PD_OK) {
		if (iValidateIntoTable == 1) {
DEBUGLOG(("ProcessStmtFile() Start Creating Transaction...\n"));
			iSkipCount=0;
			hFile = RecordSet_GetFirst(myFile);
			while (hFile) {
				GetField_Int(hFile, "line", &iCurrLine);

				GetField_CString(hFile, "as_ind", &csTmp);
				if (!strcmp(csTmp, "accept")) {
					PutField_CString(hFile, "file_id", csFileId);
					PutField_Int(hFile, "statement_seq",(iAcceptCount+1));
					PutField_CString(hFile, "baid", csBAID);
					PutField_CString(hFile, "input_channel", PD_BANK_STATEMENT);
					PutField_CString(hFile, "create_user", csUser);
					PutField_CString(hFile, "update_user", csUser);

					BOObjPtr = CreateObj(BOPtr, "BOOLBankStmtMatch", "MatchStmtWithSms");
					if ((unsigned long)(*BOObjPtr)(hContext,hRequest,hFile) != PD_OK) {
						iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile() line %d BOOLBankStmtMatch::MatchStmtWithSms() FAILURE!!!\n",iCurrLine)); 
ERRLOG("BOOLBankStmt::ProcessStmtFile() line %d BOOLBankStmtMatch::MatchStmtWithSms() FAILURE!!!\n",iCurrLine); 
						break;
					} else {
						iAcceptCount++;
						if (GetField_Int(hFile,"sms",&iTmp)) {
							iSmsCount++;
						}
						if (GetField_Int(hFile,"hold",&iTmp)) {
							iHoldCount++;
						}
						if (GetField_Int(hFile,"post",&iTmp)) {
							iPostCount++;
						}
// DEBUGLOG(("ProcessStmtFile() line %d BOOLBankStmtMatch::MatchStmtWithSms() success\n",iCurrLine)); 
					}
				} else {
					iSkipCount++;
				}
				hFile = RecordSet_GetNext(myFile);
			}
DEBUGLOG(("ProcessStmtFile() Summary: [%d] Records Post, [%d] Sms, [%d] Hold\n",iPostCount,iSmsCount,iHoldCount));
		} else {
DEBUGLOG(("ProcessStmtFile() ** call BOOLBankStmtMatch::MatchStmtWithSms() Skipped\n"));
		}
	}

	if(fin) {
		fclose(fin);
		fin = NULL;
	}

	PutField_Int(hContext,"skip_count",iSkipCount);
	PutField_Int(hContext,"sms_count",iSmsCount);
	PutField_Int(hContext,"hold_count",iHoldCount);
	PutField_Int(hContext,"accept_count",iAcceptCount);
	PutField_Int(hContext,"total_count",(iTotalCount+iTotalExtraCount));
DEBUGLOG(("ProcessStmtFile() Result: Accept[%d](Sms[%d])(Hold[%d])/Skip[%d]/Total[%d+%d]\n",iAcceptCount,iSmsCount,iHoldCount,iSkipCount,iTotalCount,iTotalExtraCount));

	FREE_ME(csTag);
	FREE_ME(csCmd);

	hFile = RecordSet_GetFirst(myFile);
	while(hFile != NULL) {
		hash_destroy(hFile);
		FREE_ME(hFile);
		hFile = RecordSet_GetNext(myFile);
	}
	recordset_destroy(myFile);
	FREE_ME(myFile);
	FREE_ME(myRec);
	FREE_ME(myRecDb);

DEBUGLOG(("ProcessStmtFile() iRet = [%d]\n", iRet));
	return iRet;
}


int splitLineByhFormat(const char *csLine, const char *csFormatId, const hash_t *hFormat, hash_t *hRec)
{
	int iRet = PD_OK;
	char *csTag = (char*) malloc (64);
	char csDelimiter[2], *csDesc = NULL, *csTemplate = NULL;
	int iNextLevel = 0;
	char *csTmp;

	char *csLineField, *csRemainField;
	char csNewField[PD_TMP_MSG_BUF_LEN], csNewLine[PD_TMP_MSG_BUF_LEN];
	char csConcatField[PD_TMP_MSG_BUF_LEN];
	int iFieldCount = 1;

/* delimiter */
	sprintf(csTag, "delimiter_%s", csFormatId);
	if (!GetField_CString(hFormat, csTag, &csTmp)) {
		iRet = INT_FORMAT_TEMPLATE_ERROR;
DEBUGLOG(("ProcessStmtFile() [%s] NOT FOUND!!!\n", csTag));
ERRLOG("BOOLBankStmt::ProcessStmtFile() [%s] NOT FOUND!!!\n", csTag);
	} else {
		sprintf(csDelimiter,"%c",atoi(csTmp));
	}

	strcpy(csNewLine, csLine);

	csLineField = mystrtok_r(csNewLine, csDelimiter, &csRemainField);
	while (csLineField != NULL && iRet == PD_OK) {
		strcpy(csNewField, TrimAll((const unsigned char*)csLineField, strlen(csLineField)));

		csDesc = NULL;
		csTemplate = NULL;
		iNextLevel = 0;

/* desc - CONTENT */
		sprintf(csTag, "content_desc_%s_%d", csFormatId, iFieldCount);
		if (GetField_CString(hFormat, csTag, &csDesc) && strcmp(csNewField,"")) {
			if (GetField_CString(hRec, csDesc, &csTmp)) {
				if (csTmp[0] != '\0') {
					sprintf(csConcatField,"%s %s",csTmp,csNewField);
					strcpy(csNewField,csConcatField);
				}
			}
			PutField_CString(hRec, csDesc, csNewField);
// DEBUGLOG((" %s (%s)[%s]\n", csTag, csDesc, csNewField));
		}

/* desc_2 - CONTENT */
		sprintf(csTag, "content_desc_2_%s_%d", csFormatId, iFieldCount);
		if (GetField_CString(hFormat, csTag, &csDesc) && strcmp(csNewField,"")) {
			if (GetField_CString(hRec, csDesc, &csTmp)) {
				if (csTmp[0] != '\0') {
					sprintf(csConcatField,"%s %s",csTmp,csNewField);
					strcpy(csNewField,csConcatField);
				}
			}
			PutField_CString(hRec, csDesc, csNewField);
// DEBUGLOG((" %s (%s)[%s]\n", csTag, csDesc, csNewField));
		}


/* template - CONTENT */
		sprintf(csTag, "content_temp_%s_%d", csFormatId, iFieldCount);
		if (GetField_CString(hFormat, csTag, &csTemplate)) {
// DEBUGLOG((" %s [%s]\n", csTag, csTemplate));


/* nextlevel - CONTENT */
			sprintf(csTag, "content_nxlv_%s_%d", csFormatId, iFieldCount);
			if (GetField_Int(hFormat, csTag, &iNextLevel)) {
				if (strlen(csFormatId)>=strlen(csTemplate)) {
					iRet = INT_FORMAT_TEMPLATE_ERROR;
DEBUGLOG(("ProcessStmtFile() Next level [%s] Error!!!\n",csTemplate));
ERRLOG("BOOLBankStmt::ProcessStmtFile() Next level [%s] Error!!!\n",csTemplate);
				} else {
					iRet = splitLineByhFormat(csNewField, csTemplate, hFormat, hRec);
				}
			} else if (csDesc != NULL) {
				sprintf(csTag, "%s_t", csDesc);
				PutField_CString(hRec, csTag, csTemplate);
			}
		}

		iFieldCount++;
		csLineField = mystrtok_r(NULL, csDelimiter, &csRemainField);
	}

	free(csTag);

	return iRet;
}

int CheckDetail(const hash_t* hContext, hash_t *hRls, char* cs_err_msg_buf)
{
	int	iRet = PD_OK;
	int	iDetailRow=0, iSampleRow=0, iCurrLine=0;
	int	iStartYear, iReverse, iNegAmount, iNegBalance, iTolDateTime;
	int	iTmp;
	char	*csTmp=NULL;
	char	*csPhDate=NULL, *csCountry=NULL, *csAcctCcy=NULL, *csTimeZone=NULL;
	char	*csSysDate=NULL, *csSysTime=NULL;
	char	*csTolDate=NULL, *csTolTime=NULL;

	char	*csStmtDate=NULL, *csStmtTime=NULL;
	char	*csOutStmtDate=NULL, *csOutStmtTime=NULL;
	char	csDateTemplate[PD_CONT_TEMPLATE_LEN+1], csTimeTemplate[PD_CONT_TEMPLATE_LEN+1];
	char	csStmtDateTime[PD_DATETIME_LEN + 1], *csOutStmtDateTime=NULL;

	char	cs_tmp_buf1[PD_TMP_BUF_LEN];
	char	cs_tmp_buf2[PD_TMP_BUF_LEN];

	strcpy(cs_tmp_buf2,"");

/* iDetailRow */
	if (!GetField_Int(hRls,"detail_row",&iDetailRow)){
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       detail_row NOT FOUND!!!\n"));
	}

/* iSampleRow */
	if (!GetField_Int(hRls,"sample_row",&iSampleRow)){
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       sample_row NOT FOUND!!!\n"));
	}

/* line */
	if (!GetField_Int(hRls,"line",&iCurrLine)){
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       line NOT FOUND!!!\n"));
	}

/* PHDATE */
	if (!GetField_CString(hContext,"PHDATE",&csPhDate)){
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       PHDATE NOT FOUND!!!\n"));
	}

/* country */
	if (!GetField_CString(hContext, "country", &csCountry)) {
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       country NOT FOUND!!!\n"));
	}

/* acct_ccy */
	if (!GetField_CString(hContext,"acct_ccy",&csAcctCcy)){
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       acct_ccy NOT FOUND!!!\n"));
	}

/* neg_amount */
	if(!GetField_Int(hContext, "neg_amount", &iNegAmount)) {
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       neg_amount NOT FOUND!!!\n"));
	}
/* neg_balance */
	if(!GetField_Int(hContext, "neg_balance", &iNegBalance)) {
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       neg_balance NOT FOUND!!!\n"));
	}
/* reverse */
	if(!GetField_Int(hContext, "reverse", &iReverse)) {
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       reverse NOT FOUND!!!\n"));
	}
/* start_year */
	if(!GetField_Int(hContext, "start_year", &iStartYear)) {
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       start_year NOT FOUND!!!\n"));
	}
/* tol_datetime */
	if(!GetField_Int(hContext, "tol_datetime", &iTolDateTime)) {
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       tol_datetime NOT FOUND!!!\n"));
	}

/* TIMEZONE */
	if (!GetField_CString(hContext,"TIMEZONE",&csTimeZone)){
	}

/* SYS_DATE */
	if (!GetField_CString(hContext,"SYS_DATE",&csSysDate)){
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       SYS_DATE NOT FOUND!!!\n"));
	}

/* SYS_TIME */
	if (!GetField_CString(hContext,"SYS_TIME",&csSysTime)){
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       SYS_TIME NOT FOUND!!!\n"));
	}

/* TOL_DATE */
	if (!GetField_CString(hContext,"TOL_DATE",&csTolDate)){
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       TOL_DATE NOT FOUND!!!\n"));
	}

/* TOL_TIME */
	if (!GetField_CString(hContext,"TOL_TIME",&csTolTime)){
		iRet = PD_ERR;
DEBUGLOG(("ProcessStmtFile()       TOL_TIME NOT FOUND!!!\n"));
	}

/* txn_ccy */
	if(GetField_CString(hRls,"txn_ccy",&csTmp)) {
		if (csAcctCcy != NULL && strcmp(csAcctCcy,csTmp)) {
			iRet = PD_ERR;
			snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Invalid Currency]");
			strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       txn_ccy Invalid [%s]\n",csTmp));
		}
	} else {
		PutField_CString(hRls,"txn_ccy",csAcctCcy);
	}

/* balance */
	if (GetField_CString(hRls,"balance",&csTmp)) {
		deleteCharacters(csTmp,",");
		if (isdigit(csTmp[0]) && atof(csTmp) > -1E-9) {
			sprintf(cs_tmp_buf1,"%.2lf",atof(csTmp));
			PutField_CString(hRls,"balance",cs_tmp_buf1);
		} else {
			if (atof(csTmp) < -1E-9 && iNegBalance == 1) {
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       ** allow balance [%s]\n",csTmp));
				sprintf(cs_tmp_buf1,"%.2lf",atof(csTmp));
				PutField_CString(hRls,"balance",cs_tmp_buf1);
			} else {
				iRet = PD_ERR;
				snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Invalid Balance]");
				strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       balance Invalid [%s]\n",csTmp));
			}
		}
	} else {
		iRet = PD_ERR;
		snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Balance Not Found]");
		strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       balance NOT FOUND!!!\n"));
	}

/* txn_amount */
	if (GetField_CString(hRls,"cr_txn_amount",&csTmp)) {
		deleteCharacters(csTmp,",");
		if (atof(csTmp) > 1E-9) {
			PutField_CString(hRls,"amt_type",PD_CR);
			PutField_CString(hRls,"txn_amount",csTmp);
		} else if (atof(csTmp) < -1E-9 && iNegAmount == 1) {
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       ** mv to other side [%s %s]\n",PD_CR,csTmp));
			PutField_CString(hRls,"amt_type",PD_DR);
			PutField_CString(hRls,"txn_amount",++csTmp);
		}
	}
	if (GetField_CString(hRls,"dr_txn_amount",&csTmp)) {
		deleteCharacters(csTmp,",");
		if (atof(csTmp) > 1E-9) {
			PutField_CString(hRls,"amt_type",PD_DR);
			PutField_CString(hRls,"txn_amount",csTmp);
		} else if (atof(csTmp) < -1E-9 && iNegAmount == 1) {
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       ** mv to other side [%s %s]\n",PD_DR,csTmp));
			PutField_CString(hRls,"amt_type",PD_CR);
			PutField_CString(hRls,"txn_amount",++csTmp);
		}
	}
	if (GetField_CString(hRls,"signed_txn_amount",&csTmp)) {
		deleteCharacters(csTmp,",");
		if (atof(csTmp) > 1E-9) {
			PutField_CString(hRls,"amt_type",PD_CR);
			PutField_CString(hRls,"txn_amount",csTmp);
		} else if (atof(csTmp) < -1E-9) {
			PutField_CString(hRls,"amt_type",PD_DR);
			PutField_CString(hRls,"txn_amount",++csTmp);
		}
	}

	if (GetField_CString(hRls,"txn_amount",&csTmp)) {
		deleteCharacters(csTmp,",");

		if (atof(csTmp) > 1E-9) {
			sprintf(cs_tmp_buf1,"%.2lf",atof(csTmp));
			PutField_CString(hRls,"txn_amount",cs_tmp_buf1);
		} else {
			iRet = PD_ERR;
			snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Invalid Txn Amount]");
			strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       txn_amount Invalid [%s]\n",csTmp));
		}
/* amt_type */
		if (GetField_CString(hRls,"amt_type",&csTmp)) {
			if (strcmp(PD_CR,csTmp) && strcmp(PD_DR,csTmp)) {
				iRet = PD_ERR;
				snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Invalid Amount Type]");
				strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       amt_type Invalid [%s]\n",csTmp));
			}
		} else {
			iRet = PD_ERR;
			snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Amount Type Not Found]");
			strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       amt_type NOT FOUND!!!\n"));
		}
	} else {
		iRet = PD_ERR;
		if (GetField_CString(hRls,"cr_txn_amount",&csTmp)) {
			snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Invalid Txn Amount]");
			strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
		} else if (GetField_CString(hRls,"dr_txn_amount",&csTmp)) {
			snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Invalid Txn Amount]");
			strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
		} else {
			snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Txn Amount Not Found]");
			strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
		}
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       txn_amount NOT FOUND!!!\n"));
	}

/* bank_charge */
	if (GetField_CString(hRls,"bank_charge",&csTmp)) {
		deleteCharacters(csTmp,",");

		if (atof(csTmp) > 1E-9) {
			sprintf(cs_tmp_buf1,"%.2lf",atof(csTmp));
			PutField_CString(hRls,"bank_charge",cs_tmp_buf1);
		} else if (atof(csTmp) < -1E-9) {
			iRet = PD_ERR;
			snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Invalid Bank Charge]");
			strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       bank_charge Invalid [%s]\n",csTmp));
		} else {
			RemoveField_CString(hRls,"bank_charge");
		}
	}

/* statement_date */
	if(GetField_CString(hRls,"statement_date",&csStmtDate) || GetField_CString(hRls,"statement_datetime",&csStmtDate)) {
		if(GetField_CString(hRls,"statement_date_t",&csTmp) || GetField_CString(hRls,"statement_datetime_t",&csTmp)) {
			strcpy(csDateTemplate,csTmp);
		}

		csOutStmtDate = ChangeDateTimeFormat(csStmtDate,0,csDateTemplate,csDateTemplate); //
		if (strcmp(csOutStmtDate,csStmtDate)) {
			snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Invalid Date]");
			strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
			iRet = PD_ERR;
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       Date Format Invalid [%s] in[%s][%s]!!!\n",csOutStmtDate,csStmtDate,csDateTemplate));
		} else {
			if (strcmp(csDateTemplate,PD_DEFAULT_DATE_FORMAT)) {
				csOutStmtDate = ChangeDateTimeFormat(csStmtDate,iStartYear,csDateTemplate,PD_DEFAULT_DATE_FORMAT); //
				PutField_CString(hRls,"statement_date",csOutStmtDate);
			}
if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       Date [%s] in[%s][%s]\n",csOutStmtDate,csStmtDate,csDateTemplate));
		}

	} else {
		snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Date Not Found]");
		strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
		iRet = PD_ERR;
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       statement_date NOT FOUND!!!\n"));
	}

/* statement_time */
	if (iRet == PD_OK) {
		if(GetField_CString(hRls,"statement_time",&csStmtTime) || GetField_CString(hRls,"statement_datetime",&csStmtTime)) {
			if(GetField_CString(hRls,"statement_time_t",&csTmp) || GetField_CString(hRls,"statement_datetime_t",&csTmp)) {
				strcpy(csTimeTemplate,csTmp);
			}

			csOutStmtTime = ChangeDateTimeFormat(csStmtTime,0,csTimeTemplate,csTimeTemplate); //
			if (strcmp(csOutStmtTime,csStmtTime)) {
				snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Invalid Time]");
				strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
				iRet = PD_OTHER_ERR;
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       Time Format Invalid [%s] in[%s][%s]!!!\n",csOutStmtTime,csStmtTime,csTimeTemplate));
			} else {
				if (strcmp(csTimeTemplate,PD_DEFAULT_TIME_FORMAT)) {
					csOutStmtTime = ChangeDateTimeFormat(csStmtTime,0,csTimeTemplate,PD_DEFAULT_TIME_FORMAT); //
					PutField_CString(hRls,"statement_time",csOutStmtTime);
				}
if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       Time  [%s]  in[%s][%s]\n",csOutStmtTime,csStmtTime,csTimeTemplate));
			}

		} else if (GetField_CString(hRls,"statement_time_t",&csTmp) || GetField_CString(hRls,"statement_datetime_t",&csTmp)) {
			snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Time Not Found]");
			strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
			iRet = PD_OTHER_ERR;
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       statement_time NOT FOUND!!!\n"));
		}
	}

/* Default Time */
	if (iRet == PD_OK) {
		if (!GetField_CString(hRls,"statement_time",&csStmtTime)) {
			PutField_Int(hRls,"new_stmt_time",1);
			if (GetField_CString(hRls,"statement_date",&csStmtDate)) {
				if (strcmp(csSysDate,csStmtDate) > 0) {
					PutField_CString(hRls,"statement_time","235959");
 if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       Time  [%s]  in[%s]<sys_date[%s]\n","235959",csStmtDate,csSysDate));
				} else if (strcmp(csSysDate,csStmtDate) < 0) {
					PutField_CString(hRls,"statement_time","000000");
 if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       Time  [%s]  in[%s]>sys_date[%s]\n","000000",csStmtDate,csSysDate));
				} else {
					PutField_CString(hRls,"statement_time",csSysTime);
 if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       Time  [%s]  in[%s]=sys_date[%s]\n",csSysTime,csStmtDate,csSysDate));
				}
			}
		}
	}


/* Time Tolerance */
	if (iRet == PD_OK) {
		if (iTolDateTime > 0 &&
		    GetField_CString(hRls,"statement_date",&csStmtDate) &&
		    GetField_CString(hRls,"statement_time",&csStmtTime)) {
			if (!GetField_Int(hRls, "new_stmt_time", &iTmp)) {
				if ((strcmp(csStmtDate,csTolDate) == 0 && strcmp(csStmtTime,csTolTime) > 0) ||
				     strcmp(csStmtDate,csTolDate) > 0) {
					snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Future Date Time]");
					strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
					iRet = PD_OTHER_ERR;
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       Curr Date Time [%s][%s] > Tolerance Date Time [%s][%s]!!!\n",csStmtDate,csStmtTime,csTolDate,csTolTime));
				} else {
 if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       Curr Date Time [%s][%s] <= Tolerance Date Time [%s][%s]\n",csStmtDate,csStmtTime,csTolDate,csTolTime));
				}
			} else {
				if (strcmp(csStmtDate,csSysDate) > 0) {
					snprintf(cs_tmp_buf1,sizeof(cs_tmp_buf1),"[Future Date]");
					strncat(cs_tmp_buf2,cs_tmp_buf1,sizeof(cs_tmp_buf2)-strlen(cs_tmp_buf2)-1);
					iRet = PD_OTHER_ERR;
if (iDetailRow == 1) DEBUGLOG(("ProcessStmtFile()       Curr Date [%s] > Tolerance Date [%s]!!!\n",csStmtDate,csSysDate));
				} else {
 if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       Curr Date [%s] <= Tolerance Date [%s]\n",csStmtDate,csSysDate));
				}
			}
		} else {
 if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       ** No Tolerance Date Time Check\n"));
		}
	}

/* Time Zone */	
	if (iRet == PD_OK) {
		if (GetField_CString(hRls,"statement_date",&csStmtDate) &&
		    GetField_CString(hRls,"statement_time",&csStmtTime)) {

			if (GetField_CString(hContext,"TIMEZONE",&csTimeZone)) {
				snprintf(csStmtDateTime,sizeof(csStmtDateTime),"%s",csStmtDate);
				strncat(csStmtDateTime,csStmtTime,sizeof(csStmtDateTime)-strlen(csStmtDateTime)-1);

				csOutStmtDateTime = ChangeTimeZone(csStmtDateTime,PD_DEFAULT_DATETIME_FORMAT,csTimeZone,PD_DESTZONE); //
 if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       Change Time Zone [%s] in[%s][%s]\n",csOutStmtDateTime,csStmtDateTime,PD_DEFAULT_DATETIME_FORMAT));
				PutField_CString(hRls,"statement_time",&csOutStmtDateTime[PD_DATE_LEN]);
				csOutStmtDateTime[PD_DATE_LEN]='\0';
				PutField_CString(hRls,"statement_date",csOutStmtDateTime);
			} else {
 if (iSampleRow == 1) DEBUGLOG(("ProcessStmtFile()       ** No Change Time Zone for %s\n",csCountry));
			}
		}
	}

	if (iRet != PD_OK) {
		sprintf(cs_err_msg_buf,"%s",cs_tmp_buf2);
	}
	return iRet;
}

int GetCompareKey(const hash_t *hContext, char *csTag[], int iArraySize, char *csCompareKey)
{
	int iRet = PD_OK;

	char csTmpCompareKey[PD_TMP_BUF_LEN] = "";
	char *csTmp;
	int iTmp;

	for (iTmp=0;iTmp<iArraySize;iTmp++) {
		if (GetField_CString(hContext,csTag[iTmp],&csTmp)) {
			strcat(csTmpCompareKey, csTmp);
		} else {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile::GetCompareKey() %s is missing!!!\n",csTag[iTmp]));
ERRLOG("BOOLBankStmt::ProcessStmtFile::GetCompareKey() %s is missing!!!\n",csTag[iTmp]);
		}
	}

	strcpy(csCompareKey, csTmpCompareKey);

	return iRet;
}

int MultiKeywordsSearch(const char *csLine, char *csTemplate, int iFullMatch)
{
	char *csTemplateField;
	csTemplateField = mystrtok(csTemplate, ",");
	while (csTemplateField != NULL) {

		if (!strcmp(csTemplateField,"")) continue;

		if (iFullMatch == 0 && strstr(csLine, csTemplateField) != NULL) {
// DEBUGLOG(("MultiKeywordsSearch() Contains\n"));
			return FOUND;

		} else if (iFullMatch == 1 && !strcmp(csLine, csTemplateField)) {
// DEBUGLOG(("MultiKeywordsSearch() Full Match\n"));
			return FOUND;

		} else if (!strcmp(csTemplateField,"NOTNULL") && strcmp(csLine,"")) {
// DEBUGLOG(("MultiKeywordsSearch() NOTNULL Match\n"));
			return FOUND;

		} else if (!strcmp(csTemplateField,"NULL") && !strcmp(csLine,"")) {
// DEBUGLOG(("MultiKeywordsSearch() NULL Match\n"));
			return FOUND;
		}
		csTemplateField = mystrtok(NULL, ",");
	}
	return NOT_FOUND;
}

