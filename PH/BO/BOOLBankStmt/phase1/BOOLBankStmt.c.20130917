/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/07/26              David Wong
Add ProcessStmtFile                                2013/07/29              Stan Poon
Add running balance checking                       2013/08/06              David Wong
Add de-duplication                                 2013/08/15              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "dbutility.h"
#include "BOOLBankStmt.h"
#include "myrecordset.h"
#include "myhash.h"
#include "math.h"

#define	IN_FILE_EXT_DELIMITER	"."
#define	OUT_FILE_NAME_SUFFIX	"_converted"
#define	EXCEL_CONVERT_SCRIPT	"xls2txt"
#define	TEXT_CONVERT_SCRIPT	"iconv"
#define	OUT_FILE_ENCODING	"UTF-8"
#define PD_RAW			"raw"
#define PD_CONVERTED		"converted"

#define	PD_FMT_TYPE_HOLD		"hold"
#define	PD_FMT_TYPE_DELIMITER		"delimiter"

#define	PD_FMT_TYPE_BANK_ACCT_ROW	"bank_acct_row"
#define	PD_FMT_TYPE_START_YEAR		"start_year"
#define	PD_FMT_TYPE_SORT		"sort"
#define	PD_FMT_TYPE_TOTAL_FIELD		"total_field"
#define	PD_FMT_TYPE_START_ROW		"start_row"
#define	PD_FMT_TYPE_END_ROW		"end_row"
#define	PD_FMT_TYPE_RUNNING_BAL		"running_bal"

#define	PD_FMT_FORMAT_ID	"format_id"
#define	PD_FMT_NEXT_LEVEL	"nextlevel"
#define	PD_FMT_DESC		"desc"
#define	PD_FMT_TEMPLATE		"template"

#define	PD_HOLD_DELIMITER	","

char cDebug;
OBJPTR(DB);
OBJPTR(BO);

void BOOLBankStmt(char cdebug)
{
	cDebug = cdebug;
}


int ConvertStmtFile(const char* csIntBankCode, const char* csInFileName, char* csOutFileName)
{
	int iRet = PD_OK;
	int iCnt = 0;
	char csTmpForStrtok[PD_MAX_BUFFER];
	char *csTmp;
	char csInFileExt[PD_MAX_BUFFER];
	char csScriptName[PD_MAX_BUFFER];
	char csInFileEncoding[PD_MAX_BUFFER];
	char csInFilePrefix[PD_MAX_BUFFER];
	char csInFileCountry[PD_MAX_BUFFER];
	char csTmpInFileName[PD_MAX_BUFFER];
	char csTmpOutFileName[PD_MAX_BUFFER];
	char csSysCmd[PD_MAX_BUFFER];

/* get in_file_ext */
	if (iRet == PD_OK) {
		iCnt = 0;
		strcpy(csTmpForStrtok, csInFileName);
		csTmp = strtok(csTmpForStrtok, IN_FILE_EXT_DELIMITER);
		while (csTmp != NULL) {
// DEBUGLOG(("ConvertStmtFile() in_file_name token: [%s]\n", csTmp));
			iCnt++;
			strcpy(csInFileExt, csTmp);
			csTmp = strtok(NULL, IN_FILE_EXT_DELIMITER);
		}

		if (iCnt > 0) {
//DEBUGLOG(("ConvertStmtFile() in_file_ext = [%s]\n", csInFileExt));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("ConvertStmtFile() in_file_ext is missing!!!\n"));
ERRLOG("BOOLBankStmt::ConvertStmtFile() in_file_ext is missing!!!\n");
		}
	}

/* get convert info */
	if (iRet == PD_OK) {
DEBUGLOG(("ConvertStmtFile() call OLStmtConvertScript::GetConvertInfo()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtConvertScript", "GetConvertInfo");
		iRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csInFileExt, csScriptName, csInFileEncoding, csInFilePrefix, csInFileCountry);

		if (iRet == PD_OK) {
//DEBUGLOG(("ConvertStmtFile() script_name = [%s]\n", csScriptName));
//DEBUGLOG(("ConvertStmtFile() in_file_encoding = [%s]\n", csInFileEncoding));
//DEBUGLOG(("ConvertStmtFile() in_file_prefix = [%s]\n", csInFilePrefix));
//DEBUGLOG(("ConvertStmtFile() in_file_country = [%s]\n", csInFileCountry));
//DEBUGLOG(("ConvertStmtFile() call OLStmtConvertScript::GetConvertInfo() success\n"));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("ConvertStmtFile() call OLStmtConvertScript::GetConvertInfo() failed!!!\n"));
ERRLOG("BOOLBankStmt::ConvertStmtFile() call OLStmtConvertScript::GetConvertInfo() failed!!!\n");
		}
	}

/* do the conversion
example: xls2csv -x "spreadsheet.xls" -b WINDOWS-1252 -c "csvfile.csv" -a UTF-8
example: iconv -f WINDOWS-1252 -t UTF-8 "spreadsheet.xls"
example: xls2txt "spreadsheet.xls"
*/
	if (iRet == PD_OK) {
		sprintf(csTmpInFileName, "%s/%s/%s/%s/%s", getenv(PD_FILE_PATH_ENV_VAR), csInFileCountry, csIntBankCode, PD_RAW, csInFileName);
		sprintf(csTmpOutFileName, "%s/%s/%s/%s/%s", getenv(PD_FILE_PATH_ENV_VAR), csInFileCountry, csIntBankCode, PD_CONVERTED, csInFileName);
		if (!strcmp(csScriptName, EXCEL_CONVERT_SCRIPT)) {
			sprintf(csSysCmd, "%s \"%s\" > \"%s\"", EXCEL_CONVERT_SCRIPT, csTmpInFileName, csTmpOutFileName);
		}
		else if (!strcmp(csScriptName, TEXT_CONVERT_SCRIPT)) {
			sprintf(csSysCmd, "%s -f %s -t %s \"%s\" > \"%s\"", TEXT_CONVERT_SCRIPT, csInFileEncoding, OUT_FILE_ENCODING, csTmpInFileName, csTmpOutFileName);
		} else {
			sprintf(csSysCmd, "cd $HOME/bin/batch/ ; %s %s %s %s %s", csScriptName, csInFileEncoding, OUT_FILE_ENCODING, csTmpInFileName, csTmpOutFileName);
		}
DEBUGLOG(("ConvertStmtFile() call system command [%s]\n", csSysCmd));
		iRet = system(csSysCmd);

		if (iRet == PD_OK) {
			strcpy(csOutFileName, csTmpOutFileName);
		} else {
DEBUGLOG(("ConvertStmtFile() convert failed!!!\n"));
ERRLOG("BOOLBankStmt::ConvertStmtFile() convert failed!!!\n");
		}
	}

DEBUGLOG(("ConvertStmtFile() Normal Exit! iRet = [%d]\n", iRet));

	return iRet;
}


struct node
{
	hash_t *hDtl;
	struct node *next;
};


int ProcessStmtFile(const char* csFileName, const char* csFileNameWithPath, const char* csIntBankCode,
			const char* csBankAcctNum, const char* csCreateUser,
			recordset_t* rRecordFormat, hash_t *hResponse)
{
	int iRet = PD_OK, iTmpRet = PD_OK;
	int iCurrLine = 0, iTotalLine = 0;
	char *csFormatId, *csDelimiter;
	int iBankAcctRow, iStartYear, iReverse, iTotalField, iStartRow, iEndRow, iRunningBal;
	int iFormatCount = 0, iCount = 0;
	int iTotalCount = 0, iAcceptCount = 0, iHoldCount = 0, iSkipCount = 0;

	FILE *fin;
	char csFullFileName[PD_MAX_BUFFER + 1], csNewFileName[PD_MAX_BUFFER + 1];
	char cs_input_buf[PD_MAX_BUFFER + 1];
	//char *csStartName, *csEndName;
	char csCcy[PD_CCY_ID_LEN + 1];
	char csStartDate[PD_DATE_LEN + 1], csStartTime[PD_TIME_LEN + 1];
	char csEndDate[PD_DATE_LEN + 1], csEndTime[PD_TIME_LEN + 1];
	int iStatementSeq = 1;

	char *csTag = (char*) malloc (64);
	char *csTmp;
	int iTmp;

	struct node *head = NULL, *tail = NULL, *temp = NULL, *currentNode;

	hash_t *hFormat;
	hash_t *hRec;
	hash_t *hFile;

	recordset_t *rRecordFile;
	rRecordFile = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordFile, 0);
	recordset_t *rRecordDb;
	rRecordDb = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordDb, 0);

/* file */
	strcpy(csFullFileName, csFileNameWithPath);

	fin = fopen(csFullFileName, "r");
	if (fin == NULL) {
DEBUGLOG(("ProcessStmtFile:: cannot open file [%s]!!!\n", csFileName));
ERRLOG("BOOLBankStmt:: ProcessStmtFile() cannot open file [%s]!!!\n", csFileName);
		iRet = INT_FILE_NOT_FOUND;
	}


/* Support Multi format */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile:: Start Checking Format\n"));
		hFormat = RecordSet_GetFirst(rRecordFormat);
		while (hFormat) {
			iCurrLine = 0;
			iTotalLine = 0;
			rewind(fin);

/* format_id */
			if (!GetField_CString(hFormat, PD_FMT_FORMAT_ID, &csFormatId)) {
DEBUGLOG(("ProcessStmtFile:: Format ID NOT FOUND!!!\n"));
			} else {
DEBUGLOG(("ProcessStmtFile:: Format ID = [%s]\n", csFormatId));
/* delimiter */
				sprintf(csTag, "%s_%s", PD_FMT_TYPE_DELIMITER, csFormatId);
				if (!GetField_CString(hFormat, csTag, &csDelimiter)) {
DEBUGLOG(("ProcessStmtFile:: Delimiter NOT FOUND!!!\n"));
				}
			}
/* bank_acct_row */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_BANK_ACCT_ROW, &csTmp)) {
				iBankAcctRow = 0;
			} else {
				iBankAcctRow = atoi(csTmp);
			}
/* start_year */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_START_YEAR, &csTmp)) {
				iStartYear = 0;
			} else {
				iStartYear = atoi(csTmp);
			}
/* sort */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_SORT, &csTmp)) {
				iReverse = 0;
			} else if (!strcmp(csTmp, "REVERSE")) {
				iReverse = 1;
			} else {
				iReverse = 0;
			}
/* total_field */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_TOTAL_FIELD, &csTmp)) {
				iTotalField = 0;
			} else {
				iTotalField = atoi(csTmp);
			}
/* start_row */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_START_ROW, &csTmp)) {
				iStartRow = 1;
			} else {
				iStartRow = atoi(csTmp);
			}
/* end_row */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_END_ROW, &csTmp)) {
				iEndRow = 1;
			} else {
				iEndRow = atoi(csTmp);
			}
/* running_bal */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_RUNNING_BAL, &csTmp)) {
				iRunningBal = 0;
			} else {
				iRunningBal = atoi(csTmp);
			}

			while (fgets(cs_input_buf, PD_MAX_BUFFER, fin) != NULL) {
				iCurrLine++;
				if (iCurrLine == iStartRow && iTotalField > 0) {
					iTmp = 0;
					csTmp = mystrtok(cs_input_buf, csDelimiter);
					while (csTmp != NULL) {
						iTmp++;
						csTmp = mystrtok(NULL, csDelimiter);
					}
					if (iTmp != iTotalField) {
						break;
					} else {
						iFormatCount = 1;
					}
				}
				iTotalLine++;
			}

			if (iFormatCount == 1)
				break;

			hFormat = RecordSet_GetNext(rRecordFormat);
		}
DEBUGLOG(("ProcessStmtFile:: End Checking Format\n"));

		if (iFormatCount == 1) {
			iTotalCount = iTotalLine - iStartRow - iEndRow + 2;
			if (iTotalLine <= iStartRow + iEndRow - 2) {
				iRet = INT_RECORD_ROW_NOT_MATCH;
DEBUGLOG(("ProcessStmtFile:: End row does not match!!!\n"));
ERRLOG("BOOLBankStmt:: ProcessStmtFile() End row does not match!!!\n");
			}
		} else {
			iRet = INT_NO_FORMAT_MATCH;
DEBUGLOG(("ProcessStmtFile:: No format matches!!!\n"));
ERRLOG("BOOLBankStmt:: ProcessStmtFile() No format matches!!!\n");
		}
	}


/* Filename */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile:: DBOLStatement:: GetNextHeaderFileIndex() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetNextHeaderFileIndex");
		iTmpRet = (unsigned long)(*DBObjPtr)(csFileName, &iTmp);
		if (iTmpRet != PD_FOUND && iTmpRet != PD_NOT_FOUND) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile:: call DBOLStatement:: GetNextHeaderFileIndex() failed!!!\n"));
		} else if (iTmpRet == PD_FOUND) {
//			sprintf(csNewFileName, "%s_%03d", csFileName, iTmp);
//DEBUGLOG(("ProcessStmtFile:: New filename = [%s]\n", csNewFileName));
			iRet = INT_FILE_ALREADY_EXIST;
DEBUGLOG(("ProcessStmtFile:: filename [%s] already exist!!!\n", csNewFileName));
		} else if (iTmpRet == PD_NOT_FOUND) {
			strcpy(csNewFileName, csFileName);
DEBUGLOG(("ProcessStmtFile:: filename = [%s]\n", csNewFileName));
		}
	}
/*
	if (iRet == PD_OK) {
		strcpy(csTag, csFileName);
		csStartName = mystrtok(csTag, ".");
		csEndName = mystrtok(NULL, ".");

DEBUGLOG(("ProcessStmtFile:: DBOLStatement:: GetNextHeaderFileIndex() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetNextHeaderFileIndex");
		iTmpRet = (unsigned long)(*DBObjPtr)(csStartName, csEndName, csFileName, &iTmp);
		if (iTmpRet != PD_FOUND && iTmpRet != PD_NOT_FOUND) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile:: call DBOLStatement:: GetNextHeaderFileIndex() failed!!!\n"));
		} else if (iTmpRet == PD_FOUND) {
			sprintf(csNewFileName, "%s(%d).%s", csStartName, iTmp, csEndName);
DEBUGLOG(("ProcessStmtFile:: New filename = [%s]\n", csNewFileName));
		} else if (iTmpRet == PD_NOT_FOUND) {
			strcpy(csNewFileName, csFileName);
		}
	}
*/

/* Statement Header Add */
	if (iRet == PD_OK) {
		hRec = (hash_t*) malloc (sizeof(hash_t));
		hash_init(hRec, 0);

		PutField_CString(hRec, "filename", csNewFileName);
		PutField_CString(hRec, "int_bank_code", csIntBankCode);
		PutField_CString(hRec, "bank_acct_num", csBankAcctNum);
		PutField_CString(hRec, "input_channel", "FILE");
		PutField_Int(hRec, "total_count", iTotalCount);
		PutField_CString(hRec, "create_user", csCreateUser);

DEBUGLOG(("ProcessStmtFile:: DBOLStatement:: AddHeader() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "AddHeader");
		if ((*DBObjPtr)(hRec)) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile:: call DBOLStatement:: AddHeader() failed!!!\n"));
//		} else {
//			TxnCommit();
		}

		hash_destroy(hRec);
		FREE_ME(hRec);
	}


/* Acct Ccy */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile:: DBOLBankAccts:: GetAcctCcy() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLBankAccts", "GetAcctCcy");
		if ((*DBObjPtr)(csIntBankCode, csBankAcctNum, csCcy)) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile:: call DBOLBankAccts:: GetAcctCcy() failed!!!\n"));
		}
	}


/* Statement Detail Preparation */
	if (iRet == PD_OK) {
		iCount = 0;
		iCurrLine = 0;
		rewind(fin);

DEBUGLOG(("ProcessStmtFile:: Start Reading File\n"));
DEBUGLOG(("ProcessStmtFile:: CheckDetail()\n"));
		while (fgets(cs_input_buf, PD_MAX_BUFFER, fin) != NULL) {
			cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
			iCurrLine++;

			/* Check bank account number */
			if (iCurrLine == iBankAcctRow) {
				csTmp = strstr(cs_input_buf, csBankAcctNum);
				if (csTmp == NULL) {
					iRet = INT_BANK_ACCT_NOT_MATCH;
DEBUGLOG(("ProcessStmtFile:: Bank account number does not match!!!\n"));
ERRLOG("BOOLBankStmt:: ProcessStmtFile() Bank account does not match!!!\n");
					break;
				}
			}

			/* Skip leading and trailing rows */
			if (iCurrLine < iStartRow || iCurrLine > iTotalLine - iEndRow + 1)
				continue;

			hRec = (hash_t*) malloc (sizeof(hash_t));
			hash_init(hRec, 0);

			currentNode = (struct node*) malloc (sizeof(struct node));
			currentNode->hDtl = hRec;
			if (head == NULL) {
				head = currentNode;
				head->next = NULL;
				tail = head;
			} else if (iReverse == 1) {
				currentNode->next = head;
				head = currentNode;
			} else {
				tail->next = currentNode;
				tail = currentNode;
				tail->next = NULL;
			}

			iTmpRet = splitLineByhFormat(cs_input_buf, csFormatId, hFormat, hRec);
			if (iTmpRet != PD_OK) {
				iRet = INT_FORMAT_NOT_MATCH;
DEBUGLOG(("ProcessStmtFile:: Format error!!!\n"));
ERRLOG("BOOLBankStmt:: ProcessStmtFile() Format error!!!\n");
				break;
			}

			PutField_Int(hRec, "line", iCurrLine);
			PutField_Int(hRec, "start_year", iStartYear);

// DEBUGLOG(("ProcessStmtFile:: DBOLStatement:: CheckDetail() called\n"));
			DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "CheckDetail");
			if ((*DBObjPtr)(iCurrLine, csCcy, hRec)) {
				iRet = INT_CHECK_DETAIL_ERROR;
DEBUGLOG(("ProcessStmtFile:: call DBOLStatement:: CheckDetail() line [%d] failed!!!\n", iCurrLine));
				iCount++;
				sprintf(csTag, "line_%d", iCount);
DEBUGLOG(("csTag:[%s]\n",csTag));
				PutField_Int(hResponse, csTag, iCurrLine);
				if (iCount >= PD_NUM_OF_ERROR_LINE) {
					break;
				}
			}
		}
DEBUGLOG(("ProcessStmtFile:: End Reading File\n"));

		if (head != NULL) {
			hRec = head->hDtl;
			if (GetField_CString(hRec, "statement_date", &csTmp)) {
				strncpy(csStartDate, csTmp, PD_DATE_LEN + 1);
			}
	
			if (GetField_Int(hRec, "new_stmt_time", &iTmp)) {
				strncpy(csStartTime, "000000", PD_TIME_LEN + 1);
			} else if (GetField_CString(hRec, "statement_time", &csTmp)) {
				strncpy(csStartTime, csTmp, PD_TIME_LEN + 1);
			}
	
			hRec = tail->hDtl;
			if (GetField_CString(hRec, "statement_date", &csTmp)) {
				strncpy(csEndDate, csTmp, PD_DATE_LEN + 1);
			}
	
			if (GetField_Int(hRec, "new_stmt_time", &iTmp)) {
				strncpy(csEndTime, "235959", PD_TIME_LEN + 1);
			} else if (GetField_CString(hRec, "statement_time", &csTmp)) {
				strncpy(csEndTime, csTmp, PD_TIME_LEN + 1);
			}
		}

		while (head != NULL) {
			hRec = head->hDtl;
			RecordSet_Add(rRecordFile, hRec);
			/* delete */
			temp = head;
			head = head->next;
			FREE_ME(temp);
		}
	}


/* De-duplication and Running Balance Check */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile:: DBOLStatement:: GetExistingPastRecords() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetExistingPastRecords");
		iTmpRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csBankAcctNum, csStartDate, csStartTime, csEndDate, csEndTime, rRecordDb);
		if (iTmpRet != PD_FOUND && iTmpRet != PD_NOT_FOUND) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile:: call DBOLStatement:: GetExistingPastRecords() failed!!!\n"));
		}

		if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile:: DeDupAndBalCheck() called\n"));
			iRet = DeDupAndBalCheck(csIntBankCode, csBankAcctNum, rRecordFile, rRecordDb, iRunningBal, &iTmp);
			if (iRet != PD_OK) {
				iRet = INT_RUNNING_BALANCE_ERROR;
DEBUGLOG(("ProcessStmtFile:: DeDupAndBalCheck() failed!!!\n"));
				iCount=1;
				PutField_Int(hResponse,"line_1",iTmp);
			}
		}
	}


/* Statement Detail Add */
	if (iRet == PD_OK) {
		iCount=0;
DEBUGLOG(("ProcessStmtFile:: DBOLStatement:: AddDetail() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "AddDetail");
		hFile = RecordSet_GetFirst(rRecordFile);
		while (hFile) {
			GetField_CString(hFile, "as_ind", &csTmp);
			if (!strcmp(csTmp, "accept")) {
				PutField_CString(hFile, "filename", csNewFileName);
				PutField_CString(hFile, "int_bank_code", csIntBankCode);
				PutField_CString(hFile, "bank_acct_num", csBankAcctNum);
				PutField_Int(hFile, "statement_seq", iStatementSeq);
				if (!GetField_Int(hFile, "hold", &iTmp))
					PutField_Char(hFile, "status", PD_STATUS_UNALLOCATED);
				else {
					iHoldCount++;
					PutField_Char(hFile, "status", PD_STATUS_HOLD);
				}
				PutField_CString(hFile, "create_user", csCreateUser);

				GetField_Int(hFile, "line", &iCurrLine);
				if ((*DBObjPtr)(iStatementSeq, hFile)) {
					iRet = INT_ADD_DETAIL_ERROR;
DEBUGLOG(("ProcessStmtFile:: call DBOLStatement:: AddDetail() failed!!!\n"));
					iCount++;
					sprintf(csTag, "line_%d", iCount);
					PutField_Int(hResponse, csTag, iCurrLine);
					if (iCount >= PD_NUM_OF_ERROR_LINE) {
						break;
					}
				} else {
					iAcceptCount++;
					iStatementSeq++;
				}
			} else {
				iSkipCount++;
			}
			hFile = RecordSet_GetNext(rRecordFile);
		}
	}


/* Statement Header Update */
	if (iRet == PD_OK) {
		hRec = (hash_t*) malloc (sizeof(hash_t));
		hash_init(hRec, 0);

		PutField_CString(hRec, "filename", csNewFileName);
		PutField_Int(hRec, "accept_count", iAcceptCount);
		PutField_Int(hRec, "skip_count", iSkipCount);

DEBUGLOG(("ProcessStmtFile:: DBOLStatement:: UpdateHeader() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "UpdateHeader");
		if ((*DBObjPtr)(hRec)) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile:: call DBOLStatement:: UpdateHeader() failed!!!\n"));
		}

		hash_destroy(hRec);
		FREE_ME(hRec);
	}

	if (iCount > 0) {
		PutField_Int(hResponse, "line_cnt", iCount);
	}

	if (iRet != PD_OK) {
		TxnAbort();
	}

DEBUGLOG(("ProcessStmtFile:: Result: Accept[%d](Hold[%d])/Skip[%d]/Total[%d]\n", iAcceptCount, iHoldCount, iSkipCount, iTotalCount));
	PutField_Int(hResponse,"accept",iAcceptCount);
	PutField_Int(hResponse,"hold",iHoldCount);
	PutField_Int(hResponse,"skip",iSkipCount);
	PutField_Int(hResponse,"total",iTotalCount);

	if (fin) fclose(fin);

/*
	hash_destroy(hFormat);
	FREE_ME(hFormat);
	hash_destroy(hFile);
	FREE_ME(hFile);
*/

	RecordSet_Destroy(rRecordFile);
	FREE_ME(rRecordFile);
	RecordSet_Destroy(rRecordDb);
	FREE_ME(rRecordDb);

	FREE_ME(csTag);

DEBUGLOG(("ProcessStmtFile:: iRet = [%d]\n", iRet));
	return iRet;
}


char *mystrtok_r(char *string, const char *seps, char **context)
{
	char *head; /* Start of word */
	char *tail; /* End of word */

	/* If we're starting up, initialize context */
	if (string) {
		*context = string;
	}

	/* Get potential start of this next word */
	head = *context;
	if (head == NULL) {
		return NULL;
	}

	/* Skip any leading separators
	while (*head && strchr(seps, *head)) {
		head++;
	}*/

	/* Did we hit the end? */
	if (*head == 0) {
		/* Nothing left */
		*context = NULL;
		return NULL;
	}

	/* Skip over word */
	tail = head;
	while (*tail && !strchr(seps, *tail)) {
		tail++;
	}

	/* Save head for next time in context */
	if (*tail == 0) {
		*context = NULL;
	} else {
		*tail = 0;
		tail++;
		*context = tail;
	}

	/* Return current word */
	return head;
}


int splitLineByhFormat(const char* csLine, const char* csFormatId,
			const hash_t* hFormat, hash_t* hRec)
{
	int iRet = PD_OK;
	char *csDesc, *csTemplate, *csHold;
	int iNextLevel;

	char *csDelimiter, *csFirstField, *csRemainField, *csHoldFirstField, *csHoldRemainField;
	int iFieldCount = 1, iTmp = 0, iMatch = 0, iNotMatch = 0;
	char *csTag = (char*) malloc (64);

	char csTmpField[PD_MAX_BUFFER + 1];
	char csTmpLine[PD_MAX_BUFFER + 1];
	strcpy(csTmpLine, csLine);

	/* Get the delimiter first */
	sprintf(csTag, "%s_%s", PD_FMT_TYPE_DELIMITER, csFormatId);
	if (!GetField_CString(hFormat, csTag, &csDelimiter)) {
		iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile:: %s not found!!!\n", csTag));
	}

	csFirstField = mystrtok_r(csTmpLine, csDelimiter, &csRemainField);
	while (csFirstField != NULL && iRet == PD_OK) {
		strcpy(csTmpField, TrimAll((const unsigned char*)csFirstField, strlen(csFirstField)));
// DEBUGLOG(("val  : %s_%d : [%s]\n", csFormatId, iFieldCount, csTmpField));

		sprintf(csTag, "%s_%s_%d", PD_FMT_DESC, csFormatId, iFieldCount);
		if (!GetField_CString(hFormat, csTag, &csDesc)) {
			// to be implemented
		}
// DEBUGLOG(("desc : %s_%d : [%s]\n", csFormatId, iFieldCount, csDesc));

		sprintf(csTag, "%s_%s_%d", PD_FMT_NEXT_LEVEL, csFormatId, iFieldCount);
		if (GetField_Int(hFormat, csTag, &iNextLevel)) {
			if (iNextLevel == 1) {
				iRet = splitLineByhFormat(csTmpField, csDesc, hFormat, hRec);
			} else if (iNextLevel == 0) {
				if (strcmp(csTmpField, "")) {
					PutField_CString(hRec, csDesc, csTmpField);
// DEBUGLOG(("#[%s] = [%s]\n", csDesc, csTmpField));
				}
			}
		}

		sprintf(csTag, "%s_%s_%d", PD_FMT_TEMPLATE, csFormatId, iFieldCount);
		if (GetField_CString(hFormat, csTag, &csTemplate)) {
			sprintf(csTag, "%s_t", csDesc);
			PutField_CString(hRec, csTag, csTemplate);
		}

		sprintf(csTag, "%s_%d", PD_FMT_TYPE_HOLD, iFieldCount);
		if (GetField_CString(hFormat, csTag, &csHold)) {
			iTmp = 0;
			csHoldFirstField = mystrtok_r(csHold, PD_HOLD_DELIMITER, &csHoldRemainField);
			while (csHoldFirstField != NULL) {
				if (strstr(csTmpField, csHoldFirstField) != NULL) {
					iTmp++;
					break;
				}
				csHoldFirstField = mystrtok_r(NULL, PD_HOLD_DELIMITER, &csHoldRemainField);
			}
			if (iTmp <= 0) {
				iNotMatch++;
			} else {
				iMatch++;
			}
		}

		iFieldCount++;
		csFirstField = mystrtok_r(NULL, csDelimiter, &csRemainField);
	}

	if (iMatch > 0 && iNotMatch == 0) {
		PutField_Int(hRec, "hold", 1);
	}

	free(csTag);

	return iRet;
}


int GetCompareKey(const hash_t* hRec, char* csCompareKey)
{
	char *csTmp;
	double dTmp;
	int iTmp;
	char csTmpCompareKey[PD_MAX_BUFFER] = "";

	if (GetField_CString(hRec, "statement_date", &csTmp)) {
		strcat(csTmpCompareKey, csTmp);
	} else {
DEBUGLOG(("GetCompareKey:: statement_date is missing!!!\n"));
ERRLOG("BOOLBankStmt:: GetCompareKey:: statement_date is missing!!!\n");
		return PD_ERR;
	}

	if (!GetField_Int(hRec, "new_stmt_time", &iTmp)) {
		if (GetField_CString(hRec, "statement_time", &csTmp)) {
			strcat(csTmpCompareKey, csTmp);
		} else {
DEBUGLOG(("GetCompareKey:: statement_time is missing!!!\n"));
ERRLOG("BOOLBankStmt:: GetCompareKey:: statement_time is missing!!!\n");
			return PD_ERR;
		}
	}

	if (GetField_CString(hRec, "txn_ccy", &csTmp)) {
		strcat(csTmpCompareKey, csTmp);
	} else {
DEBUGLOG(("GetCompareKey:: txn_ccy is missing!!!\n"));
ERRLOG("BOOLBankStmt:: GetCompareKey:: txn_ccy is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "amt_type", &csTmp)) {
		strcat(csTmpCompareKey, csTmp);
	} else {
DEBUGLOG(("GetCompareKey:: amt_type is missing!!!\n"));
ERRLOG("BOOLBankStmt:: GetCompareKey:: amt_type is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "txn_amount", &csTmp)) {
		dTmp = atof(csTmp);
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else if (GetField_Double(hRec, "txn_amount", &dTmp)) {
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else {
DEBUGLOG(("GetCompareKey:: txn_amount is missing!!!\n"));
ERRLOG("BOOLBankStmt:: GetCompareKey:: txn_amount is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "balance", &csTmp)) {
		dTmp = atof(csTmp);
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else if (GetField_Double(hRec, "balance", &dTmp)) {
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else {
DEBUGLOG(("GetCompareKey:: balance is missing!!!\n"));
ERRLOG("BOOLBankStmt:: GetCompareKey:: balance is missing!!!\n");
		return PD_ERR;
	}

	strcpy(csCompareKey, csTmpCompareKey);

	return PD_OK;
}


int DeDupAndBalCheck(const char* csIntBankCode, const char* csBankAcctNum,
			recordset_t *rRecordFile, recordset_t *rRecordDb, int iRunningBal, int *iLine)
{
	int iRet = PD_OK;
	int iFound = PD_FOUND;
	int iTmp, iCmpResult;
	char *csTmp;

	char csFileCompareKey[PD_MAX_BUFFER] = "";
	char csDbCompareKey[PD_MAX_BUFFER] = "";
	char *csAmtType;
	double dRunBal, dBal, dTxnAmt, dCalBal;

	hash_t *hFile;
	hash_t *hDb;

	/* START de-duplication */
	if (iRet == PD_OK) {
		hFile = RecordSet_GetFirst(rRecordFile);
		hDb = RecordSet_GetFirst(rRecordDb);

		while (hFile && hDb) {
			if (GetField_Int(hFile, "new_stmt_time", &iTmp)) {
				PutField_Int(hDb, "new_stmt_time", iTmp);
			}
			GetCompareKey(hFile, csFileCompareKey);
			GetCompareKey(hDb, csDbCompareKey);
			iCmpResult = strcmp(csFileCompareKey, csDbCompareKey);

			if (iCmpResult == 0) {
				/* exist in file and db, skip */
				PutField_CString(hFile, "as_ind", "skip");
				hFile = RecordSet_GetNext(rRecordFile);
				hDb = RecordSet_GetNext(rRecordDb);
			} else if (iCmpResult > 0) {
				/* exist in db but not in file, ignore */
				hDb = RecordSet_GetNext(rRecordDb);
			} else if (iCmpResult < 0) {
				/* exist in file but not in db, accept */
				PutField_CString(hFile, "as_ind", "accept");
				hFile = RecordSet_GetNext(rRecordFile);
			}
		}

		while (hFile) {
			PutField_CString(hFile, "as_ind", "accept");
			hFile = RecordSet_GetNext(rRecordFile);
		}
	}
	/* END de-duplication */

	/* START check running balance */
	if (iRet == PD_OK) {
		hFile = RecordSet_GetFirst(rRecordFile);
		while (hFile) {
			GetField_CString(hFile, "as_ind", &csTmp);
			if (!strcmp(csTmp, "accept")) {
				/* Try to get initial running balance from DB */
				DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetLastBalance");
				iFound = (unsigned long)(*DBObjPtr)(csIntBankCode, csBankAcctNum, &dRunBal);

				if (iFound == PD_FOUND) {
DEBUGLOG(("DeDupAndBalCheck:: Running balance from DB = [%.2f]\n", dRunBal));
				} else {
DEBUGLOG(("DeDupAndBalCheck:: Running balance from DB not found!!!\n"));
					GetField_CString(hFile, "balance", &csTmp);
					dRunBal = atof(csTmp);
					hFile = RecordSet_GetNext(rRecordFile);
				}
				break;
			} else {
				hFile = RecordSet_GetNext(rRecordFile);
			}
		}

		while (hFile && iRunningBal == 1) {
			GetField_CString(hFile, "balance", &csTmp);
			dBal = atof(csTmp);
//DEBUGLOG((" dBal = [%.2lf], csTmp = [%s]\n",dBal,csTmp));
			GetField_CString(hFile, "amt_type", &csAmtType);
			GetField_CString(hFile, "txn_amount", &csTmp);
			dTxnAmt = atof(csTmp);

			if (!strcmp(csAmtType, PD_CR))
				dCalBal = dRunBal + dTxnAmt;
			else
				dCalBal = dRunBal - dTxnAmt;

// DEBUGLOG(("DeDupAndBalCheck:: expected: [%f]\n", dBal));
// DEBUGLOG(("DeDupAndBalCheck:: actual  : [%f] = [%f] [%s] [%f]\n", dCalBal, dRunBal, csAmtType, dTxnAmt));

			if (fabs(dCalBal - dBal) < 1E-9)
				dRunBal = dBal;
			else {
				iRet = INT_ERR;
DEBUGLOG((" runbal [%.2f] +- txnamt [%.2f] = calbal [%.2f] != bal [%.2f]\n",dRunBal,dTxnAmt,dCalBal,dBal));
				GetField_Int(hFile, "line", &iTmp);
				*iLine = iTmp;
DEBUGLOG(("DeDupAndBalCheck:: running balance does not match!!! expected: [%.2f] actual: [%.2f] at line [%d]\n", dBal, dCalBal,iTmp));
ERRLOG("BOOLBankStmt:: DeDupAndBalCheck:: running balance does not match!!! expected: [%.2f] actual: [%.2f]\n", dBal, dCalBal);
				break;
			}

			hFile = RecordSet_GetNext(rRecordFile);
		}
	}
	/* END check running balance */

/*
	hash_destroy(hFile);
	FREE_ME(hFile);
	hash_destroy(hDb);
	FREE_ME(hDb);
*/

	return iRet;
}

