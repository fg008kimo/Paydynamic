/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/07/26              David Wong
Add ProcessStmtFile                                2013/07/29              Stan Poon
Add running balance checking                       2013/08/06              David Wong
Add de-duplication                                 2013/08/15              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "BOOLBankStmt.h"
#include "myrecordset.h"
#include "myhash.h"

#define IN_FILE_EXT_DELIMITER "."
#define OUT_FILE_NAME_SUFFIX "_converted"
#define EXCEL_CONVERT_SCRIPT "xls2txt"
#define TEXT_CONVERT_SCRIPT "iconv"
#define OUT_FILE_ENCODING "UTF-8"

#define	PD_FILE_PATH			"tmp/bank_statement/"

#define	PD_FORMAT_TYPE_FORMAT_ID	"format_id"
#define	PD_FORMAT_TYPE_START_ROW	"start_row"
#define	PD_FORMAT_TYPE_END_ROW		"end_row"
#define	PD_FORMAT_TYPE_START_YEAR	"start_year"
#define	PD_FORMAT_TYPE_BANK_ACCT_ROW	"bank_acct_row"
#define	PD_FORMAT_TYPE_TOTAL_FIELD	"total_field"

#define	PD_FORMAT_TYPE_DELIMITER	"delimiter"
#define	PD_FORMAT_NEXT_LEVEL	"nextlevel"
#define	PD_FORMAT_DESC		"desc"
#define	PD_FORMAT_TEMPLATE	"template"

char cDebug;
OBJPTR(DB);
OBJPTR(BO);

void BOOLBankStmt(char cdebug)
{
	cDebug = cdebug;
}

int ConvertStmtFile(const char* csIntBankCode, const char* csInFileName, char* csOutFileName)
{
	int iRet = PD_OK;
	int iCnt = 0;
	char csTmpForStrtok[PD_MAX_BUFFER];
	char *csTmp;
	char csInFileExt[PD_MAX_BUFFER];
	char csScriptName[PD_MAX_BUFFER];
	char csInFileEncoding[PD_MAX_BUFFER];
	char csTmpFileName[PD_MAX_BUFFER];
	char csSysCmd[PD_MAX_BUFFER];

/* get in_file_ext */
	if (iRet == PD_OK) {
		iCnt = 0;
		strcpy(csTmpForStrtok, csInFileName);
		csTmp = strtok(csTmpForStrtok, IN_FILE_EXT_DELIMITER);
		while (csTmp != NULL) {
// DEBUGLOG(("ConvertStmtFile() in_file_name token: [%s]\n", csTmp));
			iCnt++;
			strcpy(csInFileExt, csTmp);
			csTmp = strtok(NULL, IN_FILE_EXT_DELIMITER);
		}

		if (iCnt > 0) {
DEBUGLOG(("ConvertStmtFile() in_file_ext = [%s]\n", csInFileExt));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("ConvertStmtFile() in_file_ext is missing!!!\n"));
ERRLOG("BOOLBankStmt::ConvertStmtFile() in_file_ext is missing!!!\n");
		}
	}

/* get convert info */
	if (iRet == PD_OK) {
DEBUGLOG(("ConvertStmtFile() call OLStmtConvertScript::GetConvertInfo()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtConvertScript", "GetConvertInfo");
		iRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csInFileExt, csScriptName, csInFileEncoding);

		if (iRet == PD_OK) {
DEBUGLOG(("ConvertStmtFile() script_name = [%s]\n", csScriptName));
DEBUGLOG(("ConvertStmtFile() in_file_encoding = [%s]\n", csInFileEncoding));
DEBUGLOG(("ConvertStmtFile() call OLStmtConvertScript::GetConvertInfo() success!!!\n"));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("ConvertStmtFile() call OLStmtConvertScript::GetConvertInfo() failed!!!\n"));
ERRLOG("BOOLBankStmt::ConvertStmtFile() call OLStmtConvertScript::GetConvertInfo() failed!!!\n");
		}
	}

/* do the conversion
example: xls2csv -x "spreadsheet.xls" -b WINDOWS-1252 -c "csvfile.csv" -a UTF-8
example: iconv -f WINDOWS-1252 -t UTF-8 "spreadsheet.xls"
example: xls2txt "spreadsheet.xls"
*/
	if (iRet == PD_OK) {
		strcpy(csTmpFileName, csInFileName);
		strcat(csTmpFileName, OUT_FILE_NAME_SUFFIX);
		if (strcmp(csScriptName, EXCEL_CONVERT_SCRIPT) == 0) {
			sprintf(csSysCmd, "cd $HOME/tmp/bank_statement/ ; %s \"%s\" > \"%s\"", EXCEL_CONVERT_SCRIPT, csInFileName, csTmpFileName);
DEBUGLOG(("ConvertStmtFile() call system command [%s]\n", csSysCmd));
			iRet = system(csSysCmd);
		}
		else if (strcmp(csScriptName, TEXT_CONVERT_SCRIPT) == 0) {
			sprintf(csSysCmd, "cd $HOME/tmp/bank_statement/ ; %s -f %s -t %s \"%s\" > \"%s\"", TEXT_CONVERT_SCRIPT, csInFileEncoding, OUT_FILE_ENCODING, csInFileName, csTmpFileName);
DEBUGLOG(("ConvertStmtFile() call system command [%s]\n", csSysCmd));
			iRet = system(csSysCmd);
		} else {
			sprintf(csSysCmd, "cd $HOME/bin/batch/ ; %s %s %s %s %s", csScriptName, csInFileEncoding, OUT_FILE_ENCODING, csInFileName, csTmpFileName);
DEBUGLOG(("ConvertStmtFile() call system command [%s]\n", csSysCmd));
			iRet = system(csSysCmd);
		}

		if (iRet == PD_OK) {
			strcpy(csOutFileName, csTmpFileName);
		} else {
DEBUGLOG(("ConvertStmtFile() convert failed!!!\n"));
ERRLOG("BOOLBankStmt::ConvertStmtFile() convert failed!!!\n");
		}
	}

DEBUGLOG(("ConvertStmtFile() Normal Exit! iRet = [%d]\n\n", iRet));
	return iRet;
}


char *mystrtok_r(char *string, const char *seps, char **context);
int splitLineByhFormat(const char* csLine, const char* csFormatId,
				const hash_t* hFormat, hash_t* hRec, int iDebugLine);
int getCompareKey(const hash_t* hRec, char* csCompareKey);

int ProcessStmtFile(const char* cs_file_name, const char* cs_bank_code,
					const char* cs_acct_num, recordset_t* rRecordFormat, int iDebugLine)
{
	int iRet = SUCCESS, iHdrRet = SUCCESS, iDtlRet = SUCCESS;
	char *csFormatId, *csDelimiter;
	int iBankAcctRow, iTotalField, iStartRow, iEndRow;
	int iCurrLine = 0, iTotalLine = 0;
	int iAcceptCount = 0, iSkipCount = 0;

	char csFullFileName[PD_MAX_BUFFER + 1], csNewFileName[PD_MAX_BUFFER + 1];
	char *csStartName, *csEndName;
	char csCcy[PD_CCY_ID_LEN + 1];
	char cs_input_buf[PD_MAX_BUFFER + 1];
	int iStatementSeq = 1;

	double dRunBal, dBal, dTxnAmt, dCalBal;
	char *csAmtType;

	FILE *fin;
	int iTmp;
	char *csTmp;
	hash_t *hRec = (hash_t*) malloc (sizeof(hash_t));
	char *csTag = (char*) malloc (64);

	hash_t *hFormat;
	hash_t *hFile;
	hash_t *hDb;
	recordset_t *rRecordFile;
	rRecordFile = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordFile, 0);
	recordset_t *rRecordDb;
	rRecordDb = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordDb, 0);

DEBUGLOG(("ProcessStmtFile:: Start Checking File [%s]\n", cs_file_name));
/* file */
	sprintf(csFullFileName, "%s/%s/%s", getenv("HOME"), PD_FILE_PATH, cs_file_name);
	fin = fopen(csFullFileName, "r");
	if (fin == NULL) {
DEBUGLOG(("ProcessStmtFile:: File Err! CANNOT OPEN FILE [%s]\n", cs_file_name));
		return FAILURE;
	}

	hFormat = RecordSet_GetFirst(rRecordFormat);

/* format_id */
	if (!GetField_CString(hFormat, PD_FORMAT_TYPE_FORMAT_ID, &csFormatId)) {
DEBUGLOG(("ProcessStmtFile:: Int Err! Format ID NOT FOUND!!!\n"));
		iRet = FAILURE;
	} else {
DEBUGLOG(("ProcessStmtFile:: Format ID = [%s]\n", csFormatId));
/* delimiter */
		sprintf(csTag, "%s_%s", PD_FORMAT_TYPE_DELIMITER, csFormatId);
		if (!GetField_CString(hFormat, csTag, &csDelimiter)) {
			iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile:: Int Err! Delimiter NOT FOUND!!!\n", csTag));
		}
	}

/* bank_acct_row */
	if (!GetField_CString(hFormat, PD_FORMAT_TYPE_BANK_ACCT_ROW, &csTmp)) {
		iBankAcctRow = 0;
	} else {
		iBankAcctRow = atoi(csTmp);
	}

/* total_field */
	if (!GetField_CString(hFormat, PD_FORMAT_TYPE_TOTAL_FIELD, &csTmp)) {
		iTotalField = 0;
	} else {
		iTotalField = atoi(csTmp);
	}

/* start_row */
	if (!GetField_CString(hFormat, PD_FORMAT_TYPE_START_ROW, &csTmp)) {
		iStartRow = 1;
	} else {
		iStartRow = atoi(csTmp);
	}

/* end_row */
	if (!GetField_CString(hFormat, PD_FORMAT_TYPE_END_ROW, &csTmp)) {
		iEndRow = 1;
	} else {
		iEndRow = atoi(csTmp);
	}

	while (fgets(cs_input_buf, PD_MAX_BUFFER, fin) != NULL) {
		iCurrLine++;

		/* START check bank account number */
		if (iCurrLine == iBankAcctRow && iBankAcctRow > 0) {
			csTmp = strstr(cs_input_buf, cs_acct_num);
			if (csTmp == NULL) {
				iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile() bank account number does not match!!!\n"));
ERRLOG("BOOLBankStmt::ProcessStmtFile() bank account does not match!!!\n");
				break;
			}
		}
		/* END check bank account number */

		if (iCurrLine == iStartRow && iTotalField > 0) {
			iTmp = 0;
			csTmp = mystrtok(cs_input_buf, csDelimiter);
			while (csTmp != NULL) {
				iTmp++;
				csTmp = mystrtok(NULL, csDelimiter);
			}
			if (iTmp != iTotalField) {
				iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile:: File Err! (expect:%d) Total Field [%d] FAILURE!!!\n", iTotalField, iTmp));
				break;
			}
		}
		iTotalLine++;
	}

	if (iRet == SUCCESS) {
		if (iTotalLine <= iStartRow + iEndRow - 2) {
			iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile:: File Err! (Start:%d End:%d) Total Row [%d] FAILURE!!!\n", iStartRow, iEndRow, iTotalLine));
		}
	}
DEBUGLOG(("ProcessStmtFile:: End Checking File\n\n"));


/* Acct Ccy */
	if (iRet == SUCCESS) {
DEBUGLOG(("ProcessStmtFile:: DBOLBankAccts::GetAcctCcy() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLBankAccts", "GetAcctCcy");
		if ((*DBObjPtr)(cs_bank_code, cs_acct_num, csCcy)) {
			iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile:: DBOLBankAccts::GetAcctCcy:: FAILURE\n"));
		}
	}


/* Statement Header */
	hash_init(hRec, 0);

	if (iRet == SUCCESS && iDebugLine <= 0) {
		PutField_CString(hRec,"int_bank_code", cs_bank_code);
		PutField_CString(hRec,"bank_acct_num", cs_acct_num);
		PutField_CString(hRec,"create_user", PD_UPDATE_USER);

		strcpy(csTag, cs_file_name);
		csStartName = mystrtok(csTag, ".");
		csEndName = mystrtok(NULL, ".");

DEBUGLOG(("ProcessStmtFile:: DBOLStatement::GetNextHeaderFileIndex() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetNextHeaderFileIndex");
		iHdrRet = (unsigned long)(*DBObjPtr)(csStartName, csEndName, cs_file_name, &iTmp);
		if (iHdrRet != PD_FOUND && iHdrRet != PD_NOT_FOUND) {
			iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile:: DBOLStatement::GetNextHeaderFileIndex:: FAILURE!!!\n"));
		}
		else if (iHdrRet == PD_FOUND) {
			sprintf(csNewFileName,"%s(%d).%s",csStartName,iTmp,csEndName);
DEBUGLOG(("ProcessStmtFile:: New filename = [%s]\n",csNewFileName));
		} else if (iHdrRet == PD_NOT_FOUND) {
			strcpy(csNewFileName,cs_file_name);
		}
		PutField_CString(hRec,"filename",csNewFileName);
	}

	if (iRet == SUCCESS && iDebugLine <= 0) {
DEBUGLOG(("ProcessStmtFile:: DBOLStatement::AddHeader() called\n"));
		DBObjPtr = CreateObj(DBPtr,"DBOLStatement","AddHeader");
		if ((*DBObjPtr)(hRec)) {
			iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile:: DBOLStatement::AddHeader:: FAILURE!!!\n"));
		}
	}
	hash_destroy(hRec);

/* Statement Detail */
	if (iRet==SUCCESS)
DEBUGLOG(("ProcessStmtFile:: Start Reading File\n"));
	iCurrLine=0;
	rewind(fin);
	while (iRet==SUCCESS && fgets(cs_input_buf,PD_MAX_BUFFER,fin)!=NULL) {
		cs_input_buf[strlen(cs_input_buf)-1] = '\0';

		iCurrLine++;
		if(iCurrLine < iStartRow || iCurrLine > iTotalLine-iEndRow+1)
			continue;

		if(iDebugLine > 0 && iDebugLine != iCurrLine)
			continue;

if(iDebugLine>0) DEBUGLOG(("line = [%s]\n",cs_input_buf));

		hRec = (hash_t*) malloc (sizeof(hash_t));
		hash_init(hRec, 0);

		iDtlRet = splitLineByhFormat(cs_input_buf,csFormatId,hFormat,hRec,iDebugLine);

		if (iDtlRet == SUCCESS) {
			PutField_CString(hRec,"filename",csNewFileName);
			PutField_CString(hRec,"int_bank_code",cs_bank_code);
			PutField_CString(hRec,"bank_acct_num",cs_acct_num);
			PutField_Int(hRec,"statement_seq",iStatementSeq);
			PutField_CString(hRec,"create_user",PD_UPDATE_USER);

			PutField_Char(hRec,"status",PD_STATUS_UNALLOCATED);
			if (!GetField_CString(hRec,"txn_ccy",&csTmp))
				PutField_CString(hRec,"txn_ccy",csCcy);

			DBObjPtr = CreateObj(DBPtr,"DBOLStatement","CheckDetail");
			if ((*DBObjPtr)(iCurrLine,hRec)) {
				iDtlRet = FAILURE;
DEBUGLOG(("ProcessStmtFile:: DBOLStatement::CheckDetail:: FAILURE!!!\n"));
			}
		}

		if (iDtlRet == SUCCESS) {
			RecordSet_Add(rRecordFile, hRec);
			iStatementSeq++;
		}
	}

	if (iRet == SUCCESS) {
DEBUGLOG(("ProcessStmtFile:: End Reading File\n\n"));
	}

	/* START sorting */
	/* END sorting*/

	/* START check running balance */
	if (iRet == SUCCESS) {
		// TO BE IMPLEMENTED : should get initial running balance from DB
		hFile = RecordSet_GetFirst(rRecordFile);
		GetField_CString(hFile, "balance", &csTmp);
		dRunBal = atof(csTmp);
		//

		hFile = RecordSet_GetNext(rRecordFile);
		while (hFile) {
			GetField_CString(hFile, "balance", &csTmp);
			dBal = atof(csTmp);
			GetField_CString(hFile, "amt_type", &csAmtType);
			GetField_CString(hFile, "txn_amount", &csTmp);
			dTxnAmt = atof(csTmp);

			if (strcmp(csAmtType, PD_CR) == 0)
				dCalBal = dRunBal + dTxnAmt;
			else
				dCalBal = dRunBal - dTxnAmt;

// DEBUGLOG(("expected: [%.2f]\n", dBal));
// DEBUGLOG(("actual  : [%.2f] = [%.2f] [%s] [%.2f]\n", dCalBal, dRunBal, csAmtType, dTxnAmt));

			if (abs(dCalBal - dBal) < 1E-9)
				dRunBal = dCalBal;
			else {
				iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile() running balance does not match!!! expected: [%.2f] actual: [%.2f]\n", dBal, dCalBal));
ERRLOG("BOOLBankStmt::ProcessStmtFile() running balance does not match!!! expected: [%.2f] actual: [%.2f]\n", dBal, dCalBal);
				break;
			}

			hFile = RecordSet_GetNext(rRecordFile);
		}
	}
	/* END check running balance */

	/* START get existing bank statement records */
	if (iRet == SUCCESS) {
		hFile = RecordSet_GetFirst(rRecordFile);
DEBUGLOG(("ProcessStmtFile() call DBOLStatement::GetPastRecord()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetPastRecord");
		iRet = (unsigned long)(*DBObjPtr)(cs_bank_code, cs_acct_num, hFile, hRec, rRecordDb);
		if (iRet == PD_ERR) {
			iRet = FAILURE;
DEBUGLOG(("ConvertStmtFile() call DBOLStatement::GetPastRecord() failed!!!\n"));
ERRLOG("BOOLBankStmt::ConvertStmtFile() call DBOLStatement::GetPastRecord() failed!!!\n");
		} else {
			iRet = SUCCESS;
DEBUGLOG(("ConvertStmtFile() call DBOLStatement::GetPastRecord() success!!!\n"));
		}
	}
	/* END get existing bank statement records */

	/* START de-duplication */
	if (iRet == SUCCESS) {
		char csFileCompareKey[PD_MAX_BUFFER] = "";
		char csDbCompareKey[PD_MAX_BUFFER] = "";
		int iCmpResult;

		hFile = RecordSet_GetFirst(rRecordFile);
		hDb = RecordSet_GetFirst(rRecordDb);

		while (hFile && hDb) {
			getCompareKey(hFile, csFileCompareKey);
			getCompareKey(hDb, csDbCompareKey);
// DEBUGLOG(("csFileCompareKey = [%s]\n", csFileCompareKey));
// DEBUGLOG(("csDbCompareKey = [%s]\n", csDbCompareKey));
			iCmpResult = strcmp(csFileCompareKey, csDbCompareKey);
// DEBUGLOG(("iCmpResult = [%i]\n", iCmpResult));

			if (iCmpResult == 0) {
				/* same, skip */
				iSkipCount++;
				PutField_CString(hFile, "as_ind", "skip");
				hFile = RecordSet_GetNext(rRecordFile);
				hDb = RecordSet_GetNext(rRecordDb);
			} else if (iCmpResult > 0) {
				hDb = RecordSet_GetNext(rRecordDb);
			} else if (iCmpResult < 0) {
				iAcceptCount++;
				PutField_CString(hFile, "as_ind", "accept");
// DEBUGLOG(("New!!! csFileCompareKey: [%s]\n", csFileCompareKey));
// DEBUGLOG(("New!!! csDbCompareKey: [%s]\n", csDbCompareKey));
				hFile = RecordSet_GetNext(rRecordFile);
			}
		}

		while (hFile) {
			getCompareKey(hFile, csFileCompareKey);
			iAcceptCount++;
			PutField_CString(hFile, "as_ind", "accept");
// DEBUGLOG(("New!!! csFileCompareKey: [%s]\n", csFileCompareKey));
			hFile = RecordSet_GetNext(rRecordFile);
		}
	}
	/* END de-duplication */

	/* START insert detail */
	if (iRet == SUCCESS) {
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "AddDetail");
		hFile = RecordSet_GetFirst(rRecordFile);
		while (hFile) {
			GetField_CString(hFile, "as_ind", &csTmp);
			if (strcmp(csTmp, "accept") == 0) {
				GetField_Int(hFile, "statement_seq", &iStatementSeq);
				if ((*DBObjPtr)(iStatementSeq, hFile)) {
DEBUGLOG(("ProcessStmtFile:: call DBOLStatement::AddDetail:: failed!!!\n"));
					// TO BE IMPLEMENTED : should handle insert error records
				}
			}
			hFile = RecordSet_GetNext(rRecordFile);
		}
	}
	/* END insert detail */

	//// hash_destroy(hRec);

/* Statement Header */
	if (iRet == SUCCESS && iDebugLine <= 0) {
		hRec = (hash_t*) malloc (sizeof(hash_t));
		hash_init(hRec,0);

		PutField_CString(hRec,"filename",csNewFileName);
		PutField_Int(hRec,"skip_count",iSkipCount);
		PutField_Int(hRec,"accept_count",iAcceptCount);
		PutField_Int(hRec,"total_count",(iTotalLine-iStartRow-iEndRow+2));
		PutField_CString(hRec,"update_user",PD_UPDATE_USER);

DEBUGLOG(("ProcessStmtFile:: DBOLStatement::UpdateHeader() called\n"));
		DBObjPtr = CreateObj(DBPtr,"DBOLStatement","UpdateHeader");
		if ((*DBObjPtr)(hRec)) {
			iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile:: DBOLStatement::UpdateHeader:: FAILURE!!!\n"));
		}
		hash_destroy(hRec);
	}

	if (iRet == SUCCESS) {
DEBUGLOG(("ProcessStmtFile:: Result: Accept[%d]/Skip[%d]/Total[%d]\n",iAcceptCount,iSkipCount,(iTotalLine-iStartRow-iEndRow+2)));
printf("ProcessStmtFile:: Result: Accept[%d]/Skip[%d]/Total[%d]\n",iAcceptCount,iSkipCount,(iTotalLine-iStartRow-iEndRow+2));
	}

	fclose(fin);

	hash_destroy(hFormat);
	FREE_ME(hFormat);

	RecordSet_Destroy(rRecordFile);
	FREE_ME(rRecordFile);
	RecordSet_Destroy(rRecordDb);
	FREE_ME(rRecordDb);
	// hash_destroy(hFile);
	FREE_ME(hFile);
	// hash_destroy(hDb);
	FREE_ME(hDb);

	FREE_ME(hRec);
	FREE_ME(csTag);

	return iRet;
}


char *mystrtok_r(char *string, const char *seps, char **context)
{
	char *head;  /* start of word */
	char *tail;  /* end of word */

	/* If we're starting up, initialize context */
	if (string) {
		*context = string;
	}

	/* Get potential start of this next word */
	head = *context;
	if (head == NULL) {
		return NULL;
	}

	/* Skip any leading separators
	while (*head && strchr(seps, *head)) {
		head++;
	}*/

	/* Did we hit the end? */
	if (*head == 0) {
		/* Nothing left */
		*context = NULL;
		return NULL;
	}

	/* skip over word */
	tail = head;
	while (*tail && !strchr(seps, *tail)) {
		tail++;
	}

	/* Save head for next time in context */
	if (*tail == 0) {
		*context = NULL;
	}
	else {
		*tail = 0;
		tail++;
		*context = tail;
	}

	/* Return current word */
	return head;
}


int splitLineByhFormat(const char* csLine, const char* csFormatId,
				const hash_t* hFormat, hash_t* hRec, int iDebugLine)
{
	int	iRet = SUCCESS;
	char	*csDesc, *csTemplate;
	int	iNextLevel;

	char	*csDelimiter, *csFirstField, *csRemainField;
	int	iFieldCount = 1;
	char	*csTag = (char*) malloc (64);

	char	csTmpField[PD_MAX_BUFFER + 1];
	char	csTmpLine[PD_MAX_BUFFER + 1];
	strcpy(csTmpLine, csLine);

	sprintf(csTag,"%s_%s",PD_FORMAT_TYPE_DELIMITER,csFormatId);
	if (!GetField_CString(hFormat,csTag,&csDelimiter)) {
		iRet = FAILURE;
DEBUGLOG(("ProcessStmtFile:: INT ERR! %s NOT FOUND!!!\n",csTag));
	}

	csFirstField = mystrtok_r(csTmpLine,csDelimiter,&csRemainField);
	while (csFirstField != NULL && iRet == SUCCESS) {//
		strcpy(csTmpField,TrimAll((const unsigned char*)csFirstField,strlen(csFirstField)));
if (iDebugLine > 0) DEBUGLOG((" %s_%d: [%s]\n",csFormatId,iFieldCount,csTmpField));

		sprintf(csTag,"%s_%s_%d",PD_FORMAT_DESC,csFormatId,iFieldCount);
		if (!GetField_CString(hFormat,csTag,&csDesc)) {
		}

		sprintf(csTag,"%s_%s_%d",PD_FORMAT_NEXT_LEVEL,csFormatId,iFieldCount);
		if (GetField_Int(hFormat,csTag,&iNextLevel)) {
			if (iNextLevel == 1) {
				iRet=splitLineByhFormat(csTmpField,csDesc,hFormat,hRec,iDebugLine);//
			} else if (iNextLevel == 0){
				if (!strcmp(csDesc,PD_CR_TXN_AMOUNT) && atof(csTmpField)) {
					PutField_CString(hRec,"amt_type",PD_CR);
					PutField_CString(hRec,PD_TXN_AMOUNT,csTmpField);
if (iDebugLine > 0) DEBUGLOG(("   #[%s](%s) = [%s]\n",PD_TXN_AMOUNT,PD_CR,csTmpField));
				} else if (!strcmp(csDesc,PD_DR_TXN_AMOUNT) && atof(csTmpField)) {
					PutField_CString(hRec,"amt_type",PD_DR);
					PutField_CString(hRec,PD_TXN_AMOUNT,csTmpField);
if (iDebugLine > 0) DEBUGLOG(("   #[%s](%s) = [%s]\n",PD_TXN_AMOUNT,PD_DR,csTmpField));
				} else if (strcmp(csTmpField,"")){
					PutField_CString(hRec,csDesc,csTmpField);
if (iDebugLine > 0) DEBUGLOG(("   #[%s] = [%s]\n",csDesc,csTmpField));
				}
			}
		}

		sprintf(csTag,"%s_%s_%d",PD_FORMAT_TEMPLATE,csFormatId,iFieldCount);
		if (GetField_CString(hFormat,csTag,&csTemplate)) {
			sprintf(csTag,"%s_t",csDesc);
			PutField_CString(hRec,csTag,csTemplate);
		}

		iFieldCount++;
		csFirstField = mystrtok_r(NULL,csDelimiter,&csRemainField);//
	}//

	free(csTag);

	return iRet;
}


int getCompareKey(const hash_t* hRec, char* csCompareKey)
{
	char *csTmp;
	double dTmp;
	char csTmpCompareKey[PD_MAX_BUFFER] = "";

	if (GetField_CString(hRec, "stmt_datetime", &csTmp)) {
		strcat(csTmpCompareKey, csTmp);
	} else {
DEBUGLOG(("getCompareKey() stmt_datetime is missing!!!\n"));
ERRLOG("BOOLBankStmt::getCompareKey() stmt_datetime is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "txn_ccy", &csTmp)) {
		strcat(csTmpCompareKey, csTmp);
	} else {
DEBUGLOG(("getCompareKey() txn_ccy is missing!!!\n"));
ERRLOG("BOOLBankStmt::getCompareKey() txn_ccy is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "amt_type", &csTmp)) {
		strcat(csTmpCompareKey, csTmp);
	} else {
DEBUGLOG(("getCompareKey() amt_type is missing!!!\n"));
ERRLOG("BOOLBankStmt::getCompareKey() amt_type is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "txn_amount", &csTmp)) {
		dTmp = atof(csTmp);
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else if (GetField_Double(hRec, "txn_amount", &dTmp)) {
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else {
DEBUGLOG(("getCompareKey() txn_amount is missing!!!\n"));
ERRLOG("BOOLBankStmt::getCompareKey() txn_amount is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "balance", &csTmp)) {
		dTmp = atof(csTmp);
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else if (GetField_Double(hRec, "balance", &dTmp)) {
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else {
DEBUGLOG(("getCompareKey() balance is missing!!!\n"));
ERRLOG("BOOLBankStmt::getCompareKey() balance is missing!!!\n");
		return PD_ERR;
	}

// DEBUGLOG(("csTmpCompareKey = [%s]\n", csTmpCompareKey));

	strcpy(csCompareKey, csTmpCompareKey);

	return PD_OK;
}
