/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/07/26              David Wong
Add ProcessStmtFile                                2013/07/29              Stan Poon
Add running balance checking                       2013/08/06              David Wong
Add de-duplication                                 2013/08/15              David Wong
Add error table					   2013/09/17		   Stan Poon
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "dbutility.h"
#include "BOOLBankStmt.h"
#include "myrecordset.h"
#include "myhash.h"
#include "math.h"

#define	IN_FILE_EXT_DELIMITER	"."
#define	EXCEL_CONVERT_SCRIPT	"xls2txt"
#define	TEXT_CONVERT_SCRIPT	"iconv"
#define	OUT_FILE_ENCODING	"UTF-8"
#define PD_RAW			"raw"
#define PD_CONVERTED		"converted"

#define	PD_FMT_TYPE_HOLD		"hold"
#define	PD_FMT_TYPE_DELIMITER		"delimiter"

#define	PD_FMT_TYPE_BANK_ACCT_ROW	"bank_acct_row"
#define	PD_FMT_TYPE_START_YEAR		"start_year"
#define	PD_FMT_TYPE_SORT		"sort"
#define	PD_FMT_TYPE_TOTAL_FIELD		"total_field"
#define	PD_FMT_TYPE_START_ROW		"start_row"
#define	PD_FMT_TYPE_END_ROW		"end_row"

#define	PD_FMT_FORMAT_ID	"format_id"
#define	PD_FMT_NEXT_LEVEL	"nextlevel"
#define	PD_FMT_DESC		"desc"
#define	PD_FMT_TEMPLATE		"template"

#define	PD_HOLD_DELIMITER	","

char cDebug;
OBJPTR(DB);
OBJPTR(BO);

void BOOLBankStmt(char cdebug)
{
	cDebug = cdebug;
}

int ProcessAuxStmtFile(hash_t *hContext, hash_t *hRequest)
{
	int iRet = PD_OK;

	FILE *fin;
	char *csInFileName, *csInFilePath, *csTmp;

/* in_file_name */
	if (GetField_CString(hContext, "in_file_name", &csInFileName)) {
DEBUGLOG(("ProcessAuxStmtFile:: in_file_name = [%s]\n", csInFileName));
	}

/* in_file_path */
	if (GetField_CString(hContext, "in_file_path", &csInFilePath)) {
DEBUGLOG(("ProcessAuxStmtFile:: in_file_path = [%s]\n", csInFilePath));
	}

/* open file */
	if (iRet == PD_OK) {
		sprintf(csTmp, "%s/%s", csInFilePath, csInFileName);
DEBUGLOG(("ProcessAuxStmtFile:: ready to open file [%s]\n", csTmp));
		fin = fopen(csTmp, "r");
		if (fin == NULL) {
			iRet = INT_FILE_NOT_FOUND;
DEBUGLOG(("ProcessAuxStmtFile:: cannot open file [%s]\n", csTmp));
ERRLOG("BOOLBankStmt:: ProcessAuxStmtFile:: cannot open file [%s]\n", csTmp);
		}
	}


	return iRet;
}


int ConvertStmtFile(hash_t* hContext, char* csOutFileName)
{
	int iRet = PD_OK;
	int iCnt = 0;
	char csTmpForStrtok[PD_TMP_BUF_LEN];
	char *csTmp;
	char *csInFileName, *csInFilePath, *csIntBankCode;
	char csInFileExt[PD_TMP_BUF_LEN];
	char csScriptName[PD_TMP_BUF_LEN];
	char csInFileEncoding[PD_TMP_BUF_LEN];
	char csInFilePrefix[PD_TMP_BUF_LEN];
	char csInFileCountry[PD_TMP_BUF_LEN];
	char csTmpInFileName[PD_TMP_BUF_LEN];
	char csTmpOutFileName[PD_TMP_BUF_LEN];
	char csSysCmd[PD_TMP_BUF_LEN];

/* in_file_name */
	if (GetField_CString(hContext, "in_file_name", &csInFileName)) {
DEBUGLOG(("ConvertStmtFile in_file_name = [%s]\n", csInFileName));
	}

/* in_file_path */
	if (GetField_CString(hContext, "in_file_path", &csInFilePath)) {
DEBUGLOG(("ConvertStmtFile in_file_path = [%s]\n", csInFilePath));
	}

/* int_bank_code */
	if (GetField_CString(hContext, "int_bank_code", &csIntBankCode)) {
DEBUGLOG(("ConvertStmtFile int_bank_code = [%s]\n", csIntBankCode));
	}

/* get in_file_ext */
	if (iRet == PD_OK) {
		iCnt = 0;
		strcpy(csTmpForStrtok, csInFileName);
		csTmp = strtok(csTmpForStrtok, IN_FILE_EXT_DELIMITER);
		while (csTmp != NULL) {
// DEBUGLOG(("ConvertStmtFile in_file_name token: [%s]\n", csTmp));
			iCnt++;
			strcpy(csInFileExt, csTmp);
			csTmp = strtok(NULL, IN_FILE_EXT_DELIMITER);
		}

		if (iCnt > 0) {
//DEBUGLOG(("ConvertStmtFile in_file_ext = [%s]\n", csInFileExt));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("ConvertStmtFile in_file_ext is missing!!!\n"));
//ERRLOG("BOOLBankStmt::ConvertStmtFile() in_file_ext is missing!!!\n");
		}
	}

/* get convert info */
	if (iRet == PD_OK) {
DEBUGLOG(("ConvertStmtFile call OLStmtConvertScript::GetConvertInfo()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtConvertScript", "GetConvertInfo");
		iRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csInFileExt, csScriptName, csInFileEncoding, csInFilePrefix, csInFileCountry);

		if (iRet == PD_OK) {
//DEBUGLOG(("ConvertStmtFile script_name = [%s]\n", csScriptName));
//DEBUGLOG(("ConvertStmtFile in_file_encoding = [%s]\n", csInFileEncoding));
//DEBUGLOG(("ConvertStmtFile in_file_prefix = [%s]\n", csInFilePrefix));
//DEBUGLOG(("ConvertStmtFile in_file_country = [%s]\n", csInFileCountry));
//DEBUGLOG(("ConvertStmtFile call OLStmtConvertScript::GetConvertInfo() success\n"));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("ConvertStmtFile call OLStmtConvertScript::GetConvertInfo() FAILURE!!!\n"));
//ERRLOG("BOOLBankStmt::ConvertStmtFile() call OLStmtConvertScript::GetConvertInfo() FAILURE!!!\n");
		}
	}

/* do the conversion
example: xls2csv -x "spreadsheet.xls" -b WINDOWS-1252 -c "csvfile.csv" -a UTF-8
example: iconv -f WINDOWS-1252 -t UTF-8 "spreadsheet.xls"
example: xls2txt "spreadsheet.xls"
*/
	if (iRet == PD_OK) {
		snprintf(csTmpInFileName, sizeof(csTmpInFileName), "%s/%s", csInFilePath, csInFileName);
		csInFilePath[strlen(csInFilePath)-strlen(PD_RAW)] = '\0';
		snprintf(csTmpOutFileName, sizeof(csTmpOutFileName), "%s%s/%s", csInFilePath, PD_CONVERTED, csInFileName);
		if (!strcmp(csScriptName, EXCEL_CONVERT_SCRIPT)) {
			snprintf(csSysCmd, sizeof(csSysCmd), "%s \"%s\" > \"%s\"", EXCEL_CONVERT_SCRIPT, csTmpInFileName, csTmpOutFileName);
		}
		else if (!strcmp(csScriptName, TEXT_CONVERT_SCRIPT)) {
			snprintf(csSysCmd, sizeof(csSysCmd), "%s -f %s -t %s \"%s\" > \"%s\"", TEXT_CONVERT_SCRIPT, csInFileEncoding, OUT_FILE_ENCODING, csTmpInFileName, csTmpOutFileName);
		} else {
			snprintf(csSysCmd, sizeof(csSysCmd), "cd $HOME/bin/batch/ ; %s %s %s %s %s", csScriptName, csInFileEncoding, OUT_FILE_ENCODING, csTmpInFileName, csTmpOutFileName);
		}
DEBUGLOG(("ConvertStmtFile call system command [%s]\n", csSysCmd));
		iRet = system(csSysCmd);

		if (iRet == PD_OK) {
			strcpy(csOutFileName, csTmpOutFileName);
		} else {
DEBUGLOG(("ConvertStmtFile conversion FAILURE!!!\n"));
//ERRLOG("BOOLBankStmt::ConvertStmtFile() conversion FAILURE!!!\n");
		}
	}

DEBUGLOG(("ConvertStmtFile Normal Exit! iRet = [%d]\n", iRet));

	return iRet;
}


struct node
{
	hash_t *hDtl;
	struct node *next;
};

char *mystrtok_r(char *string, const char *seps, char **context);
int splitLineByhFormat(const char* csLine, const char* csFormatId, const hash_t* hFormat, hash_t* hRec);
int GetCompareKey(const hash_t* hRec, char* csCompareKey);
int DeDupAndBalCheck(const char* csIntBankCode, const char* csBankAcctNum,
			recordset_t *rRecordFile, recordset_t *rRecordDb, char* cs_err_buf, int *iLine);

int ProcessStmtFile(hash_t *hContext, const char* csOutFullName, recordset_t* rRecordFormat)
{
	int iRet = PD_OK, iTmpRet = PD_OK;
	int iCurrLine = 0, iTotalLine = 0;
	char *csFormatId, *csDelimiter;
	int iBankAcctRow, iStartYear, iReverse, iTotalField, iStartRow, iEndRow;
	int iFormatCount = 0, iCount = 0;
	int iTotalCount = 0, iAcceptCount = 0, iHoldCount = 0, iSkipCount = 0;

	FILE *fin;
	char *csInFileName, *csIntBankCode, *csBankAcctNum, *csUser, *csCcy;
	char cs_input_buf[PD_TMP_MSG_BUF_LEN];
	char cs_tmp_buf[PD_TMP_BUF_LEN];
	char cs_err_buf[PD_TMP_BUF_LEN];
	char csStartDate[PD_DATE_LEN + 1], csStartTime[PD_TIME_LEN + 1];
	char csEndDate[PD_DATE_LEN + 1], csEndTime[PD_TIME_LEN + 1];
	int iStatementSeq = 1;

	char *csTag = (char*) malloc (64);
	char *csCmd = (char *) malloc (PD_TMP_BUF_LEN-1 + 30 + 1);
	FILE *stream;
	char *csTmp;
	int iTmp=0, iLine;

	struct node *head = NULL, *tail = NULL, *temp = NULL, *currentNode;

	hash_t *hFormat;
	hash_t *hRec;
	hash_t *hFile;

	recordset_t *rRecordFile;
	rRecordFile = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordFile, 0);
	recordset_t *rRecordDb;
	rRecordDb = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordDb, 0);

/* in_file_name */
	if (GetField_CString(hContext, "in_file_name", &csInFileName)) {
DEBUGLOG(("ProcessStmtFile in_file_name = [%s]\n", csInFileName));
	}

/* int_bank_code */
	if (GetField_CString(hContext, "int_bank_code", &csIntBankCode)) {
DEBUGLOG(("ProcessStmtFile int_bank_code = [%s]\n", csIntBankCode));
	}

/* bank_acct_num */
	if (GetField_CString(hContext, "bank_acct_num", &csBankAcctNum)) {
DEBUGLOG(("ProcessStmtFile bank_acct_num = [%s]\n", csBankAcctNum));
	}

/* user */
	if (GetField_CString(hContext, "add_user", &csUser)) {
DEBUGLOG(("ProcessStmtFile user = [%s]\n", csUser));
	}

/* ccy */
	if (GetField_CString(hContext, "txn_ccy", &csCcy)) {
DEBUGLOG(("ProcessStmtFile ccy = [%s]\n", csCcy));
	}

/* file */
	fin = fopen(csOutFullName, "r");
	if (fin == NULL) {
DEBUGLOG(("ProcessStmtFile cannot open file [%s]!!!\n", csInFileName));
ERRLOG("BOOLBankStmt:: ProcessStmtFile() cannot open file [%s]!!!\n", csInFileName);
		iRet = INT_ERR;
	}


/* Support Multi format */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile Start Checking Format\n"));
		hFormat = RecordSet_GetFirst(rRecordFormat);
		snprintf(cs_err_buf, sizeof(cs_err_buf), "No Format Matched");
		while (hFormat) {
			iCurrLine = 0;
			iTotalLine = 0;
			rewind(fin);
/* format_id */
			if (!GetField_CString(hFormat, PD_FMT_FORMAT_ID, &csFormatId)) {
DEBUGLOG(("ProcessStmtFile Format ID NOT FOUND!!!\n"));
			} else {
/* delimiter */
				sprintf(csTag, "%s_%s", PD_FMT_TYPE_DELIMITER, csFormatId);
				if (!GetField_CString(hFormat, csTag, &csDelimiter)) {
DEBUGLOG(("ProcessStmtFile Delimiter NOT FOUND!!!\n"));
				}
			}
/* bank_acct_row */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_BANK_ACCT_ROW, &csTmp)) {
				iBankAcctRow = 0;
			} else {
				iBankAcctRow = atoi(csTmp);
			}
/* start_year */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_START_YEAR, &csTmp)) {
				iStartYear = 0;
			} else {
				iStartYear = atoi(csTmp);
			}
/* sort */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_SORT, &csTmp)) {
				iReverse = 0;
			} else if (!strcmp(csTmp, "REVERSE")) {
				iReverse = 1;
			} else {
				iReverse = 0;
			}
/* total_field */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_TOTAL_FIELD, &csTmp)) {
				iTotalField = 0;
			} else {
				iTotalField = atoi(csTmp);
			}
/* start_row */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_START_ROW, &csTmp)) {
				iStartRow = 1;
			} else {
				iStartRow = atoi(csTmp);
			}
/* end_row */
			if (!GetField_CString(hFormat, PD_FMT_TYPE_END_ROW, &csTmp)) {
				iEndRow = 1;
			} else {
				iEndRow = atoi(csTmp);
			}

			while (fgets(cs_input_buf, sizeof(cs_input_buf)-1, fin) != NULL) {
				iCurrLine++;
				if (iCurrLine == iStartRow && iTotalField > 0) {
					strcpy(cs_tmp_buf,cs_input_buf);
					iTmp = 0;
					csTmp = mystrtok(cs_tmp_buf, csDelimiter);
					while (csTmp != NULL) {
						iTmp++;
						csTmp = mystrtok(NULL, csDelimiter);
					}
DEBUGLOG(("ProcessStmtFile format_id[%s] counted_field[%d]/total_field[%d]\n",csFormatId,iTmp,iTotalField));
					if (iTmp != iTotalField) {
						snprintf(cs_tmp_buf,sizeof(cs_tmp_buf)," at line %d (Field[%d/%d])",iStartRow,iTmp,iTotalField);
						strncat(cs_err_buf,cs_tmp_buf,sizeof(cs_err_buf)-strlen(cs_err_buf)-1);
						break;
					} else {
						iFormatCount = 1;
					}
				}
				iTotalLine++;
			}

			if (iFormatCount == 1)
				break;

			hFormat = RecordSet_GetNext(rRecordFormat);
		}
DEBUGLOG(("ProcessStmtFile End Checking Format\n"));

		if (iFormatCount != 1) {
			iRet = INT_FORMAT_NOT_MATCH;
DEBUGLOG(("ProcessStmtFile No format matches!!!\n"));
//ERRLOG("BOOLBankStmt:: ProcessStmtFile() No format matches!!!\n");
			PutField_Int(hContext, "record_cnt", 1);
			PutField_CString(hContext, "line_1", cs_input_buf);
			PutField_CString(hContext, "result_1", cs_err_buf);
		}
	}

/* Check START ROW and End Row */
	if (iRet == PD_OK) {
		iTotalCount = iTotalLine - iStartRow - iEndRow + 2;

		iCurrLine = iStartRow - 1;
		sprintf(csCmd,"sed -n '%dp' %s",iCurrLine,csOutFullName);
		stream = popen(csCmd, "r");
		if (fgets(cs_input_buf, sizeof(cs_input_buf)-1, stream) != NULL) {
			hRec = (hash_t*) malloc (sizeof(hash_t));
			hash_init(hRec, 0);
DEBUGLOG(("csCmd = [%s]\n",csCmd));
// DEBUGLOG(("cs_input_buf = [%s]\n",cs_input_buf));
			PutField_Int(hRec, "line", iCurrLine);
			PutField_Int(hRec, "start_year", iStartYear);
			iTmpRet = splitLineByhFormat(cs_input_buf, csFormatId, hFormat, hRec);
			DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "CheckDetail");
			if (!(*DBObjPtr)(csCcy, hRec, cs_err_buf)) {
				iRet = INT_RECORD_NOT_MATCH;
DEBUGLOG(("ProcessStmtFile Extra Row FOUND!!!\n"));
				snprintf(cs_err_buf, sizeof(cs_err_buf), "Extra Row Found at line %d", iCurrLine);
				PutField_Int(hContext, "record_cnt", 1);
				PutField_CString(hContext, "line_1", cs_input_buf);
				PutField_CString(hContext, "result_1", cs_err_buf);
			} else {
DEBUGLOG(("ProcessStmtFile Extra Row Checking Success\n"));
			}
			hash_destroy(hRec);
			FREE_ME(hRec);

		}
		pclose(stream);

		iCurrLine = iTotalLine - iEndRow + 2;
		sprintf(csCmd,"sed -n '%dp' %s",iCurrLine,csOutFullName);
		stream = popen(csCmd, "r");
		if (fgets(cs_input_buf, sizeof(cs_input_buf)-1, stream) != NULL) {
			hRec = (hash_t*) malloc (sizeof(hash_t));
			hash_init(hRec, 0);
DEBUGLOG(("csCmd = [%s]\n",csCmd));
// DEBUGLOG(("cs_input_buf = [%s]\n",cs_input_buf));
			PutField_Int(hRec, "line", iCurrLine);
			PutField_Int(hRec, "start_year", iStartYear);
			iTmpRet = splitLineByhFormat(cs_input_buf, csFormatId, hFormat, hRec);
			DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "CheckDetail");
			if (!(*DBObjPtr)(csCcy, hRec, cs_err_buf)) {
				iRet = INT_RECORD_NOT_MATCH;
DEBUGLOG(("ProcessStmtFile Extra Row FOUND!!!\n"));
				snprintf(cs_err_buf, sizeof(cs_err_buf), "Extra Row Found at line %d", iCurrLine);
				PutField_Int(hContext, "record_cnt", 1);
				PutField_CString(hContext, "line_1", cs_input_buf);
				PutField_CString(hContext, "result_1", cs_err_buf);
			} else {
DEBUGLOG(("ProcessStmtFile Extra Row Checking Success\n"));
			}
			hash_destroy(hRec);
			FREE_ME(hRec);

		}
		pclose(stream);
	}

/* Statement Header Add */
	if (iRet == PD_OK) {
		hRec = (hash_t*) malloc (sizeof(hash_t));
		hash_init(hRec, 0);

		PutField_CString(hRec, "filename", csInFileName);
		PutField_CString(hRec, "int_bank_code", csIntBankCode);
		PutField_CString(hRec, "bank_acct_num", csBankAcctNum);
		PutField_Int(hRec, "total_count", iTotalCount);
		PutField_CString(hRec, "create_user", csUser);

DEBUGLOG(("ProcessStmtFile DBOLStatement:: AddHeader() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "AddHeader");
		if ((*DBObjPtr)(hRec)) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile call DBOLStatement:: AddHeader() FAILURE!!!\n"));
//		} else {
//			TxnCommit();
		}

		hash_destroy(hRec);
		FREE_ME(hRec);
	}


/* Statement Detail Preparation */
	if (iRet == PD_OK) {
		iCount = 0;
		iCurrLine = 0;
		rewind(fin);

DEBUGLOG(("ProcessStmtFile Start Reading File\n"));
DEBUGLOG(("ProcessStmtFile CheckDetail()\n"));
		while (fgets(cs_input_buf, sizeof(cs_input_buf)-1, fin) != NULL) {
			if (cs_input_buf[strlen(cs_input_buf)-1] == '\n')
				cs_input_buf[strlen(cs_input_buf)-1] = '\0';
			if (cs_input_buf[strlen(cs_input_buf)-1] == '\r')
				cs_input_buf[strlen(cs_input_buf)-1] = '\0';
			iCurrLine++;

			/* Check bank account number */
			if (iCurrLine == iBankAcctRow) {
				csTmp = strstr(cs_input_buf, csBankAcctNum);
				if (csTmp == NULL) {
					iRet = INT_BANK_ACCT_NOT_MATCH;
DEBUGLOG(("ProcessStmtFile Bank account number does not match!!!\n"));
//ERRLOG("BOOLBankStmt:: ProcessStmtFile() Bank account does not match!!!\n");
					snprintf(cs_err_buf, sizeof(cs_err_buf), "Bank Acc Not Matched at line %d", iCurrLine);
					PutField_Int(hContext, "record_cnt", 1);
					PutField_CString(hContext, "line_1", cs_input_buf);
					PutField_CString(hContext, "result_1", cs_err_buf);
					break;
				}
			}

			/* Skip leading and trailing rows */
			if (iCurrLine < iStartRow || iCurrLine > iTotalLine - iEndRow + 1)
				continue;

			hRec = (hash_t*) malloc (sizeof(hash_t));
			hash_init(hRec, 0);

			currentNode = (struct node*) malloc (sizeof(struct node));
			currentNode->hDtl = hRec;
			if (head == NULL) {
				head = currentNode;
				head->next = NULL;
				tail = head;
			} else if (iReverse == 1) {
				currentNode->next = head;
				head = currentNode;
			} else {
				tail->next = currentNode;
				tail = currentNode;
				tail->next = NULL;
			}

			iTmpRet = splitLineByhFormat(cs_input_buf, csFormatId, hFormat, hRec);
			if (iTmpRet != PD_OK) {
				iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile Format error!!!\n"));
ERRLOG("BOOLBankStmt:: ProcessStmtFile() Format error!!!\n");
				break;
			}

			PutField_CString(hRec, "input_channel", PD_BANK_STATEMENT);
			PutField_Int(hRec, "line", iCurrLine);
			PutField_Int(hRec, "start_year", iStartYear);
			PutField_Char(hRec, "process_group", 'S'); /* ***to do*** */

// DEBUGLOG(("ProcessStmtFile DBOLStatement:: CheckDetail() called\n"));
			DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "CheckDetail");
			if ((*DBObjPtr)(csCcy, hRec, cs_err_buf)) {
				iRet = INT_DETAIL_FIELD_ERROR;
DEBUGLOG(("ProcessStmtFile call DBOLStatement:: CheckDetail() line [%d] FAILURE!!!\n", iCurrLine));
				iCount++;
				sprintf(csTag, "line_%d", iCount);
				PutField_CString(hContext, csTag, cs_input_buf);
				sprintf(csTag, "result_%d", iCount);
				PutField_CString(hContext, csTag, cs_err_buf);
				if (iCount >= PD_NUM_OF_ERROR_LINE) {
					break;
				}
			}
		}
DEBUGLOG(("ProcessStmtFile End Reading File\n"));

		if (iCount > 0) {
			PutField_Int(hContext, "record_cnt", iCount);
		}

		if (head != NULL) {
			hRec = head->hDtl;
			if (GetField_CString(hRec, "statement_date", &csTmp)) {
				snprintf(csStartDate, sizeof(csStartDate), "%s", csTmp);
			}
	
			if (GetField_Int(hRec, "new_stmt_time", &iTmp)) {
				snprintf(csStartTime, sizeof(csStartTime), "000000");
			} else if (GetField_CString(hRec, "statement_time", &csTmp)) {
				snprintf(csStartTime, sizeof(csStartTime), "%s", csTmp);
			}
	
			hRec = tail->hDtl;
			if (GetField_CString(hRec, "statement_date", &csTmp)) {
				snprintf(csEndDate, sizeof(csEndDate), "%s", csTmp);
			}
	
			if (GetField_Int(hRec, "new_stmt_time", &iTmp)) {
				snprintf(csEndTime, sizeof(csEndTime), "235959");
			} else if (GetField_CString(hRec, "statement_time", &csTmp)) {
				snprintf(csEndTime, sizeof(csEndTime), "%s", csTmp);
			}
		}

		while (head != NULL) {
			hRec = head->hDtl;
			RecordSet_Add(rRecordFile, hRec);
			/* delete */
			temp = head;
			head = head->next;
			FREE_ME(temp);
		}
	}


/* De-duplication and Running Balance Check */
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile DBOLStatement:: GetExistingPastRecords() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetExistingPastRecords");
		iTmpRet = (unsigned long)(*DBObjPtr)(csIntBankCode, csBankAcctNum, csStartDate, csStartTime, csEndDate, csEndTime, rRecordDb);
		if (iTmpRet != PD_FOUND && iTmpRet != PD_NOT_FOUND) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile call DBOLStatement:: GetExistingPastRecords() FAILURE!!!\n"));
		}

		if (iRet == PD_OK) {
DEBUGLOG(("ProcessStmtFile DeDupAndBalCheck() called\n"));
			iRet = DeDupAndBalCheck(csIntBankCode, csBankAcctNum, rRecordFile, rRecordDb, cs_err_buf, &iLine);
			if (iRet != PD_OK) {
				iRet = INT_RUNNING_BALANCE_ERROR;
DEBUGLOG(("ProcessStmtFile DeDupAndBalCheck() FAILURE!!!\n"));
				sprintf(csCmd,"sed -n '%dp' %s",iLine,csOutFullName);
				stream = popen(csCmd, "r");
				if (fgets(cs_input_buf, sizeof(cs_input_buf)-1, stream) != NULL) {
					PutField_Int(hContext, "record_cnt", 1);
					PutField_CString(hContext, "line_1", cs_input_buf);
					PutField_CString(hContext, "result_1", cs_err_buf);
				}
				pclose(stream);
			}
		}
	}


/* Statement Detail Add */
	if (iRet == PD_OK) {
		iCount=0;
DEBUGLOG(("ProcessStmtFile DBOLStatement:: AddDetail() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "AddDetail");
		hFile = RecordSet_GetFirst(rRecordFile);
		while (hFile) {
			GetField_CString(hFile, "as_ind", &csTmp);
			if (!strcmp(csTmp, "accept")) {
				PutField_CString(hFile, "filename", csInFileName);
				PutField_CString(hFile, "int_bank_code", csIntBankCode);
				PutField_CString(hFile, "bank_acct_num", csBankAcctNum);
				PutField_Int(hFile, "statement_seq", iStatementSeq);
				if (!GetField_Int(hFile, "hold", &iTmp))
					PutField_Char(hFile, "status", PD_STATUS_UNALLOCATED);
				else {
					iHoldCount++;
					PutField_Char(hFile, "status", PD_STATUS_HOLD);
				}
				PutField_CString(hFile, "create_user", csUser);

				GetField_Int(hFile, "line", &iCurrLine);
				if ((*DBObjPtr)(hFile)) {
					iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile call DBOLStatement:: AddDetail() FAILURE!!!\n"));
					break;
				} else {
					iAcceptCount++;
					iStatementSeq++;
				}
			} else {
				iSkipCount++;
			}
			hFile = RecordSet_GetNext(rRecordFile);
		}
	}


/* Statement Header Update */
	if (iRet == PD_OK) {
		hRec = (hash_t*) malloc (sizeof(hash_t));
		hash_init(hRec, 0);

		PutField_CString(hRec, "filename", csInFileName);
		PutField_Int(hRec, "accept_count", iAcceptCount);
		PutField_Int(hRec, "skip_count", iSkipCount);

DEBUGLOG(("ProcessStmtFile DBOLStatement:: UpdateHeader() called\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "UpdateHeader");
		if ((*DBObjPtr)(hRec)) {
			iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile call DBOLStatement:: UpdateHeader() FAILURE!!!\n"));
		}

		hash_destroy(hRec);
		FREE_ME(hRec);
	}

	if(fin) fclose(fin);

	if (iRet != PD_OK) TxnAbort();

	PutField_Int(hContext,"accept",iAcceptCount);
	PutField_Int(hContext,"hold",iHoldCount);
	PutField_Int(hContext,"skip",iSkipCount);
	PutField_Int(hContext,"total",iTotalCount);
DEBUGLOG(("ProcessStmtFile Result: Accept[%d](Hold[%d])/Skip[%d]/Total[%d]\n", iAcceptCount, iHoldCount, iSkipCount, iTotalCount));

	FREE_ME(csTag);
	FREE_ME(csCmd);

	/*hash_destroy(hFormat);
	FREE_ME(hFormat);
	hash_destroy(hFile);
	FREE_ME(hFile);*/

	RecordSet_Destroy(rRecordFile);
	FREE_ME(rRecordFile);
	RecordSet_Destroy(rRecordDb);
	FREE_ME(rRecordDb);

DEBUGLOG(("ProcessStmtFile iRet = [%d]\n", iRet));
	return iRet;
}


char *mystrtok_r(char *string, const char *seps, char **context)
{
	char *head; /* Start of word */
	char *tail; /* End of word */

	/* If we're starting up, initialize context */
	if (string) {
		*context = string;
	}

	/* Get potential start of this next word */
	head = *context;
	if (head == NULL) {
		return NULL;
	}

	/* Skip any leading separators
	while (*head && strchr(seps, *head)) {
		head++;
	}*/

	/* Did we hit the end? */
	if (*head == 0) {
		/* Nothing left */
		*context = NULL;
		return NULL;
	}

	/* Skip over word */
	tail = head;
	while (*tail && !strchr(seps, *tail)) {
		tail++;
	}

	/* Save head for next time in context */
	if (*tail == 0) {
		*context = NULL;
	} else {
		*tail = 0;
		tail++;
		*context = tail;
	}

	/* Return current word */
	return head;
}


int splitLineByhFormat(const char* csLine, const char* csFormatId,
			const hash_t* hFormat, hash_t* hRec)
{
	int iRet = PD_OK;
	char *csDesc, *csTemplate, *csHold;
	int iNextLevel;

	char *csDelimiter, *csFirstField, *csRemainField, *csHoldFirstField, *csHoldRemainField;
	int iFieldCount = 1, iTmp = 0, iMatch = 0, iNotMatch = 0;
	char *csTag = (char*) malloc (64);

	char csTmpField[PD_TMP_BUF_LEN];
	char csTmpLine[PD_TMP_MSG_BUF_LEN];
	strcpy(csTmpLine, csLine);

	/* Get the delimiter first */
	sprintf(csTag, "%s_%s", PD_FMT_TYPE_DELIMITER, csFormatId);
	if (!GetField_CString(hFormat, csTag, &csDelimiter)) {
		iRet = INT_ERR;
DEBUGLOG(("ProcessStmtFile %s NOT FOUND!!!\n", csTag));
	}

	csFirstField = mystrtok_r(csTmpLine, csDelimiter, &csRemainField);
	while (csFirstField != NULL && iRet == PD_OK) {
		strcpy(csTmpField, TrimAll((const unsigned char*)csFirstField, strlen(csFirstField)));
// DEBUGLOG(("val  : %s_%d : [%s]\n", csFormatId, iFieldCount, csTmpField));

		sprintf(csTag, "%s_%s_%d", PD_FMT_DESC, csFormatId, iFieldCount);
		if (!GetField_CString(hFormat, csTag, &csDesc)) {
			// to be implemented
		}
// DEBUGLOG(("desc : %s_%d : [%s]\n", csFormatId, iFieldCount, csDesc));

		sprintf(csTag, "%s_%s_%d", PD_FMT_NEXT_LEVEL, csFormatId, iFieldCount);
		if (GetField_Int(hFormat, csTag, &iNextLevel)) {
			if (iNextLevel == 1) {
				iRet = splitLineByhFormat(csTmpField, csDesc, hFormat, hRec);
			} else if (iNextLevel == 0) {
				if (strcmp(csTmpField, "")) {
					PutField_CString(hRec, csDesc, csTmpField);
// DEBUGLOG(("#[%s] = [%s]\n", csDesc, csTmpField));
				}
			}
		}

		sprintf(csTag, "%s_%s_%d", PD_FMT_TEMPLATE, csFormatId, iFieldCount);
		if (GetField_CString(hFormat, csTag, &csTemplate)) {
			sprintf(csTag, "%s_t", csDesc);
			PutField_CString(hRec, csTag, csTemplate);
		}

		sprintf(csTag, "%s_%d", PD_FMT_TYPE_HOLD, iFieldCount);
		if (GetField_CString(hFormat, csTag, &csHold)) {
			iTmp = 0;
			csHoldFirstField = mystrtok_r(csHold, PD_HOLD_DELIMITER, &csHoldRemainField);
			while (csHoldFirstField != NULL) {
				if (strstr(csTmpField, csHoldFirstField) != NULL) {
					iTmp++;
					break;
				}
				csHoldFirstField = mystrtok_r(NULL, PD_HOLD_DELIMITER, &csHoldRemainField);
			}
			if (iTmp <= 0) {
				iNotMatch++;
			} else {
				iMatch++;
			}
		}

		iFieldCount++;
		csFirstField = mystrtok_r(NULL, csDelimiter, &csRemainField);
	}

	if (iMatch > 0 && iNotMatch == 0) {
		PutField_Int(hRec, "hold", 1);
	}

	free(csTag);

	return iRet;
}


int GetCompareKey(const hash_t* hRec, char* csCompareKey)
{
	char *csTmp;
	double dTmp;
	int iTmp;
	char csTmpCompareKey[PD_TMP_BUF_LEN] = "";

	if (GetField_CString(hRec, "statement_date", &csTmp)) {
		strcat(csTmpCompareKey, csTmp);
	} else {
DEBUGLOG(("GetCompareKey:: statement_date is missing!!!\n"));
//ERRLOG("BOOLBankStmt:: GetCompareKey:: statement_date is missing!!!\n");
		return PD_ERR;
	}

	if (!GetField_Int(hRec, "new_stmt_time", &iTmp)) {
		if (GetField_CString(hRec, "statement_time", &csTmp)) {
			strcat(csTmpCompareKey, csTmp);
		} else {
DEBUGLOG(("GetCompareKey:: statement_time is missing!!!\n"));
//ERRLOG("BOOLBankStmt:: GetCompareKey:: statement_time is missing!!!\n");
			return PD_ERR;
		}
	}

	if (GetField_CString(hRec, "txn_ccy", &csTmp)) {
		strcat(csTmpCompareKey, csTmp);
	} else {
DEBUGLOG(("GetCompareKey:: txn_ccy is missing!!!\n"));
//ERRLOG("BOOLBankStmt:: GetCompareKey:: txn_ccy is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "amt_type", &csTmp)) {
		strcat(csTmpCompareKey, csTmp);
	} else {
DEBUGLOG(("GetCompareKey:: amt_type is missing!!!\n"));
//ERRLOG("BOOLBankStmt:: GetCompareKey:: amt_type is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "txn_amount", &csTmp)) {
		dTmp = atof(csTmp);
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else if (GetField_Double(hRec, "txn_amount", &dTmp)) {
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else {
DEBUGLOG(("GetCompareKey:: txn_amount is missing!!!\n"));
//ERRLOG("BOOLBankStmt:: GetCompareKey:: txn_amount is missing!!!\n");
		return PD_ERR;
	}

	if (GetField_CString(hRec, "balance", &csTmp)) {
		dTmp = atof(csTmp);
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else if (GetField_Double(hRec, "balance", &dTmp)) {
		sprintf(csTmpCompareKey, "%s%.2f", csTmpCompareKey, dTmp);
	} else {
DEBUGLOG(("GetCompareKey:: balance is missing!!!\n"));
//ERRLOG("BOOLBankStmt:: GetCompareKey:: balance is missing!!!\n");
		return PD_ERR;
	}

	strcpy(csCompareKey, csTmpCompareKey);

	return PD_OK;
}


int DeDupAndBalCheck(const char* csIntBankCode, const char* csBankAcctNum,
			recordset_t *rRecordFile, recordset_t *rRecordDb, char* cs_err_buf, int *iLine)
{
	int iRet = PD_OK;
	int iFound = PD_FOUND;
	int iTmp, iCmpResult;
	char *csTmp;

	char csFileCompareKey[PD_TMP_BUF_LEN] = "";
	char csDbCompareKey[PD_TMP_BUF_LEN] = "";
	char *csAmtType;
	double dRunBal, dBal, dTxnAmt, dCalBal;

	hash_t *hFile;
	hash_t *hDb;

	/* START de-duplication */
	if (iRet == PD_OK) {
		hFile = RecordSet_GetFirst(rRecordFile);
		hDb = RecordSet_GetFirst(rRecordDb);

		while (hFile && hDb) {
			if (GetField_Int(hFile, "new_stmt_time", &iTmp)) {
				PutField_Int(hDb, "new_stmt_time", iTmp);
			}
			GetCompareKey(hFile, csFileCompareKey);
			GetCompareKey(hDb, csDbCompareKey);
			iCmpResult = strcmp(csFileCompareKey, csDbCompareKey);

			if (iCmpResult == 0) {
				/* exist in file and db, skip */
				PutField_CString(hFile, "as_ind", "skip");
				hFile = RecordSet_GetNext(rRecordFile);
				hDb = RecordSet_GetNext(rRecordDb);
			} else if (iCmpResult > 0) {
				/* exist in db but not in file, ignore */
				hDb = RecordSet_GetNext(rRecordDb);
			} else if (iCmpResult < 0) {
				/* exist in file but not in db, accept */
				PutField_CString(hFile, "as_ind", "accept");
				hFile = RecordSet_GetNext(rRecordFile);
			}
		}

		while (hFile) {
			PutField_CString(hFile, "as_ind", "accept");
			hFile = RecordSet_GetNext(rRecordFile);
		}
	}
	/* END de-duplication */

	/* START check running balance */
	if (iRet == PD_OK) {
		hFile = RecordSet_GetFirst(rRecordFile);
		while (hFile) {
			GetField_CString(hFile, "as_ind", &csTmp);
			if (!strcmp(csTmp, "accept")) {
				/* Try to get initial running balance from DB */
				DBObjPtr = CreateObj(DBPtr, "DBOLStatement", "GetLastBalance");
				iFound = (unsigned long)(*DBObjPtr)(csIntBankCode, csBankAcctNum, PD_BANK_STATEMENT, &dRunBal);

				if (iFound == PD_FOUND) {
DEBUGLOG(("DeDupAndBalCheck:: Last balance from DB = [%.2f]\n", dRunBal));
				} else {
DEBUGLOG(("DeDupAndBalCheck:: Last balance from DB not found\n"));
					GetField_CString(hFile, "balance", &csTmp);
					dRunBal = atof(csTmp);
					hFile = RecordSet_GetNext(rRecordFile);
				}
				break;
			} else {
				hFile = RecordSet_GetNext(rRecordFile);
			}
		}

		while (hFile) {
			GetField_CString(hFile, "balance", &csTmp);
			dBal = atof(csTmp);
//DEBUGLOG((" dBal = [%.2lf], csTmp = [%s]\n",dBal,csTmp));
			GetField_CString(hFile, "amt_type", &csAmtType);
			GetField_CString(hFile, "txn_amount", &csTmp);
			dTxnAmt = atof(csTmp);

			if (!strcmp(csAmtType, PD_CR))
				dCalBal = dRunBal + dTxnAmt;
			else
				dCalBal = dRunBal - dTxnAmt;

// DEBUGLOG(("DeDupAndBalCheck:: expected: [%f]\n", dBal));
// DEBUGLOG(("DeDupAndBalCheck:: actual  : [%f] = [%f] [%s] [%f]\n", dCalBal, dRunBal, csAmtType, dTxnAmt));

			if (fabs(dCalBal - dBal) < 1E-9)
				dRunBal = dBal;
			else {
				iRet = INT_ERR;
				GetField_Int(hFile, "line", &iTmp);
				*iLine = iTmp;
				snprintf(cs_err_buf,PD_TMP_BUF_LEN,"Running Balance Error at line %d (Previous Bal[%.2f])", iTmp, dRunBal);
DEBUGLOG(("DeDupAndBalCheck:: running balance does not match!!! at line [%d]\n",iTmp));
DEBUGLOG(("DeDupAndBalCheck:: Previous Balance:[%.2f] Txn Amount:[%.2f] Balance:[%.2f]\n",dRunBal,dTxnAmt,dBal));
//ERRLOG("BOOLBankStmt:: DeDupAndBalCheck:: running balance does not match!!!);
				break;
			}

			hFile = RecordSet_GetNext(rRecordFile);
		}
	}
	/* END check running balance */

/*
	hash_destroy(hFile);
	FREE_ME(hFile);
	hash_destroy(hDb);
	FREE_ME(hDb);
*/

	return iRet;
}

