/*
Partnerdelight (c)2014. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/11/05              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "dbutility.h"
#include "BOOLStmtEngine.h"
#include "myrecordset.h"
#include "myhash.h"
#include "math.h"
#include <time.h>

char cDebug;
OBJPTR(DB);
OBJPTR(BO);
OBJPTR(Txn);


void BOOLStmtEngine(char cdebug)
{
	cDebug = cdebug;
}


int DoAction(hash_t *hContext, hash_t *hMatchRule);
int TmpSkip(hash_t *hMatchFilter);
int CheckKeywords(hash_t *hMatchFilter);
int SplitAmount(hash_t *hMatchFilter);


int ProcessMatching(hash_t *hContext) {
	int iRet = PD_OK;
	int iTmpRet;
	int iTmp;

	char *csBaidTxnId;
	char *csNextEngineAction;
	char *csFailedBaidTxnCode;
	int iSubRuleId;
	int iActionSeq;
	char *csActionType;
	int iFilterId;
	int iExitOnError;

	int iCnt, iMatched, iExitSubRule, iSkipOnce;
	int iLastSubRuleId;
	int iLastActionSeq;
	char csLastActionType[PD_ENGINE_ACTION_LEN + 1];

	hash_t *hMatchEngine;
	hMatchEngine = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hMatchEngine, 0);

	recordset_t *rMatchRule;
	rMatchRule = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rMatchRule, 0);
	hash_t *hMatchRule;

/*
	// get baid_txn_id_1
	if (iRet == PD_OK) {
		if (!GetField_CString(hContext, "baid_txn_id_1", &csBaidTxnId)) {
DEBUGLOG(("ProcessMatching:: baid_txn_id_1 not found\n"));
			iRet = PD_ERR;
		} else {
DEBUGLOG(("ProcessMatching:: baid_txn_id_1 = [%s]\n", csBaidTxnId));
		}
	}
*/

/*
	// lock baid txn
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessMatching:: call DBOLBAIDTxn::MatchRespTxnNoWait()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLBAIDTxn", "MatchRespTxnNoWait");
		iTmpRet = (unsigned long)(*DBObjPtr)(csBaidTxnId, PD_COMPLETE);
		if (iTmpRet != PD_FOUND) {
DEBUGLOG(("ProcessMatching:: call DBOLBAIDTxn::MatchRespTxnNoWait() failed\n"));
			iRet = PD_ERR;
		}
	}
*/

	// get stmt match engine
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessMatching:: call DBOLStmtMatchEngine::GetStmtMatchEngine()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtMatchEngine", "GetStmtMatchEngine");
		iTmpRet = (unsigned long)(*DBObjPtr)(hContext, hMatchEngine);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("ProcessMatching:: call DBOLStmtMatchEngine::GetStmtMatchEngine() failed\n"));
			iRet = PD_ERR;
		} else {
			// get rule_id
			if (!GetField_Int(hMatchEngine, "rule_id", &iTmp)) {
DEBUGLOG(("ProcessMatching:: rule_id not found\n"));
				iRet = PD_ERR;
			} else {
DEBUGLOG(("ProcessMatching:: rule_id = [%d]\n", iTmp));
				PutField_Int(hContext, "rule_id", iTmp);
			}

			// get next_engine_action
			if (!GetField_CString(hMatchEngine, "next_engine_action", &csNextEngineAction)) {
DEBUGLOG(("ProcessMatching:: next_engine_action not found\n"));
				iRet = PD_ERR;
			} else {
DEBUGLOG(("ProcessMatching:: next_engine_action = [%s]\n", csNextEngineAction));
			}

			// get failed_baid_txn_code
			if (!GetField_CString(hMatchEngine, "failed_baid_txn_code", &csFailedBaidTxnCode)) {
DEBUGLOG(("ProcessMatching:: failed_baid_txn_code not found\n"));
			} else {
DEBUGLOG(("ProcessMatching:: failed_baid_txn_code = [%s]\n", csFailedBaidTxnCode));
			}
		}
	}

	// get stmt match rule
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessMatching:: call DBOLStmtMatchRule::GetStmtMatchRule()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtMatchRule", "GetStmtMatchRule");
		iTmpRet = (unsigned long)(*DBObjPtr)(hContext, rMatchRule);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("ProcessMatching:: call DBOLStmtMatchRule::GetStmtMatchRule() failed\n"));
			iRet = PD_ERR;
		}
	}

	// loop match rule
	if (iRet == PD_OK) {
		iCnt = 0;
		iMatched = 0;
		iExitSubRule = 0;

		hMatchRule = RecordSet_GetFirst(rMatchRule);
		while (hMatchRule) {
			iSkipOnce = 0;
			iCnt++;

			if (iCnt != 1) {
				iLastSubRuleId = iSubRuleId;
				iLastActionSeq = iActionSeq;
				strcpy(csLastActionType, csActionType);
			}

			// get sub_rule_id
			if (!GetField_Int(hMatchRule, "sub_rule_id", &iSubRuleId)) {
DEBUGLOG(("ProcessMatching:: sub_rule_id not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("ProcessMatching:: sub_rule_id = [%d]\n", iSubRuleId));
			}

			// get action_seq
			if (!GetField_Int(hMatchRule, "action_seq", &iActionSeq)) {
DEBUGLOG(("ProcessMatching:: action_seq not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("ProcessMatching:: action_seq = [%d]\n", iActionSeq));
			}

			// get action_type
			if (!GetField_CString(hMatchRule, "action_type", &csActionType)) {
DEBUGLOG(("ProcessMatching:: action_type not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("ProcessMatching:: action_type = [%s]\n", csActionType));
			}

			// get action_filter_id
			if (!GetField_Int(hMatchRule, "action_filter_id", &iFilterId)) {
DEBUGLOG(("ProcessMatching:: action_filter_id not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("ProcessMatching:: action_filter_id = [%d]\n", iFilterId));
			}

			// get exit_on_error
			if (!GetField_Int(hMatchRule, "exit_on_error", &iExitOnError)) {
DEBUGLOG(("ProcessMatching:: exit_on_error not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("ProcessMatching:: exit_on_error = [%d]\n", iExitOnError));
			}

			if (iCnt != 1) {
				if (iSubRuleId != iLastSubRuleId) {
					iExitSubRule = 0;
					// check last sub_rule result
					if (iMatched) {
DEBUGLOG(("ProcessMatching:: last sub_rule matched! skip remaining sub_rule(s)\n"));
						break;
					}
				} else if (iExitSubRule) {
					// skip this sub-rule
DEBUGLOG(("ProcessMatching:: this sub-rule failed! skip\n"));
					hMatchRule = RecordSet_GetNext(rMatchRule);
					continue;
				} /*else if ((!strcmp(csActionType, csLastActionType)) && (iMatched)) {
					// same action type already returns okay (the "or" condition)
DEBUGLOG(("ProcessMatching:: skip this action\n"));
					iSkipOnce = 1;
				}*/
			}

			// process action_type
			if (1) {
				iRet = DoAction(hContext, hMatchRule);

/* for testing start */
				printf ("Enter value for iRet: ");
				scanf ("%d", &iRet);
DEBUGLOG(("ProcessMatching:: iRet = [%d]\n", iRet));
/* for testing end */

				if (iRet == PD_OK) {
					iMatched = 1;
				} else {
					iMatched = 0;
					if (iExitOnError) {
						iExitSubRule = 1;
					}
				}
			}

			hMatchRule = RecordSet_GetNext(rMatchRule);
		}

		if (iRet == PD_OK) {
			if ((iCnt > 0) && (iMatched)) {
DEBUGLOG(("ProcessMatching:: statement matched!\n"));
			}
		}
	}

	// hash destroy
	hash_destroy(hMatchEngine);
	FREE_ME(hMatchEngine);
	// recordset destroy
	RecordSet_Destroy(rMatchRule);
	FREE_ME(rMatchRule);

DEBUGLOG(("ProcessMatching() exit iRet = [%d]\n", iRet));
	return iRet;
}


int DoAction(hash_t *hContext, hash_t *hMatchRule) {
	int iRet = PD_OK;
	int iTmpRet;
	char *csTmp;

	char *csParty, *csFilter, *csSpecialHandling, *csOperator, *csLeftOperand, *csRightOperand;
	int iFromInput, iToOutput;
	int iInputCount = 0;
	int iOutputCount = 0;
	int iIsSpecialHandling = 0;

	hash_t *hMatchAction;
	hMatchAction = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hMatchAction, 0);

	recordset_t *rMatchFilter;
	rMatchFilter = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rMatchFilter, 0);
	hash_t *hMatchFilter;

	hash_t *hEngineSql;
	hEngineSql = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hEngineSql, 0);

	// get stmt match action
	if (iRet == PD_OK) {
DEBUGLOG(("DoAction:: call DBOLStmtMatchAction::GetStmtMatchAction()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtMatchAction", "GetStmtMatchAction");
		iTmpRet = (unsigned long)(*DBObjPtr)(hMatchRule, hMatchAction);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("DoAction:: call DBOLStmtMatchAction::GetStmtMatchAction() failed\n"));
			iRet = PD_ERR;
		} else {
			// get first_party
			if (!GetField_CString(hMatchAction, "first_party", &csTmp)) {
DEBUGLOG(("DoAction:: first_party not found\n"));
				iRet = PD_ERR;
			} else {
DEBUGLOG(("DoAction:: first_party = [%s]\n", csTmp));
			}

			// get second_party
			if (!GetField_CString(hMatchAction, "second_party", &csTmp)) {
DEBUGLOG(("DoAction:: second_party not found\n"));
				iRet = PD_ERR;
			} else {
DEBUGLOG(("DoAction:: second_party = [%s]\n", csTmp));
			}
		}
	}

	// get stmt match filter
	if (iRet == PD_OK) {
DEBUGLOG(("DoAction:: call DBOLStmtMatchFilter::GetStmtMatchFilter()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtMatchFilter", "GetStmtMatchFilter");
		iTmpRet = (unsigned long)(*DBObjPtr)(hMatchRule, hMatchAction, rMatchFilter);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("DoAction:: call DBOLStmtMatchFilter::GetStmtMatchFilter() failed\n"));
			iRet = PD_ERR;
		}
	}

	// loop match filter
	if (iRet == PD_OK) {
		hMatchFilter = RecordSet_GetFirst(rMatchFilter);
		while (hMatchFilter) {
			iIsSpecialHandling = 0;

			// get party (mandatory)
			if (!GetField_CString(hMatchFilter, "party", &csParty)) {
DEBUGLOG(("DoAction:: party not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("DoAction:: party = [%s]\n", csParty));
			}

			// get filter (mandatory)
			if (!GetField_CString(hMatchFilter, "filter", &csFilter)) {
DEBUGLOG(("DoAction:: filter not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("DoAction:: filter = [%s]\n", csFilter));
			}

			// get special_handling (optional)
			if (!GetField_CString(hMatchFilter, "special_handling", &csSpecialHandling)) {
DEBUGLOG(("DoAction:: no special_handling\n"));
			} else {
DEBUGLOG(("DoAction:: special_handling = [%s]\n", csSpecialHandling));
				iIsSpecialHandling = 1;
				if (!strcmp(csSpecialHandling, "tmp_skip")) {
					iRet = TmpSkip(hMatchFilter);
				} else if (!strcmp(csSpecialHandling, "check_keywords")) {
					iRet = CheckKeywords(hMatchFilter);
				} else if (!strcmp(csSpecialHandling, "split_amount")) {
					iRet = SplitAmount(hMatchFilter);
				}
			}

			// get from_input (mandatory)
			if (!GetField_Int(hMatchFilter, "from_input", &iFromInput)) {
DEBUGLOG(("DoAction:: from_input not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("DoAction:: from_input = [%d]\n", iFromInput));
				if (iFromInput) {
					if (!iInputCount) {
						iInputCount++;
					}/* else {
DEBUGLOG(("DoAction:: multiple input not supported\n"));
						iRet = PD_ERR;
						break;
					}*/
				}
			}

			// get to_output (mandatory)
			if (!GetField_Int(hMatchFilter, "to_output", &iToOutput)) {
DEBUGLOG(("DoAction:: to_output not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("DoAction:: to_output = [%d]\n", iToOutput));
				if (iToOutput) {
					if (!iOutputCount) {
						iOutputCount++;
					}/* else {
DEBUGLOG(("DoAction:: multiple output not supported\n"));
						iRet = PD_ERR;
						break;
					}*/
				}
			}

			// get operator (mandatory except output & special handling)
			if (!GetField_CString(hMatchFilter, "operator", &csOperator)) {
				if (!iToOutput && !iIsSpecialHandling) {
DEBUGLOG(("DoAction:: operator not found\n"));
					iRet = PD_ERR;
					break;
				}
			} else {
DEBUGLOG(("DoAction:: operator = [%s]\n", csOperator));
			}

			// get left_operand (mandatory except special handling)
			if (!GetField_CString(hMatchFilter, "left_operand", &csLeftOperand)) {
				if (!iIsSpecialHandling) {
DEBUGLOG(("DoAction:: left_operand not found\n"));
					iRet = PD_ERR;
					break;
				}
			} else {
DEBUGLOG(("DoAction:: left_operand = [%s]\n", csLeftOperand));
			}

			// get right_operand (mandatory except input & output & special handling)
			if (!GetField_CString(hMatchFilter, "right_operand", &csRightOperand)) {
				if (!iFromInput && !iToOutput && !iIsSpecialHandling) {
DEBUGLOG(("DoAction:: right_operand not found\n"));
					iRet = PD_ERR;
					break;
				}
			} else {
DEBUGLOG(("DoAction:: right_operand = [%s]\n", csRightOperand));
			}

			hMatchFilter = RecordSet_GetNext(rMatchFilter);
		}

		if (!iInputCount || !iOutputCount) {
DEBUGLOG(("DoAction:: missing input or output filter\n"));
				iRet = PD_ERR;
		}
	}

	// get engine sql
	if (iRet == PD_OK) {
		PutField_CString(hMatchRule, "engine_type", PD_STMT_ENGINE_TYPE);
DEBUGLOG(("DoAction:: call DBOLEngineSql::GetEngineSql()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLEngineSql", "GetEngineSql");
		iTmpRet = (unsigned long)(*DBObjPtr)(hMatchRule, hMatchAction, hEngineSql);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("DoAction:: call DBOLEngineSql::GetEngineSql() failed\n"));
			iRet = PD_ERR;
		} else {
			// get from_clause
			if (!GetField_CString(hEngineSql, "from_clause", &csTmp)) {
DEBUGLOG(("DoAction:: from_clause not found\n"));
				iRet = PD_ERR;
			} else {
DEBUGLOG(("DoAction:: from_clause = [%s]\n", csTmp));
			}
		}
	}

	// execute engine sql
	if (iRet == PD_OK) {
DEBUGLOG(("DoAction:: call DBOLStmtMatchEngine::ExecuteSql()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtMatchEngine", "ExecuteSql");
		iTmpRet = (unsigned long)(*DBObjPtr)(hContext, rMatchFilter, hEngineSql);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("DoAction:: call DBOLStmtMatchEngine::ExecuteSql() failed\n"));
			iRet = PD_ERR;
		}
	}

	// hash destroy
	hash_destroy(hMatchAction);
	FREE_ME(hMatchAction);
	hash_destroy(hEngineSql);
	FREE_ME(hEngineSql);
	// recordset destroy
	RecordSet_Destroy(rMatchFilter);
	FREE_ME(rMatchFilter);

DEBUGLOG(("DoAction() exit iRet = [%d]\n", iRet));
	return iRet;
}


int TmpSkip(hash_t *hMatchFilter) {
	PutField_Int(hMatchFilter, "skip", 1);
	return PD_OK;
}

int CheckKeywords(hash_t *hMatchFilter) {
	PutField_Int(hMatchFilter, "skip", 1);
	return PD_OK;
}

int SplitAmount(hash_t *hMatchFilter) {
	return PD_OK;
}
