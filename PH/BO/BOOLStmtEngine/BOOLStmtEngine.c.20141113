/*
Partnerdelight (c)2014. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/11/05              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "internal.h"
#include "dbutility.h"
#include "BOOLStmtEngine.h"
#include "myrecordset.h"
#include "myhash.h"
#include "math.h"
#include <time.h>

char cDebug;
OBJPTR(DB);
OBJPTR(BO);
OBJPTR(Txn);

void BOOLStmtEngine(char cdebug)
{
	cDebug = cdebug;
}

int GenSqlCondition(const char* csActionType, hash_t* hContext, hash_t* hMatchRule, const int iIndex);
int DoAction(const char* csActionType, hash_t* hContext, hash_t* hMatchRule);
int fr_baid1_to_log1(const char* csParty, const char* csFilter,
						const char* csOperator, const char* csValue, char** csSqlCond);
int fr_log1_to_log2(const char* csParty, const char* csFilter,
						const char* csOperator, const char* csValue, char** csSqlCond);
int fr_log2_to_baid2(const char* csParty, const char* csFilter,
						const char* csOperator, const char* csValue, char** csSqlCond);
int fr_log1_to_baid2(const char* csParty, const char* csFilter,
						const char* csOperator, const char* csValue, char** csSqlCond);

int ProcessMatching(hash_t* hContext) {
	int iRet = PD_OK;
	int iTmpRet;

	char *csBaidTxnId;
/*
	char *csTriggerType;
	char *csNature;
	char *csBaidTxnCode;
*/

	int iSubRuleId;
	char *csActionType;
	int iExitOnError;

	int iCnt;
	int iMatched;
	int iExitSubRule;
	int iSkipOnce;
	int iLastSubRuleId;
	char csLastActionType[PD_STMT_MATCH_ACTION_DESC_LEN + 1];

	recordset_t *rMatchRule;
	rMatchRule = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rMatchRule, 0);
	hash_t *hMatchRule;

	// get baid_txn_id
	if (iRet == PD_OK) {
		if (!GetField_CString(hContext, "baid_txn_id", &csBaidTxnId)) {
DEBUGLOG(("ProcessMatching:: baid_txn_id not found\n"));
			iRet = PD_ERR;
		} else {
DEBUGLOG(("ProcessMatching:: baid_txn_id = [%s]\n", csBaidTxnId));
		}
	}

/*
	// lock baid txn
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessMatching:: call DBOLBAIDTxn::MatchRespTxnNoWait()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLBAIDTxn", "MatchRespTxnNoWait");
		iTmpRet = (unsigned long)(*DBObjPtr)(csBaidTxnId, PD_COMPLETE);
		if (iTmpRet != PD_FOUND) {
DEBUGLOG(("ProcessMatching:: call DBOLBAIDTxn::MatchRespTxnNoWait() failed\n"));
			iRet = PD_ERR;
		}
	}
*/

/*
	// get trigger_type
	if (iRet == PD_OK) {
		if (!GetField_CString(hContext, "trigger_type", &csTriggerType)) {
DEBUGLOG(("ProcessMatching:: trigger_type not found\n"));
			iRet = PD_ERR;
		} else {
DEBUGLOG(("ProcessMatching:: trigger_type = [%s]\n", csTriggerType));
		}
	}

	// get bank_acct_type
	if (iRet == PD_OK) {
		if (!GetField_CString(hContext, "bank_acct_type", &csNature)) {
DEBUGLOG(("ProcessMatching:: bank_acct_type not found\n"));
			iRet = PD_ERR;
		} else {
DEBUGLOG(("ProcessMatching:: bank_acct_type = [%s]\n", csNature));
		}
	}

	// get baid_txn_code
	if (iRet == PD_OK) {
		if (!GetField_CString(hContext, "baid_txn_code", &csBaidTxnCode)) {
DEBUGLOG(("ProcessMatching:: baid_txn_code not found\n"));
			iRet = PD_ERR;
		} else {
DEBUGLOG(("ProcessMatching:: baid_txn_code = [%s]\n", csBaidTxnCode));
		}
	}
*/

	// get match rule
	if (iRet == PD_OK) {
DEBUGLOG(("ProcessMatching:: call DBOLStmtMatchEngine::GetStmtRule()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtMatchEngine", "GetStmtRule");
		iTmpRet = (unsigned long)(*DBObjPtr)(hContext, rMatchRule);
		if (iTmpRet != PD_OK) {
DEBUGLOG(("ProcessMatching:: call DBOLStmtMatchEngine::GetStmtRule() failed\n"));
			iRet = PD_ERR;
		}
	}

	if (iRet == PD_OK) {
		// loop match rule
		iCnt = 0;
		iMatched = 0;
		iExitSubRule = 0;

		hMatchRule = RecordSet_GetFirst(rMatchRule);
		while (hMatchRule) {
			iSkipOnce = 0;
			iCnt++;

			// get sub_rule_id
			if (!GetField_Int(hMatchRule, "sub_rule_id", &iSubRuleId)) {
DEBUGLOG(("ProcessMatching:: sub_rule_id not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("ProcessMatching:: sub_rule_id = [%d]\n", iSubRuleId));
			}

			// get action_type
			if (!GetField_CString(hMatchRule, "action_type", &csActionType)) {
DEBUGLOG(("ProcessMatching:: action_type not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("ProcessMatching:: action_type = [%s]\n", csActionType));
			}

			// get exit_on_error
			if (!GetField_Int(hMatchRule, "exit_on_error", &iExitOnError)) {
DEBUGLOG(("ProcessMatching:: exit_on_error not found\n"));
				iRet = PD_ERR;
				break;
			} else {
DEBUGLOG(("ProcessMatching:: exit_on_error = [%d]\n", iExitOnError));
			}

			if (iCnt == 1) {
				iLastSubRuleId = iSubRuleId;
				strcpy(csLastActionType, csActionType);
			} else {
				if (iSubRuleId != iLastSubRuleId) {
					if (iMatched) {
DEBUGLOG(("ProcessMatching:: matched! skip remaining sub-rule\n"));
						break;
					} else {
						iExitSubRule = 0;
					}
					iLastSubRuleId = iSubRuleId;
				} else if (iExitSubRule) {
DEBUGLOG(("ProcessMatching:: skip this sub-rule\n"));
					hMatchRule = RecordSet_GetNext(rMatchRule);
					continue;
				} else if ((!strcmp(csActionType, csLastActionType)) && (iMatched)) {
DEBUGLOG(("ProcessMatching:: skip this action\n"));
					iSkipOnce = 1;
				}
				strcpy(csLastActionType, csActionType);
			}

			// process action_type
			if (!iSkipOnce) {
				iRet = DoAction(csActionType, hContext, hMatchRule);

				printf ("Enter value for iRet: ");
				scanf ("%d", &iRet);
DEBUGLOG(("ProcessMatching:: iRet = [%d]\n", iRet));
				//iRet = PD_OK;
				//iRet = PD_ERR;

				if (iRet == PD_OK) {
					iMatched = 1;
				} else {
					iMatched = 0;
					if (iExitOnError) {
						iExitSubRule = 1;
					}
				}
			}

			hMatchRule = RecordSet_GetNext(rMatchRule);
		}

		if (iRet == PD_OK) {
			if ((iCnt > 0) && (iMatched)) {
DEBUGLOG(("debug: i am here\n"));
			}
		}
	}

	// recordset destroy
	RecordSet_Destroy(rMatchRule);
	FREE_ME(rMatchRule);

DEBUGLOG(("ProcessMatching() exit iRet = [%d]\n", iRet));
	return iRet;
}

int DoAction(const char* csActionType, hash_t* hContext, hash_t* hMatchRule) {
	int iRet = PD_OK;

	int iFieldCnt, iIndex;
	char *csTmp;
	char *csTag = (char*) malloc (64);

	// get field_cnt
	if (!GetField_Int(hMatchRule, "field_cnt", &iFieldCnt)) {
DEBUGLOG(("DoAction:: field_cnt not found\n"));
		iRet = PD_ERR;
	} else {
DEBUGLOG(("DoAction:: field_cnt = [%d]\n", iFieldCnt));
	}

	// loop
	if (iRet == PD_OK) {
		for (iIndex = 1; iIndex <= iFieldCnt; iIndex++) {
			// gen sql condition
			iRet = GenSqlCondition(csActionType, hContext, hMatchRule, iIndex);

			if (iRet == PD_OK) {
				sprintf(csTag, "sql_cond_%d", iIndex);
				if (!GetField_CString(hMatchRule, csTag, &csTmp)) {
DEBUGLOG(("DoAction:: [%s] not found\n", csTag));
					iRet = PD_ERR;
					break;
				} else {
DEBUGLOG(("DoAction:: [%s] = [%s]\n", csTag, csTmp));
				}
			}
		}

		if (iRet == PD_OK) {
			// pass hMatchRule to execute sql depends on action type
		}
	}

DEBUGLOG(("DoAction() exit iRet = [%d]\n", iRet));
	return iRet;
}

int GenSqlCondition(const char* csActionType, hash_t* hContext, hash_t* hMatchRule, const int iIndex) {
	int iRet = PD_OK;

	char *csParty = NULL, *csFilter = NULL, *csOperator = NULL, *csValue = NULL, *csSqlCond = NULL;
	char *csTag = (char*) malloc (64);

	// get party
	sprintf(csTag, "party_%d", iIndex);
	if (!GetField_CString(hMatchRule, csTag, &csParty)) {
DEBUGLOG(("GenSqlCondition:: [%s] not found\n", csTag));
		iRet = PD_ERR;
	} else {
DEBUGLOG(("GenSqlCondition:: [%s] = [%s]\n", csTag, csParty));
	}

	// get filter
	sprintf(csTag, "filter_%d", iIndex);
	if (!GetField_CString(hMatchRule, csTag, &csFilter)) {
DEBUGLOG(("GenSqlCondition:: [%s] not found\n", csTag));
		iRet = PD_ERR;
	} else {
DEBUGLOG(("GenSqlCondition:: [%s] = [%s]\n", csTag, csFilter));
	}

	// if party != "both"
	if (strcmp(csParty, "both") != 0) {
		// get operator
		sprintf(csTag, "operator_%d", iIndex);
		if (!GetField_CString(hMatchRule, csTag, &csOperator)) {
DEBUGLOG(("GenSqlCondition:: [%s] not found\n", csTag));
			iRet = PD_ERR;
		} else {
DEBUGLOG(("GenSqlCondition:: [%s] = [%s]\n", csTag, csOperator));
		}

		// get value
		sprintf(csTag, "value_%d", iIndex);
		if (!GetField_CString(hMatchRule, csTag, &csValue)) {
DEBUGLOG(("GenSqlCondition:: [%s] not found\n", csTag));
			iRet = PD_ERR;
		} else {
DEBUGLOG(("GenSqlCondition:: [%s] = [%s]\n", csTag, csValue));
		}
	}

	// depends on action_type
	if (!strcmp(csActionType, "fr_baid1_to_log1")) {
		iRet = fr_baid1_to_log1(csParty, csFilter, csOperator, csValue, &csSqlCond);
	} else if (!strcmp(csActionType, "fr_log1_to_log2")) {
		iRet = fr_log1_to_log2(csParty, csFilter, csOperator, csValue, &csSqlCond);
	} else if (!strcmp(csActionType, "fr_log2_to_baid2")) {
		iRet = fr_log2_to_baid2(csParty, csFilter, csOperator, csValue, &csSqlCond);
	} else if (!strcmp(csActionType, "fr_log1_to_baid2")) {
		iRet = fr_log1_to_baid2(csParty, csFilter, csOperator, csValue, &csSqlCond);
	} else {
DEBUGLOG(("GenSqlCondition:: undefined action_type\n"));
		iRet = PD_ERR;
	}

	sprintf(csTag, "sql_cond_%d", iIndex);
	PutField_CString(hMatchRule, csTag, csSqlCond);

	return iRet;
}

int fr_baid1_to_log1(const char* csParty, const char* csFilter, const char* csOperator, const char* csValue, char** csSqlCond) {
	int iRet = PD_OK;
	char csTmp[PD_MAX_BUFFER];

	if ((csParty == NULL) || (csFilter == NULL)) {
DEBUGLOG(("fr_baid1_to_log1:: csParty or csFilter is null\n"));
		iRet = PD_ERR;
	} else {
		if (!strcmp(csParty, "both")) {
			if (!strcmp(csFilter, "provider")) {
				strcpy(csTmp, "opd.opd_client_id=baid_txn.opd_client_id");
			} else if (!strcmp(csFilter, "bank_code")) {
				strcpy(csTmp, "otp.otp_bank_code=baid_txn.obt_bank_code");
			} else if (!strcmp(csFilter, "txn_amt")) {
				strcpy(csTmp, "oth.oth_transaction_amount=baid_txn.real_amt");
			} else {
DEBUGLOG(("fr_baid1_to_log1:: undefined filter for party [both]\n"));
				iRet = PD_ERR;
			}
		} else {
			if ((csOperator == NULL) || (csValue == NULL)) {
DEBUGLOG(("fr_baid1_to_log1:: csOperator or csValue is null\n"));
			} else {
				if (!strcmp(csFilter, "reconciled")) {
					if (!strcmp(csParty, "txn_log")) {
						// txn_log // reconciled
						strcpy(csTmp, "oth.oth_recon_status");
						strcat(csTmp, csOperator);
						strcat(csTmp, csValue);
					} else {
DEBUGLOG(("fr_baid1_to_log1:: undefined party for filter [reconciled]\n"));
					}
				} else if (!strcmp(csFilter, "txn_code")) {
					if (!strcmp(csParty, "txn_log")) {
						// txn_log // txn_code
						strcpy(csTmp, "oth.oth_txn_code");
						strcat(csTmp, csOperator);
						strcat(csTmp, csValue);
					} else {
DEBUGLOG(("fr_baid1_to_log1:: undefined party for filter [txn_code]\n"));
					}
				} else if (!strcmp(csFilter, "sysdate_diff")) {
					if (!strcmp(csParty, "txn_log")) {
						// txn_log // sysdate_diff
						strcpy(csTmp, "oth.oth_approval_timestamp");
						strcat(csTmp, csOperator);
						strcat(csTmp, "sysdate-");
						strcat(csTmp, csValue);
					} else {
DEBUGLOG(("fr_baid1_to_log1:: undefined party for filter [sysdate_diff]\n"));
					}
				} else if (!strcmp(csFilter, "stmt_date_diff")) {
					if (!strcmp(csParty, "txn_log")) {
						// txn_log // stmt_date_diff
						if (!strcmp(csOperator, ">=")) {
							strcpy(csTmp, "oth.oth_approval_timestamp");
							strcat(csTmp, csOperator);
							strcat(csTmp, "baid_txn.olsd_statement_timestamp-");
							strcat(csTmp, csValue);
						} else if (!strcmp(csOperator, "<=")) {
							strcpy(csTmp, "oth.oth_approval_timestamp");
							strcat(csTmp, csOperator);
							strcat(csTmp, "baid_txn.olsd_statement_timestamp+");
							strcat(csTmp, csValue);
						} else {
DEBUGLOG(("fr_baid1_to_log1:: undefined operator for filter [stmt_date_diff]\n"));
						}
					} else {
DEBUGLOG(("fr_baid1_to_log1:: undefined party for filter [stmt_date_diff]\n"));
					}
				} else {
DEBUGLOG(("fr_baid1_to_log1:: undefined csFilter\n"));
				}
			}
		}
	}

	*csSqlCond = csTmp;
	return iRet;
}

int fr_log1_to_log2(const char* csParty, const char* csFilter, const char* csOperator, const char* csValue, char** csSqlCond) {
	int iRet = PD_OK;
	char csTmp[PD_MAX_BUFFER];

DEBUGLOG(("i am in fr_log1_to_log2\n"));
	strcpy(csTmp, "this is halloween 1");
	*csSqlCond = csTmp;
	return iRet;
}

int fr_log2_to_baid2(const char* csParty, const char* csFilter, const char* csOperator, const char* csValue, char** csSqlCond) {
	int iRet = PD_OK;
	char csTmp[PD_MAX_BUFFER];

DEBUGLOG(("i am in fr_log2_to_baid2\n"));
	strcpy(csTmp, "this is halloween 2");
	*csSqlCond = csTmp;
	return iRet;
}

int fr_log1_to_baid2(const char* csParty, const char* csFilter, const char* csOperator, const char* csValue, char** csSqlCond) {
	int iRet = PD_OK;
	char csTmp[PD_MAX_BUFFER];

DEBUGLOG(("i am in fr_log1_to_baid2\n"));
	strcpy(csTmp, "this is halloween 3");
	*csSqlCond = csTmp;
	return iRet;
}
