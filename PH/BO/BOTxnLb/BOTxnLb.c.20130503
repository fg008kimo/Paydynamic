/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/01/04              Cody Chan
Add Override value ratio and Priority from pool    2012/02/01		   Cody Chan
Mapping
CheckScheduler more than one rule		   2012/02/13		   LokMan Chow
Remove PSP detail's ratio and Priority             2012/12/19		   Cody Chan
Random Select PSP if the Priority is the Same
Add Criteria Priority
when pickpsp check the business type 
and bank also					   2013/01/17		   LokMan Chow
bug fix for select Pool if bank is disabled        2013/03/04		   Cody Chan
Check psp limit before bank selection		   2013/03/20		   Stan Poon
filter psp by checking small delta amount	   
check ip is restricted or not		 	   2013/04/11		   LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"
#include "common.h"
#include "BOTxnLb.h"

char    cDebug;

OBJPTR(DB);
OBJPTR(BO);
void BOTxnLb(char    cdebug)
{
        cDebug = cdebug;
}

int CheckAmountTier(double dMinTxnAmt, double dMaxTxnAmt, double dTxnAmt);
int CheckScheduler(int iId,const char* csDateTime);
int GetPool(int iId,recordset_t* rRs);
int CheckPools(double dTxnAmt,
		const char* csServiceCode,
                const char* csTxnCountry,
                const char* csTxnCcy,
                const char* csPayMethod,
		const char* csBankCode,
		hash_t*	hPsp,
		recordset_t *,
		char*,
		const char* csOrgDateTime);

int CheckPoolLimit(int iId,
		const char* csServiceCode,
		const char* csTxnCountry,
		const char* csTxnCcy,
		const char* csPayMethod,
		double	dTxnAmt,
		double dLimit,
		double *dCurr,
		double *dTotalCurr,
		double *dReqCurr,
		double *dTotalReqCurr);
int PickPsp(hash_t* hPsp,
		int iId,
		const char* csBankCode,
		const char* csPayMethod,
		const char* csServiceCode,
		const char* csTxnCountry,
		const char* csTxnCcy,
		char*	csSelectedPspId,
		double	dTxnAmt,
		const char* csOrgDateTime);
/*
int PickPsp(int iId,
		const char* csPayMethod,
		const char* csServiceCode,
		const char* csTxnCountry,
		const char* csTxnCcy,
		char*	csSelectedPspId);
*/
int CheckPspLimit(const char* csId,
		const char* csServiceCode,
		const char* csTxnCountry,
		const char* csTxnCcy,
		const char* csPayMethod,
		double dTxnAmt,
		double dLimit,
		double *dCurr,
		double *dTotalCurr,
		double *dReqCurr,
		double *dTotalReqCurr);

int GetTxnPsp(hash_t *hContext,
                const hash_t* hRequest)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	cPtr;
	char	*csServiceCode;
	char	*csTxnCountry;
	char	*csTxnCcy;
	char	*csPayMethod;
	char	*csOrgDateTime;
	char	*csBankCode;
	char	csSelectedPspId[PD_PSP_ID_LEN +1];
	double	dTxnAmt = 0.0;
	
	hash_t	*hReq;
	hash_t	*hPsp, *hTmpPsp;
	recordset_t     *rRecordSet;
	recordset_t     *rRs;


DEBUGLOG(("GetTxnPsp()\n"));
	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
       	recordset_init(rRecordSet,0);	

	rRs = (recordset_t*) malloc (sizeof(recordset_t));
       	recordset_init(rRs,0);	
 
	hReq = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hReq,0);

	hPsp = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hPsp,0);
	hTmpPsp = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hTmpPsp,0);


/* channel Code */
	if (GetField_CString(hContext,"channel_code",&csPtr)) {
DEBUGLOG(("GetTxnPsp() Channel Code = [%s]\n",csPtr));
		PutField_CString(hReq,"channel_code",csPtr);
	}
	else {
DEBUGLOG(("GetTxnPsp() channel Code is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() channel Code is missing!!!\n");
		iRet = PD_ERR;
	}

/* service code  */
	if (GetField_CString(hRequest,"service_code",&csServiceCode)) {
DEBUGLOG(("GetTxnPsp() service_code = [%s]\n",csServiceCode));
		PutField_CString(hReq,"service_code",csServiceCode);
	}
	else if (GetField_CString(hContext,"org_service_code",&csServiceCode)) {
DEBUGLOG(("GetTxnPsp() service_code = [%s]\n",csServiceCode));
		PutField_CString(hReq,"service_code",csServiceCode);
	}
	else {
DEBUGLOG(("GetTxnPsp() service_code is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() service_code is missing!!!\n");
		iRet = PD_ERR;
	}

/* payment_method  */
	if (GetField_CString(hContext,"selected_pay_method",&csPayMethod)) {
DEBUGLOG(("GetTxnPsp() selected_pay_method  = [%s]\n",csPayMethod));
		PutField_CString(hReq,"pay_method",csPayMethod);
	}
	else {
DEBUGLOG(("GetTxnPsp() selected_pay_method  is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() selected_pay_method  is missing!!!\n");
		iRet = PD_ERR;
	}

/* txn_country  */
	if (GetField_CString(hRequest,"txn_country",&csTxnCountry)) {
DEBUGLOG(("GetTxnPsp() txn_country  = [%s]\n",csTxnCountry));
		PutField_CString(hReq,"txn_country",csTxnCountry);
	}
	else if (GetField_CString(hContext,"org_txn_country",&csTxnCountry)) {
DEBUGLOG(("GetTxnPsp() txn_country  = [%s]\n",csTxnCountry));
		PutField_CString(hReq,"txn_country",csTxnCountry);
	}
	else {
DEBUGLOG(("GetTxnPsp() txn_country  is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() txn_country  is missing!!!\n");
		iRet = PD_ERR;
	}

/* txn_ccy  */
	if (GetField_CString(hRequest,"txn_ccy",&csTxnCcy)) {
DEBUGLOG(("GetTxnPsp() txn_ccy  = [%s]\n",csTxnCcy));
		PutField_CString(hReq,"txn_ccy",csTxnCcy);
	}
	else if (GetField_CString(hContext,"org_txn_ccy",&csTxnCcy)) {
DEBUGLOG(("GetTxnPsp() txn_ccy  = [%s]\n",csTxnCcy));
		PutField_CString(hReq,"txn_ccy",csTxnCcy);
	}
	else {
DEBUGLOG(("GetTxnPsp() txn_ccy  is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() txn_ccy  is missing!!!\n");
		iRet = PD_ERR;
	}

/* merchant_id  */
	if (GetField_CString(hRequest,"merchant_id",&csPtr)) {
DEBUGLOG(("GetTxnPsp() merchant_id  = [%s]\n",csPtr));
		PutField_CString(hReq,"merchant_id",csPtr);
	}
	else if (GetField_CString(hContext,"org_merchant_id",&csPtr)) {
DEBUGLOG(("GetTxnPsp() merchant_id  = [%s]\n",csPtr));
		PutField_CString(hReq,"merchant_id",csPtr);
	}
	else {
DEBUGLOG(("GetTxnPsp() merchant_id  is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() merchant_id  is missing!!!\n");
		iRet = PD_ERR;
	}

/* merchant_clinet_id  */
	if (GetField_CString(hRequest,"client_id",&csPtr)) {
DEBUGLOG(("GetTxnPsp() client_id  = [%s]\n",csPtr));
		PutField_CString(hReq,"client_id",csPtr);
	}
	else if (GetField_CString(hContext,"org_client_id",&csPtr)) {
DEBUGLOG(("GetTxnPsp() client_id  = [%s]\n",csPtr));
		PutField_CString(hReq,"client_id",csPtr);
	}
	else {
DEBUGLOG(("GetTxnPsp() merchant_client_id  is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() merchant_client_id  is missing!!!\n");
		iRet = PD_ERR;
	}

/* business_type */
	if (GetField_Char(hContext,"org_merchant_type",&cPtr)) {
DEBUGLOG(("GetTxnPsp() merchant_type  = [%c]\n",cPtr));
		PutField_Char(hReq,"business_type",cPtr);
	}
	else {
DEBUGLOG(("GetTxnPsp() merchant_type  is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() merchant_type  is missing!!!\n");
		iRet = PD_ERR;
	}
/* customer_tag */
	if (GetField_CString(hContext,"customer_tag",&csPtr)) {
DEBUGLOG(("GetTxnPsp() customer_tag  = [%s]\n",csPtr));
		PutField_CString(hReq,"customer_tag",csPtr);
	}

/* txn_amt */
	if (GetField_Double(hRequest,"txn_amt",&dTxnAmt)) {
DEBUGLOG(("GetTxnPsp() txn_amt  = [%f]\n",dTxnAmt));
	}
	else if (GetField_Double(hContext,"org_txn_amt",&dTxnAmt)) {
DEBUGLOG(("GetTxnPsp() txn_amt  = [%f]\n",dTxnAmt));
	}
	else {
DEBUGLOG(("GetTxnPsp() txn_amt  is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() txn_amt  is missing!!!\n");
		iRet = PD_ERR;
	}
/* org_local_tm_datetime  */
	if (GetField_CString(hContext,"org_local_tm_datetime",&csOrgDateTime)) {
DEBUGLOG(("GetTxnPsp() org_local_tm_datetime  = [%s]\n",csOrgDateTime));
	}
	else {
DEBUGLOG(("GetTxnPsp() org_local_tm_datetime  is missing!!!\n"));
ERRLOG("BOTxnLb::GetTxnPsp() org_local_tm_datetime  is missing!!!\n");
		iRet = PD_ERR;
	}

/* bank_code  */
	if (GetField_CString(hRequest,"bank_code",&csBankCode)) {
DEBUGLOG(("GetTxnPsp() bank_code  = [%s]\n",csBankCode));
	}
	else {
DEBUGLOG(("GetTxnPsp() bank_code  is missing!!!\n"));
ERRLOG("BOTxnLB::GetTxnPsp() bank_code  is missing!!!\n");
		iRet = PD_ERR;
	}

/* check available psp first */
DEBUGLOG(("GetTxnPsp() Call BOBank:GetAvailablePspByBank\n"));
	BOObjPtr = CreateObj(BOPtr,"BOBank","GetAvailablePspByBank");
        if ((unsigned long)(*BOObjPtr)(csBankCode,csTxnCountry,csOrgDateTime,hTmpPsp) == PD_OK) {
                int     iPtr = 0;
                if (GetField_Int(hTmpPsp,"psp_id_cnt",&iPtr)) {
DEBUGLOG(("GetTxnPsp() psp id cnt = [%d]\n",iPtr));
                }
                if (iPtr == 0 ) {
DEBUGLOG(("GetTxnPsp() no aval psp for this bank [%s]\n",csBankCode));
                        iRet = INT_PSP_NOT_AVAILABLE;
                }
        }
        else {
DEBUGLOG(("GetTxnPsp() no aval psp for this bank [%s]\n",csBankCode));
                iRet = INT_PSP_NOT_AVAILABLE;
        }

//////filter psp by checking small delta amount
	if(iRet == PD_OK){
DEBUGLOG(("GetTxnPsp() Call BODeltaAmt:FilterAvailablePsp\n"));
		BOObjPtr = CreateObj(BOPtr,"BODeltaAmt","FilterAvailablePsp");
		if ((unsigned long)(*BOObjPtr)(hContext,hTmpPsp,hPsp,dTxnAmt)==PD_OK){
			int     iPtr = 0;
			if (GetField_Int(hPsp,"psp_id_cnt",&iPtr)) {
DEBUGLOG(("GetTxnPsp() psp id cnt = [%d]\n",iPtr));
			}
			if (iPtr == 0 ) {
DEBUGLOG(("GetTxnPsp() no aval psp for amount [%lf]\n",dTxnAmt));
                        	iRet = INT_PSP_NOT_AVAILABLE;
			}
		}
	}

/////check if deposit request is come from special region
	if(iRet == PD_OK){
		PutField_Int(hReq,"restricted_ip",PD_FALSE);

		if(GetField_CString(hRequest,"ip_addr", &csPtr)){
DEBUGLOG(("GetTxnPsp() check ip_addr [%s]\n",csPtr));
			DBObjPtr = CreateObj(DBPtr,"DBIpFilter","GetIpFilter");
			if ((unsigned long)((*DBObjPtr)(csPtr)) == PD_FOUND) {
				PutField_Int(hReq,"restricted_ip",PD_TRUE);
DEBUGLOG(("GetTxnPsp() restricted ip [%s]\n",csPtr));
			}
		}
	}

	if (iRet == PD_OK) {
		//int	iTxnAmountTierId = 0;
		int	iCriteriaPoolId = 0;
		int	iSchedulerId = 0;
		int	iPriority = 0;
		int	iCnt = 0;
		int	iGcnt = 0;

		double	dMinTxnAmt = 0.0;
		double	dMaxTxnAmt = 0.0;

		hash_t	*hRec;
		DBObjPtr = CreateObj(DBPtr,"DBRuleLB","MatchCriteria");	
		if ((unsigned long)(*DBObjPtr)(hReq,rRecordSet) == PD_FOUND) {
			hRec = RecordSet_GetFirst(rRecordSet);
                	while (hRec) {
/*txn amount tier */
/*
				if (GetField_Int(hRec,"amount_tier_id",&iTxnAmountTierId)) {
DEBUGLOG(("GetTxnPsp() [%02d] amount_tier_id = [%d]\n",iCnt,iTxnAmountTierId));
				}
*/

				if (GetField_Double(hRec, "min_txn_amount", &dMinTxnAmt)) {
DEBUGLOG(("GetTxnPsp() [%02d] min_txn_amount = [%lf]\n",iCnt,dMinTxnAmt));
				}

				if (GetField_Double(hRec, "max_txn_amount", &dMaxTxnAmt)) {
DEBUGLOG(("GetTxnPsp() [%02d] max_txn_amount = [%lf]\n",iCnt,dMaxTxnAmt));
				}

/*criteria_pool id */
				if (GetField_Int(hRec,"criteria_pool_id",&iCriteriaPoolId)) {
DEBUGLOG(("GetTxnPsp() [%02d] criteria_pool_id = [%d]\n",iCnt,iCriteriaPoolId));
				}
/*scheduler id */
				if (GetField_Int(hRec,"scheduler_id",&iSchedulerId)) {
DEBUGLOG(("GetTxnPsp() [%02d] scheduler_id = [%d]\n",iCnt,iSchedulerId));
				}
/* priority */
				if (GetField_Int(hRec,"priority",&iPriority)) {
DEBUGLOG(("GetTxnPsp() [%02d] priority = [%d]\n",iCnt,iPriority));
				}

				//if (CheckAmountTier(iTxnAmountTierId,dTxnAmt) == PD_OK)  
				if (CheckAmountTier(dMinTxnAmt, dMaxTxnAmt, dTxnAmt) == PD_OK)  
				{
DEBUGLOG(("GEtTxnPsp() [%02d] passed CheckAmount Tier\n",iCnt));
					if (CheckScheduler(iSchedulerId,csOrgDateTime) == PD_OK)  {
DEBUGLOG(("GEtTxnPsp() [%02d] this looks good\n",iCnt));
						iGcnt++;
						RecordSet_Add(rRs,hRec);
					}
					else {
DEBUGLOG(("GEtTxnPsp() [%02d] failed CheckScheduler Tier\n",iCnt));
					}
				}
				else {
DEBUGLOG(("GEtTxnPsp() [%02d] failed CheckAmount Tier\n",iCnt));
				}

				hRec = RecordSet_GetNext(rRecordSet);
				iCnt++;
			}
		}

		if (iGcnt == 0) {
DEBUGLOG(("BOTxnLb:GetTxnPsp LoadBalancer could not find any rule!!!\n"));
ERRLOG("FATAL ERROR:BOTxnLb:GetTxnPsp LoadBalancer could not find any rule!!!\n");
			iRet = INT_NO_LB_RECORD;
		}
	}

	if (iRet == PD_OK) {
DEBUGLOG(("GetTxnPsp next level\n"));
		int iCnt = 0;
		int iCriteriaPoolId;
		hash_t	*hRec;

		recordset_t	*rPools;

		rPools = (recordset_t*) malloc (sizeof(recordset_t));

		hRec = RecordSet_GetFirst(rRs);
		iRet = PD_ERR;
                while (hRec && iRet != PD_OK) {
        		recordset_init(rPools,0);
			if (GetField_Int(hRec,"criteria_pool_id",&iCriteriaPoolId)) {
DEBUGLOG(("GetTxnPsp() [%02d] criteria_pool_id = [%d]\n",iCnt,iCriteriaPoolId));
				iRet =  GetPool(iCriteriaPoolId,rPools);
				if (iRet == PD_OK) {
					iRet = CheckPools(dTxnAmt,
							csServiceCode,
							csTxnCountry,
							csTxnCcy,
							csPayMethod,
							csBankCode,
							hPsp,
							rPools,
							csSelectedPspId,
							csOrgDateTime);
				}
			}
			RecordSet_Destroy(rPools);
			hRec = RecordSet_GetNext(rRs);
		}
       		FREE_ME(rPools);
		if (iRet == PD_OK) {
DEBUGLOG(("GetTxnPsp PSP ID [%s] will be appiled for this txn\n",csSelectedPspId));
			PutField_CString(hContext,"psp_id",csSelectedPspId);
		}
	}

	hash_destroy(hTmpPsp);
        FREE_ME(hTmpPsp);
	hash_destroy(hPsp);
        FREE_ME(hPsp);

	hash_destroy(hReq);
        FREE_ME(hReq);

	RecordSet_Destroy(rRs);
       	FREE_ME(rRs);

	RecordSet_Destroy(rRecordSet);
       	FREE_ME(rRecordSet);
DEBUGLOG(("GetTxnPsp() exit iRet = [%d]\n",iRet));
	return iRet;
}

int CheckAmountTier(double dMinTxnAmt, double dMaxTxnAmt, double dTxnAmt)
{
        int             iRet = PD_ERR;

        //double  dMaxVal = 0;
        //double  dMinVal = 0;
        //char    *csDesc;

DEBUGLOG(("CheckAmountTier()\n"));
DEBUGLOG(("CheckAmountTier() min_txn_amt = [%lf] max_txn_amt = [%lf] and Txn Amt = [%f]\n",dMinTxnAmt, dMaxTxnAmt, dTxnAmt));

	if (dTxnAmt >= dMinTxnAmt && (dTxnAmt <= dMaxTxnAmt || dMaxTxnAmt == 0.0)) { 
DEBUGLOG(("CheckAmountTier() min_txn_amt [%lf] max_txn_amt [%lf]  will be applied\n",dMinTxnAmt, dMaxTxnAmt ));
                        iRet = PD_OK;
        }
	else {
DEBUGLOG(("CheckAmountTier() min_txn_amt [%lf] max_txn_amt [%lf] will be filter out!!!\n",dMinTxnAmt, dMaxTxnAmt));
        }

DEBUGLOG(("CheckAmountTier exit iRet = [%d]\n",iRet));
        return  iRet;
}


int CheckScheduler(int iId,const char* csTxnDateTime)
{
	int	iRet = PD_ERR;
	recordset_t     *rRecordSet;
	hash_t	*hRec;
	char	cMode;
	char	*csStartDateTime;
	char	*csEndDateTime;
	char	*csStartTime;
	char	*csEndTime;
	char	csTime[PD_TIME_LEN +1];
	int	iDayOfWeek;
	int	iDay;
DEBUGLOG(("CheckSchedulerId()\n"));
DEBUGLOG(("CheckSchedulerId() id = [%d] txn datetime = [%s]\n",iId,csTxnDateTime));
	iDayOfWeek = day_of_week((const unsigned char*)csTxnDateTime);
	memcpy(csTime,&csTxnDateTime[PD_DATE_LEN],PD_TIME_LEN);
	csTime[PD_TIME_LEN] = '\0';
DEBUGLOG(("CheckSchedulerId() txn datetime = [%s] txn time = [%s]\n",csTxnDateTime,csTime));
	

DEBUGLOG(("CheckSchedulerId() day of week = [%d]\n",iDayOfWeek));

	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

	DBObjPtr = CreateObj(DBPtr,"DBRuleSchedulerHeader","GetIdDetail");	
	if ((unsigned long)(*DBObjPtr)(iId,rRecordSet) == PD_FOUND) {
		iRet = PD_ERR;
		hRec = RecordSet_GetFirst(rRecordSet);
		while(hRec && (iRet==PD_ERR)){
			if (GetField_Char(hRec,"schedule_mode",&cMode)) {
DEBUGLOG(("CheckSchedulerId() schedule_mode = [%c]\n",cMode));
			}
			if (cMode == PD_SCHEDULER_ONCE || cMode == PD_SCHEDULER_MIX ) {
				if (GetField_CString(hRec,"start_datetime",&csStartDateTime)) {
DEBUGLOG(("CheckSchedulerId() start_datetime = [%s]\n",csStartDateTime));
					if (memcmp(csTxnDateTime,csStartDateTime,PD_DATETIME_LEN) >= 0) {
						if (GetField_CString(hRec,"end_datetime",&csEndDateTime)) {
DEBUGLOG(("CheckSchedulerId() end_datetime = [%s]\n",csEndDateTime));
							if (memcmp(csTxnDateTime,csEndDateTime,PD_DATETIME_LEN) > 0) {
DEBUGLOG(("CheckSchedulerId() id [%d] [%s] had expired\n",iId,csEndDateTime));
								iRet = PD_ERR;
							}
							else
								iRet = PD_OK;
						}
						else
							iRet = PD_OK;
					}
					else {
DEBUGLOG(("CheckSchedulerId() id [%d] [%s] not yet in range\n",iId,csStartDateTime));
						iRet = PD_ERR;
					}
				}
			}

			if ((cMode == PD_SCHEDULER_RECURR && iRet == PD_ERR) ||
			    (cMode == PD_SCHEDULER_MIX && iRet == PD_OK)) {
				if (GetField_Int(hRec,"day",&iDay)) {
DEBUGLOG(("CheckSchedulerId() iDay = [%d]\n",iDay));
					if (iDay != 7 && iDay != iDayOfWeek)  {
						iRet = PD_ERR;
DEBUGLOG(("CheckSchedulerId() not today!!!\n"));
					}
					else {
						if (GetField_CString(hRec,"start_time",&csStartTime)) {
DEBUGLOG(("CheckSchedulerId() start_time = [%s]\n",csStartTime));
                                			if (memcmp(csTime,csStartTime,PD_TIME_LEN) >= 0) {
                                        			if (GetField_CString(hRec,"end_time",&csEndTime)) {
DEBUGLOG(("CheckSchedulerId() end_datetime = [%s]\n",csEndTime));
                                                			if (memcmp(csTime,csEndTime,PD_TIME_LEN) > 0) {
DEBUGLOG(("CheckSchedulerId() id [%d] [%s] had expired\n",iId,csEndTime));
                                                        			iRet = PD_ERR;
                                                			}
									else
										iRet=PD_OK;
                                        			}
								else
									iRet=PD_OK;
                                			}
                                			else {
DEBUGLOG(("CheckSchedulerId() id [%d] [%s] not yet in range\n",iId,csStartDateTime));
                                        			iRet = PD_ERR;
                                			}
						}
					}
				}
				else {
DEBUGLOG(("CheckSchedulerId() can't get day tag!!!\n"));
					iRet = PD_ERR;
				}
			}
			hRec = RecordSet_GetNext(rRecordSet);
		}//end while
	}

	RecordSet_Destroy(rRecordSet);
       	FREE_ME(rRecordSet);
DEBUGLOG(("CheckSchedulerId exit iRet = [%d]\n",iRet));
	return	iRet;
}


int GetPool(int iId,recordset_t* rRs)
{
	int	iRet = PD_OK;
	char	*csPtr;
	double 	dPtr;
	int	iPtr;

	hash_t	*hRec;
        recordset_t     *rRecordSet;

	hash_t	*hRsp;

DEBUGLOG(("GetPool()\n"));
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

	DBObjPtr = CreateObj(DBPtr,"DBRulePspLbPools","GetDetailById");	
	if ((unsigned long)(*DBObjPtr)(iId,rRecordSet) == PD_FOUND) {
		hRec = RecordSet_GetFirst(rRecordSet);
		while (hRec) {
			hRsp = (hash_t*) malloc (sizeof(hash_t));
			hash_init(hRsp,0);
/* pool_id */
			if (GetField_Int(hRec,"pool_id",&iPtr)) {
//DEBUGLOG(("GetPool() pool_id = [%d]\n",iPtr));
				PutField_Int(hRsp,"pool_id",iPtr);
			}
/* desc */
			if (GetField_CString(hRec,"desc",&csPtr)) {
//DEBUGLOG(("GetPool() desc = [%s]\n",csPtr));
				PutField_CString(hRsp,"desc",csPtr);
			}

/* pool limit */
			if (GetField_Double(hRec,"pool_limit",&dPtr)) {
//DEBUGLOG(("GetPool() pool limt = [%f]\n",dPtr));
				PutField_Double(hRsp,"pool_limit",dPtr);
			}
/* ratio */
			if (GetField_Int(hRec,"ratio",&iPtr)) {
//DEBUGLOG(("GetPool() ratio = [%d]\n",iPtr));
				PutField_Int(hRsp,"ratio",iPtr);
			}
/* priority */
			if (GetField_Int(hRec,"priority",&iPtr)) {
//DEBUGLOG(("GetPool() priority = [%d]\n",iPtr));
				PutField_Int(hRsp,"priority",iPtr);
			}

			RecordSet_Add(rRs,hRsp);
			hRec = RecordSet_GetNext(rRecordSet);
		}
	}

	RecordSet_Destroy(rRecordSet);
       	FREE_ME(rRecordSet);

DEBUGLOG(("GetPool() exit iRet = [%d]\n",iRet));
	return	iRet;
}
	
int CheckPools(double dTxnAmt,
		const char* csServiceCode,
                const char* csTxnCountry,
                const char* csTxnCcy,
                const char* csPayMethod,
		const char* csBankCode,
		hash_t*	hPsp,
		recordset_t *rRs,
		char*	csSelectedPspId,
		const char* csOrgDateTime)
{
	int	iRet = PD_OK;
	hash_t	*hCurrPool;
	hash_t	*hRec;
	double	dPoolLimit = 0.0;

	double	dCurr = 0.0;
	double	dTotalCurr = 0.0;
	double	dReqCurr = 0.0;
	double	dTotalReqCurr = 0.0;

	int	iPoolId;
	int	iTotalRatio = 0;
	double	dTotalVol = 0.0;
	int	iRatio;
	int	iPriority;
	
	int	iRand = 0;
	int	iCheck = PD_FALSE;
	int	iFinal = PD_FALSE;
	int	iPoolList[PD_TMP_BUF_LEN]; //max 256 pools
	recordset_t     *rPools;

        rPools = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rPools,0);


DEBUGLOG(("CheckPools()\n"));
	hCurrPool = (hash_t*)  malloc (sizeof(hash_t));
        hash_init(hCurrPool,0);


	hRec = RecordSet_GetFirst(rRs);

        rPools = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rPools,0);

	while (hRec) {
		dPoolLimit  = 0.0;
		dCurr  = 0.0;
		dReqCurr  = 0.0;
		iRatio = 0;
		iPriority = 0;
		iCheck = PD_OK;

		if (GetField_Int(hRec,"pool_id",&iPoolId)) {
DEBUGLOG(("CheckPools pool id = [%d]\n",iPoolId));
		}
		else {
DEBUGLOG(("CheckPools pool id is missing!!!\n"));
		}
		
/* check if any ava psp in this pool */
		DBObjPtr = CreateObj(DBPtr,"DBRuleLB","FindAvalPspForPool");      
        	if ((unsigned long)(*DBObjPtr)(iPoolId,hPsp) != PD_OK) {
DEBUGLOG(("CheckPools can't find any aval psp for this pool [%d]\n",iPoolId));
			iCheck = INT_PSP_NOT_AVAILABLE;
		}
		else {
/* check psp with schudler */
		}	
		

		if (iCheck== PD_OK) {
/* check if its psp still has quota */
			if (GetField_Double(hRec,"pool_limit",&dPoolLimit)) {
DEBUGLOG(("CheckPools pool limit = [%f] for pool [%d]\n",dPoolLimit,iPoolId));
			}
			DBObjPtr = CreateObj(DBPtr,"DBRuleLB","FindAvalPsp");      
        		if ((unsigned long)(*DBObjPtr)(iPoolId,csServiceCode,csTxnCountry,dTxnAmt) != PD_OK) {
DEBUGLOG(("CheckPools none of aval psp for this pool [%d] has quota to handle txn amt [%f]\n",iPoolId,dTxnAmt));
				iCheck = INT_PSP_NOT_AVAILABLE;
			}
		}



		if (iCheck == PD_OK ) {
			if (GetField_Int(hRec,"ratio",&iRatio)) {
DEBUGLOG(("CheckPools ratio = [%d]\n",iRatio));
			}

			if (GetField_Int(hRec,"priority",&iPriority)) {
DEBUGLOG(("CheckPools priority = [%d]\n",iPriority));
			}

/*
DEBUGLOG(("CheckPools ------------------------------------------\n"));
DEBUGLOG(("CheckPools ServiceCode = [%s]\n",csServiceCode));
DEBUGLOG(("CheckPools TxnCountry = [%s]\n",csTxnCountry));
DEBUGLOG(("CheckPools TxnCcy = [%s]\n",csTxnCcy));
DEBUGLOG(("CheckPools PayMethod = [%s]\n",csPayMethod));
DEBUGLOG(("CheckPools ------------------------------------------\n"));
*/
			if (dPoolLimit != 0.0 ) {
DEBUGLOG(("CheckPools call checkpoolimit\n"));
				iCheck = CheckPoolLimit(iPoolId,
       	        					csServiceCode,
       	        					csTxnCountry,
       	        					csTxnCcy,
       	        					csPayMethod,
							dTxnAmt,
       	        					dPoolLimit,
							&dCurr,
							&dTotalCurr,
							&dReqCurr,
							&dTotalReqCurr);
			}
			else {
/* Get Curr Pool Hit */
				DBObjPtr = CreateObj(DBPtr,"DBRulePspLbPools","GetPspPoolsTotal");      
       		 		iCheck = (unsigned long)(*DBObjPtr)(iPoolId,csServiceCode,csTxnCountry,csTxnCcy,csPayMethod,&dCurr,&dTotalCurr,&dReqCurr,&dTotalReqCurr);
DEBUGLOG(("CheckPools iRet = [%d] from GetPspPoolsTotal\n",iRet));
			}
			if (iCheck == PD_OK) {
/* check aval psp limit under this pool */
			}

			if (iCheck == PD_OK) {
DEBUGLOG(("CheckPools pool id [%d] is good Pool Curr = [%f] Req Curr = [%f]\n",iPoolId,dCurr,dReqCurr));
				RecordSet_Add(rPools,hRec);	
				PutField_Double(hRec,"pool_curr",dCurr);
				PutField_Double(hRec,"pool_req_curr",dReqCurr);
				iFinal=PD_TRUE;
			}
		}

		if (iCheck == PD_OK) {
			iTotalRatio += iRatio;
//			dTotalVol += dCurr; /* approval amount */
			dTotalVol += dReqCurr; /* request txn amount */
DEBUGLOG(("CheckPools total ratio now =  [%d] total Vol = [%lf]\n",iTotalRatio,dTotalVol));
		}
		hRec = RecordSet_GetNext(rRs);
	}
	if(!iFinal){
		iRet=iCheck;
	}

	if (iTotalRatio > 0) {
DEBUGLOG(("CheckPools ------------let see which pool will fit\n"));
		int    	iFinalPoolId;
	        int    	iFinalPriority = 0;	
		int	iCnt=0;
		double 	dFinalVolRatio = 0;
		double 	dFinalPoolRatio = 0;
		double 	dTmpVolRatio = 0.0;
		double 	dPoolRatio = 0.0;
		hRec = RecordSet_GetFirst(rPools);
		while (hRec) {
			if (GetField_Int(hRec,"pool_id",&iPoolId)) {
DEBUGLOG(("CheckPools ------------pool id = [%d]\n",iPoolId));
			}
			if (GetField_Double(hRec,"pool_limit",&dPoolLimit)) {
DEBUGLOG(("CheckPools ------------pool limit = [%f] for pool [%d]\n",dPoolLimit,iPoolId));
			}

			if (GetField_Int(hRec,"ratio",&iRatio)) {
DEBUGLOG(("CheckPools ------------ratio = [%d]\n",iRatio));
                	}

                	if (GetField_Int(hRec,"priority",&iPriority)) {
DEBUGLOG(("CheckPools ------------priority = [%d]\n",iPriority));
                	}

                	if (GetField_Double(hRec,"pool_curr",&dCurr)) {
DEBUGLOG(("CheckPools ------------pool_curr = [%f]\n",dCurr));
                	}

                	if (GetField_Double(hRec,"pool_req_curr",&dReqCurr)) {
DEBUGLOG(("CheckPools ------------pool_req_curr = [%f]\n",dReqCurr));
                	}

			if (iRatio > 0 ) {
				dPoolRatio = (double)iRatio/(double)iTotalRatio;
DEBUGLOG(("CheckPools ------------Pool Ratio = [%f]\n",dPoolRatio));

				if (dCurr == 0.0 ) 
					dTmpVolRatio = 0.0;
				else 
					dTmpVolRatio = dReqCurr/dTotalVol; /* request amount */
			//		dTmpVolRatio = dCurr/dTotalVol; /* approval amount */

//DEBUGLOG(("CheckPools ------------tmp vol ratio = [%f] = [%f / [%f]\n",dTmpVolRatio,dCurr,dTotalVol));
DEBUGLOG(("CheckPools ------------tmp vol ratio = [%f] = [%f / [%f]\n",dTmpVolRatio,dReqCurr,dTotalVol));

				if (iCnt == 0) {
					iFinalPoolId = iPoolId;
					iFinalPriority = iPriority;
					dFinalVolRatio = dTmpVolRatio;
					dFinalPoolRatio = dPoolRatio;
				}
				iCnt++;
/* if the pool was never hit */
				//if (dCurr == 0.0 ) {
				if (dReqCurr == 0.0 ) {
DEBUGLOG(("dReqCurr == 0.0\n"));
				/* if both pools are never hit */
					if (dFinalVolRatio == 0.0) {
DEBUGLOG(("FinalVolRatio == 0.0\n"));
						if (iPriority > iFinalPriority)  {
							iFinalPoolId = iPoolId;
							iFinalPriority = iPriority;
							dFinalVolRatio = 0.0;
							dFinalPoolRatio = dPoolRatio;
							iRand = 0;
						}
						else if (iPriority == iFinalPriority) {
/* insert into random pool list */
							iPoolList[iRand] = iPoolId;
							iRand++;
							
						}
					}
				/* take the lowest */
					else {
						iFinalPoolId = iPoolId;
						iFinalPriority = iPriority;
						dFinalVolRatio = 0.0;
						dFinalPoolRatio = dPoolRatio;
					}
				}
/* if exceed the current ratio */
				else if ( dTmpVolRatio <= dFinalVolRatio) {
DEBUGLOG(("CheckPools TmpVolRatio [%f] <= FinalVolRatio [%f]\n",dTmpVolRatio,dFinalVolRatio));
					if (dFinalPoolRatio < dFinalVolRatio  || iPriority > iFinalPriority) {
DEBUGLOG(("CheckPools it has higher Priority or previous pool has reach its ratio\n"));
DEBUGLOG(("CheckPools  FinalPoolRatio [%f] < FinalVolRaio [%f] || Priority[%d] > FinalPriority[%d]\n",dFinalPoolRatio,dFinalVolRatio,iPriority,iFinalPriority));
						iFinalPoolId = iPoolId;
						iFinalPriority = iPriority;
						dFinalVolRatio = dTmpVolRatio;
						dFinalPoolRatio = dPoolRatio;
					}
				}
			}
DEBUGLOG(("CheckPools ++ pool id [%d] Priority [%d] Vol Ratio [%f] Pool Ratio [%f]\n",iFinalPoolId,iFinalPriority,dFinalVolRatio,dFinalPoolRatio));
			hRec = RecordSet_GetNext(rPools);
		}
/* select pool */
		iRet = PD_ERR;
		int	iPoolTmpList[PD_TMP_BUF_LEN]; //max 256 pools
		while (iRet != PD_OK) {
			int i = 0;
			int j;
			if (iRand > 0 ) {	
				int iRandIndex = rand() % iRand;
				DEBUGLOG(("CheckPools Idx = [%d] [%d]\n",iRandIndex,iPoolList[iRandIndex]));
				iFinalPoolId = iPoolList[iRandIndex];
				/* prepare for reselect from the list */
				for (j = 0; j < iRand; j++ ) {
					if (i ==  iRandIndex) 
						continue;
					else {
						iPoolTmpList[i]  = iPoolList[j];
						i++;
					}
				}
			}
DEBUGLOG(("CheckPools +++ call PickPsp\n"));
			iRet = PickPsp(hPsp,iFinalPoolId,csBankCode,csPayMethod,csServiceCode,csTxnCountry,csTxnCcy,csSelectedPspId,dTxnAmt,csOrgDateTime);
			iRand = i;
DEBUGLOG(("CheckPools +++ call PickPsp iRet = [%d]\n",iRet));
/* prepare for reselect from the list */
			if (iRet != PD_OK) {
				if (iRand == 0 ) 
					break;
				for (j = 0; j < iRand; j++ ) {
					iPoolList[j]  = iPoolTmpList[j];
				}
			}
		}
	}
	else {
DEBUGLOG(("CheckPools no pool will fit .....\n"));
ERRLOG("FATAL ERROR BOTxnLb: CheckPools no pool will fit .....\n");
		iRet = INT_EXCEED_LIMIT_PSP_AMT;
	}


	hash_destroy(hCurrPool);
        FREE_ME(hCurrPool);


	RecordSet_Destroy(rPools);
       	FREE_ME(rPools);
DEBUGLOG(("CheckPools() exit iRet = [%d]\n",iRet));
	return	iRet;
}

int CheckPoolLimit(int iId,
		const char* csServiceCode,
		const char* csTxnCountry,
		const char* csTxnCcy,
		const char* csPayMethod,
		double dTxnAmt,
		double dLimit,
		double *dPoolCurr,
		double *dTotalPoolCurr,
		double *dPoolReqCurr,
		double *dTotalPoolReqCurr)
{
	int iRet = PD_ERR;
DEBUGLOG(("CheckPoolLimit()\n"));

/*
DEBUGLOG(("CheckPoolLimit ------------------------------------------\n"));
DEBUGLOG(("CheckPoolLimits ServiceCode = [%s]\n",csServiceCode));
DEBUGLOG(("CheckPoolLimits TxnCountry = [%s]\n",csTxnCountry));
DEBUGLOG(("CheckPoolLimits TxnCcy = [%s]\n",csTxnCcy));
DEBUGLOG(("CheckPoolLimits PayMethod = [%s]\n",csPayMethod));
DEBUGLOG(("CheckPoolLimits ------------------------------------------\n"));
*/
	DBObjPtr = CreateObj(DBPtr,"DBRulePspLbPools","GetPspPoolsTotal");	
	/*iRet = (unsigned long)(*DBObjPtr)(iId,csServiceCode,csTxnCountry,csTxnCcy,csPayMethod,dPoolCurr,dTotalPoolCurr,&dPoolReqCurr,&dTotalPoolReqCurr);*/

	iRet = (unsigned long)(*DBObjPtr)(iId,csServiceCode,csTxnCountry,csTxnCcy,csPayMethod,
						dPoolCurr,dTotalPoolCurr,dPoolReqCurr,dTotalPoolReqCurr);

	if (iRet == PD_OK) {
//DEBUGLOG(("Rule limit = [%f] current hit = [%f]\n",dLimit,*dPoolCurr));
DEBUGLOG(("Rule limit = [%f] current hit = [%f] PoolReqCurr = [%f]\n",dLimit,*dPoolCurr,*dTotalPoolReqCurr));

		if (*dTotalPoolCurr == 0.0) {
DEBUGLOG(("CheckPoolLimit() Not Yet Exceed Limit since no txn had been made for this pool [%d]+++\n",iId));
		}
		else if (*dTotalPoolCurr + dTxnAmt > dLimit) {
DEBUGLOG(("CheckPoolLimit() Exceed Limit [%f + %f] > [%f]*****\n",*dTotalPoolCurr,dTxnAmt,dLimit));
			iRet = INT_EXCEED_LIMIT_PSP_AMT;
		}
		else {
DEBUGLOG(("CheckPoolLimit() Not Yet Exceed Limit (%f + %f <= %f+++\n",*dTotalPoolCurr,dTxnAmt,dLimit));
		}
	}
DEBUGLOG(("CheckPoolLimit() exit iRet = [%d]\n",iRet));
	return iRet;
}
	
int PickPsp(hash_t* hPsp,
		int iId,
		const char* csBankCode,
		const char* csPayMethod,
		const char* csServiceCode,
		const char* csTxnCountry,
		const char* csTxnCcy,
		char*	csSelectedPspId,
		double	dTxnAmt,
		const char* csOrgDateTime)
{
	int	iRet = PD_OK;
	char	*csPspId;
	double	dLimit;
	double	dPspCurr;
	double	dTotalPspCurr;
	double	dPspReqCurr;
	double	dTotalPspReqCurr;
	double	dTotalVol = 0.0;
	int	iTotalRatio = 0;
	int	iRatio;

	int	iRand = 0;
	int	iRecord = 0;
	int	iFinal = PD_FALSE;
	int	iCheck = PD_FALSE;
	char	csPspList[PD_TMP_BUF_LEN ][PD_PSP_ID_LEN +1]; //max 256 psp
	recordset_t     *rPsp,*rAvalPsp;
	hash_t		*hRec;


DEBUGLOG(("PickPsp()\n"));
DEBUGLOG(("PickPsp() Pool id = [%d] country = [%s] pay method = [%s] service code = [%s]\n",iId,csTxnCountry,csPayMethod,csServiceCode));
        rPsp = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rPsp,0);

        rAvalPsp = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rAvalPsp,0);

	DBObjPtr = CreateObj(DBPtr,"DBRuleLB","GetAvalPspsByPool");	
	if ((*DBObjPtr)(hPsp,iId,rPsp) == PD_OK) {
		hRec = RecordSet_GetFirst(rPsp);
		while(hRec) {
			iRatio = 0.0;
			dLimit = 0.0;
			dPspCurr = 0.0;
			dTotalPspCurr = 0.0;
			dPspReqCurr = 0.0;
			dTotalPspReqCurr = 0.0;
			if (GetField_CString(hRec,"psp_id",&csPspId)) {
DEBUGLOG(("PickPsp psp id  = [%s]\n",csPspId));
				DBObjPtr = CreateObj(DBPtr,"DBRulePspLbPsp","GetPsp");	
				iRet = (unsigned long)(*DBObjPtr)(csPspId,hRec);
				if (iRet != PD_OK) 
					break;
				if (GetField_Double(hRec,"psp_limit",&dLimit )) {
DEBUGLOG(("PickPsp limit for [%s]  = [%f]\n",csPspId,dLimit));
				}
				if (GetField_Int(hRec,"pool_psp_ratio",&iRatio)) {
DEBUGLOG(("PickPsp ratio for [%s]  = [%d] from Pool Mapping\n",csPspId,iRatio));
				}
				else 
					iRatio = 0;

/* don't use psp level's ratio and priority
				if (iRatio == 0) { //if don't override by the pool mapping
					if (GetField_Int(hRec,"psp_ratio",&iRatio )) {
DEBUGLOG(("PickPsp ratio for [%s]  = [%d]\n",csPspId,iRatio));
					}
				}
*/

				if (dLimit != 0.0) {
					iCheck = CheckPspLimit(csPspId,
								csServiceCode,
								csTxnCountry,
								csTxnCcy,
								csPayMethod,
								dTxnAmt,
								dLimit,
								&dPspCurr,
								&dTotalPspCurr,
								&dPspReqCurr,
								&dTotalPspReqCurr);	
				}
				else {
/* Get Curr Pool Hit */
                        		DBObjPtr = CreateObj(DBPtr,"DBRulePspLbPsp","GetPspLimit");
                        		iCheck = (unsigned long)(*DBObjPtr)(csPspId,csServiceCode,csTxnCountry,csTxnCcy,csPayMethod,&dPspCurr,&dTotalPspCurr,&dPspReqCurr,&dTotalPspReqCurr);
				}

				if (iCheck== PD_OK) {
DEBUGLOG(("PickPsp psp id [%s] is good psp Curr = [%f]\n",csPspId,dPspCurr));
                                        PutField_Double(hRec,"psp_curr",dPspCurr);
                                        PutField_Double(hRec,"psp_req_curr",dPspReqCurr);
                                        RecordSet_Add(rAvalPsp,hRec);
					iFinal = PD_TRUE;
                                }
			}
                       	iTotalRatio += iRatio;
                     //  	dTotalVol += dPspCurr; /* approval amount */
                       	dTotalVol += dPspReqCurr; /* request amount */
DEBUGLOG(("CheckPools total ratio now =  [%d] total Vol = [%lf]\n",iTotalRatio,dTotalVol));
			hRec = RecordSet_GetNext(rPsp);
		}
	}
	else {
DEBUGLOG(("PickPsp Not record return from!!!\n"));
	}

	if(!iFinal){
		iRet = iCheck;
	}

	if (iTotalRatio >0 ) {
DEBUGLOG(("PickPsp ------------let see which psp will fit\n"));
                int    	iFinalPriority = 0;
		int    	iPriority = 0;
                double 	dFinalVolRatio = 0;
                double 	dFinalPspRatio = 0;
                double 	dTmpVolRatio = 0.0;
                double 	dPspRatio = 0.0;
		int	iCnt = 0;
                hRec = RecordSet_GetFirst(rAvalPsp);
                while (hRec) {
			iRecord++;
                        if (GetField_CString(hRec,"psp_id",&csPspId)) {
DEBUGLOG(("PickPsp ------------psp id = [%s]\n",csPspId));
                        }
                        if (GetField_Double(hRec,"psp_limit",&dLimit)) {
DEBUGLOG(("PickPsp ------------pool limit = [%f] for psp [%s]\n",dLimit,csPspId));
                        }

			if (GetField_Int(hRec,"pool_psp_ratio",&iRatio)) {
DEBUGLOG(("PickPsp ------------ratio from pool mapping = [%d]\n",iRatio));
			} else {
				iRatio = 0;
			}

/* don't use psp level of ratio 
			if (iRatio == 0) { // if not override by pool mapping
                        	if (GetField_Int(hRec,"psp_ratio",&iRatio)) {
DEBUGLOG(("PickPsp ------------ratio = [%d]\n",iRatio));
                        	}
			}
*/

                        if (GetField_Int(hRec,"pool_psp_priority",&iPriority)) {
DEBUGLOG(("PickPsp ------------priority = [%d] from pool mapping\n",iPriority));
			}
			else 
				iPriority = 0;
/* don't use psp level of priority 
			if (iPriority == 0) { // if not override by pool mapping
                        	if (GetField_Int(hRec,"psp_priority",&iPriority)) {
DEBUGLOG(("PickPsp ------------priority = [%d]\n",iPriority));
                        	}
			}
*/

                        if (GetField_Double(hRec,"psp_curr",&dPspCurr)) {
DEBUGLOG(("PickPsp ------------psp_curr = [%f]\n",dPspCurr));
                        }
                        if (GetField_Double(hRec,"psp_req_curr",&dPspReqCurr)) {
DEBUGLOG(("PickPsp ------------psp_req_curr = [%f]\n",dPspReqCurr));
                        }

                        if (iRatio > 0 ) {
                                dPspRatio = (double)iRatio/(double)iTotalRatio;
DEBUGLOG(("PickPsp ------------psp Ratio = [%f]\n",dPspRatio));
				//if (dPspCurr == 0.0 )
				if (dPspReqCurr == 0.0 )
                                        dTmpVolRatio = 0.0;
                                else
                                        dTmpVolRatio = dPspReqCurr/dTotalVol; /* Request Amount*/
                                        //dTmpVolRatio = dPspCurr/dTotalVol; /* approval amount */

				if (iCnt == 0) {
					strcpy(csSelectedPspId,csPspId);
                                	iFinalPriority = iPriority;
                                	dFinalVolRatio = dTmpVolRatio;
                                	dFinalPspRatio = dPspRatio;
				}
				iCnt++;

DEBUGLOG(("PickPsp ------------tmp vol ratio = [%f]\n",dTmpVolRatio));

/* if the psp was never hit */
                                //if (dPspCurr == 0.0 ) { /* approval amount */
                                if (dPspReqCurr == 0.0 ) {
                                /* if both psp are never hit */
DEBUGLOG((" pspreqcurr == 0.0 \n"));
                                        if (dFinalVolRatio == 0.0) {
DEBUGLOG((" finalvolratio == 0.0 \n"));
                                                if (iPriority > iFinalPriority)  {
DEBUGLOG((" Priority [%d] > FinalPriorty [%d] \n",iPriority,iFinalPriority));
							strcpy(csSelectedPspId,csPspId);
                                                        iFinalPriority = iPriority;
                                                        dFinalVolRatio = 0.0;
                                			dFinalPspRatio = dPspRatio;
							iRand = 0;
                                                }
/* if both are the same */
						else if (iPriority == iFinalPriority) {
DEBUGLOG((" insert into the random list[%d]\n",iRand));						
							strcpy(csPspList[iRand],csPspId);
							iRand++;
						}
                                        }
                                /* take the lowest */
                                        else {
DEBUGLOG((" else \n"));
						strcpy(csSelectedPspId,csPspId);
                                                iFinalPriority = iPriority;
                                                dFinalVolRatio = 0.0;
                                		dFinalPspRatio = dPspRatio;
                                        }
                                }
/* if exceed the current ratio */
				else if ( dTmpVolRatio <= dFinalVolRatio) {
DEBUGLOG(("PickPsp TmpVolRatio [%f] <= FinalVolRatio [%f]\n",dTmpVolRatio,dFinalVolRatio));
                                        if (dFinalPspRatio < dFinalVolRatio  || iPriority > iFinalPriority) {
DEBUGLOG(("PickPsp it has higher Priority or previous pool has reach its ratio\n"));
DEBUGLOG(("PickPsp FinalPspRatio [%f] < FinalVolRaio [%f] || Priority[%d] > FinalPriority[%d]\n",dFinalPspRatio,dFinalVolRatio,iPriority,iFinalPriority));
						strcpy(csSelectedPspId,csPspId);
                                                iFinalPriority = iPriority;
                                                dFinalVolRatio = dTmpVolRatio;
                                		dFinalPspRatio = dPspRatio;
                                        }
                                }
                        }
DEBUGLOG(("PickPsp +++ psp id [%s] Priority [%d] Ratio [%f]\n",csSelectedPspId,iFinalPriority,dFinalVolRatio));
                        hRec = RecordSet_GetNext(rAvalPsp);
                }
	}
	if(!iRecord){
		iRet = INT_PSP_NOT_AVAILABLE;
DEBUGLOG(("PickPsp +++ no psp available!!!!!\n"));
ERRLOG("BOTxnLb: PickPsp +++ no psp available!!!!!\n");
	}

	RecordSet_Destroy(rAvalPsp);
       	FREE_ME(rAvalPsp);

	RecordSet_Destroy(rPsp);
       	FREE_ME(rPsp);

	if (iRand >0 ) {
//Random Select PSP
		int iRandIndex = rand() % iRand; 
DEBUGLOG(("PickPsp idx = [%d] [%s] from total of [%d]\n",iRandIndex,csPspList[iRandIndex],iRand));
		strcpy(csSelectedPspId,csPspList[iRandIndex]);
	}
DEBUGLOG(("PickPsp() exit iRet = [%d] [%s]\n",iRet,csSelectedPspId));
	return iRet;
}


int CheckPspLimit(const char* csId,
                const char* csServiceCode,
                const char* csTxnCountry,
                const char* csTxnCcy,
                const char* csPayMethod,
                double dTxnAmt,
                double dLimit,
                double *dPoolCurr,
                double *dTotalPoolCurr,
                double *dPoolReqCurr,
                double *dTotalPoolReqCurr)
{
        int iRet = PD_ERR;
DEBUGLOG(("CheckPspLimit()\n"));

/*
DEBUGLOG(("CheckPspLimit ------------------------------------------\n"));
DEBUGLOG(("CheckPspLimit ServiceCode = [%s]\n",csServiceCode));
DEBUGLOG(("CheckPspLimit TxnCountry = [%s]\n",csTxnCountry));
DEBUGLOG(("CheckPspLimit TxnCcy = [%s]\n",csTxnCcy));
DEBUGLOG(("CheckPspLimit PayMethod = [%s]\n",csPayMethod));
DEBUGLOG(("CheckPspLimit ------------------------------------------\n"));
*/

        DBObjPtr = CreateObj(DBPtr,"DBRulePspLbPsp","GetPspLimit");
        iRet = (unsigned long)(*DBObjPtr)(csId,csServiceCode,csTxnCountry,csTxnCcy,csPayMethod,dPoolCurr,dTotalPoolCurr,dPoolReqCurr,dTotalPoolReqCurr);

        if (iRet == PD_OK) {
DEBUGLOG(("Rule limit = [%f] current hit = [%f]\n",dLimit,*dPoolCurr));

                if (*dTotalPoolCurr == 0.0) {
DEBUGLOG(("CheckPspLimit() Not Yet Exceed Limit since no txn had been made for this psp [%s]+++\n",csId));
                }
                else if (*dTotalPoolCurr + dTxnAmt > dLimit) {
DEBUGLOG(("CheckPspLimit() Exceed Limit [%f] + [%f]> [%f]*****                                    +++\n",*dTotalPoolCurr,dTxnAmt,dLimit));
                        iRet = INT_EXCEED_LIMIT_PSP_AMT;
                }
                else {
DEBUGLOG(("CheckPspLimit() Not Yet Exceed Limit (%f + %f <= %f [%s]+++\n",*dTotalPoolCurr,dTxnAmt,dLimit,csId));
                }
        }
DEBUGLOG(("ChecPspLimit() exit iRet = [%d]\n",iRet));
        return iRet;
}


int CheckAllPossiblePspLimit(hash_t* hContext,
				const hash_t* hRequest)
{
	int	iRet = PD_OK;
	int	iCnt = 0;
	int	avaCnt = 0;
	char*	csTmp;

	char*	csMerchantId;
	char*	csTxnCcy;
	double	dTxnAmt;

	double	dPspLimit = -1.0;
	double	dPspRemainingLimit = -1.0;
	char*	csPspCcy;
	double	dConvertAmt = -1.0;

	recordset_t	*rRecordSet;

	if (GetField_CString(hRequest, "merchant_id", &csMerchantId)) { 
DEBUGLOG(("CheckAllPossiblePspLimit() merchant_id = [%s]\n",csMerchantId)); 
	} else {
		iRet = PD_ERR;
DEBUGLOG(("CheckAllPossiblePspLimit() merchant_id missing!!!\n")); 
	}

	if (GetField_CString(hRequest, "txn_ccy", &csTxnCcy)) { 
DEBUGLOG(("CheckAllPossiblePspLimit() txn_ccy = [%s]\n",csTxnCcy)); 
	} else {
		iRet = PD_ERR;
DEBUGLOG(("CheckAllPossiblePspLimit() txn_ccy missing!!!\n")); 
	}

	if (GetField_Double(hContext, "org_txn_amt", &dTxnAmt)) { 
DEBUGLOG(("CheckAllPossiblePspLimit() txn_amt = [%lf]\n",dTxnAmt)); 
	} else {
		iRet = PD_ERR;
DEBUGLOG(("CheckAllPossiblePspLimit() txn_amt missing!!!\n")); 
	}

        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

	hash_t	*hRec;

DEBUGLOG(("CheckAllPossiblePspLimit Call GetAllPspByMerch ()\n")); 
	DBObjPtr = CreateObj(DBPtr,"DBRuleLB","GetAllPspByMerch");
	iRet = (unsigned long)(*DBObjPtr)(csMerchantId,rRecordSet);
	if(iRet == PD_OK){
		hRec = RecordSet_GetFirst(rRecordSet);
		while(hRec){

			dPspLimit = -1.0;
			dPspRemainingLimit = -1.0;
			dConvertAmt = -1.0;

			if (GetField_CString(hRec, "psp_name", &csTmp)) { 
DEBUGLOG(("GetAllPspByMerch() [%02d] psp_name = [%s]\n",iCnt,csTmp)); 
			}

			if (GetField_CString(hRec, "psp_id", &csTmp)) { 
//DEBUGLOG(("GetAllPspByMerch() [%02d] psp_id = [%s]\n",iCnt,csTmp)); 
			}

			if (GetField_CString(hRec, "psp_ccy", &csPspCcy)) { 
//DEBUGLOG(("GetAllPspByMerch() [%02d] currency_id = [%s]\n",iCnt,csPspCcy)); 
			} else {
DEBUGLOG(("GetAllPspByMerch() [%02d] currency_id missing!!!\n",iCnt)); 
			}

			if (GetField_Double(hRec, "psp_limit", &dPspLimit)) { 
//DEBUGLOG(("GetAllPspByMerch() [%02d] limit = [%lf]\n",iCnt,dPspLimit)); 
			} else {
DEBUGLOG(("GetAllPspByMerch() [%02d] limit missing!!!\n",iCnt)); 
			}

			if (GetField_Double(hRec, "psp_remaining_limit", &dPspRemainingLimit)) { 
DEBUGLOG(("GetAllPspByMerch() [%02d] remaining_limit = [%lf]\n",iCnt,dPspRemainingLimit)); 
			} else {
DEBUGLOG(("GetAllPspByMerch() [%02d] remaining_limit missing!!!\n",iCnt)); 
			}

			if (dPspRemainingLimit > 0.0){
				if (strcmp(csPspCcy, csTxnCcy)){
					PutField_CString(hContext,"dst_txn_ccy",csPspCcy);
DEBUGLOG(("CheckAllPossiblePspLimit Call GetExchangeInfo()\n")); 
					BOObjPtr = CreateObj(BOPtr,"BOExchange","GetExchangeInfo");
					iRet = (unsigned long)(*BOObjPtr)(hContext,hRequest);
					if(iRet != PD_OK || !GetField_Double(hContext, "dst_txn_amt", &dConvertAmt)){
						dConvertAmt = -1.0;
DEBUGLOG(("CheckAllPossiblePspLimit Call GetExchangeInfo() Fail!!!\n")); 
					}
				} else {
					dConvertAmt = dTxnAmt;
				}

DEBUGLOG(("CheckAllPossiblePspLimit amount [%lf] in ccy [%s]\n",dConvertAmt,csPspCcy)); 
				if (iRet == PD_OK) {
					if (dPspRemainingLimit > dConvertAmt && dConvertAmt > 0.0){
						avaCnt++;
						break;
					} else {
DEBUGLOG(("CheckAllPossiblePspLimit exceed limit!\n"));
					}
				}
			}

			iCnt++;
			hRec = RecordSet_GetNext(rRecordSet);
		}	
	} else {
DEBUGLOG(("CheckAllPossiblePspLimit Call GetAllPspByMerch () Fail!!!\n")); 
	}

	RecordSet_Destroy(rRecordSet);
	
	if(iRet == PD_OK){
		if(avaCnt == 0){
			iRet = INT_EXCEED_LIMIT_PSP_AMT;
			PutField_Int(hContext,"internal_error",iRet);
		}
	}
//DEBUGLOG(("CheckAllPossiblePspLimit Psp cnt = [%d/%d]\n",avaCnt,iCnt));
DEBUGLOG(("CheckAllPossiblePspLimit iRet = [%d]\n",iRet));
	return iRet;
}


int CheckEffectiveScheduler(int iId,const char* csTxnDateTime)
{
	int	iRet = PD_ERR;
	recordset_t     *rRecordSet;
	hash_t	*hRec;
	//char	cMode;
	char	*csStartDateTime;
	char	*csEndDateTime;
	//char	csTime[PD_TIME_LEN +1];
	int	iDayOfWeek;
	//int	iDay;
DEBUGLOG(("CheckEffectiveScheduler()\n"));
DEBUGLOG(("CheckEffectiveScheduler() id = [%d] txn datetime = [%s]\n",iId,csTxnDateTime));
	iDayOfWeek = day_of_week((const unsigned char*)csTxnDateTime);
	//memcpy(csTime,&csTxnDateTime[PD_DATE_LEN],PD_TIME_LEN);
	//csTime[PD_TIME_LEN] = '\0';
//DEBUGLOG(("CheckEffectiveScheduler() txn datetime = [%s] txn time = [%s]\n",csTxnDateTime,csTime));
DEBUGLOG(("CheckEffectiveScheduler() day of week = [%d]\n",iDayOfWeek));

	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

	DBObjPtr = CreateObj(DBPtr,"DBRuleSchedulerHeader","GetIdDetail");	
	if ((unsigned long)(*DBObjPtr)(iId,rRecordSet) == PD_FOUND) {
		iRet = PD_ERR;
		hRec = RecordSet_GetFirst(rRecordSet);
		while(hRec && (iRet==PD_ERR)){
			if (GetField_CString(hRec,"effect_datetime",&csStartDateTime)) {
DEBUGLOG(("CheckEffectiveScheduler() effect_datetime = [%s]\n",csStartDateTime));
				if (memcmp(csTxnDateTime,csStartDateTime,PD_DATETIME_LEN) >= 0) {
					if (GetField_CString(hRec,"end_datetime",&csEndDateTime)) {
DEBUGLOG(("CheckEffectiveScheduler() end_datetime = [%s]\n",csEndDateTime));
						if (memcmp(csTxnDateTime,csEndDateTime,PD_DATETIME_LEN) < 0) {
							iRet = PD_OK;
						}
					}
					else
						iRet = PD_OK;
				}
				else {
DEBUGLOG(("CheckEffectiveScheduler() id [%d] [%s] not effective now\n",iId,csStartDateTime));
				}
			}
			hRec = RecordSet_GetNext(rRecordSet);
		}//end while
	}

	RecordSet_Destroy(rRecordSet);
       	FREE_ME(rRecordSet);
DEBUGLOG(("CheckEffectiveScheduler exit iRet = [%d]\n",iRet));
	return	iRet;
}
