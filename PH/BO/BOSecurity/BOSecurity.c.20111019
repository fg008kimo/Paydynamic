/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2010/09/29              Cody Chan
ESky Support					   2011/01/11		   Cody Chan
MD5 Support					   2011/04/13		   Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"
#include "common.h"
#include "BOSecurity.h"
#include "mymd5.h"
#define PD_MY_KEY	"1234567890abcdef1234567890ABCDEF"

#define	MY_FIELD_TOKEN	"|"
char    cDebug;

int GenerateMD5Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT);
int Generate3DESMac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT);
int GenerateSHA1Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT);
int VerifyMD5Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN);
int VerifySHA1Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN);
int Verify3DESMac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN);


OBJPTR(DB);
OBJPTR(BO);
OBJPTR(Msg);

void BOSecurity(char    cdebug)
{
        cDebug = cdebug;
}



int VerifyXpaySign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char	*csBuf,*csOUT;
	char	*csPtr;
	char	*csSign = strdup("");
	
DEBUGLOG(("BOSecurity:VerifyXpaySign()\n"));
	csBuf = (char*) malloc (1024 * 2 +1);
	csOUT = (char*) malloc (1024 * 2 +1);

	csBuf[0]='\0';
	csOUT[0]='\0';
/* merchant_id */
	if (GetField_CString(hRequest,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() merchant_id= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}

/* encrypt_type */
	if (GetField_CString(hRequest,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() encrypt_type= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* plainttext_data */
	if (GetField_CString(hRequest,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() plainttext_data= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* merchant_key */
	if (GetField_CString(hContext,"merchant_key",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() merchant_key= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
	}
	else {
DEBUGLOG(("BOSecurity:VerifyXpaySign() merchant_key is missing!!!\n"));
	}
DEBUGLOG(("BOSecurity:VerifyXpaySign() verify_data= [%s]\n",csBuf));

	md5sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifyXpaySign() sign             = [%s]\n",csOUT));
	csBuf[0] = '\0';
	U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifyXpaySign() sign             = [%s]\n",csBuf));


	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() sign from Request= [%s]\n",csSign));
	}

	else {
errlog("BOSecurity:VerifyXpaySign sign not found\n");
DEBUGLOG(("BOSecurity:VerifyXpaySign sign not found\n"));
		iRet = INT_SIGN_DATA_NOT_FOUND;
		PutField_Int(hContext,"internal_error",iRet);
	}
/* verify sign */
	if (memcmp(csSign,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifyXpaySign() iRet = [%d]\n",iRet));

	
	return iRet;
}


int GenerateXpaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;

DEBUGLOG(("BOSecurity:GenerateXpaySign()\n"));
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);

        csBuf[0]='\0';
        csOUT[0]='\0';
/* merchant_id */
        if (GetField_CString(hOut,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() merchant_id= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }

/* encrypt_type */
        if (GetField_CString(hOut,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() encrypt_type= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* plainttext_data */
        if (GetField_CString(hOut,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() plainttext_data= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* merchant_key */
        if (GetField_CString(hContext,"merchant_key",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() merchant_key= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
DEBUGLOG(("BOSecurity:GenerateXpaySign() sign_data= [%s]\n",csBuf));

        md5sum(csBuf,strlen(csBuf),csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateXpaySign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateXpaySign() sign             = [%s]\n",csBuf));
	PutField_CString(hOut,"sign",csBuf);


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateXpaySign() iRet = [%d]\n",iRet));


        return iRet;
}
int GenerateMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
        int     iRet = PD_OK;
        char    *csEncType;
        char    *csMerchantId;
        char    *csKey;
        char    *csMac;
        char    *csData;
	char	*csKeyName;
	
        hash_t  *hRec;
        recordset_t     *rRecordSet;
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

DEBUGLOG(("BOSecurity:GenerateMac()\n"));

        if (GetField_CString(hResponse,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:GenerateMac encrypt_type = [%s]\n",csEncType));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMac encrypt_type is missing!!!\n");
                iRet = INT_ERR;
        }

        if (GetField_CString(hResponse,"merchant_id",&csMerchantId) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateMac merchant_id = [%s]\n",csMerchantId));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMac merchant_id is missing!!!\n"));
                iRet = INT_MERCHANT_ID_NOT_FOUND;
        }


        if (GetField_CString(hResponse,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateMac auth_data = [%s]\n",csData));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMac auth_data is missing!!!\n");
                iRet = INT_ERR;
        }

	csKeyName = (char*) malloc (PD_TMP_BUF_LEN +1);
        if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                strcpy(csKeyName,PD_PTK_KEY_NAME);
        }
        else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                strcpy(csKeyName,PD_SHA1_KEY_NAME);
        }

        if (iRet == PD_OK ) {
                DBObjPtr = CreateObj(DBPtr,"DBMerchKeys","GetMerchantKey");
                if ((*DBObjPtr)(csMerchantId,csKeyName,rRecordSet) != PD_OK) {
                        iRet = INT_ERR;
ERRLOG("BOSecurity:GenerateMac: Merchant Key for Merchant[%s] not found\n",csMerchantId);
DEBUGLOG(("BOSecurity:GenerateMac key for Merchant[%s] not found\n",csMerchantId));
                }
                else{
                        iRet = INT_ERR;
                        hRec = RecordSet_GetFirst(rRecordSet);
                        while(hRec){
                                if (GetField_CString(hRec,"key_value",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateMac GetMerchantKey - merchant_key_value = [%s]\n",csKey));
                                        iRet = PD_OK;
                                }
                                hRec = RecordSet_GetNext(rRecordSet);
                        }
                }
	}
        if (iRet == PD_OK) {
        	csMac = (char*) malloc (PD_TMP_MSG_BUF_LEN  +1);
                if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                        iRet = GenerateMD5Mac(csKey,csData,strlen(csData),csMac);
                }
                else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                        iRet = GenerateSHA1Mac(csKey,csData,strlen(csData),csMac);
                }
                else {
DEBUGLOG(("BOSecurity:GenerateMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:GenerateMac unsupported encrypt type [%s]\n",csEncType);
                }
		if (iRet == PD_OK) 
			PutField_CString(hResponse,"mac",csMac);
		FREE_ME(csMac);
        }
        if (iRet != PD_OK)
                PutField_Int(hContext,"internal_error",iRet);

        RecordSet_Destroy(rRecordSet);
        FREE_ME(rRecordSet);

	FREE_ME(csKeyName);

DEBUGLOG(("BOSecurity:GenerateMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int Generate3DESMac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT)
{
	int 	iRet = PD_OK;
	int	i;
        unsigned char   csKey[PD_KEY_LEN +1];
        unsigned char   csMAC[PD_KEY_LEN +1];
        unsigned char   csMac[PD_KEY_LEN +1];

DEBUGLOG(("Generate3DESMac() input = [%s][%s][%d]\n",KEY,DATA,strlen(DATA)));

        Ascii2Hex((char*)csKey,(unsigned char*)KEY,PD_KEY_LEN *2 );

	i = (PD_KEY_LEN / 2) - DATA_LEN % (PD_KEY_LEN /2);
        i += DATA_LEN; 

        EncryptKeyDIV(csKey,DATA,i,csMAC,NULL);

        Hex2Ascii((char*)csMac,csMAC,PD_KEY_LEN /2);
DEBUGLOG(("Generate3DESMac() Hex2Ascii = [%s][%d]\n",csMac,strlen(csMac)));
	memset(OUT,0,sizeof(OUT));
	strcpy(OUT,csMac);

DEBUGLOG(("BOSecurity:Generate3DESMac() iRet = [%d]\n",iRet));
	return iRet;
}

int GenerateMD5Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT)
{
        int             iRet = PD_OK;
	char		*csBuf;

DEBUGLOG(("BOSecurity:GenerateMD5Mac()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        OUT[0]='\0';
        csBuf[0]='\0';

	strcat(OUT,DATA);
	strcat(OUT,KEY);

         md5sum(OUT,strlen(OUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateMD5Mac() sign             = [%s]\n",csBuf));
	OUT[0] = '\0';

        U2L(csBuf,strlen(csBuf),OUT);
DEBUGLOG(("BOSecurity:GenerateMD5Mac() sign             = [%s]\n",OUT));

        FREE_ME(csBuf);
DEBUGLOG(("BOSecurity:GenerateMD5Mac() iRet = [%d]\n",iRet));
        return iRet;
}

int GenerateSHA1Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT)
{
        int             iRet = PD_OK;
        char            *csBuf;

DEBUGLOG(("BOSecurity:GenerateSHA1Mac()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        OUT[0]='\0';
        csBuf[0]='\0';

        strcat(OUT,DATA);
        strcat(OUT,KEY);

         sha1sum(OUT,strlen(OUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateSHA1Mac() sign             = [%s]\n",csBuf));
        OUT[0] = '\0';

        U2L(csBuf,strlen(csBuf),OUT);
DEBUGLOG(("BOSecurity:GenerateSHA1Mac() sign             = [%s]\n",OUT));

        FREE_ME(csBuf);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() iRet = [%d]\n",iRet));
        return iRet;
}


int VerifyMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
	int	iRet = PD_OK;
	char	*csEncType;
	char	*csMerchantId;
	char	*csKey;
	char	*csMac;
	char	*csData;
	char	*csKeyName;
	hash_t	*hRec;
	recordset_t     *rRecordSet;
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

DEBUGLOG(("BOSecurity:VerifyMac()\n"));

	if (GetField_CString(hRequest,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:VerifyMac encrypt_type = [%s]\n",csEncType));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMac encrypt_type is missing!!!\n");
		iRet = INT_ERR;
	}

	if (GetField_CString(hRequest,"merchant_id",&csMerchantId) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMac merchant_id = [%s]\n",csMerchantId));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac merchant_id is missing!!!\n"));
		iRet = INT_MERCHANT_ID_NOT_FOUND;
	}

	if (GetField_CString(hRequest,"mac",&csMac) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMac mac = [%s]\n",csMac));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac mac is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMac mac is missing!!!\n");
		iRet = INT_MAC_NOT_FOUND;
	}
	
	if (GetField_CString(hRequest,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMac auth_data = [%s]\n",csData));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMac auth_data is missing!!!\n");
		iRet = INT_ERR;
	}
        csKeyName = (char*) malloc (PD_TMP_BUF_LEN +1);
	if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
		strcpy(csKeyName,PD_PTK_KEY_NAME);
	}
	else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
		strcpy(csKeyName,PD_SHA1_KEY_NAME);
	}

DEBUGLOG(("BOSecurity:VerifyMac keyname = [%s]\n",csKeyName));
	if (iRet == PD_OK ) {
                DBObjPtr = CreateObj(DBPtr,"DBMerchKeys","GetMerchantKey");
                if ((*DBObjPtr)(csMerchantId,csKeyName,rRecordSet) != PD_OK) {
                        iRet = INT_ERR;
ERRLOG("BOSecurity:VerifyMac: Merchant Key for Merchant[%s] not found\n",csMerchantId);
DEBUGLOG(("BOSecurity:VerifyMac key for Merchant[%s] not found\n",csMerchantId));
                }
                else{
                        iRet = INT_ERR;
                        hRec = RecordSet_GetFirst(rRecordSet);
                        while(hRec){
                                if (GetField_CString(hRec,"key_value",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyMac GetMerchantKey - merchant_key_value = [%s]\n",csKey));
                                        iRet = PD_OK;
                                }
                                hRec = RecordSet_GetNext(rRecordSet);
                        }
                }
        }
	if (iRet == PD_OK) {
		if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
			iRet = VerifyMD5Mac(csMac,csKey,csData,strlen(csData));
		}
		else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
			iRet = VerifySHA1Mac(csMac,csKey,csData,strlen(csData));
		}
		else {
DEBUGLOG(("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType);
			iRet = INT_UNSUPPORTED_ENC_TYPE;
		}
	}

DEBUGLOG(("BOSecurity:VerifyMac iRet = [%d]\n",iRet));
	RecordSet_Destroy(rRecordSet);
        FREE_ME(rRecordSet);
	FREE_ME(csKeyName);

DEBUGLOG(("BOSecurity:VerifyMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int Verify3DESMac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN)
{
	int 		iRet = PD_OK;
        unsigned char   csKey[PD_KEY_LEN +1];
        unsigned char   csMAC[PD_KEY_LEN +1];
        unsigned char   csMac[PD_KEY_LEN +1];
	int	i;

        Ascii2Hex((char*)csKey,(unsigned char*)KEY,PD_KEY_LEN *2 );

	i = (PD_KEY_LEN/2) - DATA_LEN % (PD_KEY_LEN /2);
        i += DATA_LEN; 
DEBUGLOG(("BOSecurity:Verify3DESMac() MAC  = [%s]\n",MAC));
DEBUGLOG(("BOSecurity:Verify3DESMac() KEY  = [%s]\n",KEY));

        EncryptKeyDIV(csKey,DATA,i,csMAC,NULL);
        Hex2Ascii((char*)csMac,csMAC,PD_KEY_LEN /2);
DEBUGLOG(("BOSecurity:Verify3DESMac() *MAC = [%s]\n",csMac));
	if (memcmp(csMac,MAC,PD_KEY_LEN) != 0 ) {
		iRet = INT_MAC_ERR;

DEBUGLOG(("BOSecurity:Verify3DESMac()Invlide Mac\n"));
	}

DEBUGLOG(("BOSecurity:Verify3DESMac() iRet = [%d]\n",iRet));
	return iRet;
}

int VerifyMD5Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN)
{       
        int             iRet = PD_OK;
	char    *csOUT,*csBuf;

DEBUGLOG(("BOSecurity:VerifyMD5Mac()\n"));
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csOUT[0]='\0';
        csBuf[0]='\0';
	
	strcat(csBuf,DATA);
	strcat(csBuf,KEY);

	 md5sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifyMD5Mac() DATA = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifyMD5Mac() sign             = [%s]\n",csOUT));
        csBuf[0]='\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifyMD5Mac() sign             = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifyMD5Mac() mac in msg       = [%s]\n",MAC));
        
	if (memcmp(MAC,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verifyMD5Mac  error\n");
                iRet = INT_MAC_ERR;
        }

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifyMD5Mac() iRet = [%d]\n",iRet));
        return iRet;
}


int VerifySHA1Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN)
{
        int             iRet = PD_OK;
        char    *csOUT,*csBuf;

DEBUGLOG(("BOSecurity:VerifySHA1Mac()\n"));
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csOUT[0]='\0';
        csBuf[0]='\0';

        strcat(csBuf,DATA);
        strcat(csBuf,KEY);

DEBUGLOG(("BOSecurity:VerifySHA1Mac() DATA             = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifySHA1Mac() DATA             = [%s]\n",csBuf));

        sha1sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() sign             = [%s]\n",csOUT));
        csBuf[0]='\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() sign             = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifySHA1Mac() mac in msg       = [%s]\n",MAC));

	if (memcmp(MAC,csBuf,PD_SHA1_SUM_LEN) != 0) {
errlog("BOSecurity:verifySHA1Mac  error\n");
                iRet = INT_MAC_ERR;
        }


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() iRet = [%d]\n",iRet));
        return iRet;
}


int VerifyEskySign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char*	csPtr;
	char*   csSign;

	char	*csOUT;
	char	*csTmpBuf;
	csTmpBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	

	csTmpBuf[0] ='\0';

/* status */
	if (GetField_CString(hRequest,"status",&csPtr)) {
DEBUGLOG(("VerifyEskySing:1. status[str_ok] = [%s]\n",csPtr));
		strcat(csTmpBuf,csPtr);
	}
	else {
DEBUGLOG(("VerifyEskySing: status[str_ok] Not FOUND!!!\n"));
	}

/* order_no */
	if (GetField_CString(hRequest,"txn_seq",&csPtr)) {
DEBUGLOG(("VerifyEskySing:2. txn_seq[e_oderno] = [%s]\n",csPtr));
		strcat(csTmpBuf,csPtr);
	}
	else {
DEBUGLOG(("VerifyEskySing: txn_seq[e_oderno] Not FOUND!!!\n"));
	}

/* psp_merchant_id */
	if (GetField_CString(hRequest,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("VerifyEskySing:3. psp_merchant_id[e_no] = [%s]\n",csPtr));
		strcat(csTmpBuf,csPtr);
	}
	else {
DEBUGLOG(("VerifyEskySing:3. psp_merchant_id[e_no]Not Found!!!\n"));
	}

/* txn amount */
	if (GetField_CString(hRequest,"txn_amt",&csPtr)) {
DEBUGLOG(("VerifyEskySing:4. txn amount[e_money] = [%s]\n",csPtr));
		strcat(csTmpBuf,csPtr);
	}
	else {
DEBUGLOG(("VerifyEskySing:4. txn amount[e_money] Not Found!!!\n"));
	}

/* tid */
	if (GetField_CString(hRequest,"tid",&csPtr)) {
DEBUGLOG(("VerifyEskySing:5. tid[str_no] = [%s]\n",csPtr));
		strcat(csTmpBuf,csPtr);
	}
	else {
DEBUGLOG(("VerifyEskySing:5. tid[str_no] Not Found!!!\n"));
	}

/* psp_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("VerifyEskySign() psp_key= [%s]\n",csPtr));
                strcat(csTmpBuf,csPtr);
        }
	else {
DEBUGLOG(("VerifyEskySign() psp_key is missing!!!\n"));
	}
DEBUGLOG(("VerifyEskySign() sign_data= [%s]\n",csTmpBuf));

/* sign */
	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("VerifyEskySign() sign from msg = [%s]\n",csSign));
	}
	
	md5sum(csTmpBuf,strlen(csTmpBuf),csOUT);
DEBUGLOG(("VerifyEskySign() sign             = [%s]\n",csOUT));
	csTmpBuf[0] = '\0';
	U2L(csOUT,strlen(csOUT),csTmpBuf);
DEBUGLOG(("VerifyEskySign() sign             = [%s]\n",csTmpBuf));

/* verify sign */
	if (memcmp(csSign,csTmpBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csTmpBuf);
	FREE_ME(csOUT);
	return iRet;
}


int GenerateEskySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;
	double	dTmp;
	char	csTmp[PD_TMP_MSG_BUF_LEN + 1];

DEBUGLOG(("BOSecurity:GenerateEskySign()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csBuf[0]='\0';
        csOUT[0]='\0';

/* e_oderno */
        if (GetField_CString(hContext,"from_txn_seq",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateEskySign() from_txn_seq= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
        else if (GetField_CString(hContext,"txn_seq",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateEskySign() txn_seq= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
	else {
DEBUGLOG(("BOSecurity:GenerateEskySign() txn_seq is missing***\n"));
	}

/* psp_merchant_id */
        if (GetField_CString(hContext,"psp_merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateEskySign() psp_merchant_id= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
	else {
DEBUGLOG(("BOSecurity:GenerateEskySign() psp_merchant_id is missing***\n"));
	}

/* txn amount */
	if (GetField_Double(hOut,"psp_txn_amt",&dTmp)) {
DEBUGLOG(("BOSecurity:GenerateEskySign() txn_amt= [%f]\n",dTmp));
		sprintf(csTmp,"%.2f",dTmp);
                strcat(csBuf,csTmp);
DEBUGLOG(("BOSecurity:GenerateEskySign() txn_amt= [%s]\n",csTmp));
	}
	else {
DEBUGLOG(("BOSecurity:GenerateEskySign() txn_amt is missing***\n"));
	}


/* psp_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateEskySign() psp_key= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
	else {
DEBUGLOG(("BOSecurity:GenerateEskySign() psp_key is missing***\n"));
	}

DEBUGLOG(("BOSecurity:GenerateEskySign() sign_data= [%s]\n",csBuf));

        md5sum(csBuf,strlen(csBuf),csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateEskySign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateEskySign() sign             = [%s]\n",csBuf));
	PutField_CString(hOut,"sign",csBuf);


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateEskySign() iRet = [%d]\n",iRet));


        return iRet;
}


int GeneratePspSign(hash_t *hContext,
                        hash_t *hRequest,
                        hash_t *hResponse)
{
	int	iRet = PD_OK;
	char* csPspChannel;
DEBUGLOG(("BOSecurity::GenreatePspSign()\n"));

	if (!GetField_CString(hContext,"psp_channel_code",&csPspChannel)) {	
DEBUGLOG(("BOSecurity::GenreatePspSign psp_channel_code is missing!!!\n"));
ERRLOG("BOSecurity::GenreatePspSign psp_channel_code is missing!!!\n");
		iRet = PD_ERR;
	}
	else {
DEBUGLOG(("BOSecurity::GenreatePspSign psp_channel_code = [%s]\n",csPspChannel));
	}

	if (iRet == PD_OK) {
		if (!strcmp(csPspChannel,PD_CHANNEL_ESKY)) {
               		BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateEskySign");
                        iRet = (unsigned long)(*BOObjPtr)(hContext,hResponse);
		}
		else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY) || !strcmp(csPspChannel,PD_CHANNEL_LKPAY)
                      || !strcmp(csPspChannel,PD_CHANNEL_HHPAY)) {
			if (!strcmp(csPspChannel,PD_CHANNEL_LKPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"LkpMsg","BuildData");
                        else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY))
                       		MsgObjPtr = CreateObj(MsgPtr,"HpyMsg","BuildData");
                        else if (!strcmp(csPspChannel,PD_CHANNEL_HHPAY))
                                MsgObjPtr = CreateObj(MsgPtr,"HhpMsg","BuildData");

			if ((*MsgObjPtr)(hResponse) == PD_OK) {
DEBUGLOG(("BOSecurity::GenreatePspSign BuildData = [%d]\n",PD_OK));
                       		hash_t  *hCon;
                                char*   csTmp;
                                hCon = (hash_t*) malloc (sizeof(hash_t));
                                hash_init(hCon,0);
                                if (GetField_CString(hContext,"psp_merchant_id",&csTmp)) {
DEBUGLOG(("BOSecurity::GenreatePspSign psp_merchant_id = [%s]\n",csTmp));
                               		PutField_CString(hResponse,"merchant_id",csTmp);
                                }
                                if (GetField_CString(hContext,"psp_key",&csTmp)) {
DEBUGLOG(("BOSecurity::GenreatePspSign psp_key = [%s]\n",csTmp));
                                        PutField_CString(hCon,"merchant_key",csTmp);
                                }

                                PutField_CString(hResponse,"encrypt_type","01");
                                BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateXpaySign");
                                iRet = (unsigned long)(*BOObjPtr)(hCon,hResponse);
                                FREE_ME(hCon);
                       }
	
		}
	}
DEBUGLOG(("BOSecurity::GenreatePspSign() iRet = [%d]\n",iRet));
	return iRet;
}

int VerifyPspSign(hash_t *hContext,
                        hash_t *hRequest,
                        hash_t *hResponse)
{
        int     iRet = PD_OK;
	char    *csReturnPspChannel;
	char	*csPtr;
DEBUGLOG(("BOSecurity::VerifyPspSign()\n"));

	if (GetField_CString(hContext,"return_psp_channel",&csReturnPspChannel)) {
DEBUGLOG(("BOSecurity::VerifyPspSign return psp_channel = [%s]\n",csReturnPspChannel));
        }
        else {
DEBUGLOG(("BOSecurity::VerifyPspSign return psp missing!!!!\n"));
ERRLOG("BOSecurity::VerifyPspSign return psp missing!!!!\n");
		iRet = PD_ERR;
        }
	if (GetField_CString(hContext,"merchant_key",&csPtr)) {
DEBUGLOG(("BOSecurity::VerifyPspSign merchant_key = [%s]\n",csPtr));
		PutField_CString(hContext,"psp_key",csPtr);
	}

	if (iRet == PD_OK) {
		if (!strcmp(csReturnPspChannel,PD_CHANNEL_HPAY) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_LKPAY) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_HHPAY))
                {
                	BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyXpaySign");
                        iRet = (unsigned long)(*BOObjPtr)(hContext,hRequest);
                }
		else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ESKY)) {
			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyEskySign");
                        iRet = (unsigned long)(*BOObjPtr)(hContext,hRequest);
		}
	}

DEBUGLOG(("BOSecurity::VerifyPspSign() iRet = [%d]\n",iRet));
	return iRet;
}
int Encrypt3DESTxnSeq(const char* csTxnSeq, unsigned char* OUT)
{
	int 	iRet = PD_OK;
        unsigned char   csKey[PD_KEY_LEN +1];
	unsigned char	csDATA[PD_EN_TXN_SEQ_LEN +1];
	unsigned char	csOUT[PD_EN_TXN_SEQ_LEN +1];


        Ascii2Hex((char*)csKey,(unsigned char*)PD_MY_KEY,PD_KEY_LEN *2 );

	sprintf(csOUT,"%ld%ld%ld%ld%ld",random(),random(),random(),random(),random());
	memset(csDATA,0,PD_EN_TXN_SEQ_LEN);
	memcpy(&csDATA[0],csTxnSeq,PD_TXN_SEQ_LEN);
	memcpy(&csDATA[PD_TXN_SEQ_LEN],csOUT,PD_EN_TXN_SEQ_LEN - PD_TXN_SEQ_LEN);
	csDATA[PD_EN_TXN_SEQ_LEN] = '\0';
DEBUGLOG(("Encrypt3DESTxnSeq() data=[%s]\n",csDATA));

	csOUT[0]= '\0';
	myECBdes3_encrypt(csKey, csDATA,PD_EN_TXN_SEQ_LEN ,csOUT);

        Hex2Ascii((char*)OUT,csOUT,PD_EN_TXN_SEQ_LEN / 2 );
DEBUGLOG(("Encrypt3DESTxnSeq() Hex2Ascii = [%s][%d]\n",OUT,strlen(OUT)));
	return iRet;
}

int Decrypt3DESTxnSeq(const char* csEnTxnSeq, unsigned char* OUT)
{
        int     iRet = PD_OK;
        unsigned char   csKey[PD_KEY_LEN +1];
        unsigned char   csDATA[PD_EN_TXN_SEQ_LEN +1];
        unsigned char   csEnDATA[PD_EN_TXN_SEQ_LEN/2 +1];


DEBUGLOG(("Decrypt3DESTxnSeq() encrypted txn seq = [%s]\n",csEnTxnSeq));
        Ascii2Hex((char*)csKey,(unsigned char*)PD_MY_KEY,PD_KEY_LEN *2 );
        Ascii2Hex((char*)csEnDATA,(unsigned char*)csEnTxnSeq,PD_EN_TXN_SEQ_LEN *2 );

        myECBdes3_decrypt(csKey, csEnDATA,PD_EN_TXN_SEQ_LEN ,csDATA);
	csDATA[PD_TXN_SEQ_LEN] = '\0';

DEBUGLOG(("Decrypt3DESTxnSeq() DATA = [%s][%d]\n",csDATA,strlen(csDATA)));
	memcpy(OUT,csDATA,PD_TXN_SEQ_LEN);
	OUT[PD_TXN_SEQ_LEN] = '\0';
        return iRet;

}

