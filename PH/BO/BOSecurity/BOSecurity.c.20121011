/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2010/09/29              Cody Chan
ESky Support					   2011/01/11		   Cody Chan
MD5 Support					   2011/04/13		   Cody Chan
YeePay Support					   2011/10/19		   Cody Chan
MMS Support					   2011/10/21		   Cody Chan
51Epay Support					   2011/11/11		   Cody Chan
AllinPay Support				   2012/02/15		   Cody Chan
AllinPay INQ Support				   2012/05/15		   Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"
#include "common.h"
#include "BOSecurity.h"
#include "mymd5.h"
#define PD_MY_KEY	"1234567890abcdef1234567890ABCDEF"

#define	MY_FIELD_TOKEN	"|"
char    cDebug;

int GenerateMD5Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT);
int Generate3DESMac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT);
int GenerateSHA1Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT);
int VerifyMD5Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN);
int VerifySHA1Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN);
int Verify3DESMac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN);

OBJPTR(DB);
OBJPTR(DB);
OBJPTR(BO);
OBJPTR(Msg);

void BOSecurity(char    cdebug)
{
        cDebug = cdebug;
}



int VerifyXpaySign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char	*csBuf,*csOUT;
	char	*csPtr;
	char	*csSign = strdup("");
	
DEBUGLOG(("BOSecurity:VerifyXpaySign()\n"));
	csBuf = (char*) malloc (1024 * 2 +1);
	csOUT = (char*) malloc (1024 * 2 +1);

	csBuf[0]='\0';
	csOUT[0]='\0';
/* merchant_id */
	if (GetField_CString(hRequest,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() merchant_id= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}

/* encrypt_type */
	if (GetField_CString(hRequest,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() encrypt_type= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* plainttext_data */
	if (GetField_CString(hRequest,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() plainttext_data= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* merchant_key */
	if (GetField_CString(hContext,"merchant_key",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() merchant_key= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
	}
	else {
DEBUGLOG(("BOSecurity:VerifyXpaySign() merchant_key is missing!!!\n"));
	}
DEBUGLOG(("BOSecurity:VerifyXpaySign() verify_data= [%s]\n",csBuf));

	md5sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifyXpaySign() sign             = [%s]\n",csOUT));
	csBuf[0] = '\0';
	U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifyXpaySign() sign             = [%s]\n",csBuf));


	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() sign from Request= [%s]\n",csSign));
	}

	else {
errlog("BOSecurity:VerifyXpaySign sign not found\n");
DEBUGLOG(("BOSecurity:VerifyXpaySign sign not found\n"));
		iRet = INT_SIGN_DATA_NOT_FOUND;
		PutField_Int(hContext,"internal_error",iRet);
	}
/* verify sign */
	if (memcmp(csSign,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifyXpaySign() iRet = [%d]\n",iRet));

	
	return iRet;
}


int GenerateXpaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;

DEBUGLOG(("BOSecurity:GenerateXpaySign()\n"));
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);

        csBuf[0]='\0';
        csOUT[0]='\0';
/* merchant_id */
        if (GetField_CString(hOut,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() merchant_id= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }

/* encrypt_type */
        if (GetField_CString(hOut,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() encrypt_type= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* plainttext_data */
        if (GetField_CString(hOut,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() plainttext_data= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* merchant_key */
        if (GetField_CString(hContext,"merchant_key",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() merchant_key= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
DEBUGLOG(("BOSecurity:GenerateXpaySign() sign_data= [%s]\n",csBuf));

        md5sum(csBuf,strlen(csBuf),csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateXpaySign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateXpaySign() sign             = [%s]\n",csBuf));
	PutField_CString(hOut,"sign",csBuf);


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateXpaySign() iRet = [%d]\n",iRet));


        return iRet;
}
int GenerateMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
        int     iRet = PD_OK;
        char    *csEncType;
        char    *csMerchantId;
        char    *csKey;
        char    *csMac;
        char    *csData;
	char	*csKeyName;
	
        hash_t  *hRec;
        recordset_t     *rRecordSet;
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

DEBUGLOG(("BOSecurity:GenerateMac()\n"));

        if (GetField_CString(hResponse,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:GenerateMac encrypt_type = [%s]\n",csEncType));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMac encrypt_type is missing!!!\n");
                iRet = INT_ERR;
        }

        if (GetField_CString(hResponse,"merchant_id",&csMerchantId) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateMac merchant_id = [%s]\n",csMerchantId));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMac merchant_id is missing!!!\n"));
                iRet = INT_MERCHANT_ID_NOT_FOUND;
        }


        if (GetField_CString(hResponse,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateMac auth_data = [%s]\n",csData));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMac auth_data is missing!!!\n");
                iRet = INT_ERR;
        }

	csKeyName = (char*) malloc (PD_TMP_BUF_LEN +1);
        if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                strcpy(csKeyName,PD_PTK_KEY_NAME);
        }
        else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                strcpy(csKeyName,PD_SHA1_KEY_NAME);
        }

        if (iRet == PD_OK ) {
                DBObjPtr = CreateObj(DBPtr,"DBMerchKeys","GetMerchantKey");
                if ((*DBObjPtr)(csMerchantId,csKeyName,rRecordSet) != PD_OK) {
                        iRet = INT_ERR;
ERRLOG("BOSecurity:GenerateMac: Merchant Key for Merchant[%s] not found\n",csMerchantId);
DEBUGLOG(("BOSecurity:GenerateMac key for Merchant[%s] not found\n",csMerchantId));
                }
                else{
                        iRet = INT_ERR;
                        hRec = RecordSet_GetFirst(rRecordSet);
                        while(hRec){
                                if (GetField_CString(hRec,"key_value",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateMac GetMerchantKey - merchant_key_value = [%s]\n",csKey));
                                        iRet = PD_OK;
                                }
                                hRec = RecordSet_GetNext(rRecordSet);
                        }
                }
	}
        if (iRet == PD_OK) {
        	csMac = (char*) malloc (PD_TMP_MSG_BUF_LEN  +1);
                if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                        iRet = GenerateMD5Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                        iRet = GenerateSHA1Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else {
DEBUGLOG(("BOSecurity:GenerateMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:GenerateMac unsupported encrypt type [%s]\n",csEncType);
                }
		if (iRet == PD_OK) 
			PutField_CString(hResponse,"mac",csMac);
		FREE_ME(csMac);
        }
        if (iRet != PD_OK)
                PutField_Int(hContext,"internal_error",iRet);

        RecordSet_Destroy(rRecordSet);
        FREE_ME(rRecordSet);

	FREE_ME(csKeyName);

DEBUGLOG(("BOSecurity:GenerateMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int Generate3DESMac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT)
{
	int 	iRet = PD_OK;
	int	i;
        unsigned char   csKey[PD_KEY_LEN +1];
        unsigned char   csMAC[PD_KEY_LEN +1];
        unsigned char   csMac[PD_KEY_LEN +1];

DEBUGLOG(("Generate3DESMac() input = [%s][%s][%d]\n",KEY,DATA,strlen((char*)DATA)));

        Ascii2Hex((char*)csKey,(char*)KEY,PD_KEY_LEN *2 );

	i = (PD_KEY_LEN / 2) - DATA_LEN % (PD_KEY_LEN /2);
        i += DATA_LEN; 

        EncryptKeyDIV(csKey,DATA,i,csMAC,NULL);

        Hex2Ascii((char*)csMac,csMAC,PD_KEY_LEN /2);
DEBUGLOG(("Generate3DESMac() Hex2Ascii = [%s][%d]\n",csMac,strlen((char*)csMac)));
	memset(OUT,0,sizeof(OUT));
	strcpy((char*)OUT,(char*)csMac);

DEBUGLOG(("BOSecurity:Generate3DESMac() iRet = [%d]\n",iRet));
	return iRet;
}

int GenerateMD5Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT)
{
        int             iRet = PD_OK;
	char		*csBuf;

DEBUGLOG(("BOSecurity:GenerateMD5Mac()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        OUT[0]='\0';
        csBuf[0]='\0';

	strcat((char*)OUT,(char*)DATA);
	strcat((char*)OUT,(char*)KEY);

         md5sum((const char*)OUT,strlen((const char*)OUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateMD5Mac() sign             = [%s]\n",csBuf));
	OUT[0] = '\0';

        U2L(csBuf,strlen(csBuf),(char*)OUT);
DEBUGLOG(("BOSecurity:GenerateMD5Mac() sign             = [%s]\n",OUT));

        FREE_ME(csBuf);
DEBUGLOG(("BOSecurity:GenerateMD5Mac() iRet = [%d]\n",iRet));
        return iRet;
}

int GenerateSHA1Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT)
{
        int             iRet = PD_OK;
        char            *csBuf;

DEBUGLOG(("BOSecurity:GenerateSHA1Mac()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        OUT[0]='\0';
        csBuf[0]='\0';

        strcat((char*)OUT,(char*)DATA);
        strcat((char*)OUT,(char*)KEY);

        sha1sum((const char*)OUT,strlen((char*)OUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateSHA1Mac() sign             = [%s]\n",csBuf));
        OUT[0] = '\0';

        U2L(csBuf,strlen(csBuf),(char*)OUT);
DEBUGLOG(("BOSecurity:GenerateSHA1Mac() sign             = [%s]\n",OUT));

        FREE_ME(csBuf);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() iRet = [%d]\n",iRet));
        return iRet;
}


int VerifyMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
	int	iRet = PD_OK;
	char	*csEncType;
	char	*csMerchantId;
	char	*csKey;
	char	*csMac;
	char	*csData;
	char	*csKeyName;
	hash_t	*hRec;
	recordset_t     *rRecordSet;
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

DEBUGLOG(("BOSecurity:VerifyMac()\n"));

	if (GetField_CString(hRequest,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:VerifyMac encrypt_type = [%s]\n",csEncType));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMac encrypt_type is missing!!!\n");
		iRet = INT_ERR;
	}

	if (GetField_CString(hRequest,"merchant_id",&csMerchantId) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMac merchant_id = [%s]\n",csMerchantId));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac merchant_id is missing!!!\n"));
		iRet = INT_MERCHANT_ID_NOT_FOUND;
	}

	if (GetField_CString(hRequest,"mac",&csMac) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMac mac = [%s]\n",csMac));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac mac is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMac mac is missing!!!\n");
		iRet = INT_MAC_NOT_FOUND;
	}
	
	if (GetField_CString(hRequest,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMac auth_data = [%s]\n",csData));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMac auth_data is missing!!!\n");
		iRet = INT_ERR;
	}
        csKeyName = (char*) malloc (PD_TMP_BUF_LEN +1);
	if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
		strcpy(csKeyName,PD_PTK_KEY_NAME);
	}
	else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
		strcpy(csKeyName,PD_SHA1_KEY_NAME);
	}

DEBUGLOG(("BOSecurity:VerifyMac keyname = [%s]\n",csKeyName));
	if (iRet == PD_OK ) {
                DBObjPtr = CreateObj(DBPtr,"DBMerchKeys","GetMerchantKey");
                if ((*DBObjPtr)(csMerchantId,csKeyName,rRecordSet) != PD_OK) {
                        iRet = INT_ERR;
ERRLOG("BOSecurity:VerifyMac: Merchant Key for Merchant[%s] not found\n",csMerchantId);
DEBUGLOG(("BOSecurity:VerifyMac key for Merchant[%s] not found\n",csMerchantId));
                }
                else{
                        iRet = INT_ERR;
                        hRec = RecordSet_GetFirst(rRecordSet);
                        while(hRec){
                                if (GetField_CString(hRec,"key_value",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyMac GetMerchantKey - merchant_key_value = [%s]\n",csKey));
                                        iRet = PD_OK;
                                }
                                hRec = RecordSet_GetNext(rRecordSet);
                        }
                }
        }
	if (iRet == PD_OK) {
		if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
			iRet = VerifyMD5Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
			iRet = VerifySHA1Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else {
DEBUGLOG(("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType);
			iRet = INT_UNSUPPORTED_ENC_TYPE;
		}
	}

DEBUGLOG(("BOSecurity:VerifyMac iRet = [%d]\n",iRet));
	RecordSet_Destroy(rRecordSet);
        FREE_ME(rRecordSet);
	FREE_ME(csKeyName);

DEBUGLOG(("BOSecurity:VerifyMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int Verify3DESMac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN)
{
	int 		iRet = PD_OK;
        unsigned char   csKey[PD_KEY_LEN +1];
        unsigned char   csMAC[PD_KEY_LEN +1];
        unsigned char   csMac[PD_KEY_LEN +1];
	int	i;

        Ascii2Hex((char*)csKey,(char*)KEY,PD_KEY_LEN *2 );

	i = (PD_KEY_LEN/2) - DATA_LEN % (PD_KEY_LEN /2);
        i += DATA_LEN; 
DEBUGLOG(("BOSecurity:Verify3DESMac() MAC  = [%s]\n",MAC));
DEBUGLOG(("BOSecurity:Verify3DESMac() KEY  = [%s]\n",KEY));

        EncryptKeyDIV(csKey,DATA,i,csMAC,NULL);
        Hex2Ascii((char*)csMac,csMAC,PD_KEY_LEN /2);
DEBUGLOG(("BOSecurity:Verify3DESMac() *MAC = [%s]\n",csMac));
	if (memcmp(csMac,MAC,PD_KEY_LEN) != 0 ) {
		iRet = INT_MAC_ERR;

DEBUGLOG(("BOSecurity:Verify3DESMac()Invlide Mac\n"));
	}

DEBUGLOG(("BOSecurity:Verify3DESMac() iRet = [%d]\n",iRet));
	return iRet;
}

int VerifyMD5Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN)
{       
        int             iRet = PD_OK;
	char    *csOUT,*csBuf;

DEBUGLOG(("BOSecurity:VerifyMD5Mac()\n"));
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csOUT[0]='\0';
        csBuf[0]='\0';
	
	strcat(csBuf,(char*)DATA);
	strcat(csBuf,(char*)KEY);

	 md5sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifyMD5Mac() DATA = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifyMD5Mac() sign             = [%s]\n",csOUT));
        csBuf[0]='\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifyMD5Mac() sign             = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifyMD5Mac() mac in msg       = [%s]\n",MAC));
        
	if (memcmp(MAC,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verifyMD5Mac  error\n");
                iRet = INT_MAC_ERR;
        }

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifyMD5Mac() iRet = [%d]\n",iRet));
        return iRet;
}


int VerifySHA1Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN)
{
        int             iRet = PD_OK;
        char    *csOUT,*csBuf;

DEBUGLOG(("BOSecurity:VerifySHA1Mac()\n"));
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csOUT[0]='\0';
        csBuf[0]='\0';

        strcat(csBuf,(char*)DATA);
        strcat(csBuf,(char*)KEY);

DEBUGLOG(("BOSecurity:VerifySHA1Mac() DATA             = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifySHA1Mac() DATA             = [%s]\n",csBuf));

        sha1sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() sign             = [%s]\n",csOUT));
        csBuf[0]='\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() sign             = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifySHA1Mac() mac in msg       = [%s]\n",MAC));

	if (memcmp(MAC,csBuf,PD_SHA1_SUM_LEN) != 0) {
errlog("BOSecurity:verifySHA1Mac  error\n");
                iRet = INT_MAC_ERR;
        }


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() iRet = [%d]\n",iRet));
        return iRet;
}


int VerifyMD5Sign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char*	csPtr;
	char*   csSign;

	char	*csOUT;
	char	*csTmpBuf;
	csTmpBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	

	csTmpBuf[0] ='\0';
/* auth data */
        if (GetField_CString(hRequest,"auth_data",&csPtr)) {
DEBUGLOG(("VerifyMD5Sign() auth_data= [%s]\n",csPtr));
                strcat(csTmpBuf,csPtr);
        }

/* psp_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("VerifyMD5Sign() psp_key= [%s]\n",csPtr));
                strcat(csTmpBuf,csPtr);
        }
	else {
DEBUGLOG(("VerifyMD5Sign() psp_key is missing!!!\n"));
	}
DEBUGLOG(("VerifyMD5Sign() sign_data= [%s]\n",csTmpBuf));

/* sign */
	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("VerifyMD5Sign() sign from msg = [%s]\n",csSign));
	}
	
	md5sum(csTmpBuf,strlen(csTmpBuf),csOUT);
DEBUGLOG(("VerifyMD5Sign() sign             = [%s]\n",csOUT));
	csTmpBuf[0] = '\0';

	char*   csPspChannel;
        if (!GetField_CString(hContext,"return_psp_channel",&csPspChannel)) {
DEBUGLOG(("BOSecurity:GenerateMD5Sing psp_channel = [%s]\n",csPspChannel));
        }
        if (!strcmp(csPspChannel,PD_CHANNEL_SHENGPAY))
		L2U(csOUT,strlen(csOUT),csTmpBuf);
	else
		U2L(csOUT,strlen(csOUT),csTmpBuf);
DEBUGLOG(("VerifyMD5Sign() sign             = [%s]\n",csTmpBuf));

/* verify sign */
	if (memcmp(csSign,csTmpBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csTmpBuf);
	FREE_ME(csOUT);
	return iRet;
}


int GenerateMD5Sign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;

DEBUGLOG(("BOSecurity:GenerateMD5Sign()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csBuf[0]='\0';
        csOUT[0]='\0';

	char*	csPspChannel = strdup("");
	if (GetField_CString(hContext,"psp_channel_code",&csPspChannel)) {
DEBUGLOG(("BOSecurity:GenerateMD5Sing psp_channel = [%s]\n",csPspChannel));
	}

/* auth_data */
	if (GetField_CString(hOut,"auth_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateMD5Sign() auth_data = [%s]\n",csPtr));
               	strcat(csBuf,csPtr);
	}

/* psp_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateMD5Sign() auth_key= [%s]\n",csPtr));
	  	if (!strcmp(csPspChannel,PD_CHANNEL_ALLINPAY))
			strcat(csBuf,"key=");
                strcat(csBuf,csPtr);
        }
	else {
DEBUGLOG(("BOSecurity:GenerateMD5Sign() psp_key is missing***\n"));
	}

DEBUGLOG(("BOSecurity:GenerateMD5Sign() sign_data= [%s]\n",csBuf));

        md5sum(csBuf,strlen(csBuf),csOUT);
        csBuf[0] = '\0';


	if (!strcmp(csPspChannel,PD_CHANNEL_SHENGPAY)
	  ||!strcmp(csPspChannel,PD_CHANNEL_ALLINPAY))
		L2U(csOUT,strlen(csOUT),csBuf);
	else
        	U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateMD5Sign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateMD5Sign() sign             = [%s]\n",csBuf));
	PutField_CString(hOut,"sign",csBuf);


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateMD5Sign() iRet = [%d]\n",iRet));


        return iRet;
}


int GeneratePspSign(hash_t *hContext,
                        hash_t *hRequest,
                        hash_t *hResponse)
{
	int	iRet = PD_OK;
	char* 	csPspChannel;
	char*	csPtr;
DEBUGLOG(("BOSecurity::GenreatePspSign()\n"));

	if (!GetField_CString(hContext,"psp_channel_code",&csPspChannel)) {	
DEBUGLOG(("BOSecurity::GenreatePspSign psp_channel_code is missing!!!\n"));
ERRLOG("BOSecurity::GenreatePspSign psp_channel_code is missing!!!\n");
		iRet = PD_ERR;
	}
	else {
DEBUGLOG(("BOSecurity::GenreatePspSign psp_channel_code = [%s]\n",csPspChannel));
	}

	if (iRet == PD_OK) {
		if (!strcmp(csPspChannel,PD_CHANNEL_LKPAY))
                       	MsgObjPtr = CreateObj(MsgPtr,"LkpMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY))
          		MsgObjPtr = CreateObj(MsgPtr,"HpyMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY_CNP))
          		MsgObjPtr = CreateObj(MsgPtr,"HcpMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_HHPAY))
                        MsgObjPtr = CreateObj(MsgPtr,"HhpMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_ESKY))
                	MsgObjPtr = CreateObj(MsgPtr,"ESkyMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_EEP))
                	MsgObjPtr = CreateObj(MsgPtr,"EepMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_YEEPAY))
                	MsgObjPtr = CreateObj(MsgPtr,"YpyMsg","BuildReqData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_51EPAY))
                	MsgObjPtr = CreateObj(MsgPtr,"FepMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_PGEN))
                       	return iRet; 
		else if (!strcmp(csPspChannel,PD_CHANNEL_ALLINPAY))
			MsgObjPtr = CreateObj(MsgPtr,"AlpMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_SHENGPAY))
			MsgObjPtr = CreateObj(MsgPtr,"SpyMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_IPAY))
			MsgObjPtr = CreateObj(MsgPtr,"IpyMsg","BuildAuthData");
//do nothing
//do nothing
		else {
DEBUGLOG(("BOSecurity::GeneratePspSign PSP undefine\n"));
ERRLOG("BOSecurity::GeneratePspSign PSP undefine\n");
			return iRet;
		}

		if ((*MsgObjPtr)(hResponse) == PD_OK) {
DEBUGLOG(("BOSecurity::GenereatePspSign BuildData = [%d]\n",PD_OK));
            		hash_t  *hCon;
                        char*   csTmp;
                        hCon = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(hCon,0);

/* put psp_channel_code */
			PutField_CString(hCon,"psp_channel_code",csPspChannel);
                        if (GetField_CString(hContext,"psp_merchant_id",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSign psp_merchant_id = [%s]\n",csTmp));
                       		PutField_CString(hResponse,"merchant_id",csTmp);
                        }
                        if (GetField_CString(hContext,"psp_key",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSign psp_key = [%s]\n",csTmp));
                        	PutField_CString(hCon,"psp_key",csTmp);
                        }

			if (!strcmp(csPspChannel,PD_CHANNEL_ESKY) || !strcmp(csPspChannel,PD_CHANNEL_EEP)
				|| !strcmp(csPspChannel,PD_CHANNEL_ALLINPAY) 
 				|| !strcmp(csPspChannel,PD_CHANNEL_SHENGPAY)) {
               			BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateMD5Sign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY) || !strcmp(csPspChannel,PD_CHANNEL_LKPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HHPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HPAY_CNP)) {
                              	PutField_CString(hResponse,"encrypt_type","01");
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateHaiPaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_YEEPAY)) {
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateYeePaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_51EPAY)) {
				if (GetField_CString(hContext,"psp_privatepem",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_privatepem = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_privatepem",csPtr);
				}
				if (GetField_CString(hContext,"psp_passphrase",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_passphrase = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_passphrase",csPtr);
				}
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","Generate51EpaySign");
			}
                        iRet = (unsigned long)(*BOObjPtr)(hCon,hResponse);
                        FREE_ME(hCon);
            	}
	
	}
DEBUGLOG(("BOSecurity::GenereatePspSign() iRet = [%d]\n",iRet));
	return iRet;
}

int VerifyPspSign(hash_t *hContext,
                        hash_t *hRequest,
                        hash_t *hResponse)
{
        int     iRet = PD_OK;
	char    *csReturnPspChannel;
	//char	*csPtr;
DEBUGLOG(("BOSecurity::VerifyPspSign()\n"));

	if (GetField_CString(hContext,"return_psp_channel",&csReturnPspChannel)) {
DEBUGLOG(("BOSecurity::VerifyPspSign return psp_channel = [%s]\n",csReturnPspChannel));
        }
        else {
DEBUGLOG(("BOSecurity::VerifyPspSign return psp missing!!!!\n"));
ERRLOG("BOSecurity::VerifyPspSign return psp missing!!!!\n");
		iRet = PD_ERR;
        }
/*
	if (GetField_CString(hContext,"merchant_key",&csPtr)) {
DEBUGLOG(("BOSecurity::VerifyPspSign merchant_key = [%s]\n",csPtr));
		PutField_CString(hContext,"auth_key",csPtr);
	}
*/

	if (iRet == PD_OK) {
		if (!strcmp(csReturnPspChannel,PD_CHANNEL_TWV)) {
			char*	csKey;
			/* merchant_key */
        		if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyPspSing() auth_key= [%s]\n",csKey));
        		}
			else {
				iRet = PD_ERR;
DEBUGLOG(("BOSecurity:VerifyPspSing() auth_key is missing\n"));
ERRLOG("BOSecurity:VerifyPspSing() auth_key is missing\n");
			}
			if (iRet == PD_OK) {
				char*   csAccessKey;
                                if (GetField_CString(hRequest,"access_key",&csAccessKey)) {
DEBUGLOG(("BOSecurity:VerifyPspSing() remote key = [%s]\n",csAccessKey));
                                        if (strcmp(csKey,csAccessKey)) {
DEBUGLOG(("BOSecurity:VerifyPspSingKey Mismatch host[%s] remote[%s]\n",csKey,csAccessKey));
ERRLOG("BOSecurity:VerifyPspSing: TWVChannel Key Mismatch host[%s] remote[%s]\n",csKey,csAccessKey);
                                                iRet = INT_MAC_ERR;
                                        }
                                }
                                else {
DEBUGLOG(("access Key is missing\n"));
ERRLOG("TWV Channel access Key is missing\n");
                                        iRet = INT_MAC_ERR;
                                }
			}
		}
		else if (!strcmp(csReturnPspChannel,PD_CHANNEL_HPAY) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_HPAY_CNP) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_LKPAY) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_HHPAY))
                {
                	BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyHaiPaySign");
                        iRet = (unsigned long)(*BOObjPtr)(hContext,hRequest);
                }
		else {
			if (!strcmp(csReturnPspChannel,PD_CHANNEL_ESKY))
                        	MsgObjPtr = CreateObj(MsgPtr,"ESkyMsg","BuildAuthData");
                	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_EEP))
                        	MsgObjPtr = CreateObj(MsgPtr,"EepMsg","BuildAuthData");
                	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_YEEPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"YpyMsg","BuildRspData");
                	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_51EPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"FepMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ALLINPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"AlpMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_SHENGPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"SpyMsg","BuildRspAuthData");
			else {
DEBUGLOG(("BOSecurity:VerifyPspSign, PSP undefine\n"));
ERRLOG("BOSecurity:VerifyPspSign, PSP undefine\n");
				iRet = PD_ERR;
			}

			if (iRet == PD_OK) {
                		if ((*MsgObjPtr)(hRequest) == PD_OK) {
DEBUGLOG(("BOSecurity::VerifyPspSign BuildData = [%d]\n",PD_OK));
				
                			if (!strcmp(csReturnPspChannel,PD_CHANNEL_ESKY) 
                			   || !strcmp(csReturnPspChannel,PD_CHANNEL_EEP) 
                			   || !strcmp(csReturnPspChannel,PD_CHANNEL_SHENGPAY) 
					) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyMD5Sign");
					}
                			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_51EPAY)) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","Verify51EpaySign");
					}
                			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_YEEPAY)) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyYeePaySign");
					}
                			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ALLINPAY)) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyAllinPaySign");
					}
                        		iRet = (unsigned long)(*BOObjPtr)(hContext,hRequest);
				}
			}
			else {
DEBUGLOG(("BOSecurity::VerifyPspSign  BuildRspData Error\n"));
ERRLOG("BOSecurity::VerifyPspSign  BuildRspData Error\n");
				iRet = PD_ERR;
			}
		}
	}

DEBUGLOG(("BOSecurity::VerifyPspSign() iRet = [%d]\n",iRet));
	return iRet;
}
int Encrypt3DESTxnSeq(const char* csTxnSeq, unsigned char* OUT)
{
	int 	iRet = PD_OK;
        unsigned char   csKey[PD_KEY_LEN +1];
	unsigned char	csDATA[PD_EN_TXN_SEQ_LEN +1];
	unsigned char	csOUT[PD_EN_TXN_SEQ_LEN +1];


        Ascii2Hex((char*)csKey,PD_MY_KEY,PD_KEY_LEN *2 );

	sprintf((char*)csOUT,"%ld%ld%ld%ld%ld",random(),random(),random(),random(),random());
	memset(csDATA,0,PD_EN_TXN_SEQ_LEN);
	memcpy(&csDATA[0],csTxnSeq,PD_TXN_SEQ_LEN);
	memcpy(&csDATA[PD_TXN_SEQ_LEN],csOUT,PD_EN_TXN_SEQ_LEN - PD_TXN_SEQ_LEN);
	csDATA[PD_EN_TXN_SEQ_LEN] = '\0';
DEBUGLOG(("Encrypt3DESTxnSeq() data=[%s]\n",csDATA));

	csOUT[0]= '\0';
	myECBdes3_encrypt(csKey, csDATA,PD_EN_TXN_SEQ_LEN ,csOUT);

        Hex2Ascii((char*)OUT,csOUT,PD_EN_TXN_SEQ_LEN / 2 );
DEBUGLOG(("Encrypt3DESTxnSeq() Hex2Ascii = [%s][%d]\n",OUT,strlen((char*)OUT)));
	return iRet;
}

int Decrypt3DESTxnSeq(const char* csEnTxnSeq, unsigned char* OUT)
{
        int     iRet = PD_OK;
        unsigned char   csKey[PD_KEY_LEN +1];
        unsigned char   csDATA[PD_EN_TXN_SEQ_LEN +1];
        unsigned char   csEnDATA[PD_EN_TXN_SEQ_LEN/2 +1];


DEBUGLOG(("Decrypt3DESTxnSeq() encrypted txn seq = [%s]\n",csEnTxnSeq));
        Ascii2Hex((char*)csKey,PD_MY_KEY,PD_KEY_LEN *2 );
        Ascii2Hex((char*)csEnDATA,(char*)csEnTxnSeq,PD_EN_TXN_SEQ_LEN *2 );

        myECBdes3_decrypt(csKey, csEnDATA,PD_EN_TXN_SEQ_LEN ,csDATA);
	csDATA[PD_TXN_SEQ_LEN] = '\0';

DEBUGLOG(("Decrypt3DESTxnSeq() DATA = [%s][%d]\n",csDATA,strlen((char*)csDATA)));
	memcpy(OUT,csDATA,PD_TXN_SEQ_LEN);
	OUT[PD_TXN_SEQ_LEN] = '\0';
        return iRet;

}

int GenerateYeePaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;
	char	*csKey;

DEBUGLOG(("BOSecurity:GenerateXpaySign()\n"));
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);

        csBuf[0]='\0';
        csOUT[0]='\0';

/* auth_data */
        if (GetField_CString(hOut,"auth_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateYeePaySign() auth_data= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateYeePaySign() auth_key= [%s]\n",csKey));
        }
DEBUGLOG(("BOSecurity:GenerateYeePaySign() sign_data= [%s]\n",csBuf));
        
        hmac_md5((unsigned char*)csBuf,strlen(csBuf),(unsigned char*)csKey,strlen(csKey),(unsigned char*)csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateYeePaySign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateYeePaySign() sign             = [%s]\n",csBuf));
        PutField_CString(hOut,"sign",csBuf);

        
        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateYeePaySign() iRet = [%d]\n",iRet));

        
        return iRet;
}

int VerifyYeePaySign(hash_t *hContext,
                const hash_t* hRequest)
{
	int	iRet = PD_OK;
	char	*csAuthData;
	char	*csClearSig;
	char	*csKey;
        char    *csBuf,*csOUT;
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);
DEBUGLOG(("BOSecurity:VerifyYeePaySign()\n"));

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:VerifyYeePaySign() auth_data= [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("BOSecurity:VerifyYeePaySign() sign= [%s]\n",csClearSig));
        }

/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyYeePaySign() auth_key= [%s]\n",csKey));
        }

        hmac_md5((unsigned char*)csAuthData,strlen(csAuthData),(unsigned char*)csKey,strlen(csKey),(unsigned char*)csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);

DEBUGLOG(("BOSecurity:VerifyYeePaySign 	msg sign = [%s]\n",csClearSig));
DEBUGLOG(("BOSecurity:VerifyYeePaySign 	    sign = [%s]\n",csBuf));
/* verify sign */
	if (memcmp(csClearSig,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify YeePay sign error\n");
DEBUGLOG(("BOSecurity:verify YeePay sign error\n"));
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csBuf);
	FREE_ME(csOUT);

	return iRet;
}


int Generate51EpaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csAuthData;
	char	csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char	*csRsaPem;
	char	*csPassPhrase;
	char	*csBuf;
	unsigned char 	csSignData[PD_TMP_MSG_BUF_LEN];
	unsigned int	iLen = 0;

DEBUGLOG(("BOSecurity:Generate51EpaySignign()\n"));

/* auth_data */
        if (GetField_CString(hOut,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:Generate51EpaySign() auth_data= [%s]\n",csAuthData));
        }
/* rsapem */
	if (GetField_CString(hContext,"psp_privatepem",&csRsaPem)) {
DEBUGLOG(("Generate51EpaySign privatepem = [%s]\n",csRsaPem));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("Generate51EpaySign privatepempath = [%s]\n",csRsaPemPath));
	}
	else {
		iRet = INT_ERR;
	}
/* passphrase */
	if (GetField_CString(hContext,"psp_passphrase",&csPassPhrase)) {
DEBUGLOG(("Generate51EpaySign PassPhrase = [%s]\n",csPassPhrase));
	}
	else {
		iRet = INT_ERR;
	}

	if (iRet == PD_OK) {
		sha1rsa_sign(csRsaPemPath,csPassPhrase,csAuthData, csSignData, &iLen);
        
        	csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN);
        	csBuf[0]='\0';
		base64_encode(csSignData,iLen,csBuf,PD_MAX_BUFFER);
DEBUGLOG(("BOSecurity:Generate51EPaySign() sign             = [%s]\n",csBuf));
       		PutField_CString(hOut,"sign",csBuf);
        
        	FREE_ME(csBuf);
	}
DEBUGLOG(("BOSecurity:Generate51EpaySign() iRet = [%d]\n",iRet));

        
        return iRet;
}

int Verify51EpaySign(hash_t *hContext,
                const hash_t* hRequest)
{
	int	iRet = PD_OK;
	char	csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char	*csRsaPem;
	char	*csAuthData;
	char	*csClearSig;
	unsigned char	*csSig;
	int	iSigLen;
DEBUGLOG(("BOSecurity:Verify51EpaySign()\n"));

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign() auth_data= [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign() sign= [%s]\n",csClearSig));
        }

/* publiccert */
	if (GetField_CString(hContext,"psp_publiccert",&csRsaPem)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccert = [%s]\n",csRsaPem));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccertpath = [%s]\n",csRsaPemPath));
	}
	else {
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccert is missing!!!\n"));
		iRet = INT_ERR;
	}

	

        if (iRet == PD_OK) {
DEBUGLOG(("BOSecurity:try to verify [%s]\n",csClearSig));
		csSig = (unsigned char*) malloc (PD_MAX_BUFFER);
		iSigLen = base64_decode(csClearSig,csSig,PD_MAX_BUFFER);
DEBUGLOG(("BOSecurity:try to verify sig date len = [%d]\n",iSigLen));
		iRet = sha1rsa_verify(csRsaPemPath,csAuthData,csSig,iSigLen);
		FREE_ME(csSig);
        }
DEBUGLOG(("BOSecurity:Verify51EpaySign() iRet = [%d]\n",iRet));



	return iRet;
}

int VerifyHaiPaySign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char	*csBuf,*csOUT;
	char	*csPtr;
	char	*csSign = strdup("");
	
DEBUGLOG(("BOSecurity:VerifyHaiPaySign()\n"));
	csBuf = (char*) malloc (1024 * 2 +1);
	csOUT = (char*) malloc (1024 * 2 +1);

	csBuf[0]='\0';
	csOUT[0]='\0';
/* merchant_id */
	if (GetField_CString(hRequest,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() merchant_id= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* APIVersion */
	if (GetField_CString(hRequest,"APIVersion",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() APIVersion= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}

/* encrypt_type */
	if (GetField_CString(hRequest,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() encrypt_type= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* plainttext_data */
	if (GetField_CString(hRequest,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() plainttext_data= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* psp_key */
	if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() psp_key= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
	}
	else {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() psp_key is missing!!!\n"));
	}
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() verify_data= [%s]\n",csBuf));

	md5sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() sign             = [%s]\n",csOUT));
	csBuf[0] = '\0';
	U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() sign             = [%s]\n",csBuf));


	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() sign from Request= [%s]\n",csSign));
	}

	else {
errlog("BOSecurity:VerifyHaiPaySign sign not found\n");
DEBUGLOG(("BOSecurity:VerifyHaiPaySign sign not found\n"));
		iRet = INT_SIGN_DATA_NOT_FOUND;
		PutField_Int(hContext,"internal_error",iRet);
	}
/* verify sign */
	if (memcmp(csSign,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() iRet = [%d]\n",iRet));

	
	return iRet;
}


int GenerateHaiPaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;

DEBUGLOG(("BOSecurity:GenerateXpaySign()\n"));
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);

        csBuf[0]='\0';
        csOUT[0]='\0';
/* merchant_id */
        if (GetField_CString(hOut,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() merchant_id= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }

/* encrypt_type */
        if (GetField_CString(hOut,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() encrypt_type= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* plainttext_data */
        if (GetField_CString(hOut,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() plainttext_data= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() psp_key= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() sign_data= [%s]\n",csBuf));

        md5sum(csBuf,strlen(csBuf),csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() sign             = [%s]\n",csBuf));
	PutField_CString(hOut,"sign",csBuf);


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() iRet = [%d]\n",iRet));


        return iRet;
}



int VerifyAllinPaySign(hash_t *hContext,
                const hash_t* hRequest)
{
DEBUGLOG(("BOSecurity:VerifyAllinPaySign()\n"));
	return Verify51EpaySign(hContext,hRequest);
}

int VerifyAllinPaySignTest(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
        char    csRsaPemPath[PD_MAX_FILE_LEN + 1];
        char    *csRsaPem;
        char    *csAuthData;
        char    *csClearSig;
        unsigned char   *csSig;
        int     iSigLen;
DEBUGLOG(("BOSecurity:Verify51EpaySign()\n"));

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign() auth_data= [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign() sign= [%s]\n",csClearSig));
        }

/* publiccert */
        if (GetField_CString(hContext,"psp_publiccert",&csRsaPem)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccert = [%s]\n",csRsaPem));
                sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccertpath = [%s]\n",csRsaPemPath));
        }
        else {
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccert is missing!!!\n"));
                iRet = INT_ERR;
        }



        if (iRet == PD_OK) {
DEBUGLOG(("BOSecurity:try to verify [%s]\n",csClearSig));
                csSig = (unsigned char*) malloc (PD_MAX_BUFFER);
                iSigLen = base64_decode(csClearSig,csSig,PD_MAX_BUFFER);

/****** test */
/*
		char	csData[] = "merchantId=100020091218001&version=v1.0&language=1&signType=1&payType=1&paymentOrderId=20120220182422478&orderNo=0000000000224383&orderDatetime=20120220182520&orderAmount=1000&payDatetime=20120220182422&payAmount=1000&payResult=1&returnDatetime=20120220182425";
		char	csSigData[] = "BryjqMQqJjJflMzqIi8d1dk2uKjG5Tk5bpNI1/IQ2FITExjiJqppPwtZFm8TVkSx88AOMNLwDDaOpz/B9Z0GAOEv08kca0cvv/jr6qeuaSDjSEci4bh3BxCGaeInZ1P9wAtAXMxS+ihSS8LHdWFEsBkd+7P/w9TAbHAbM0+wbVE=";
		
                iSigLen = base64_decode(csSigData,csSig,PD_MAX_BUFFER);
		csAuthData = strdup(csData);
DEBUGLOG(("BOSecurity:Verify51EpaySign() ****auth_data= [%s]\n",csAuthData));
DEBUGLOG(("BOSecurity:Verify51EpaySign() ****sign= [%s]\n",csSigData));
*/
/*******************************************/
DEBUGLOG(("BOSecurity:try to verify sig date len = [%d]\n",iSigLen));
                iRet = sha1rsa_verify(csRsaPemPath,csAuthData,csSig,iSigLen);
                FREE_ME(csSig);
        }
DEBUGLOG(("BOSecurity:Verify51EpaySign() iRet = [%d]\n",iRet));



        return iRet;
}



int GenerateMMSMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
        int     iRet = PD_OK;
        char    *csEncType;
        char    *csKey;
        char    *csMac;
        char    *csData;
	
DEBUGLOG(("BOSecurity:GenerateMMSMac()\n"));

        if (GetField_CString(hResponse,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:GenerateMMSMac encrypt_type = [%s]\n",csEncType));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMMSMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMMSMac encrypt_type is missing!!!\n");
                iRet = INT_ERR;
        }
        if (GetField_CString(hResponse,"mms_key",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateMMSMac mms_key = [%s]\n",csKey));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMMSMac mms_key is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMMSMac mms_key is missing!!!\n");
                iRet = INT_ERR;
        }


        if (GetField_CString(hResponse,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateMMSMac auth_data = [%s]\n",csData));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMMSMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMMSMac auth_data is missing!!!\n");
                iRet = INT_ERR;
        }

        if (iRet == PD_OK) {
        	csMac = (char*) malloc (PD_TMP_MSG_BUF_LEN  +1);
                if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                        iRet = GenerateMD5Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                        iRet = GenerateSHA1Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else {
DEBUGLOG(("BOSecurity:GenerateMMSMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:GenerateMMSMac unsupported encrypt type [%s]\n",csEncType);
                }
		if (iRet == PD_OK) 
			PutField_CString(hResponse,"mac",csMac);
		FREE_ME(csMac);
        }
        if (iRet != PD_OK)
                PutField_Int(hContext,"internal_error",iRet);



DEBUGLOG(("BOSecurity:GenerateMMSMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int VerifyMMSMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
	int	iRet = PD_OK;
	char	*csEncType;
	char	*csKey;
	char	*csMac;
	char	*csData;

DEBUGLOG(("BOSecurity:VerifyMMSMac()\n"));

	if (GetField_CString(hRequest,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:VerifyMMSMac encrypt_type = [%s]\n",csEncType));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMMSMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMMSMac encrypt_type is missing!!!\n");
		iRet = INT_ERR;
	}


	if (GetField_CString(hRequest,"mac",&csMac) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMMSMac mac = [%s]\n",csMac));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMMSMac mac is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMMSMac mac is missing!!!\n");
		iRet = INT_MAC_NOT_FOUND;
	}
	
	if (GetField_CString(hRequest,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMMSMac auth_data = [%s]\n",csData));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMMSMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMMSMac auth_data is missing!!!\n");
		iRet = INT_ERR;
	}

        if (GetField_CString(hContext,"mms_key",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyMMSMac mms_key = [%s]\n",csKey));
        }
        else {
DEBUGLOG(("BOSecurity:VerifyMMSMac mms_key is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMMSMac mms_key is missing!!!\n");
                iRet = INT_ERR;
        }

	if (iRet == PD_OK) {
		if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
			iRet = VerifyMD5Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
			iRet = VerifySHA1Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else {
DEBUGLOG(("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType);
			iRet = INT_UNSUPPORTED_ENC_TYPE;
		}
	}

DEBUGLOG(("BOSecurity:VerifyMMSMac iRet = [%d]\n",iRet));

DEBUGLOG(("BOSecurity:VerifMMSyMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int GeneratePspSignINQ(hash_t *hContext,
                        hash_t *hRequest,
                        hash_t *hResponse)
{
	int	iRet = PD_OK;
	char* 	csPspChannel;
	char*	csPtr;
DEBUGLOG(("BOSecurity::GenreatePspSignINQ()\n"));

	if (!GetField_CString(hContext,"psp_channel_code",&csPspChannel)) {	
DEBUGLOG(("BOSecurity::GenreatePspSignINQ psp_channel_code is missing!!!\n"));
ERRLOG("BOSecurity::GenreatePspSignINQ psp_channel_code is missing!!!\n");
		iRet = PD_ERR;
	}
	else {
DEBUGLOG(("BOSecurity::GenreatePspSignINQ psp_channel_code = [%s]\n",csPspChannel));
	}

	if (iRet == PD_OK) {
		if (!strcmp(csPspChannel,PD_CHANNEL_ALLINPAY))
			MsgObjPtr = CreateObj(MsgPtr,"AlpMsg","BuildInqAuthData");
//do nothing
		else {
DEBUGLOG(("BOSecurity::GeneratePspSignINQ PSP undefine\n"));
ERRLOG("BOSecurity::GeneratePspSignINQ PSP undefine\n");
			return iRet;
		}

		if ((*MsgObjPtr)(hRequest) == PD_OK) {
DEBUGLOG(("BOSecurity::GenereatePspSignINQ BuildData = [%d]\n",PD_OK));
            		hash_t  *hCon;
                        char*   csTmp;
                        hCon = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(hCon,0);

/* put psp_channel_code */
			PutField_CString(hCon,"psp_channel_code",csPspChannel);
                        if (GetField_CString(hContext,"psp_merchant_id",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSignINQ psp_merchant_id = [%s]\n",csTmp));
                       		PutField_CString(hResponse,"merchant_id",csTmp);
                        }
                        if (GetField_CString(hContext,"psp_key",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSignINQ psp_key = [%s]\n",csTmp));
                        	PutField_CString(hCon,"psp_key",csTmp);
                        }

			if (!strcmp(csPspChannel,PD_CHANNEL_ESKY) || !strcmp(csPspChannel,PD_CHANNEL_EEP)
				|| !strcmp(csPspChannel,PD_CHANNEL_ALLINPAY) 
 				|| !strcmp(csPspChannel,PD_CHANNEL_SHENGPAY)) {
               			BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateMD5Sign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY) || !strcmp(csPspChannel,PD_CHANNEL_LKPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HHPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HPAY_CNP)) {
                              	PutField_CString(hResponse,"encrypt_type","01");
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateHaiPaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_YEEPAY)) {
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateYeePaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_51EPAY)) {
				if (GetField_CString(hContext,"psp_privatepem",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSignINQ() psp_privatepem = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_privatepem",csPtr);
				}
				if (GetField_CString(hContext,"psp_passphrase",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSignINQ() psp_passphrase = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_passphrase",csPtr);
				}
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","Generate51EpaySign");
			}
                        iRet = (unsigned long)(*BOObjPtr)(hCon,hRequest);
                        FREE_ME(hCon);
            	}
	
	}
DEBUGLOG(("BOSecurity::GenereatePspSignINQ() iRet = [%d]\n",iRet));
	return iRet;
}
