/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2010/09/29              Cody Chan
ESky Support					   2011/01/11		   Cody Chan
MD5 Support					   2011/04/13		   Cody Chan
YeePay Support					   2011/10/19		   Cody Chan
MMS Support					   2011/10/21		   Cody Chan
51Epay Support					   2011/11/11		   Cody Chan
AllinPay Support				   2012/02/15		   Cody Chan
AllinPay INQ Support				   2012/05/15		   Cody Chan
Add HNAPay and BaoFoo				   2014/07/16		   LokMan Chow
Add TenMobile					   2014/12/18		   Virginia Yun
Add ReaPay					   2015/03/11		   Cody Chan
ReaPay INQ support				   2015/04/09		   LokMan Chow
Add EasyPay					   2015/05/28		   LokMan Chow
Add YeePayMobile				   2015/08/04		   LokMan Chow
Remove EasyPay					   2015/09/21		   LokMan Chow
Add YsePay					   2016/06/28		   LokMan Chow
Add HeePay					   2016/08/24		   LokMan Chow
Add ECPSS Mobile				   2016/09/30		   David Wong
Add WeChatPay					   2016/12/01		   David Wong
Add XJP						   2016/12/19		   David Wong
Add Now2Pay					   2016/12/22		   David Wong
Add EASYPAY-AIPWechat				   2017/01/11		   David Wong
Change Unipaygo from MD5 to RSA (send to PSP)	   2017/01/19		   David Wong
Modify  VerifyMac, GenerateMac for payout API 	   2017/03/13		   Virginia Yun
Add Now2Pay-AIPWechat				   2017/04/03		   David Wong
Add XJ-CHWechat					   2017/07/06		   David Wong
Add Unipaygo Wechat				   2017/09/12		   David Wong
Add XJ-JINHAI QR				   2017/09/28		   David Wong
Add PayLink-Dinpay				   2017/10/31		   David Wong
Add Cloud123Pay					   2017/11/07		   David Wong
Add PayLink-Dinpay QR				   2017/11/16		   David Wong
Add XJ-Ehk new API				   2017/11/28		   David Wong
Add STAR-KKPay EC				   2017/12/08		   David Wong
Add PayLink-RFPay EC				   2017/12/11		   David Wong
Add TZ-CoalaPay EC				   2017/12/18		   David Wong
Add STAR-KKPay QR				   2018/01/12		   David Wong
Add STAR-KKPay VNET				   2018/01/23		   David Wong
Add EASYPAY-OpenePay				   2018/01/25		   David Wong
Add SHANFU-SFPay EC				   2018/02/06		   David Wong
Add PayLink-HXPay VNET				   2018/02/09		   David Wong
Add PayLink-HXPay QR				   2018/02/09		   LokMan Chow
Add PAYESCAPE-eEpaylinks VNET			   2018/02/13		   LokMan Chow
Add SAMOPAY-SMPay EC				   2018/02/13		   David Wong
Add PayLink-RFPay QR				   2018/03/19		   David Wong
Add SHANFU-Payease QR				   2018/03/22		   David Wong
Add PayLink-RFPay VNET				   2018/03/28		   David Wong
Add PayLink-BFBao VNET				   2018/04/11		   David Wong
Add PayLink-BFBao QR				   2018/04/23		   LokMan Chow
Add GOLDENPAY-SandPay VNET			   2018/04/24		   David Wong
Add C123Pay QR					   2018/04/24              LokMan Chow
Add GOLDENPAY-SandPay EC			   2018/04/27		   David Wong
Add	ZPAY EC
	VerifySHA256Sign
Update	GenerateSHA256Sign			   2018/04/30              LokMan Chow
Add ESKYPAY QR					   2018/05/03              LokMan Chow
Add Now3Pay					   2018/05/10              LokMan Chow
Add PayLink-TTPay EC/VNet + QR			   2018/05/28              LokMan Chow
Add ZPAY QR					   2018/07/18		   David Wong
Add PayLink-WellPay				   2018/08/13		   David Wong
Add XJ-DBao VNET/EC				   2018/08/22		   David Wong
Add PayLink-SwiftPay QR				   2018/09/18		   David Wong
Add GOLDENPAY-XPay VNET				   2018/09/21		   David Wong
Add TRUSTPAY-SandPay EC				   2018/10/02		   David Wong
Add OUP-OpenePay EC				   2018/10/15		   David Wong
Add VerifyAESMac and GenerateAESMac		   2018/11/19		   LokMan Chow
Add EASYPAY-DF QR				   2018/11/26		   David Wong
Add XJ-DBao QR					   2018/12/14		   David Wong
Add XJ-CH					   2019/01/22		   David Wong
Add XJ-CH QR					   2019/03/21		   David Wong
Add Now3Pay QR					   2019/03/26		   David Wong
Add GOLDENPAY-XPay QR				   2019/05/29		   David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "myhash.h"
#include "myrecordset.h"
#include "internal.h"
#include "common.h"
#include "BOSecurity.h"
#include "mymd5.h"
#include "rsa.h"
#include "aes.h"
#include <openssl/rsa.h>

#define PD_MY_KEY	"1234567890abcdef1234567890ABCDEF"

#define	MY_FIELD_TOKEN	"|"
static char cDebug;

int GenerateMD5Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT);
int Generate3DESMac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT);
int GenerateSHA1Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT);
int VerifyMD5Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN);
int VerifySHA1Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN);
int Verify3DESMac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN);
char *replace_str(char *str, char *orig, char *rep);


OBJPTR(DB);
OBJPTR(DB);
OBJPTR(BO);
OBJPTR(Msg);

void BOSecurity(char    cdebug)
{
        cDebug = cdebug;
}



int VerifyXpaySign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char	*csBuf,*csOUT;
	char	*csPtr;
	char	*csSign = strdup("");
	
DEBUGLOG(("BOSecurity:VerifyXpaySign()\n"));
	csBuf = (char*) malloc (1024 * 2 +1);
	csOUT = (char*) malloc (1024 * 2 +1);

	csBuf[0]='\0';
	csOUT[0]='\0';
/* merchant_id */
	if (GetField_CString(hRequest,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() merchant_id= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}

/* encrypt_type */
	if (GetField_CString(hRequest,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() encrypt_type= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* plainttext_data */
	if (GetField_CString(hRequest,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() plainttext_data= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* merchant_key */
	if (GetField_CString(hContext,"merchant_key",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() merchant_key= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
	}
	else {
DEBUGLOG(("BOSecurity:VerifyXpaySign() merchant_key is missing!!!\n"));
	}
DEBUGLOG(("BOSecurity:VerifyXpaySign() verify_data= [%s]\n",csBuf));

	md5sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifyXpaySign() sign             = [%s]\n",csOUT));
	csBuf[0] = '\0';
	U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifyXpaySign() sign             = [%s]\n",csBuf));


	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("BOSecurity:VerifyXpaySign() sign from Request= [%s]\n",csSign));
	}

	else {
errlog("BOSecurity:VerifyXpaySign sign not found\n");
DEBUGLOG(("BOSecurity:VerifyXpaySign sign not found\n"));
		iRet = INT_SIGN_DATA_NOT_FOUND;
		PutField_Int(hContext,"internal_error",iRet);
	}
/* verify sign */
	if (memcmp(csSign,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifyXpaySign() iRet = [%d]\n",iRet));

	
	return iRet;
}


int GenerateXpaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;

DEBUGLOG(("BOSecurity:GenerateXpaySign()\n"));
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);

        csBuf[0]='\0';
        csOUT[0]='\0';
/* merchant_id */
        if (GetField_CString(hOut,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() merchant_id= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }

/* encrypt_type */
        if (GetField_CString(hOut,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() encrypt_type= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* plainttext_data */
        if (GetField_CString(hOut,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() plainttext_data= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* merchant_key */
        if (GetField_CString(hContext,"merchant_key",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXpaySign() merchant_key= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
DEBUGLOG(("BOSecurity:GenerateXpaySign() sign_data= [%s]\n",csBuf));

        md5sum(csBuf,strlen(csBuf),csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateXpaySign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateXpaySign() sign             = [%s]\n",csBuf));
	PutField_CString(hOut,"sign",csBuf);


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateXpaySign() iRet = [%d]\n",iRet));


        return iRet;
}
int GenerateMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
        int     iRet = PD_OK;
        char    *csEncType;
        char    *csMerchantId;
        char    *csKey;
        char    *csMac;
        char    *csData;
	char	*csKeyName;
	
	char	*csPOEncType = NULL;

        hash_t  *hRec;
        recordset_t     *rRecordSet;
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

DEBUGLOG(("BOSecurity:GenerateMac()\n"));

        if (GetField_CString(hResponse,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:GenerateMac encrypt_type = [%s]\n",csEncType));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMac encrypt_type is missing!!!\n");
                iRet = INT_ERR;
        }

        if (GetField_CString(hResponse,"merchant_id",&csMerchantId) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateMac merchant_id = [%s]\n",csMerchantId));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMac merchant_id is missing!!!\n"));
                iRet = INT_MERCHANT_ID_NOT_FOUND;
        }


        if (GetField_CString(hResponse,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateMac auth_data = [%s]\n",csData));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMac auth_data is missing!!!\n");
                iRet = INT_ERR;
        }

	csKeyName = (char*) malloc (PD_TMP_BUF_LEN +1);
        if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                strcpy(csKeyName,PD_PTK_KEY_NAME);
        }
        else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                strcpy(csKeyName,PD_SHA1_KEY_NAME);
        }

        if (GetField_CString(hRequest,"po_encrypt_type",&csPOEncType)) {
DEBUGLOG(("BOSecurity:GenerateMac Payout API encrypt_type = [%s]\n",csPOEncType));

		if (!strcmp(csPOEncType,PD_ENC_TYPE_MD5)) {
			strcpy(csKeyName,PD_MOK_KEY_NAME);
		}
		else if (!strcmp(csPOEncType,PD_ENC_TYPE_SHA1)) {
			strcpy(csKeyName,PD_POK_KEY_NAME);
		}
	}


        if (iRet == PD_OK ) {
                DBObjPtr = CreateObj(DBPtr,"DBMerchKeys","GetMerchantKey");
                if ((*DBObjPtr)(csMerchantId,csKeyName,rRecordSet) != PD_OK) {
                        iRet = INT_ERR;
ERRLOG("BOSecurity:GenerateMac: Merchant Key for Merchant[%s] not found\n",csMerchantId);
DEBUGLOG(("BOSecurity:GenerateMac key for Merchant[%s] not found\n",csMerchantId));
                }
                else{
                        iRet = INT_ERR;
                        hRec = RecordSet_GetFirst(rRecordSet);
                        while(hRec){
                                if (GetField_CString(hRec,"key_value",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateMac GetMerchantKey - merchant_key_value = [%s]\n",csKey));
                                        iRet = PD_OK;
                                }
                                hRec = RecordSet_GetNext(rRecordSet);
                        }
                }
	}
        if (iRet == PD_OK) {
        	csMac = (char*) malloc (PD_TMP_MSG_BUF_LEN  +1);
                if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                        iRet = GenerateMD5Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                        iRet = GenerateSHA1Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else {
DEBUGLOG(("BOSecurity:GenerateMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:GenerateMac unsupported encrypt type [%s]\n",csEncType);
                }
		if (iRet == PD_OK) 
			PutField_CString(hResponse,"mac",csMac);
		FREE_ME(csMac);
        }
        if (iRet != PD_OK)
                PutField_Int(hContext,"internal_error",iRet);

        RecordSet_Destroy(rRecordSet);
        FREE_ME(rRecordSet);

	FREE_ME(csKeyName);

DEBUGLOG(("BOSecurity:GenerateMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int Generate3DESMac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT)
{
	int 	iRet = PD_OK;
	int	i;
        unsigned char   csKey[PD_KEY_LEN +1];
        unsigned char   csMAC[PD_KEY_LEN +1];
        unsigned char   csMac[PD_KEY_LEN +1];

DEBUGLOG(("Generate3DESMac() input = [%s][%s][%d]\n",KEY,DATA,strlen((char*)DATA)));

        Ascii2Hex((char*)csKey,(char*)KEY,PD_KEY_LEN *2 );

	i = (PD_KEY_LEN / 2) - DATA_LEN % (PD_KEY_LEN /2);
        i += DATA_LEN; 

        EncryptKeyDIV(csKey,DATA,i,csMAC,NULL);

        Hex2Ascii((char*)csMac,csMAC,PD_KEY_LEN /2);
DEBUGLOG(("Generate3DESMac() Hex2Ascii = [%s][%d]\n",csMac,strlen((char*)csMac)));
	memset(OUT,0,sizeof(OUT));
	strcpy((char*)OUT,(char*)csMac);

DEBUGLOG(("BOSecurity:Generate3DESMac() iRet = [%d]\n",iRet));
	return iRet;
}

int GenerateMD5Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT)
{
        int             iRet = PD_OK;
	char		*csBuf;

DEBUGLOG(("BOSecurity:GenerateMD5Mac()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        OUT[0]='\0';
        csBuf[0]='\0';

	strcat((char*)OUT,(char*)DATA);
	strcat((char*)OUT,(char*)KEY);

         md5sum((const char*)OUT,strlen((const char*)OUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateMD5Mac() sign             = [%s]\n",csBuf));
	OUT[0] = '\0';

        U2L(csBuf,strlen(csBuf),(char*)OUT);
DEBUGLOG(("BOSecurity:GenerateMD5Mac() sign             = [%s]\n",OUT));

        FREE_ME(csBuf);
DEBUGLOG(("BOSecurity:GenerateMD5Mac() iRet = [%d]\n",iRet));
        return iRet;
}

int GenerateSHA1Mac(const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN,unsigned char* OUT)
{
        int             iRet = PD_OK;
        char            *csBuf;

DEBUGLOG(("BOSecurity:GenerateSHA1Mac()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        OUT[0]='\0';
        csBuf[0]='\0';

        strcat((char*)OUT,(char*)DATA);
        strcat((char*)OUT,(char*)KEY);

        sha1sum((const char*)OUT,strlen((char*)OUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateSHA1Mac() sign             = [%s]\n",csBuf));
        OUT[0] = '\0';

        U2L(csBuf,strlen(csBuf),(char*)OUT);
DEBUGLOG(("BOSecurity:GenerateSHA1Mac() sign             = [%s]\n",OUT));

        FREE_ME(csBuf);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() iRet = [%d]\n",iRet));
        return iRet;
}


int VerifyMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
	int	iRet = PD_OK;
	char	*csEncType;
	char	*csMerchantId;
	char	*csKey;
	char	*csMac;
	char	*csData;
	char	*csKeyName;
	hash_t	*hRec;
	recordset_t     *rRecordSet;
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

	char	*csPOEncType = NULL;	


DEBUGLOG(("BOSecurity:VerifyMac()\n"));

	if (GetField_CString(hRequest,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:VerifyMac encrypt_type = [%s]\n",csEncType));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMac encrypt_type is missing!!!\n");
		iRet = INT_ERR;
	}

	if (GetField_CString(hRequest,"merchant_id",&csMerchantId) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMac merchant_id = [%s]\n",csMerchantId));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac merchant_id is missing!!!\n"));
		iRet = INT_MERCHANT_ID_NOT_FOUND;
	}

	if (GetField_CString(hRequest,"mac",&csMac) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMac mac = [%s]\n",csMac));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac mac is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMac mac is missing!!!\n");
		iRet = INT_MAC_NOT_FOUND;
	}
	
	if (GetField_CString(hRequest,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMac auth_data = [%s]\n",csData));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMac auth_data is missing!!!\n");
		iRet = INT_ERR;
	}

        csKeyName = (char*) malloc (PD_TMP_BUF_LEN +1);
	if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
		strcpy(csKeyName,PD_PTK_KEY_NAME);
	}
	else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
		strcpy(csKeyName,PD_SHA1_KEY_NAME);
	}

	if (GetField_CString(hRequest,"po_encrypt_type",&csPOEncType)) {
DEBUGLOG(("BOSecurity:VerifyMac Payout API encrypt_type = [%s]\n",csPOEncType));

		if (!strcmp(csPOEncType,PD_ENC_TYPE_MD5)) {
			strcpy(csKeyName,PD_MOK_KEY_NAME);
		}
		else if (!strcmp(csPOEncType,PD_ENC_TYPE_SHA1)) {
			strcpy(csKeyName,PD_POK_KEY_NAME);
		}
	}


DEBUGLOG(("BOSecurity:VerifyMac keyname = [%s]\n",csKeyName));
	if (iRet == PD_OK ) {
                DBObjPtr = CreateObj(DBPtr,"DBMerchKeys","GetMerchantKey");
                if ((*DBObjPtr)(csMerchantId,csKeyName,rRecordSet) != PD_OK) {
                        iRet = INT_ERR;
ERRLOG("BOSecurity:VerifyMac: Merchant Key for Merchant[%s] not found\n",csMerchantId);
DEBUGLOG(("BOSecurity:VerifyMac key for Merchant[%s] not found\n",csMerchantId));
                }
                else{
                        iRet = INT_ERR;
                        hRec = RecordSet_GetFirst(rRecordSet);
                        while(hRec){
                                if (GetField_CString(hRec,"key_value",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyMac GetMerchantKey - merchant_key_value = [%s]\n",csKey));
                                        iRet = PD_OK;
                                }
                                hRec = RecordSet_GetNext(rRecordSet);
                        }
                }
        }
	if (iRet == PD_OK) {
		if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
			iRet = VerifyMD5Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
			iRet = VerifySHA1Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else {
DEBUGLOG(("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType);
			iRet = INT_UNSUPPORTED_ENC_TYPE;
		}
	}

DEBUGLOG(("BOSecurity:VerifyMac iRet = [%d]\n",iRet));
	RecordSet_Destroy(rRecordSet);
        FREE_ME(rRecordSet);
	FREE_ME(csKeyName);

DEBUGLOG(("BOSecurity:VerifyMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int Verify3DESMac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN)
{
	int 		iRet = PD_OK;
        unsigned char   csKey[PD_KEY_LEN +1];
        unsigned char   csMAC[PD_KEY_LEN +1];
        unsigned char   csMac[PD_KEY_LEN +1];
	int	i;

        Ascii2Hex((char*)csKey,(char*)KEY,PD_KEY_LEN *2 );

	i = (PD_KEY_LEN/2) - DATA_LEN % (PD_KEY_LEN /2);
        i += DATA_LEN; 
DEBUGLOG(("BOSecurity:Verify3DESMac() MAC  = [%s]\n",MAC));
DEBUGLOG(("BOSecurity:Verify3DESMac() KEY  = [%s]\n",KEY));

        EncryptKeyDIV(csKey,DATA,i,csMAC,NULL);
        Hex2Ascii((char*)csMac,csMAC,PD_KEY_LEN /2);
DEBUGLOG(("BOSecurity:Verify3DESMac() *MAC = [%s]\n",csMac));
	if (memcmp(csMac,MAC,PD_KEY_LEN) != 0 ) {
		iRet = INT_MAC_ERR;

DEBUGLOG(("BOSecurity:Verify3DESMac()Invlide Mac\n"));
	}

DEBUGLOG(("BOSecurity:Verify3DESMac() iRet = [%d]\n",iRet));
	return iRet;
}

int VerifyMD5Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN)
{       
        int             iRet = PD_OK;
	char    *csOUT,*csBuf;

DEBUGLOG(("BOSecurity:VerifyMD5Mac()\n"));
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csOUT[0]='\0';
        csBuf[0]='\0';
	
	strcat(csBuf,(char*)DATA);
	strcat(csBuf,(char*)KEY);

	 md5sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifyMD5Mac() DATA = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifyMD5Mac() sign             = [%s]\n",csOUT));
        csBuf[0]='\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifyMD5Mac() sign             = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifyMD5Mac() mac in msg       = [%s]\n",MAC));
        
	if (memcmp(MAC,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verifyMD5Mac  error\n");
                iRet = INT_MAC_ERR;
        }

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifyMD5Mac() iRet = [%d]\n",iRet));
        return iRet;
}


int VerifySHA1Mac(const unsigned char* MAC, const unsigned char* KEY,const unsigned char* DATA, const int DATA_LEN)
{
        int             iRet = PD_OK;
        char    *csOUT,*csBuf;

DEBUGLOG(("BOSecurity:VerifySHA1Mac()\n"));
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csOUT[0]='\0';
        csBuf[0]='\0';

        strcat(csBuf,(char*)DATA);
        strcat(csBuf,(char*)KEY);

DEBUGLOG(("BOSecurity:VerifySHA1Mac() DATA             = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifySHA1Mac() DATA             = [%s]\n",csBuf));

        sha1sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() sign             = [%s]\n",csOUT));
        csBuf[0]='\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() sign             = [%s]\n",csBuf));
DEBUGLOG(("BOSecurity:VerifySHA1Mac() mac in msg       = [%s]\n",MAC));

	if (memcmp(MAC,csBuf,PD_SHA1_SUM_LEN) != 0) {
errlog("BOSecurity:verifySHA1Mac  error\n");
                iRet = INT_MAC_ERR;
        }


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifySHA1Mac() iRet = [%d]\n",iRet));
        return iRet;
}


int VerifyMD5Sign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char*	csPtr;
	char*   csSign;

	char	*csOUT;
	char	*csTmpBuf;
	csTmpBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	

	csTmpBuf[0] ='\0';
	char*   csPspChannel;
        if (!GetField_CString(hContext,"return_psp_channel",&csPspChannel)) {
DEBUGLOG(("BOSecurity:VerifyMD5Sign psp_channel = [%s]\n",csPspChannel));
        }
/* auth data */
        if (GetField_CString(hRequest,"auth_data",&csPtr)) {
DEBUGLOG(("VerifyMD5Sign() auth_data= [%s]\n",csPtr));
                strcat(csTmpBuf,csPtr);
        }

/* psp_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("VerifyMD5Sign() psp_key= [%s]\n",csPtr));
	  	if (!strcmp(csPspChannel,PD_CHANNEL_TENPAY) ||
                    !strcmp(csPspChannel, PD_CHANNEL_TENMOBPAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_HEEPAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_WECHATPAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_OPENEPAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_SHANFU_EC) ||
		    !strcmp(csPspChannel,PD_CHANNEL_SHANFU_QR) ||
		    !strcmp(csPspChannel,PD_CHANNEL_PAYESCAPE_VNET) ||
		    !strcmp(csPspChannel,PD_CHANNEL_OUP_OPENEPAY_EC)
		)
			strcat(csTmpBuf,"key=");

		if (!strcmp(csPspChannel,PD_CHANNEL_DF_QR)
		)
			strcat(csTmpBuf,"KEY=");

		if (!strcmp(csPspChannel,PD_CHANNEL_CLOUD123PAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_C123PAY_QR))
			strcat(csTmpBuf,"APIKEY=[");

		if (!strcmp(csPspChannel,PD_CHANNEL_COALAPAY_EC))
			strcat(csTmpBuf,"{");

		if (!strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_EC) ||
		    !strcmp(csPspChannel,PD_CHANNEL_RFPAY_EC) ||
		    !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_QR) ||
		    !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_VNET)
		)
			strcat(csTmpBuf,"paySecret=");

		if (!strcmp(csPspChannel,PD_CHANNEL_AIPWECHAT)) {
			char *csToReplace, *csReplaced;
			csToReplace = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
			csReplaced = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
			csToReplace[0] = '\0';
			csReplaced[0] = '\0';
			sprintf(csToReplace, "key=%s", csPtr);
			csReplaced = replace_str(csTmpBuf, PD_REPLACE_PSP_KEY, csToReplace);
			strcpy(csTmpBuf, csReplaced);
		} else if (!strcmp(csPspChannel,PD_CHANNEL_SAMOPAY_EC)) {
			char *csTmp;
			csTmp = (char *) malloc (PD_TMP_MSG_BUF_LEN + 1);
			csTmp[0] = '\0';

			sprintf(csTmp, "%s;%s", csPtr, csTmpBuf);
			strcpy(csTmpBuf, csTmp);

			FREE_ME(csTmp);
                } else {
			strcat(csTmpBuf,csPtr);
		}

		if (!strcmp(csPspChannel,PD_CHANNEL_CLOUD123PAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_C123PAY_QR))
			strcat(csTmpBuf,"]");

		if (!strcmp(csPspChannel,PD_CHANNEL_COALAPAY_EC))
			strcat(csTmpBuf,"}");
        }
	else {
DEBUGLOG(("VerifyMD5Sign() psp_key is missing!!!\n"));
	}
DEBUGLOG(("VerifyMD5Sign() sign_data= [%s]\n",csTmpBuf));

/* sign */
	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("VerifyMD5Sign() sign from msg = [%s]\n",csSign));
	}
	
	md5sum(csTmpBuf,strlen(csTmpBuf),csOUT);
DEBUGLOG(("VerifyMD5Sign() sign             = [%s]\n",csOUT));
	csTmpBuf[0] = '\0';

        if (!strcmp(csPspChannel,PD_CHANNEL_SHENGPAY) ||
	    !strcmp(csPspChannel,PD_CHANNEL_ECPSS) ||
	    !strcmp(csPspChannel,PD_CHANNEL_ECPSSMOBILE) ||
	    !strcmp(csPspChannel,PD_CHANNEL_TENPAY) ||
	    !strcmp(csPspChannel,PD_CHANNEL_TENMOBPAY) ||
	    !strcmp(csPspChannel,PD_CHANNEL_AIPWECHAT) ||
	    !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_EC) ||
	    !strcmp(csPspChannel,PD_CHANNEL_RFPAY_EC) ||
	    !strcmp(csPspChannel,PD_CHANNEL_COALAPAY_EC) ||
	    !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_QR) ||
	    !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_VNET) ||
	    !strcmp(csPspChannel,PD_CHANNEL_OPENEPAY) ||
	    !strcmp(csPspChannel,PD_CHANNEL_OUP_OPENEPAY_EC) ||
	    !strcmp(csPspChannel,PD_CHANNEL_DF_QR)
	)
		L2U(csOUT,strlen(csOUT),csTmpBuf);
	else
		U2L(csOUT,strlen(csOUT),csTmpBuf);
DEBUGLOG(("VerifyMD5Sign() sign             = [%s]\n",csTmpBuf));

/* verify sign */
	if (memcmp(csSign,csTmpBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csTmpBuf);
	FREE_ME(csOUT);
	return iRet;
}


int GenerateMD5Sign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;

DEBUGLOG(("BOSecurity:GenerateMD5Sign()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csBuf[0]='\0';
        csOUT[0]='\0';

	char*	csPspChannel = strdup("");
	if (GetField_CString(hContext,"psp_channel_code",&csPspChannel)) {
DEBUGLOG(("BOSecurity:GenerateMD5Sign psp_channel = [%s]\n",csPspChannel));
	}

/* auth_data */
	if (GetField_CString(hOut,"auth_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateMD5Sign() auth_data = [%s]\n",csPtr));
               	strcat(csBuf,csPtr);
	}

/* psp_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateMD5Sign() auth_key= [%s]\n",csPtr));
	  	if (!strcmp(csPspChannel,PD_CHANNEL_ALLINPAY) || 
                    !strcmp(csPspChannel,PD_CHANNEL_TENPAY) ||
                    !strcmp(csPspChannel,PD_CHANNEL_TENMOBPAY) ||
                    !strcmp(csPspChannel,PD_CHANNEL_HEEPAY) ||
                    !strcmp(csPspChannel,PD_CHANNEL_WECHATPAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_N2P_AIPWECHAT) ||
		    !strcmp(csPspChannel,PD_CHANNEL_OPENEPAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_SHANFU_EC) ||
		    !strcmp(csPspChannel,PD_CHANNEL_SHANFU_QR) ||
		    !strcmp(csPspChannel,PD_CHANNEL_PAYESCAPE_VNET) ||
		    !strcmp(csPspChannel,PD_CHANNEL_NOW3PAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_OUP_OPENEPAY_EC) ||
		    !strcmp(csPspChannel,PD_CHANNEL_NOW3PAY_QR)
                   )
			strcat(csBuf,"key=");

		if (!strcmp(csPspChannel,PD_CHANNEL_DF_QR)
		)
			strcat(csBuf,"KEY=");

		if (!strcmp(csPspChannel,PD_CHANNEL_CLOUD123PAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_C123PAY_QR))
			strcat(csBuf,"APIKEY=[");

		if (!strcmp(csPspChannel,PD_CHANNEL_COALAPAY_EC))
			strcat(csBuf,"{");

		if (!strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_EC) ||
		    !strcmp(csPspChannel,PD_CHANNEL_RFPAY_EC) ||
		    !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_QR) ||
		    !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_VNET)
		)
			strcat(csBuf,"paySecret=");

		if (!strcmp(csPspChannel,PD_CHANNEL_AIPWECHAT)) {
			char *csToReplace, *csReplaced;
			csToReplace = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
			csReplaced = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
			csToReplace[0] = '\0';
			csReplaced[0] = '\0';
			sprintf(csToReplace, "key=%s", csPtr);
			csReplaced = replace_str(csBuf, PD_REPLACE_PSP_KEY, csToReplace);
			strcpy(csBuf, csReplaced);
		} else if (!strcmp(csPspChannel,PD_CHANNEL_SAMOPAY_EC)) {
			char *csTmp;
			csTmp = (char *) malloc (PD_TMP_MSG_BUF_LEN + 1);
			csTmp[0] = '\0';

			sprintf(csTmp, "%s;%s", csPtr, csBuf);

			int iTmp;
			if (GetField_Int(hContext, "isInq", &iTmp)) {
				strcpy(csBuf, csTmp);
			} else {
				L2U(csTmp, strlen(csTmp), csBuf);
			}

			FREE_ME(csTmp);
		} else {
			strcat(csBuf,csPtr);
		}

		if (!strcmp(csPspChannel,PD_CHANNEL_CLOUD123PAY) ||
		    !strcmp(csPspChannel,PD_CHANNEL_C123PAY_QR))
			strcat(csBuf,"]");

		if (!strcmp(csPspChannel,PD_CHANNEL_COALAPAY_EC))
			strcat(csBuf,"}");
        }
	else {
DEBUGLOG(("BOSecurity:GenerateMD5Sign() psp_key is missing***\n"));
	}

DEBUGLOG(("BOSecurity:GenerateMD5Sign() sign_data= [%s]\n",csBuf));

        md5sum(csBuf,strlen(csBuf),csOUT);
        csBuf[0] = '\0';


	if (!strcmp(csPspChannel,PD_CHANNEL_SHENGPAY)
	  ||!strcmp(csPspChannel,PD_CHANNEL_ALLINPAY)
	  ||!strcmp(csPspChannel,PD_CHANNEL_TENPAY)
	  ||!strcmp(csPspChannel,PD_CHANNEL_TENMOBPAY)
	  ||!strcmp(csPspChannel,PD_CHANNEL_ECPSS)
	  ||!strcmp(csPspChannel,PD_CHANNEL_ECPSSMOBILE)
	  ||!strcmp(csPspChannel,PD_CHANNEL_AIPWECHAT)
	  ||!strcmp(csPspChannel,PD_CHANNEL_N2P_AIPWECHAT)
	  ||!strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_EC)
	  ||!strcmp(csPspChannel,PD_CHANNEL_RFPAY_EC)
	  ||!strcmp(csPspChannel,PD_CHANNEL_COALAPAY_EC)
	  ||!strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_QR)
	  ||!strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_VNET)
	  ||!strcmp(csPspChannel,PD_CHANNEL_OPENEPAY)
	  ||!strcmp(csPspChannel,PD_CHANNEL_NOW3PAY)
	  ||!strcmp(csPspChannel,PD_CHANNEL_OUP_OPENEPAY_EC)
	  ||!strcmp(csPspChannel,PD_CHANNEL_DF_QR)
	  ||!strcmp(csPspChannel,PD_CHANNEL_NOW3PAY_QR)
	)
		L2U(csOUT,strlen(csOUT),csBuf);
	//else if(!strcmp(csPspChannel,PD_CHANNEL_HNAPAY))
	//	strcpy(csBuf,csOUT);
	else
        	U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateMD5Sign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateMD5Sign() sign             = [%s]\n",csBuf));
	PutField_CString(hOut,"sign",csBuf);


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateMD5Sign() iRet = [%d]\n",iRet));


        return iRet;
}


int GeneratePspSign(hash_t *hContext,
                        hash_t *hRequest,
                        hash_t *hResponse)
{
	int	iRet = PD_OK;
	char* 	csPspChannel;
	char*	csPtr;
DEBUGLOG(("BOSecurity::GenreatePspSign()\n"));

	if (!GetField_CString(hContext,"psp_channel_code",&csPspChannel)) {	
DEBUGLOG(("BOSecurity::GenreatePspSign psp_channel_code is missing!!!\n"));
ERRLOG("BOSecurity::GenreatePspSign psp_channel_code is missing!!!\n");
		iRet = PD_ERR;
	}
	else {
DEBUGLOG(("BOSecurity::GenreatePspSign psp_channel_code = [%s]\n",csPspChannel));
	}

	if (iRet == PD_OK) {
		if (!strcmp(csPspChannel,PD_CHANNEL_LKPAY))
                       	MsgObjPtr = CreateObj(MsgPtr,"LkpMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY))
          		MsgObjPtr = CreateObj(MsgPtr,"HpyMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY_CNP))
          		MsgObjPtr = CreateObj(MsgPtr,"HcpMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_HHPAY))
                        MsgObjPtr = CreateObj(MsgPtr,"HhpMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_ESKY))
                	MsgObjPtr = CreateObj(MsgPtr,"ESkyMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_EEP))
                	MsgObjPtr = CreateObj(MsgPtr,"EepMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_YEEPAY))
                	MsgObjPtr = CreateObj(MsgPtr,"YpyMsg","BuildReqData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_51EPAY))
                	MsgObjPtr = CreateObj(MsgPtr,"FepMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_PGEN) || !strcmp(csPspChannel,PD_CHANNEL_TWV))
                       	return iRet; 
		else if (!strcmp(csPspChannel,PD_CHANNEL_ALLINPAY))
			MsgObjPtr = CreateObj(MsgPtr,"AlpMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_SHENGPAY))
			MsgObjPtr = CreateObj(MsgPtr,"SpyMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_IPAY))
			MsgObjPtr = CreateObj(MsgPtr,"IpyMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_ECPSS))
			MsgObjPtr = CreateObj(MsgPtr,"EcpMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_ECPSSMOBILE))
			MsgObjPtr = CreateObj(MsgPtr,"EcmMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_GOPAY))
			MsgObjPtr = CreateObj(MsgPtr,"GpyMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_HAIPAY))
          		MsgObjPtr = CreateObj(MsgPtr,"HaiMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_PFTTOM))
          		MsgObjPtr = CreateObj(MsgPtr,"PftMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_EPLUTUS))
          		MsgObjPtr = CreateObj(MsgPtr,"EptMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_UNIPAY))
          		MsgObjPtr = CreateObj(MsgPtr,"UniMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_HNAPAY))
          		MsgObjPtr = CreateObj(MsgPtr,"HnaMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_BAOFOO))
          		MsgObjPtr = CreateObj(MsgPtr,"BfoMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_TENPAY))
          		MsgObjPtr = CreateObj(MsgPtr,"TpyMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_TENMOBPAY))
          		MsgObjPtr = CreateObj(MsgPtr,"TpmMsg","BuildAuthData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_REAPAY))
          		MsgObjPtr = CreateObj(MsgPtr,"RpyMsg","BuildAuthData");
                /*else if (!strcmp(csPspChannel,PD_CHANNEL_EASYPAY))
          		MsgObjPtr = CreateObj(MsgPtr,"EsyMsg","BuildAuthData");*/
                else if (!strcmp(csPspChannel,PD_CHANNEL_YEEPAYMOBILE))
                        MsgObjPtr = CreateObj(MsgPtr,"YpmMsg","BuildData");
                else if (!strcmp(csPspChannel,PD_CHANNEL_YSEPAY))
                        MsgObjPtr = CreateObj(MsgPtr,"YseMsg","FormatXMLMsg");
                else if (!strcmp(csPspChannel,PD_CHANNEL_HEEPAY))
                        MsgObjPtr = CreateObj(MsgPtr,"HeeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_WECHATPAY))
			MsgObjPtr = CreateObj(MsgPtr,"WcpMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XJP))
			MsgObjPtr = CreateObj(MsgPtr,"XjpMsg","BuildData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_NOW2PAY))
			MsgObjPtr = CreateObj(MsgPtr,"NtpMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_AIPWECHAT))
			MsgObjPtr = CreateObj(MsgPtr,"AwcMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_N2P_AIPWECHAT))
			MsgObjPtr = CreateObj(MsgPtr,"NtwMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XJ_CHWECHAT))
			MsgObjPtr = CreateObj(MsgPtr,"XjwMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XJ_MOBILE))
			MsgObjPtr = CreateObj(MsgPtr,"XjmMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_UNIPAY_WECHAT))
			MsgObjPtr = CreateObj(MsgPtr,"UnwMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XJ_JINHAI_QR))
			MsgObjPtr = CreateObj(MsgPtr,"XjqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_DINPAY))
			MsgObjPtr = CreateObj(MsgPtr,"DpyMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_CLOUD123PAY))
			MsgObjPtr = CreateObj(MsgPtr,"CopMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_DINPAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"DpqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XJE))
			MsgObjPtr = CreateObj(MsgPtr,"XjeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_EC))
			MsgObjPtr = CreateObj(MsgPtr,"SkeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_RFPAY_EC))
			MsgObjPtr = CreateObj(MsgPtr,"RfeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_COALAPAY_EC))
			MsgObjPtr = CreateObj(MsgPtr,"CpeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"SkqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_VNET))
			MsgObjPtr = CreateObj(MsgPtr,"SkvMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_OPENEPAY))
			MsgObjPtr = CreateObj(MsgPtr,"OppMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_SHANFU_EC))
			MsgObjPtr = CreateObj(MsgPtr,"SfeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_HXPAY_VNET))
			MsgObjPtr = CreateObj(MsgPtr,"HxvMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_HXPAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"HxqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_PAYESCAPE_VNET))
			MsgObjPtr = CreateObj(MsgPtr,"PsvMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_SAMOPAY_EC))
			MsgObjPtr = CreateObj(MsgPtr,"SmeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_RFPAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"RfqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_SHANFU_QR))
			MsgObjPtr = CreateObj(MsgPtr,"SfqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_RFPAY_VNET))
			MsgObjPtr = CreateObj(MsgPtr,"RfvMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_BFBAO_VNET))
			MsgObjPtr = CreateObj(MsgPtr,"BfvMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_OUP_EC))
			MsgObjPtr = CreateObj(MsgPtr,"OupMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_BFBAO_QR))
			MsgObjPtr = CreateObj(MsgPtr,"BfqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_GOLDENPAY_VNET))
			MsgObjPtr = CreateObj(MsgPtr,"GpvMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_C123PAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"CoqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_GOLDENPAY_EC))
			MsgObjPtr = CreateObj(MsgPtr,"GpeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_ZPAY_EC))
			MsgObjPtr = CreateObj(MsgPtr,"ZpeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_ESKY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"EsqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_NOW3PAY))
			MsgObjPtr = CreateObj(MsgPtr,"NepMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_TTPAY))
			MsgObjPtr = CreateObj(MsgPtr,"TtpMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_TTPAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"TtqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_ZPAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"ZpqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_WELLPAY))
			MsgObjPtr = CreateObj(MsgPtr,"WpyMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XJ_DBAO))
			MsgObjPtr = CreateObj(MsgPtr,"XdbMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_SWIFTPAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"SpqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XPAY_VNET))
			MsgObjPtr = CreateObj(MsgPtr,"XpvMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_TRUSTPAY_EC))
			MsgObjPtr = CreateObj(MsgPtr,"TpeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_OUP_OPENEPAY_EC))
			MsgObjPtr = CreateObj(MsgPtr,"OoeMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_DF_QR))
			MsgObjPtr = CreateObj(MsgPtr,"DfqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XJ_DBAO_QR))
			MsgObjPtr = CreateObj(MsgPtr,"XdqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XJ_CH))
			MsgObjPtr = CreateObj(MsgPtr,"XjcMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XJ_CH_QR))
			MsgObjPtr = CreateObj(MsgPtr,"XjrMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_NOW3PAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"NeqMsg","BuildAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_XPAY_QR))
			MsgObjPtr = CreateObj(MsgPtr,"XpqMsg","BuildAuthData");
//do nothing
		else {
DEBUGLOG(("BOSecurity::GeneratePspSign PSP undefine [%s]\n",csPspChannel));
ERRLOG("BOSecurity::GeneratePspSign PSP undefine [%s]\n",csPspChannel);
			return iRet;
		}

		if ((*MsgObjPtr)(hResponse) == PD_OK) {
DEBUGLOG(("BOSecurity::GenereatePspSign BuildData = [%d]\n",PD_OK));
            		hash_t  *hCon;
                        char*   csTmp;
                        hCon = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(hCon,0);

/* put psp_channel_code */
			PutField_CString(hCon,"psp_channel_code",csPspChannel);
                        if (GetField_CString(hContext,"psp_merchant_id",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSign psp_merchant_id = [%s]\n",csTmp));
                       		PutField_CString(hResponse,"merchant_id",csTmp);
                        }
                        if (GetField_CString(hContext,"psp_key",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSign psp_key = [%s]\n",csTmp));
                        	PutField_CString(hCon,"psp_key",csTmp);
                        }
                        if (GetField_CString(hContext,"aes_key",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSign aes_key = [%s]\n",csTmp));
                        	PutField_CString(hCon,"aes_key",csTmp);
                        	PutField_CString(hResponse,"aes_key",csTmp);
                        }
                        if (GetField_CString(hContext,"rsa_key",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSign rsa_key = [%s]\n",csTmp));
				PutField_CString(hCon,"rsa_key",csTmp);
				PutField_CString(hResponse,"rsa_key",csTmp);
			}
                        if (GetField_CString(hContext,"puk_key",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSign puk_key = [%s]\n",csTmp));
				PutField_CString(hCon,"puk_key",csTmp);
				PutField_CString(hResponse,"puk_key",csTmp);
			}


			if (!strcmp(csPspChannel,PD_CHANNEL_ESKY) || !strcmp(csPspChannel,PD_CHANNEL_EEP)
				|| !strcmp(csPspChannel,PD_CHANNEL_ALLINPAY) 
				|| !strcmp(csPspChannel,PD_CHANNEL_ECPSS) 
				|| !strcmp(csPspChannel,PD_CHANNEL_ECPSSMOBILE) 
 				|| !strcmp(csPspChannel,PD_CHANNEL_SHENGPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_PFTTOM)
				|| !strcmp(csPspChannel,PD_CHANNEL_HNAPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_BAOFOO)
				//|| !strcmp(csPspChannel,PD_CHANNEL_UNIPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_EPLUTUS)
				|| !strcmp(csPspChannel,PD_CHANNEL_TENPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_TENMOBPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_REAPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_HEEPAY)
				//|| !strcmp(csPspChannel,PD_CHANNEL_EASYPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_WECHATPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_NOW2PAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_AIPWECHAT)
				|| !strcmp(csPspChannel,PD_CHANNEL_N2P_AIPWECHAT)
				|| !strcmp(csPspChannel,PD_CHANNEL_XJ_JINHAI_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_CLOUD123PAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_EC)
				|| !strcmp(csPspChannel,PD_CHANNEL_RFPAY_EC)
				|| !strcmp(csPspChannel,PD_CHANNEL_COALAPAY_EC)
				|| !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_STAR_KKPAY_VNET)
				|| !strcmp(csPspChannel,PD_CHANNEL_OPENEPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_SHANFU_EC)
				|| !strcmp(csPspChannel,PD_CHANNEL_SAMOPAY_EC)
				|| !strcmp(csPspChannel,PD_CHANNEL_SHANFU_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_PAYESCAPE_VNET)
				|| !strcmp(csPspChannel,PD_CHANNEL_BFBAO_VNET)
				|| !strcmp(csPspChannel,PD_CHANNEL_BFBAO_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_C123PAY_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_ESKY_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_NOW3PAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_XPAY_VNET)
				|| !strcmp(csPspChannel,PD_CHANNEL_OUP_OPENEPAY_EC)
				|| !strcmp(csPspChannel,PD_CHANNEL_DF_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_NOW3PAY_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_XPAY_QR)
				) {
               			BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateMD5Sign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY) || !strcmp(csPspChannel,PD_CHANNEL_LKPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_GOPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HHPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HAIPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HPAY_CNP)) {
                              	PutField_CString(hResponse,"encrypt_type","01");
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateHaiPaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_YEEPAY)) {
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateYeePaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_51EPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_GOLDENPAY_VNET)
				|| !strcmp(csPspChannel,PD_CHANNEL_GOLDENPAY_EC)
			) {
				if (GetField_CString(hContext,"psp_privatepem",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_privatepem = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_privatepem",csPtr);
				}
				if (GetField_CString(hContext,"psp_passphrase",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_passphrase = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_passphrase",csPtr);
				}
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","Generate51EpaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_IPAY)) {
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateIPay88Sign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_YEEPAYMOBILE)) {
				if (GetField_CString(hContext,"psp_privatepem",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_privatepem = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_privatepem",csPtr);
				}
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateYeePayMobileSign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_YSEPAY)) {
				if(GetField_CString(hContext,"psp_privatepem",&csPtr)){
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_privatepem = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_privatepem",csPtr);
				}
				if (GetField_CString(hContext,"psp_passphrase",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_passphrase = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_passphrase",csPtr);
				}
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateYsePaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_XJP)
				|| !strcmp(csPspChannel,PD_CHANNEL_XJ_CHWECHAT)
				|| !strcmp(csPspChannel,PD_CHANNEL_XJ_MOBILE)
				|| !strcmp(csPspChannel,PD_CHANNEL_XJE)
				|| !strcmp(csPspChannel,PD_CHANNEL_RFPAY_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_RFPAY_VNET)
				|| !strcmp(csPspChannel,PD_CHANNEL_XJ_DBAO)
				|| !strcmp(csPspChannel,PD_CHANNEL_XJ_DBAO_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_XJ_CH)
				|| !strcmp(csPspChannel,PD_CHANNEL_XJ_CH_QR)
				) {
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateXJSign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_UNIPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_UNIPAY_WECHAT)
				) {
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateUniPaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_DINPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_DINPAY_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_TTPAY)
				|| !strcmp(csPspChannel,PD_CHANNEL_TTPAY_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_WELLPAY)
				) {
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateDinPaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_HXPAY_VNET)
				|| !strcmp(csPspChannel,PD_CHANNEL_HXPAY_QR)
				|| !strcmp(csPspChannel,PD_CHANNEL_TRUSTPAY_EC)
				) {
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateHXPaySign");
			}
/*
			else if (!strcmp(csPspChannel,PD_CHANNEL_PAYESCAPE_VNET)) {
				if(GetField_CString(hContext,"psp_privatepem",&csPtr)){
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_privatepem = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_privatepem",csPtr);
				}
				if (GetField_CString(hContext,"psp_passphrase",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_passphrase = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_passphrase",csPtr);
				}
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","GeneratePayEscapeSign");
			}
*/
			else if (!strcmp(csPspChannel,PD_CHANNEL_OUP_EC)) {
				if(GetField_CString(hContext,"psp_privatepem",&csPtr)){
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_privatepem = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_privatepem",csPtr);
				}
				if (GetField_CString(hContext,"psp_passphrase",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSign() psp_passphrase = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_passphrase",csPtr);
				}
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateOUPSign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_ZPAY_EC)
				|| !strcmp(csPspChannel,PD_CHANNEL_ZPAY_QR)
			) {
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateSHA256Sign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_SWIFTPAY_QR)
			) {
				BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateSHA1Sign");
			}

                        iRet = (unsigned long)(*BOObjPtr)(hCon,hResponse);
                        FREE_ME(hCon);
            	}
	
	}
DEBUGLOG(("BOSecurity::GenereatePspSign() iRet = [%d]\n",iRet));
	return iRet;
}

int VerifyPspSign(hash_t *hContext,
                        hash_t *hRequest,
                        hash_t *hResponse)
{
        int     iRet = PD_OK;
	char    *csReturnPspChannel;
	//char	*csPtr;
DEBUGLOG(("BOSecurity::VerifyPspSign()\n"));

	if (GetField_CString(hContext,"return_psp_channel",&csReturnPspChannel)) {
DEBUGLOG(("BOSecurity::VerifyPspSign return psp_channel = [%s]\n",csReturnPspChannel));
        }
        else {
DEBUGLOG(("BOSecurity::VerifyPspSign return psp missing!!!!\n"));
ERRLOG("BOSecurity::VerifyPspSign return psp missing!!!!\n");
		iRet = PD_ERR;
        }
/*
	if (GetField_CString(hContext,"merchant_key",&csPtr)) {
DEBUGLOG(("BOSecurity::VerifyPspSign merchant_key = [%s]\n",csPtr));
		PutField_CString(hContext,"auth_key",csPtr);
	}
*/

	if (iRet == PD_OK) {
		if (!strcmp(csReturnPspChannel,PD_CHANNEL_TWV)) {
			char*	csKey;
			/* merchant_key */
        		if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyPspSing() auth_key= [%s]\n",csKey));
        		}
			else {
				iRet = PD_ERR;
DEBUGLOG(("BOSecurity:VerifyPspSing() auth_key is missing\n"));
ERRLOG("BOSecurity:VerifyPspSing() auth_key is missing\n");
			}
			if (iRet == PD_OK) {
				char*   csAccessKey;
                                if (GetField_CString(hRequest,"access_key",&csAccessKey)) {
DEBUGLOG(("BOSecurity:VerifyPspSing() remote key = [%s]\n",csAccessKey));
                                        if (strcmp(csKey,csAccessKey)) {
DEBUGLOG(("BOSecurity:VerifyPspSingKey Mismatch host[%s] remote[%s]\n",csKey,csAccessKey));
ERRLOG("BOSecurity:VerifyPspSing: TWVChannel Key Mismatch host[%s] remote[%s]\n",csKey,csAccessKey);
                                                iRet = INT_MAC_ERR;
                                        }
                                }
                                else {
DEBUGLOG(("access Key is missing\n"));
ERRLOG("TWV Channel access Key is missing\n");
                                        iRet = INT_MAC_ERR;
                                }
			}
		}
		else if (!strcmp(csReturnPspChannel,PD_CHANNEL_HPAY) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_HPAY_CNP) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_LKPAY) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_GOPAY) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_HAIPAY) ||
                                !strcmp(csReturnPspChannel,PD_CHANNEL_HHPAY))
                {
                	BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyHaiPaySign");
                        iRet = (unsigned long)(*BOObjPtr)(hContext,hRequest);
                }
		else if (!strcmp(csReturnPspChannel,PD_CHANNEL_YEEPAYMOBILE)){
			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyYeePayMobileSign");
                        iRet = (unsigned long)(*BOObjPtr)(hContext,hRequest);
		}
		else {
			if (!strcmp(csReturnPspChannel,PD_CHANNEL_ESKY))
                        	MsgObjPtr = CreateObj(MsgPtr,"ESkyMsg","BuildAuthData");
                	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_EEP))
                        	MsgObjPtr = CreateObj(MsgPtr,"EepMsg","BuildAuthData");
                	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_YEEPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"YpyMsg","BuildRspData");
                	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_51EPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"FepMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ALLINPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"AlpMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_SHENGPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"SpyMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_IPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"IpyMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ECPSS))
                        	MsgObjPtr = CreateObj(MsgPtr,"EcpMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ECPSSMOBILE))
				MsgObjPtr = CreateObj(MsgPtr,"EcmMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_PFTTOM))
                        	MsgObjPtr = CreateObj(MsgPtr,"PftMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_EPLUTUS))
                        	MsgObjPtr = CreateObj(MsgPtr,"EptMsg","BuildRspAuthData");
		 	/*else if (!strcmp(csReturnPspChannel,PD_CHANNEL_UNIPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"UniMsg","BuildRspAuthData");*/
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_HNAPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"HnaMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_BAOFOO))
                        	MsgObjPtr = CreateObj(MsgPtr,"BfoMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_TENPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"TpyMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_TENMOBPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"TpmMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_REAPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"RpyMsg","BuildRspAuthData");
		 	/*else if (!strcmp(csReturnPspChannel,PD_CHANNEL_EASYPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"EsyMsg","BuildRspAuthData");*/
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_YSEPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"YseMsg","BuildRspAuthData");
		 	else if (!strcmp(csReturnPspChannel,PD_CHANNEL_HEEPAY))
                        	MsgObjPtr = CreateObj(MsgPtr,"HeeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_WECHATPAY))
				MsgObjPtr = CreateObj(MsgPtr,"WcpMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJP))
				MsgObjPtr = CreateObj(MsgPtr,"XjpMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_NOW2PAY))
				MsgObjPtr = CreateObj(MsgPtr,"NtpMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_AIPWECHAT)) {
				char *csPspKey;
				if (GetField_CString(hContext, "psp_key", &csPspKey))
					PutField_CString(hRequest, "psp_ptk_key_value", csPspKey);
				MsgObjPtr = CreateObj(MsgPtr,"AwcMsg","BuildRspAuthData");
			}
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_N2P_AIPWECHAT))
				MsgObjPtr = CreateObj(MsgPtr,"NtwMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_CHWECHAT))
				MsgObjPtr = CreateObj(MsgPtr,"XjwMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_MOBILE))
				MsgObjPtr = CreateObj(MsgPtr,"XjmMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_JINHAI_QR))
				MsgObjPtr = CreateObj(MsgPtr,"XjqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_DINPAY))
				MsgObjPtr = CreateObj(MsgPtr,"DpyMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_CLOUD123PAY))
				MsgObjPtr = CreateObj(MsgPtr,"CopMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_DINPAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"DpqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJE))
				MsgObjPtr = CreateObj(MsgPtr,"XjeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_STAR_KKPAY_EC))
				MsgObjPtr = CreateObj(MsgPtr,"SkeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_RFPAY_EC))
				MsgObjPtr = CreateObj(MsgPtr,"RfeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_COALAPAY_EC))
				MsgObjPtr = CreateObj(MsgPtr,"CpeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_STAR_KKPAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"SkqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_STAR_KKPAY_VNET))
				MsgObjPtr = CreateObj(MsgPtr,"SkvMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_OPENEPAY))
				MsgObjPtr = CreateObj(MsgPtr,"OppMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_SHANFU_EC))
				MsgObjPtr = CreateObj(MsgPtr,"SfeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_HXPAY_VNET))
				MsgObjPtr = CreateObj(MsgPtr,"HxvMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_HXPAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"HxqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_PAYESCAPE_VNET))
				MsgObjPtr = CreateObj(MsgPtr,"PsvMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_SAMOPAY_EC))
				MsgObjPtr = CreateObj(MsgPtr,"SmeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_RFPAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"RfqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_SHANFU_QR))
				MsgObjPtr = CreateObj(MsgPtr,"SfqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_RFPAY_VNET))
				MsgObjPtr = CreateObj(MsgPtr,"RfvMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_BFBAO_VNET))
				MsgObjPtr = CreateObj(MsgPtr,"BfvMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_OUP_EC))
				MsgObjPtr = CreateObj(MsgPtr,"OupMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_BFBAO_QR))
				MsgObjPtr = CreateObj(MsgPtr,"BfqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_GOLDENPAY_VNET))
				MsgObjPtr = CreateObj(MsgPtr,"GpvMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_C123PAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"CoqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_GOLDENPAY_EC))
				MsgObjPtr = CreateObj(MsgPtr,"GpeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ZPAY_EC))
				MsgObjPtr = CreateObj(MsgPtr,"ZpeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ESKY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"EsqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_NOW3PAY))
				MsgObjPtr = CreateObj(MsgPtr,"NepMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_TTPAY))
				MsgObjPtr = CreateObj(MsgPtr,"TtpMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_TTPAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"TtqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ZPAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"ZpqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_WELLPAY))
				MsgObjPtr = CreateObj(MsgPtr,"WpyMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_DBAO))
				MsgObjPtr = CreateObj(MsgPtr,"XdbMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_SWIFTPAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"SpqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XPAY_VNET))
				MsgObjPtr = CreateObj(MsgPtr,"XpvMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_TRUSTPAY_EC))
				MsgObjPtr = CreateObj(MsgPtr,"TpeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_OUP_OPENEPAY_EC))
				MsgObjPtr = CreateObj(MsgPtr,"OoeMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_DF_QR))
				MsgObjPtr = CreateObj(MsgPtr,"DfqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_DBAO_QR))
				MsgObjPtr = CreateObj(MsgPtr,"XdqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_CH))
				MsgObjPtr = CreateObj(MsgPtr,"XjcMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_CH_QR))
				MsgObjPtr = CreateObj(MsgPtr,"XjrMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_NOW3PAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"NeqMsg","BuildRspAuthData");
			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XPAY_QR))
				MsgObjPtr = CreateObj(MsgPtr,"XpqMsg","BuildRspAuthData");
			else {
DEBUGLOG(("BOSecurity:VerifyPspSign, PSP undefine\n"));
ERRLOG("BOSecurity:VerifyPspSign, PSP undefine\n");
				iRet = PD_ERR;
			}

			if (iRet == PD_OK) {
                		if ((*MsgObjPtr)(hRequest) == PD_OK) {
DEBUGLOG(("BOSecurity::VerifyPspSign BuildData = [%d]\n",PD_OK));
				
                			if (!strcmp(csReturnPspChannel,PD_CHANNEL_ESKY) 
                			   || !strcmp(csReturnPspChannel,PD_CHANNEL_EEP) 
                			   || !strcmp(csReturnPspChannel,PD_CHANNEL_ECPSS) 
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_ECPSSMOBILE) 
                			   || !strcmp(csReturnPspChannel,PD_CHANNEL_SHENGPAY) 
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_PFTTOM)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_EPLUTUS)
					   //|| !strcmp(csReturnPspChannel,PD_CHANNEL_UNIPAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_HNAPAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_BAOFOO)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_TENPAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_TENMOBPAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_REAPAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_HEEPAY)
					   //|| !strcmp(csReturnPspChannel,PD_CHANNEL_EASYPAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_WECHATPAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_NOW2PAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_AIPWECHAT)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_XJ_JINHAI_QR)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_CLOUD123PAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_STAR_KKPAY_EC)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_RFPAY_EC)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_STAR_KKPAY_QR)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_STAR_KKPAY_VNET)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_OPENEPAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_SHANFU_EC)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_SAMOPAY_EC)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_SHANFU_QR)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_PAYESCAPE_VNET)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_BFBAO_VNET)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_BFBAO_QR)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_C123PAY_QR)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_ESKY_QR)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_NOW3PAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_XPAY_VNET)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_OUP_OPENEPAY_EC)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_DF_QR)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_XPAY_QR)
					) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyMD5Sign");
					}
                			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_51EPAY)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_GOLDENPAY_VNET)
					   || !strcmp(csReturnPspChannel,PD_CHANNEL_GOLDENPAY_EC)
					) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","Verify51EpaySign");
					}
                			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_YEEPAY)) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyYeePaySign");
					}
                			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ALLINPAY)) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyAllinPaySign");
					}
                			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_IPAY)) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyIPay88Sign");
					}
                			else if (!strcmp(csReturnPspChannel,PD_CHANNEL_YSEPAY)) {
                        			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyYsePaySign");
					}
					else if (!strcmp(csReturnPspChannel,PD_CHANNEL_XJP) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_CHWECHAT) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_MOBILE) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_XJE) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_RFPAY_QR) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_RFPAY_VNET) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_DBAO) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_DBAO_QR) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_CH) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_XJ_CH_QR)
					) {
						BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyXJSign");
					}
					else if (!strcmp(csReturnPspChannel,PD_CHANNEL_N2P_AIPWECHAT) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_NOW3PAY_QR)
					) {
						BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyNTWSign");
					}
					else if (!strcmp(csReturnPspChannel,PD_CHANNEL_DINPAY) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_DINPAY_QR) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_TTPAY) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_TTPAY_QR) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_WELLPAY)
					) {
						BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyDinPaySign");
					}
					else if (!strcmp(csReturnPspChannel,PD_CHANNEL_COALAPAY_EC)) {
						BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyCPESign");
					}
					else if (!strcmp(csReturnPspChannel,PD_CHANNEL_HXPAY_VNET) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_HXPAY_QR) ||
						!strcmp(csReturnPspChannel,PD_CHANNEL_TRUSTPAY_EC)
					) {
						BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyHXPaySign");
					}
/*
					else if (!strcmp(csReturnPspChannel,PD_CHANNEL_PAYESCAPE_VNET)) {
						BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyPayEscapeSign");
					}
*/
					else if (!strcmp(csReturnPspChannel,PD_CHANNEL_OUP_EC)) {
						BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyOUPSign");
					}

					else if (!strcmp(csReturnPspChannel,PD_CHANNEL_ZPAY_EC)
						|| !strcmp(csReturnPspChannel,PD_CHANNEL_ZPAY_QR)
					) {
						BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifySHA256Sign");
					}
					else if (!strcmp(csReturnPspChannel,PD_CHANNEL_SWIFTPAY_QR)
					) {
						BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifySHA1Sign");
					}

                        		iRet = (unsigned long)(*BOObjPtr)(hContext,hRequest);
				}
			}
			else {
DEBUGLOG(("BOSecurity::VerifyPspSign  BuildRspData Error\n"));
ERRLOG("BOSecurity::VerifyPspSign  BuildRspData Error\n");
				iRet = PD_ERR;
			}
		}
	}

DEBUGLOG(("BOSecurity::VerifyPspSign() iRet = [%d]\n",iRet));
	return iRet;
}
int Encrypt3DESTxnSeq(const char* csTxnSeq, unsigned char* OUT)
{
	int 	iRet = PD_OK;
        unsigned char   csKey[PD_KEY_LEN +1];
	unsigned char	csDATA[PD_EN_TXN_SEQ_LEN +1];
	unsigned char	csOUT[PD_EN_TXN_SEQ_LEN +1];


        Ascii2Hex((char*)csKey,PD_MY_KEY,PD_KEY_LEN *2 );

	sprintf((char*)csOUT,"%ld%ld%ld%ld%ld",random(),random(),random(),random(),random());
	memset(csDATA,0,PD_EN_TXN_SEQ_LEN);
	memcpy(&csDATA[0],csTxnSeq,PD_TXN_SEQ_LEN);
	memcpy(&csDATA[PD_TXN_SEQ_LEN],csOUT,PD_EN_TXN_SEQ_LEN - PD_TXN_SEQ_LEN);
	csDATA[PD_EN_TXN_SEQ_LEN] = '\0';
DEBUGLOG(("Encrypt3DESTxnSeq() data=[%s]\n",csDATA));

	csOUT[0]= '\0';
	myECBdes3_encrypt(csKey, csDATA,PD_EN_TXN_SEQ_LEN ,csOUT);

        Hex2Ascii((char*)OUT,csOUT,PD_EN_TXN_SEQ_LEN / 2 );
DEBUGLOG(("Encrypt3DESTxnSeq() Hex2Ascii = [%s][%d]\n",OUT,strlen((char*)OUT)));
	return iRet;
}

int Decrypt3DESTxnSeq(const char* csEnTxnSeq, unsigned char* OUT)
{
        int     iRet = PD_OK;
        unsigned char   csKey[PD_KEY_LEN +1];
        unsigned char   csDATA[PD_EN_TXN_SEQ_LEN +1];
        unsigned char   csEnDATA[PD_EN_TXN_SEQ_LEN/2 +1];


DEBUGLOG(("Decrypt3DESTxnSeq() encrypted txn seq = [%s]\n",csEnTxnSeq));
        Ascii2Hex((char*)csKey,PD_MY_KEY,PD_KEY_LEN *2 );
        Ascii2Hex((char*)csEnDATA,(char*)csEnTxnSeq,PD_EN_TXN_SEQ_LEN *2 );

        myECBdes3_decrypt(csKey, csEnDATA,PD_EN_TXN_SEQ_LEN ,csDATA);
	csDATA[PD_TXN_SEQ_LEN] = '\0';

DEBUGLOG(("Decrypt3DESTxnSeq() DATA = [%s][%d]\n",csDATA,strlen((char*)csDATA)));
	memcpy(OUT,csDATA,PD_TXN_SEQ_LEN);
	OUT[PD_TXN_SEQ_LEN] = '\0';
        return iRet;

}

int GenerateYeePaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;
	char	*csKey;

DEBUGLOG(("BOSecurity:GenerateYeePaySign()\n"));
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);

        csBuf[0]='\0';
        csOUT[0]='\0';

/* auth_data */
        if (GetField_CString(hOut,"auth_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateYeePaySign() auth_data= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateYeePaySign() auth_key= [%s]\n",csKey));
        }
DEBUGLOG(("BOSecurity:GenerateYeePaySign() sign_data= [%s]\n",csBuf));
        
        hmac_md5((unsigned char*)csBuf,strlen(csBuf),(unsigned char*)csKey,strlen(csKey),(unsigned char*)csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateYeePaySign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateYeePaySign() sign             = [%s]\n",csBuf));
        PutField_CString(hOut,"sign",csBuf);

        
        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateYeePaySign() iRet = [%d]\n",iRet));

        
        return iRet;
}

int VerifyYeePaySign(hash_t *hContext,
                const hash_t* hRequest)
{
	int	iRet = PD_OK;
	char	*csAuthData;
	char	*csClearSig;
	char	*csKey;
        char    *csBuf,*csOUT;
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);
DEBUGLOG(("BOSecurity:VerifyYeePaySign()\n"));

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:VerifyYeePaySign() auth_data= [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("BOSecurity:VerifyYeePaySign() sign= [%s]\n",csClearSig));
        }

/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyYeePaySign() auth_key= [%s]\n",csKey));
        }

        hmac_md5((unsigned char*)csAuthData,strlen(csAuthData),(unsigned char*)csKey,strlen(csKey),(unsigned char*)csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);

DEBUGLOG(("BOSecurity:VerifyYeePaySign 	msg sign = [%s]\n",csClearSig));
DEBUGLOG(("BOSecurity:VerifyYeePaySign 	    sign = [%s]\n",csBuf));
/* verify sign */
	if (memcmp(csClearSig,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify YeePay sign error\n");
DEBUGLOG(("BOSecurity:verify YeePay sign error\n"));
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csBuf);
	FREE_ME(csOUT);

	return iRet;
}


int Generate51EpaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csAuthData;
	char	csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char	*csRsaPem;
	char	*csPassPhrase;
	char	*csBuf;
	unsigned char 	csSignData[PD_TMP_MSG_BUF_LEN];
	unsigned int	iLen = 0;

DEBUGLOG(("BOSecurity:Generate51EpaySignign()\n"));

/* auth_data */
        if (GetField_CString(hOut,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:Generate51EpaySign() auth_data= [%s]\n",csAuthData));
        }
/* rsapem */
	if (GetField_CString(hContext,"psp_privatepem",&csRsaPem)) {
DEBUGLOG(("Generate51EpaySign privatepem = [%s]\n",csRsaPem));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("Generate51EpaySign privatepempath = [%s]\n",csRsaPemPath));
	}
	else {
		iRet = INT_ERR;
	}
/* passphrase */
	if (GetField_CString(hContext,"psp_passphrase",&csPassPhrase)) {
DEBUGLOG(("Generate51EpaySign PassPhrase = [%s]\n",csPassPhrase));
	}
	else {
		iRet = INT_ERR;
	}

	if (iRet == PD_OK) {
		sha1rsa_sign(csRsaPemPath,csPassPhrase,csAuthData, csSignData, &iLen);
        
        	csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN);
        	csBuf[0]='\0';
		base64_encode(csSignData,iLen,csBuf,PD_MAX_BUFFER);
DEBUGLOG(("BOSecurity:Generate51EPaySign() sign             = [%s]\n",csBuf));
       		PutField_CString(hOut,"sign",csBuf);
        
        	FREE_ME(csBuf);
	}
DEBUGLOG(("BOSecurity:Generate51EpaySign() iRet = [%d]\n",iRet));

        
        return iRet;
}

int Verify51EpaySign(hash_t *hContext,
                const hash_t* hRequest)
{
	int	iRet = PD_OK;
	char	csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char	*csRsaPem;
	char	*csAuthData;
	char	*csClearSig;
	unsigned char	*csSig;
	int	iSigLen;
DEBUGLOG(("BOSecurity:Verify51EpaySign()\n"));

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign() auth_data= [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign() sign= [%s]\n",csClearSig));
        }

/* publiccert */
	if (GetField_CString(hContext,"psp_publiccert",&csRsaPem)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccert = [%s]\n",csRsaPem));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccertpath = [%s]\n",csRsaPemPath));
	}
	else {
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccert is missing!!!\n"));
		iRet = INT_ERR;
	}

	

        if (iRet == PD_OK) {
DEBUGLOG(("BOSecurity:try to verify [%s]\n",csClearSig));
		csSig = (unsigned char*) malloc (PD_MAX_BUFFER);
		iSigLen = base64_decode(csClearSig,csSig,PD_MAX_BUFFER);
DEBUGLOG(("BOSecurity:try to verify sig date len = [%d]\n",iSigLen));
		iRet = sha1rsa_verify(csRsaPemPath,csAuthData,csSig,iSigLen);
		FREE_ME(csSig);
        }
DEBUGLOG(("BOSecurity:Verify51EpaySign() iRet = [%d]\n",iRet));



	return iRet;
}

int VerifyHaiPaySign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char	*csBuf,*csOUT;
	char	*csPtr;
	char	*csSign = strdup("");
	
DEBUGLOG(("BOSecurity:VerifyHaiPaySign()\n"));
	csBuf = (char*) malloc (1024 * 2 +1);
	csOUT = (char*) malloc (1024 * 2 +1);

	csBuf[0]='\0';
	csOUT[0]='\0';
/* merchant_id */
	if (GetField_CString(hRequest,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() merchant_id= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* APIVersion */
	if (GetField_CString(hRequest,"APIVersion",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() APIVersion= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}

/* encrypt_type */
	if (GetField_CString(hRequest,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() encrypt_type= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* plainttext_data */
	if (GetField_CString(hRequest,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() plainttext_data= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
		strcat(csBuf,MY_FIELD_TOKEN);
	}
/* psp_key */
	if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() psp_key= [%s]\n",csPtr));
		strcat(csBuf,csPtr);
	}
	else {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() psp_key is missing!!!\n"));
	}
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() verify_data= [%s]\n",csBuf));

	md5sum(csBuf,strlen(csBuf),csOUT);
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() sign             = [%s]\n",csOUT));
	csBuf[0] = '\0';
	U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() sign             = [%s]\n",csBuf));


	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() sign from Request= [%s]\n",csSign));
	}

	else {
errlog("BOSecurity:VerifyHaiPaySign sign not found\n");
DEBUGLOG(("BOSecurity:VerifyHaiPaySign sign not found\n"));
		iRet = INT_SIGN_DATA_NOT_FOUND;
		PutField_Int(hContext,"internal_error",iRet);
	}
/* verify sign */
	if (memcmp(csSign,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:VerifyHaiPaySign() iRet = [%d]\n",iRet));

	
	return iRet;
}


int GenerateHaiPaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;

DEBUGLOG(("BOSecurity:GenerateHaiPaySign()\n"));
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);

        csBuf[0]='\0';
        csOUT[0]='\0';
/* merchant_id */
        if (GetField_CString(hOut,"merchant_id",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() merchant_id= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }

/* encrypt_type */
        if (GetField_CString(hOut,"encrypt_type",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() encrypt_type= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* plainttext_data */
        if (GetField_CString(hOut,"plainttext_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() plainttext_data= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
                strcat(csBuf,MY_FIELD_TOKEN);
        }
/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() psp_key= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() sign_data= [%s]\n",csBuf));

        md5sum(csBuf,strlen(csBuf),csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() sign             = [%s]\n",csBuf));
	PutField_CString(hOut,"sign",csBuf);


        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateHaiPaySign() iRet = [%d]\n",iRet));


        return iRet;
}



int VerifyAllinPaySign(hash_t *hContext,
                const hash_t* hRequest)
{
DEBUGLOG(("BOSecurity:VerifyAllinPaySign()\n"));
	return Verify51EpaySign(hContext,hRequest);
}

int VerifyAllinPaySignTest(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
        char    csRsaPemPath[PD_MAX_FILE_LEN + 1];
        char    *csRsaPem;
        char    *csAuthData;
        char    *csClearSig;
        unsigned char   *csSig;
        int     iSigLen;
DEBUGLOG(("BOSecurity:Verify51EpaySign()\n"));

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign() auth_data= [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign() sign= [%s]\n",csClearSig));
        }

/* publiccert */
        if (GetField_CString(hContext,"psp_publiccert",&csRsaPem)) {
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccert = [%s]\n",csRsaPem));
                sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccertpath = [%s]\n",csRsaPemPath));
        }
        else {
DEBUGLOG(("BOSecurity:Verify51EpaySign publiccert is missing!!!\n"));
                iRet = INT_ERR;
        }



        if (iRet == PD_OK) {
DEBUGLOG(("BOSecurity:try to verify [%s]\n",csClearSig));
                csSig = (unsigned char*) malloc (PD_MAX_BUFFER);
                iSigLen = base64_decode(csClearSig,csSig,PD_MAX_BUFFER);

/****** test */
/*
		char	csData[] = "merchantId=100020091218001&version=v1.0&language=1&signType=1&payType=1&paymentOrderId=20120220182422478&orderNo=0000000000224383&orderDatetime=20120220182520&orderAmount=1000&payDatetime=20120220182422&payAmount=1000&payResult=1&returnDatetime=20120220182425";
		char	csSigData[] = "BryjqMQqJjJflMzqIi8d1dk2uKjG5Tk5bpNI1/IQ2FITExjiJqppPwtZFm8TVkSx88AOMNLwDDaOpz/B9Z0GAOEv08kca0cvv/jr6qeuaSDjSEci4bh3BxCGaeInZ1P9wAtAXMxS+ihSS8LHdWFEsBkd+7P/w9TAbHAbM0+wbVE=";
		
                iSigLen = base64_decode(csSigData,csSig,PD_MAX_BUFFER);
		csAuthData = strdup(csData);
DEBUGLOG(("BOSecurity:Verify51EpaySign() ****auth_data= [%s]\n",csAuthData));
DEBUGLOG(("BOSecurity:Verify51EpaySign() ****sign= [%s]\n",csSigData));
*/
/*******************************************/
DEBUGLOG(("BOSecurity:try to verify sig date len = [%d]\n",iSigLen));
                iRet = sha1rsa_verify(csRsaPemPath,csAuthData,csSig,iSigLen);
                FREE_ME(csSig);
        }
DEBUGLOG(("BOSecurity:Verify51EpaySign() iRet = [%d]\n",iRet));



        return iRet;
}



int GenerateMMSMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
        int     iRet = PD_OK;
        char    *csEncType;
        char    *csKey;
        char    *csMac;
        char    *csData;
	
DEBUGLOG(("BOSecurity:GenerateMMSMac()\n"));

        if (GetField_CString(hResponse,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:GenerateMMSMac encrypt_type = [%s]\n",csEncType));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMMSMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMMSMac encrypt_type is missing!!!\n");
                iRet = INT_ERR;
        }
        if (GetField_CString(hResponse,"mms_key",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateMMSMac mms_key = [%s]\n",csKey));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMMSMac mms_key is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMMSMac mms_key is missing!!!\n");
                iRet = INT_ERR;
        }


        if (GetField_CString(hResponse,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateMMSMac auth_data = [%s]\n",csData));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateMMSMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:GenerateMMSMac auth_data is missing!!!\n");
                iRet = INT_ERR;
        }

        if (iRet == PD_OK) {
        	csMac = (char*) malloc (PD_TMP_MSG_BUF_LEN  +1);
                if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                        iRet = GenerateMD5Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                        iRet = GenerateSHA1Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else {
DEBUGLOG(("BOSecurity:GenerateMMSMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:GenerateMMSMac unsupported encrypt type [%s]\n",csEncType);
                }
		if (iRet == PD_OK) 
			PutField_CString(hResponse,"mac",csMac);
		FREE_ME(csMac);
        }
        if (iRet != PD_OK)
                PutField_Int(hContext,"internal_error",iRet);



DEBUGLOG(("BOSecurity:GenerateMMSMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int VerifyMMSMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
	int	iRet = PD_OK;
	char	*csEncType;
	char	*csKey;
	char	*csMac;
	char	*csData;

DEBUGLOG(("BOSecurity:VerifyMMSMac()\n"));

	if (GetField_CString(hRequest,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:VerifyMMSMac encrypt_type = [%s]\n",csEncType));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMMSMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMMSMac encrypt_type is missing!!!\n");
		iRet = INT_ERR;
	}


	if (GetField_CString(hRequest,"mac",&csMac) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMMSMac mac = [%s]\n",csMac));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMMSMac mac is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMMSMac mac is missing!!!\n");
		iRet = INT_MAC_NOT_FOUND;
	}
	
	if (GetField_CString(hRequest,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyMMSMac auth_data = [%s]\n",csData));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyMMSMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMMSMac auth_data is missing!!!\n");
		iRet = INT_ERR;
	}

        if (GetField_CString(hContext,"mms_key",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyMMSMac mms_key = [%s]\n",csKey));
        }
        else {
DEBUGLOG(("BOSecurity:VerifyMMSMac mms_key is missing!!!\n"));
ERRLOG("BOSecurity:VerifyMMSMac mms_key is missing!!!\n");
                iRet = INT_ERR;
        }

	if (iRet == PD_OK) {
		if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
			iRet = VerifyMD5Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
			iRet = VerifySHA1Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else {
DEBUGLOG(("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:VerifyMac unsupported encrypt type [%s]\n",csEncType);
			iRet = INT_UNSUPPORTED_ENC_TYPE;
		}
	}

DEBUGLOG(("BOSecurity:VerifyMMSMac iRet = [%d]\n",iRet));

DEBUGLOG(("BOSecurity:VerifMMSyMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int GeneratePspSignINQ(hash_t *hContext,
                        hash_t *hRequest,
                        hash_t *hResponse)
{
	int	iRet = PD_OK;
	char* 	csPspChannel;
	char*	csPtr;
DEBUGLOG(("BOSecurity::GenreatePspSignINQ()\n"));

	if (!GetField_CString(hContext,"psp_channel_code",&csPspChannel)) {	
DEBUGLOG(("BOSecurity::GenreatePspSignINQ psp_channel_code is missing!!!\n"));
ERRLOG("BOSecurity::GenreatePspSignINQ psp_channel_code is missing!!!\n");
		iRet = PD_ERR;
	}
	else {
DEBUGLOG(("BOSecurity::GenreatePspSignINQ psp_channel_code = [%s]\n",csPspChannel));
	}

	if (iRet == PD_OK) {
		if (!strcmp(csPspChannel,PD_CHANNEL_ALLINPAY))
			MsgObjPtr = CreateObj(MsgPtr,"AlpMsg","BuildInqAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_TENMOBPAY))
			MsgObjPtr = CreateObj(MsgPtr,"TpmMsg","BuildInqAuthData");
		else if (!strcmp(csPspChannel,PD_CHANNEL_REAPAY))
			MsgObjPtr = CreateObj(MsgPtr,"RpyMsg","BuildInqAuthData");
//do nothing
		else {
DEBUGLOG(("BOSecurity::GeneratePspSignINQ PSP undefine\n"));
ERRLOG("BOSecurity::GeneratePspSignINQ PSP undefine\n");
			return iRet;
		}

		if ((*MsgObjPtr)(hRequest) == PD_OK) {
DEBUGLOG(("BOSecurity::GenereatePspSignINQ BuildData = [%d]\n",PD_OK));
            		hash_t  *hCon;
                        char*   csTmp;
                        hCon = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(hCon,0);

/* put psp_channel_code */
			PutField_CString(hCon,"psp_channel_code",csPspChannel);
                        if (GetField_CString(hContext,"psp_merchant_id",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSignINQ psp_merchant_id = [%s]\n",csTmp));
                       		PutField_CString(hResponse,"merchant_id",csTmp);
                        }
                        if (GetField_CString(hContext,"psp_key",&csTmp)) {
DEBUGLOG(("BOSecurity::GenereatePspSignINQ psp_key = [%s]\n",csTmp));
                        	PutField_CString(hCon,"psp_key",csTmp);
                        }

			if (!strcmp(csPspChannel,PD_CHANNEL_ESKY) || !strcmp(csPspChannel,PD_CHANNEL_EEP)
				|| !strcmp(csPspChannel,PD_CHANNEL_ALLINPAY) 
				|| !strcmp(csPspChannel,PD_CHANNEL_TENMOBPAY) 
				|| !strcmp(csPspChannel,PD_CHANNEL_REAPAY) 
 				|| !strcmp(csPspChannel,PD_CHANNEL_SHENGPAY)) {
               			BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateMD5Sign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_HPAY) || !strcmp(csPspChannel,PD_CHANNEL_LKPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_GOPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HHPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HAIPAY)
                		|| !strcmp(csPspChannel,PD_CHANNEL_HPAY_CNP)) {
                              	PutField_CString(hResponse,"encrypt_type","01");
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateHaiPaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_YEEPAY)) {
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateYeePaySign");
			}
			else if (!strcmp(csPspChannel,PD_CHANNEL_51EPAY)) {
				if (GetField_CString(hContext,"psp_privatepem",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSignINQ() psp_privatepem = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_privatepem",csPtr);
				}
				if (GetField_CString(hContext,"psp_passphrase",&csPtr)) {
DEBUGLOG(("BOSecurity::GeneratePspSignINQ() psp_passphrase = [%s]\n",csPtr));
					PutField_CString(hCon,"psp_passphrase",csPtr);
				}
                               	BOObjPtr = CreateObj(BOPtr,"BOSecurity","Generate51EpaySign");
			}
                        iRet = (unsigned long)(*BOObjPtr)(hCon,hRequest);
                        FREE_ME(hCon);
            	}
	
	}
DEBUGLOG(("BOSecurity::GenereatePspSignINQ() iRet = [%d]\n",iRet));
	return iRet;
}


int GenerateIPay88Sign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;
	char	*csKey;

DEBUGLOG(("BOSecurity:GenerateIPay88Sign()\n"));
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);

        csBuf[0]='\0';
        csOUT[0]='\0';

/* auth_data */
        if (GetField_CString(hOut,"auth_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateIPay88Sign() auth_data= [%s]\n",csPtr));
                //strcat(csBuf,csPtr);
        }
/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateIPay88Sign() auth_key= [%s]\n",csKey));
        }
        
        strcat((char*)csBuf,(char*)csKey);
        strcat((char*)csBuf,(char*)csPtr);
DEBUGLOG(("BOSecurity:GenerateIPay88Sign() sign_data= [%s]\n",csBuf));

        sha1sum((const char*)csBuf,strlen((char*)csBuf),csOUT);
DEBUGLOG(("BOSecurity:GenerateIPay88Sign() sign             = [%s]\n",csOUT));
/* U2L is not required for iPay */
	csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
	int iLen = strlen(csBuf);
	csOUT[0] = '\0';
	Ascii2Hex(csOUT,csBuf,iLen);
        base64_encode((unsigned char*)csOUT,iLen/2,csBuf,PD_MAX_BUFFER);
        PutField_CString(hOut,"sign",csBuf);
DEBUGLOG(("BOSecurity:GenerateIPay88Sign() sign             = [%s]\n",csBuf));

        //PutField_CString(hOut,"sign","2LNGbGOS6o/gPNhRdV+2+peojng=");
//DEBUGLOG(("BOSecurity:GenerateIPay88Sign() test sign ********** = [2LNGbGOS6o/gPNhRdV+2+peojng=]\n"));
        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateIPay88Sign() iRet = [%d]\n",iRet));

        return iRet;
}

int VerifyIPay88Sign(hash_t *hContext,
                const hash_t* hRequest)
{
	int	iRet = PD_OK;
	char	*csAuthData;
	char	*csClearSig;
	char	*csKey;
        char    *csBuf,*csOUT;
        csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
        csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
DEBUGLOG(("BOSecurity:VerifyIPay88Sign()\n"));

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:VerifyIPay88Sign() auth_data= [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("BOSecurity:VerifyIPay88Sign() sign= [%s]\n",csClearSig));
        }

/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyIPay88Sign() auth_key= [%s]\n",csKey));
        }

        strcat(csBuf,(char*)csKey);
        strcat(csBuf,(char*)csAuthData);
DEBUGLOG(("BOSecurity:VerifyIPay88Sign() sign_data= [%s]\n",csBuf));

        sha1sum((const char*)csBuf,strlen((char*)csBuf),csOUT);
	csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
	int iLen = strlen(csBuf);
        csOUT[0] = '\0';
        Ascii2Hex(csOUT,csBuf,iLen);
        base64_encode((unsigned char*)csOUT,iLen/2,csBuf,PD_MAX_BUFFER);
DEBUGLOG(("BOSecurity:VerifyIPay88Sign() sign             = [%s]\n",csBuf));


DEBUGLOG(("BOSecurity:VerifyIPay88Sign() mac in msg       = [%s]\n",csClearSig));

/* verify sign */
	if (memcmp(csClearSig,csOUT,PD_SHA1_SUM_LEN) != 0) {
errlog("BOSecurity:VerifyIPay88Sign error\n");
DEBUGLOG(("BOSecurity:VerifyIPay88Sign error\n"));
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csBuf);
	FREE_ME(csOUT);

DEBUGLOG(("BOSecurity:VerifyIPay88Sign iRet = [%d]\n",iRet));
	return iRet;
}

int DesEncryptECB(const char* csInData, const char* csPspId, char* csOut)
{
	int iRet = PD_OK;
	int iLen = 0;
	hash_t  *hKey;
	char*	csKey;

	recordset_t     *rKeySet;
        rKeySet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rKeySet,0);

DEBUGLOG(("BOSecurity::DesEncrypt DATA = [%s]\n",csInData));
DEBUGLOG(("BOSecurity::DesEncrypt PID = [%s]\n",csPspId));
	DBObjPtr = CreateObj(DBPtr,"DBPspKeys","GetPspKey");
        if (!(*DBObjPtr)(csPspId,PD_DES_KEY_NAME,rKeySet)) {
        	hKey = RecordSet_GetFirst(rKeySet);
                if (hKey){
               		if (GetField_CString(hKey,"key_value",&csKey)) {
DEBUGLOG(("BOSecurity: DesEncrypt - psp_key = [%s]\n",csKey));
                       	}
                }
                else{
ERRLOG("BOSecurity: DesEncrypt - no psp_key for [%s]\n",csPspId);
DEBUGLOG(("BOSecurity: DesEncrypt - no psp_key for [%s]\n",csPspId));
			iRet = PD_ERR;
                }
	}
	else 
		iRet = PD_ERR;

	if (iRet == PD_OK) {
		char* csBuf;
		char* csTmpBuf;
        	csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN);
        	csTmpBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN);
		memset(csBuf,0,sizeof(csBuf));
		memset(csTmpBuf,0x00,sizeof(csTmpBuf));
		memset(csOut,0,sizeof(csOut));
		iLen = strlen(csInData);
        	if (iLen % 8 != 0 )  {
                	iLen = (8  - (iLen % 8)) + iLen;
        	}
		memcpy(csTmpBuf,csInData,strlen(csInData));
DEBUGLOG(("csTmpBuf = [%s][%d]\n",csTmpBuf,iLen));
DEBUGLOG(("KEY = [%s][%d]\n",csKey,strlen((const char*)csKey)));
        	myECBdes3_encrypt_new((const unsigned char*)csKey,strlen((const char*)csKey),(const unsigned char*)csTmpBuf,iLen,(unsigned char*)csBuf);
		base64_encode((unsigned char*)csBuf,iLen,csOut,PD_MAX_BUFFER);
DEBUGLOG(("BOSecurity:: encrypt data = [%s]\n",csOut));

		FREE_ME(csBuf);
		FREE_ME(csTmpBuf);
	}
	RecordSet_Destroy(rKeySet);
        FREE_ME(rKeySet);	

DEBUGLOG(("BOSecurity:: exit iRet = [%d]\n",iRet));
	return iRet;
}

int VerifyNetworkMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
	int	iRet = PD_OK;
	char	*csEncType;
	char	*csKeyId;
	char	*csKey;
	char	*csMac;
	char	*csData;
	char	*csKeyName;
	hash_t	*hRec;
	recordset_t     *rRecordSet;
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

DEBUGLOG(("BOSecurity:VerifyNetworkMac()\n"));

	if (GetField_CString(hRequest,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:VerifyNetworkMac encrypt_type = [%s]\n",csEncType));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyNetworkMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:VerifyNetworkMac encrypt_type is missing!!!\n");
		iRet = INT_ERR;
	}

	if (GetField_CString(hRequest,"key_id",&csKeyId) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyNetworkMac key_id = [%s]\n",csKeyId));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyNetworkMac key_id is missing!!!\n"));
		iRet = INT_MERCHANT_ID_NOT_FOUND;
	}

	if (GetField_CString(hRequest,"mac",&csMac) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyNetworkMac mac = [%s]\n",csMac));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyNetworkMac mac is missing!!!\n"));
ERRLOG("BOSecurity:VerifyNetworkMac mac is missing!!!\n");
		iRet = INT_MAC_NOT_FOUND;
	}
	
	if (GetField_CString(hRequest,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:VerifyNetworkMac auth_data = [%s]\n",csData));
	}
	else {
DEBUGLOG(("BOSecurity:VerifyNetworkMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:VerifyNetworkMac auth_data is missing!!!\n");
		iRet = INT_ERR;
	}
        csKeyName = (char*) malloc (PD_TMP_BUF_LEN +1);
	if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
		strcpy(csKeyName,PD_PTK_KEY_NAME);
	}
	else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
		strcpy(csKeyName,PD_SHA1_KEY_NAME);
	}

DEBUGLOG(("BOSecurity:VerifyNetworkMac keyname = [%s]\n",csKeyName));
	if (iRet == PD_OK ) {
                DBObjPtr = CreateObj(DBPtr,"DBClientKeys","GetClientKey");
                if ((*DBObjPtr)(csKeyId,csKeyName,rRecordSet) != PD_OK) {
                        iRet = INT_ERR;
ERRLOG("BOSecurity:VerifyNetworkMac: Key for Client[%s] not found\n",csKeyId);
DEBUGLOG(("BOSecurity:VerifyNetworkMac key for Client[%s] not found\n",csKeyId));
                }
                else{
                        iRet = INT_ERR;
                        hRec = RecordSet_GetFirst(rRecordSet);
                        while(hRec){
                                if (GetField_CString(hRec,"key_value",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyNetworkMac GetMerchantKey - merchant_key_value = [%s]\n",csKey));
                                        iRet = PD_OK;
                                }
                                hRec = RecordSet_GetNext(rRecordSet);
                        }
                }
        }
	if (iRet == PD_OK) {
		if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
			iRet = VerifyMD5Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
			iRet = VerifySHA1Mac((const unsigned char*)csMac,(const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData));
		}
		else {
DEBUGLOG(("BOSecurity:VerifyNetworkMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:VerifyNetworkMac unsupported encrypt type [%s]\n",csEncType);
			iRet = INT_UNSUPPORTED_ENC_TYPE;
		}
	}

DEBUGLOG(("BOSecurity:VerifyNetworkMac iRet = [%d]\n",iRet));
	RecordSet_Destroy(rRecordSet);
        FREE_ME(rRecordSet);
	FREE_ME(csKeyName);

DEBUGLOG(("BOSecurity:VerifyNetworkMac exit iRet = [%d]\n",iRet));
	return iRet;
}

int GenerateNetworkMac(hash_t* hContext,
	      const hash_t* hRequest,
	      hash_t* hResponse)
{
        int     iRet = PD_OK;
        char    *csEncType;
        char    *csKeyId;
        char    *csKey;
        char    *csMac;
        char    *csData;
	char	*csKeyName;
	
        hash_t  *hRec;
        recordset_t     *rRecordSet;
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
        recordset_init(rRecordSet,0);

DEBUGLOG(("BOSecurity:GenerateNetworkMac()\n"));

        if (GetField_CString(hResponse,"encrypt_type",&csEncType)) {
DEBUGLOG(("BOSecurity:GenerateNetworkMac encrypt_type = [%s]\n",csEncType));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateNetworkMac encrypt_type is missing!!!\n"));
ERRLOG("BOSecurity:GenerateNetworkMac encrypt_type is missing!!!\n");
                iRet = INT_ERR;
        }

        if (GetField_CString(hResponse,"key_id",&csKeyId) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateNetworkMac key_id = [%s]\n",csKeyId));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateNetworkMac key_id is missing!!!\n"));
                iRet = INT_MERCHANT_ID_NOT_FOUND;
        }


        if (GetField_CString(hResponse,"auth_data",&csData) && (iRet == PD_OK)) {
DEBUGLOG(("BOSecurity:GenerateNetworkMac auth_data = [%s]\n",csData));
        }
        else {
DEBUGLOG(("BOSecurity:GenerateNetworkMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:GenerateNetworkMac auth_data is missing!!!\n");
                iRet = INT_ERR;
        }

	csKeyName = (char*) malloc (PD_TMP_BUF_LEN +1);
        if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                strcpy(csKeyName,PD_PTK_KEY_NAME);
        }
        else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                strcpy(csKeyName,PD_SHA1_KEY_NAME);
        }

        if (iRet == PD_OK ) {
                DBObjPtr = CreateObj(DBPtr,"DBClientKeys","GetClientKey");
                if ((*DBObjPtr)(csKeyId,csKeyName,rRecordSet) != PD_OK) {
                        iRet = INT_ERR;
ERRLOG("BOSecurity:GenerateNetworkMac: Key for Client[%s] not found\n",csKeyId);
DEBUGLOG(("BOSecurity:GeneratNetworkeMac key for Client[%s] not found\n",csKeyId));
                }
                else{
                        iRet = INT_ERR;
                        hRec = RecordSet_GetFirst(rRecordSet);
                        while(hRec){
                                if (GetField_CString(hRec,"key_value",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateNetworkMac GetClientKey - client_key_value = [%s]\n",csKey));
                                        iRet = PD_OK;
                                }
                                hRec = RecordSet_GetNext(rRecordSet);
                        }
                }
	}
        if (iRet == PD_OK) {
        	csMac = (char*) malloc (PD_TMP_MSG_BUF_LEN  +1);
                if (!strcmp(csEncType,PD_ENC_TYPE_MD5)) {
                        iRet = GenerateMD5Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else if (!strcmp(csEncType,PD_ENC_TYPE_SHA1)) {
                        iRet = GenerateSHA1Mac((const unsigned char*)csKey,(const unsigned char*)csData,strlen(csData),(unsigned char*)csMac);
                }
                else {
DEBUGLOG(("BOSecurity:GenerateNetworkMac unsupported encrypt type [%s]\n",csEncType));
ERRLOG("BOSecurity:GenerateNetworkMac unsupported encrypt type [%s]\n",csEncType);
                }
		if (iRet == PD_OK) 
			PutField_CString(hResponse,"mac",csMac);
		FREE_ME(csMac);
        }
        if (iRet != PD_OK)
                PutField_Int(hContext,"internal_error",iRet);

        RecordSet_Destroy(rRecordSet);
        FREE_ME(rRecordSet);

	FREE_ME(csKeyName);

DEBUGLOG(("BOSecurity:GenerateNetworkMac exit iRet = [%d]\n",iRet));
	return iRet;
}




int VerifyYeePayMobileSign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char	*csData;
	char	*csPtr;
	char	*csSign;
	char    csRsaPemPath[PD_MAX_FILE_LEN + 1];
	
DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign()\n"));

/* plainttext_data */
	if (GetField_CString(hRequest,"plainttext_data",&csData)) {
DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign() plainttext_data= [%s]\n",csData));
	}

/*sign*/
	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign() sign from Request= [%s]\n",csSign));
	}
	else {
ERRLOG("BOSecurity:VerifyYeePayMobileSign sign not found\n");
DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign sign not found\n"));
		iRet = INT_SIGN_DATA_NOT_FOUND;
		PutField_Int(hContext,"internal_error",iRet);
	}

/* psp_key file*/
	if (GetField_CString(hRequest,"psp_key_file",&csPtr)) {
DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign() psp_key_file = [%s]\n",csPtr));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csPtr);
DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign() key_path = [%s]\n",csRsaPemPath));

		FILE    *fKey;
		fKey = fopen(csRsaPemPath,"r");
		if (fKey == NULL) {
			iRet = INT_ERR;
DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign() cannot open key file[%s]\n",csRsaPemPath));
ERRLOG("BOSecurity:VerifyYeePayMobileSign() cannot open key file[%s]\n",csRsaPemPath);
		}
		else{
			iRet = MyRsa_Verify(fKey, csData, strlen(csData),csSign);
			//iRet = sha1rsa_verify(csRsaPemPath,csData,(const unsigned char*)csSign, strlen(csSign));
			if(iRet!=PD_OK){
DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign() verify sign error [%d]\n",iRet));
				iRet = INT_MAC_ERR;
				PutField_Int(hContext,"internal_error",iRet);
ERRLOG("BOSecurity:VerifyYeePayMobileSign() verify sign error\n");
			}
			
		}
		fclose(fKey);
	}
	else {
		iRet = INT_ERR;
DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign() psp_key_file is missing!!!\n"));
	}

DEBUGLOG(("BOSecurity:VerifyYeePayMobileSign() iRet = [%d]\n",iRet));

	
	return iRet;
}


int GenerateYeePayMobileSign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
	char	csOUT[PD_TMP_MSG_BUF_LEN];
        char    *csPtr;
        char    *csData;
	char    csRsaPemPath[PD_MAX_FILE_LEN + 1];

DEBUGLOG(("BOSecurity:GenerateYeePayMobileSign()\n"));
        csOUT[0]='\0';

/* plainttext_data */
        if (GetField_CString(hOut,"plainttext_data",&csData)) {
DEBUGLOG(("BOSecurity:GenerateYeePayMobileSign() plainttext_data= [%s]\n",csData));
        }

/* psp_privatepem */
        if (GetField_CString(hContext,"psp_privatepem",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateYeePayMobileSign() psp_privatepem = [%s]\n",csPtr));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csPtr);
DEBUGLOG(("BOSecurity:GenerateYeePayMobileSign() key_path = [%s]\n",csRsaPemPath));

		FILE    *fKey;
		fKey = fopen(csRsaPemPath,"r");
		if (fKey == NULL) {
			iRet = INT_ERR;
DEBUGLOG(("BOSecurity:GenerateYeePayMobileSign() cannot open key file[%s]\n",csRsaPemPath));
ERRLOG("BOSecurity:GenerateYeePayMobileSign() cannot open key file[%s]\n",csRsaPemPath);
		}
		else{
			iRet = MyRsa_Sign(fKey, csData, csOUT);
			if(iRet == PD_OK){
				csOUT[strlen(csOUT)] = '\0';
				PutField_CString(hOut,"sign",csOUT);
DEBUGLOG(("BOSecurity:GenerateYeePayMobileSign() sign             = [%s]\n",csOUT));
			}
		}
		fclose(fKey);
        }

DEBUGLOG(("BOSecurity:GenerateYeePayMobileSign() iRet = [%d]\n",iRet));
        return iRet;
}


int RSAEncryptData(unsigned char* KEYFILE,unsigned char* DATA,unsigned char* OUT, const int isPrivate, const int isEncrype)
{
	int	iRet = PD_OK;
	unsigned int	iEncryptLen = 0;
	int	iLen = 0;
	char    csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char    csBuf[PD_MAX_BUFFER +1];
	unsigned char *KEY;
	KEY = (unsigned char*) malloc (PD_MAX_BUFFER);
	memset(KEY,0,sizeof(KEY));

	unsigned char *TmpDATA;
	TmpDATA = (unsigned char*) malloc (PD_MAX_BUFFER);
	memset(TmpDATA,0,sizeof(TmpDATA));

	unsigned char *TmpOUT;
	TmpOUT = (unsigned char*) malloc (PD_MAX_BUFFER);
	memset(TmpOUT,0,sizeof(TmpOUT));

DEBUGLOG(("RSAEncryptData Start\n"));

	if(!isEncrype){
		iLen = base64_decode((char *)DATA,(unsigned char*)TmpDATA,PD_MAX_BUFFER);
		if(iLen<=0){
			iRet = INT_ERR;
DEBUGLOG(("RSAEncryptData() cannot base64_decode[%s] Failed!!!\n",DATA));
ERRLOG("BOSecurity:RSAEncryptData() cannot base64_decode[%s] Failed!!!\n",DATA);
		}
	}


	sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),KEYFILE);
	
	FILE    *fKey;
	fKey = fopen(csRsaPemPath,"r");
	if (fKey == NULL) {
		iRet = INT_ERR;
DEBUGLOG(("RSAEncryptData() cannot open key file[%s]\n",csRsaPemPath));
ERRLOG("BOSecurity:RSAEncryptData() cannot open key file[%s]\n",csRsaPemPath);
	}
	else{
		while(fgets(csBuf,PD_TMP_BUF_LEN,fKey)){
			csBuf[strlen(csBuf)] = '\0';
			strcat((char*)KEY,csBuf);
		}
		if(isPrivate){
			if(isEncrype)
				iEncryptLen = myRSA_private_encrypt(DATA ,strlen((char*) DATA), KEY, TmpOUT);
			else
				iEncryptLen = myRSA_private_decrypt(TmpDATA ,iLen, KEY, OUT);
		}
		else{
			if(isEncrype)
				iEncryptLen = myRSA_public_encrypt(DATA ,strlen((char*)DATA), KEY, TmpOUT);
			else
				iEncryptLen = myRSA_public_decrypt(TmpDATA ,iLen, KEY, OUT);
		}
	}

	if(iEncryptLen<=0){
		iRet = INT_ERR;
DEBUGLOG(("RSAEncryptData Failed!!!\n"));
	}
	else{
		if(isEncrype){
			base64_encode(TmpOUT,iEncryptLen, (char*)OUT,PD_MAX_BUFFER);
		}
		else{
			OUT[iEncryptLen]='\0';
		}
DEBUGLOG(("RSAEncryptData EncryptData[%s][%d]\n",OUT,iEncryptLen));
	}

	fclose(fKey);

	FREE_ME(KEY);
	FREE_ME(TmpOUT);
	return iRet;
}


int AESEncryptData(unsigned char* KEY,unsigned char* DATA,unsigned char* OUT, unsigned int *iOutLen)
{
	int	iRet = PD_OK;
	unsigned int	iLen = 0;
	//unsigned char *TmpOUT;
	//TmpOUT = (unsigned char*) malloc (PD_MAX_BUFFER);
	//memset(TmpOUT,0,sizeof(TmpOUT));


DEBUGLOG(("AESEncryptData Start [%s]\n",KEY));
	//iRet = myAES_ECB_encrypt(DATA, KEY, TmpOUT, &iLen);
	iRet = myAES_ECB_encrypt(DATA, KEY, OUT, &iLen);
	if(iRet == PD_OK){
		//base64_encode(TmpOUT,iLen, (char*)OUT,PD_MAX_BUFFER);
		*iOutLen = iLen;
DEBUGLOG(("AESEncryptData EncryptData[%s][%d]\n",OUT,*iOutLen));
	}
	else{
DEBUGLOG(("AESEncryptData Failed!!!\n"));
	}

	//FREE_ME(TmpOUT);
	return iRet;
}

int AESDecryptData(unsigned char* KEY,unsigned char* DATA, const int Dlen,unsigned char* OUT)
{
	int	iRet = PD_OK;
	unsigned int	iOutLen = 0;
	unsigned char *TmpOUT;
	TmpOUT = (unsigned char*) malloc (PD_MAX_BUFFER);
	memset(TmpOUT,0,sizeof(TmpOUT));

DEBUGLOG(("AESDecryptData Start [%s]\n",KEY));
	iRet = myAES_ECB_decrypt(DATA, Dlen, KEY, OUT, &iOutLen);
	if(iRet == PD_OK){
		OUT[iOutLen] = '\0';
DEBUGLOG(("AESDecryptData DecryptData[%s][%d]\n",OUT,iOutLen));
	}
	else{
DEBUGLOG(("AESDecryptData Failed!!!\n"));
	}

	FREE_ME(TmpOUT);
	return iRet;
}




int GenerateYsePaySign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csData;
	char	csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char	*csRsaPem;
	char	*csPassPhrase;
	char	*csBuf, *csFinal;
	unsigned char 	csSignData[PD_TMP_MSG_BUF_LEN];
	unsigned int	iLen = 0;

DEBUGLOG(("GenerateYsePaySignign()\n"));

/* xml_msg */
        if (GetField_CString(hOut,"xml_msg",&csData)) {
DEBUGLOG(("GenerateYsePaySign() xml_msg = [%s]\n",csData));
        }

/* rsapem */
	if (GetField_CString(hContext,"psp_privatepem",&csRsaPem)) {
DEBUGLOG(("GenerateYsePaySign privatepem = [%s]\n",csRsaPem));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("GenerateYsePaySign privatepempath = [%s]\n",csRsaPemPath));
	}
	else {
		iRet = INT_ERR;
	}
/* passphrase */
	if (GetField_CString(hContext,"psp_passphrase",&csPassPhrase)) {
DEBUGLOG(("GenerateYsePaySign PassPhrase = [%s]\n",csPassPhrase));
	}
	else {
		iRet = INT_ERR;
	}

	if (iRet == PD_OK) {
		md5rsa_sign(csRsaPemPath,csPassPhrase,csData, csSignData, &iLen);
        
        	csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN);
        	csBuf[0]='\0';
		base64_encode(csSignData,iLen,csBuf,PD_MAX_BUFFER);
DEBUGLOG(("GenerateYsePaySign() sign             = [%s][%d]\n",csBuf, strlen(csBuf)));
		csFinal = (char*) malloc (PD_TMP_BUF_LEN+1);
                csFinal[0]='\0';
		right_pad_space(csFinal,csBuf,PD_TMP_BUF_LEN);
                csFinal[PD_TMP_BUF_LEN]='\0';

DEBUGLOG(("GenerateYsePaySign() sign (padded space)= [%s][%d]\n",csFinal,strlen(csFinal)));
       		PutField_CString(hOut,"sign",csFinal);
        
        	FREE_ME(csBuf);
        	FREE_ME(csFinal);
	}
DEBUGLOG(("GenerateYsePaySign() iRet = [%d]\n",iRet));

        
        return iRet;
}


int VerifyYsePaySign(hash_t *hContext,
                const hash_t* hRequest)
{
	int	iRet = PD_OK;
	char	csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char	*csRsaPem;
	char	*csAuthData;
	char	*csClearSig;
	unsigned char	*csSig;
	int	iSigLen;
DEBUGLOG(("VerifyYsePaySign()\n"));

/* xml_msg */
        if (GetField_CString(hRequest,"xml_msg",&csAuthData)) {
DEBUGLOG(("VerifyYsePaySign() xml_msg = [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("VerifyYsePaySign() sign= [%s]\n",csClearSig));
        }

/* publiccert */
	if (GetField_CString(hContext,"psp_publiccert",&csRsaPem)) {
DEBUGLOG(("VerifyYsePaySign publiccert = [%s]\n",csRsaPem));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("VerifyYsePaySign publiccertpath = [%s]\n",csRsaPemPath));
	}
	else {
DEBUGLOG(("VerifyYsePaySign publiccert is missing!!!\n"));
		iRet = INT_ERR;
	}

	

        if (iRet == PD_OK) {
DEBUGLOG(("VerifyYsePaySign try to verify [%s]\n",csClearSig));
		csSig = (unsigned char*) malloc (PD_MAX_BUFFER);
		iSigLen = base64_decode(csClearSig,csSig,PD_MAX_BUFFER);
DEBUGLOG(("VerifyYsePaySign try to verify sig date len = [%d]\n",iSigLen));
		iRet = md5rsa_verify(csRsaPemPath,csAuthData,csSig,iSigLen);
		FREE_ME(csSig);
        }
DEBUGLOG(("VerifyYsePaySign() iRet = [%d]\n",iRet));


	return iRet;
}

int GenerateXJSign(hash_t *hContext,
                hash_t* hOut)
{
        int     iRet = PD_OK;
        char    *csBuf,*csOUT;
        char    *csPtr;
	char	*csKey;

DEBUGLOG(("BOSecurity:GenerateXJSign()\n"));
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);

        csBuf[0]='\0';
        csOUT[0]='\0';

/* auth_data */
        if (GetField_CString(hOut,"auth_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateXJSign() auth_data= [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }
/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:GenerateXJSign() auth_key= [%s]\n",csKey));
        }
DEBUGLOG(("BOSecurity:GenerateXJSign() sign_data= [%s]\n",csBuf));
        
        hmac_md5((unsigned char*)csBuf,strlen(csBuf),(unsigned char*)csKey,strlen(csKey),(unsigned char*)csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);
DEBUGLOG(("BOSecurity:GenerateXJSign() sign             = [%s]\n",csOUT));
DEBUGLOG(("BOSecurity:GenerateXJSign() sign             = [%s]\n",csBuf));
        PutField_CString(hOut,"sign",csBuf);

        
        FREE_ME(csBuf);
        FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateXJSign() iRet = [%d]\n",iRet));

        
        return iRet;
}


int VerifyXJSign(hash_t *hContext,
                const hash_t* hRequest)
{
	int	iRet = PD_OK;
	char	*csAuthData;
	char	*csClearSig;
	char	*csKey;
        char    *csBuf,*csOUT;
        csBuf = (char*) malloc (1024 * 2 +1);
        csOUT = (char*) malloc (1024 * 2 +1);
DEBUGLOG(("BOSecurity:VerifyXjSign()\n"));

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csAuthData)) {
DEBUGLOG(("BOSecurity:VerifyXjSign() auth_data= [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("BOSecurity:VerifyXjSign() sign= [%s]\n",csClearSig));
        }

/* merchant_key */
        if (GetField_CString(hContext,"psp_key",&csKey)) {
DEBUGLOG(("BOSecurity:VerifyXjSign() auth_key= [%s]\n",csKey));
        }

        hmac_md5((unsigned char*)csAuthData,strlen(csAuthData),(unsigned char*)csKey,strlen(csKey),(unsigned char*)csOUT);
        csBuf[0] = '\0';
        U2L(csOUT,strlen(csOUT),csBuf);

DEBUGLOG(("BOSecurity:VerifyXjSign 	msg sign = [%s]\n",csClearSig));
DEBUGLOG(("BOSecurity:VerifyXjSign 	    sign = [%s]\n",csBuf));
/* verify sign */
	if (memcmp(csClearSig,csBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify XJ sign error\n");
DEBUGLOG(("BOSecurity:verify XJ sign error\n"));
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csBuf);
	FREE_ME(csOUT);

	return iRet;
}


int RSAEncryptData_with_mode(unsigned char* KEYFILE,unsigned char* DATA,unsigned char* OUT, const int isPrivate, const int isEncrype, int padding, int iKeySize)
{
	int	iRet = PD_OK;
	unsigned int	iEncryptLen = 0;
	int	iLen = 0;
	char    csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char    csBuf[PD_MAX_BUFFER +1];
	int	iRSASize = iKeySize / 8;
	unsigned char *KEY;
	KEY = (unsigned char*) malloc (PD_MAX_BUFFER);
	memset(KEY,0,sizeof(KEY));

	unsigned char *TmpDATA;
	TmpDATA = (unsigned char*) malloc (PD_MAX_BUFFER);
	memset(TmpDATA,0,sizeof(TmpDATA));

	unsigned char *TmpOUT;
	TmpOUT = (unsigned char*) malloc (PD_MAX_BUFFER);
	memset(TmpOUT,0,sizeof(TmpOUT));

DEBUGLOG(("RSAEncryptData_with_mode Start\n"));

	if(!isEncrype){
		iLen = base64_decode((char *)DATA,(unsigned char*)TmpDATA,PD_MAX_BUFFER);
		if(iLen<=0){
			iRet = INT_ERR;
DEBUGLOG(("RSAEncryptData_with_mode() cannot base64_decode[%s] Failed!!!\n",DATA));
ERRLOG("BOSecurity:RSAEncryptData_with_mode() cannot base64_decode[%s] Failed!!!\n",DATA);
		}
	}


	sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),KEYFILE);
	
	FILE    *fKey;
	fKey = fopen(csRsaPemPath,"r");
	if (fKey == NULL) {
		iRet = INT_ERR;
DEBUGLOG(("RSAEncryptData_with_mode() cannot open key file[%s]\n",csRsaPemPath));
ERRLOG("BOSecurity:RSAEncryptData_with_mode() cannot open key file[%s]\n",csRsaPemPath);
	}
	else{
		while(fgets(csBuf,PD_TMP_BUF_LEN,fKey)){
			csBuf[strlen(csBuf)] = '\0';
			strcat((char*)KEY,csBuf);
		}

		int iEncryptBufSize = 0;
		if (padding == RSA_PKCS1_OAEP_PADDING) {
			iEncryptBufSize = iRSASize - 42;
		} else if (padding == RSA_PKCS1_PADDING) {
			iEncryptBufSize = iRSASize - 11;
		} else {
			iRet = INT_ERR;
DEBUGLOG(("RSAEncryptData_with_mode() PH unsupported padding\n"));
ERRLOG("BOSecurity:RSAEncryptData_with_mode() PH unsupported padding\n");
		}
		int iDecryptBufSize = iRSASize;
DEBUGLOG(("RSAEncryptData_with_mode() iEncryptBufSize = [%d], iDecryptBufSize = [%d]\n", iEncryptBufSize, iDecryptBufSize));

		if(isEncrype) {
			int iBlockNum = strlen((char*)DATA) / iEncryptBufSize;
			int iByteLeft = strlen((char*)DATA) % iEncryptBufSize;
			unsigned int iEncryptLenTmp = 0;

			int i;
			for (i = 0; i < iBlockNum; i++) {
				if(isPrivate)
					iEncryptLenTmp = myRSA_private_encrypt_with_mode(DATA + i * iEncryptBufSize, iEncryptBufSize, KEY, TmpOUT + i * iDecryptBufSize, padding);
				else
					iEncryptLenTmp = myRSA_public_encrypt_with_mode(DATA + i * iEncryptBufSize, iEncryptBufSize, KEY, TmpOUT + i * iDecryptBufSize, padding);
				iEncryptLen = iEncryptLen + iEncryptLenTmp;
			}
			if (iByteLeft) {
				if(isPrivate)
					iEncryptLenTmp = myRSA_private_encrypt_with_mode(DATA + i * iEncryptBufSize, iByteLeft, KEY, TmpOUT + i * iDecryptBufSize, padding);
				else
					iEncryptLenTmp = myRSA_public_encrypt_with_mode(DATA + i * iEncryptBufSize, iByteLeft, KEY, TmpOUT + i * iDecryptBufSize, padding);
				iEncryptLen = iEncryptLen + iEncryptLenTmp;
			}
		}
		else{
			int iBlockNum = iLen / iDecryptBufSize;
			int iByteLeft = iLen % iDecryptBufSize;
			unsigned int iDecryptLenTmp = 0;

			int i;
			for (i = 0; i < iBlockNum; i++) {
				if(isPrivate)
					iDecryptLenTmp = myRSA_private_decrypt_with_mode(TmpDATA + i * iDecryptBufSize, iDecryptBufSize, KEY, OUT + i * iEncryptBufSize, padding);
				else
					iDecryptLenTmp = myRSA_public_decrypt_with_mode(TmpDATA + i * iDecryptBufSize, iDecryptBufSize, KEY, OUT + i * iEncryptBufSize, padding);
				iEncryptLen = iEncryptLen + iDecryptLenTmp;
			}
			if (iByteLeft) {
				if(isPrivate)
					iDecryptLenTmp = myRSA_private_decrypt_with_mode(TmpDATA + i * iDecryptBufSize, iByteLeft, KEY, OUT + i * iEncryptBufSize, padding);
				else
					iDecryptLenTmp = myRSA_public_decrypt_with_mode(TmpDATA + i * iDecryptBufSize, iByteLeft, KEY, OUT + i * iEncryptBufSize, padding);
				iEncryptLen = iEncryptLen + iDecryptLenTmp;
			}
		}
	}

	if(iEncryptLen<=0){
		iRet = INT_ERR;
DEBUGLOG(("RSAEncryptData_with_mode Failed!!!\n"));
	}
	else{
		if(isEncrype){
			base64_encode(TmpOUT,iEncryptLen, (char*)OUT,PD_MAX_BUFFER);
		}
		else{
			OUT[iEncryptLen]='\0';
		}
DEBUGLOG(("RSAEncryptData_with_mode EncryptData[%s][%d]\n",OUT,iEncryptLen));
	}

	fclose(fKey);

	FREE_ME(KEY);
	FREE_ME(TmpOUT);
	return iRet;
}


int GenerateUniPaySign(hash_t *hContext,
		hash_t* hOut)
{
	int	iRet = PD_OK;
	int	padding = RSA_PKCS1_OAEP_PADDING;
	int	iKeySize = 2048;
	char	*csBuf;
	char	*csPtr;
	char	*csRSAKeyFile;
	char	*csData;

DEBUGLOG(("BOSecurity:GenerateUniPaySign()\n"));
        csBuf = (char*) malloc (PD_MAX_BUFFER);
	csData = (char*) malloc (PD_MAX_BUFFER);

        csBuf[0] = '\0';

// auth_data
        if (GetField_CString(hOut,"auth_data",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateUniPaySign() auth_data = [%s]\n",csPtr));
                strcat(csBuf,csPtr);
        }

// rsa_key
	if (GetField_CString(hContext,"rsa_key",&csRSAKeyFile)) {
DEBUGLOG(("BOSecurity:GenerateUniPaySign() auth_key = [%s]\n",csRSAKeyFile));
        }

	memset(csData,0,sizeof(csData));
	BOObjPtr = CreateObj(BOPtr,"BOSecurity","RSAEncryptData_with_mode");
	iRet = (unsigned long)(*BOObjPtr)(csRSAKeyFile,csBuf,csData,PD_FALSE,PD_TRUE,padding,iKeySize);

	if (iRet == PD_OK) {
DEBUGLOG(("BOSecurity:GenerateUniPaySign() sign = [%s]\n",csData));
		PutField_CString(hOut,"sign",csData);
	}

        FREE_ME(csBuf);
	FREE_ME(csData);
DEBUGLOG(("BOSecurity:GenerateUniPaySign() iRet = [%d]\n",iRet));

	return iRet;
}


char *replace_str(char *str, char *orig, char *rep)
{
	static char buffer[PD_TMP_MSG_BUF_LEN];
	char *p;

	if (!(p = strstr(str, orig)))
		return str;

	strncpy(buffer, str, p-str);
	buffer[p-str] = '\0';

	sprintf(buffer+(p-str), "%s%s", rep, p+strlen(orig));

	return buffer;
}


int VerifyNTWSign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char*	csPtr;
	char*   csSign;
	int	iTmp = PD_FALSE;

	char	*csOUT;
	char	*csTmpBuf;
	csTmpBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	

	csTmpBuf[0] ='\0';
	char*   csPspChannel;
        if (!GetField_CString(hContext,"return_psp_channel",&csPspChannel)) {
DEBUGLOG(("BOSecurity:VerifyNTWSign psp_channel = [%s]\n",csPspChannel));
        }
/* auth data */
        if (GetField_CString(hRequest,"auth_data",&csPtr)) {
DEBUGLOG(("VerifyNTWSign() auth_data= [%s]\n",csPtr));
                strcat(csTmpBuf,csPtr);
        }

/* psp_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("VerifyNTWSign() psp_key= [%s]\n",csPtr));
		if (GetField_Int(hRequest,"isInitRsp",&iTmp)) {
			if (iTmp) {
				strcat(csTmpBuf,"key=");
			}
		}

		strcat(csTmpBuf,csPtr);
        }
	else {
DEBUGLOG(("VerifyNTWSign() psp_key is missing!!!\n"));
	}
DEBUGLOG(("VerifyNTWSign() sign_data= [%s]\n",csTmpBuf));

/* sign */
	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("VerifyNTWSign() sign from msg = [%s]\n",csSign));
	}
	
	md5sum(csTmpBuf,strlen(csTmpBuf),csOUT);
DEBUGLOG(("VerifyNTWSign() sign             = [%s]\n",csOUT));
	csTmpBuf[0] = '\0';

        if (iTmp)
		L2U(csOUT,strlen(csOUT),csTmpBuf);
	else
		U2L(csOUT,strlen(csOUT),csTmpBuf);
DEBUGLOG(("VerifyNTWSign() sign             = [%s]\n",csTmpBuf));

/* verify sign */
	if (memcmp(csSign,csTmpBuf,PD_MD5_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csTmpBuf);
	FREE_ME(csOUT);
	return iRet;
}


int GenerateDinPaySign(hash_t *hContext, hash_t *hOut)
{
	int iRet = PD_OK;
	char *csPtr;
	char *csInput;
	char *csRsaPem;
	unsigned char csOutput[PD_TMP_MSG_BUF_LEN];
	unsigned int iOutputLength = 0;

DEBUGLOG(("GenerateDinPaySign()\n"));
	csInput = (char*) malloc (PD_MAX_BUFFER);
	csInput[0] = '\0';

// auth_data
	if (GetField_CString(hOut, "auth_data", &csPtr)) {
DEBUGLOG(("GenerateDinPaySign() auth_data = [%s]\n", csPtr));
		strcat(csInput, csPtr);
	}

// RSA - private key
	if (GetField_CString(hContext, "rsa_key", &csRsaPem)) {
DEBUGLOG(("GenerateDinPaySign() auth_key = [%s]\n", csRsaPem));
	}

	char csRsaPemPath[PD_MAX_FILE_LEN + 1];
	sprintf(csRsaPemPath, "%s/%s", getenv("CERT_PATH"), csRsaPem);

	iRet = md5rsa_sign_new(csRsaPemPath, csInput, csOutput, &iOutputLength);
	char *csBuf;
	csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN);
	csBuf[0] = '\0';
	base64_encode(csOutput, iOutputLength, csBuf, PD_MAX_BUFFER);
DEBUGLOG(("GenerateDinPaySign() sign = [%s]\n", csBuf));
	PutField_CString(hOut, "sign", csBuf);
	FREE_ME(csBuf);

	FREE_ME(csInput);
DEBUGLOG(("GenerateDinPaySign() iRet = [%d]\n", iRet));
	return iRet;
}


int VerifyDinPaySign(hash_t *hContext, const hash_t *hRequest)
{
	int iRet = PD_OK;
	char *csRsaPem;
	char *csAuthData;
	char *csClearSig;
	unsigned char *csSig;
	int iSigLen;

DEBUGLOG(("VerifyDinPaySign()\n"));

/* auth_data */
	if (GetField_CString(hRequest, "auth_data", &csAuthData)) {
DEBUGLOG(("VerifyDinPaySign() auth_data = [%s]\n", csAuthData));
	}

/* sign */
	if (GetField_CString(hRequest, "sign", &csClearSig)) {
DEBUGLOG(("VerifyDinPaySign() sign = [%s]\n", csClearSig));
	}

/* RSA - public key */
	if (GetField_CString(hContext, "rsa_privatepem", &csRsaPem)) {
DEBUGLOG(("VerifyDinPaySign() auth_key = [%s]\n", csRsaPem));
	}

	char csRsaPemPath[PD_MAX_FILE_LEN + 1];
	sprintf(csRsaPemPath, "%s/%s", getenv("CERT_PATH"), csRsaPem);

DEBUGLOG(("VerifyDinPaySign() try to verify [%s]\n", csClearSig));
	csSig = (unsigned char*) malloc (PD_MAX_BUFFER);
	iSigLen = base64_decode(csClearSig, csSig, PD_MAX_BUFFER);
DEBUGLOG(("VerifyDinPaySign() try to verify sig data len = [%d]\n", iSigLen));
	iRet = md5rsa_verify_new(csRsaPemPath, csAuthData, csSig, iSigLen);

	FREE_ME(csSig);
DEBUGLOG(("VerifyDinPaySign() iRet = [%d]\n", iRet));
        return iRet;
}


int VerifyCPESign(hash_t *hContext, const hash_t *hRequest)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csSign;

	char	*csOUT;
	char	*csTmpBuf;
	csTmpBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
	csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);

DEBUGLOG(("BOSecurity: VerifyCPESign start\n"));

	csTmpBuf[0] = '\0';
	char	*csPspChannel;
	if (!GetField_CString(hContext, "return_psp_channel", &csPspChannel)) {
DEBUGLOG(("VerifyCPESign psp_channel = [%s]\n", csPspChannel));
	}

	/* auth data */
	if (GetField_CString(hRequest, "auth_data", &csPtr)) {
DEBUGLOG(("VerifyCPESign() auth_data = [%s]\n", csPtr));
		strcat(csTmpBuf, csPtr);
	}

	/* psp_key */
	if (GetField_CString(hContext, "psp_key", &csPtr)) {
DEBUGLOG(("VerifyCPESign() psp_key = [%s]\n", csPtr));
		strcat(csTmpBuf, "{");
		strcat(csTmpBuf, csPtr);
		strcat(csTmpBuf, "}");
	} else {
DEBUGLOG(("VerifyCPESign() psp_key is missing!!!\n"));
	}
	DEBUGLOG(("VerifyCPESign() sign_data = [%s]\n", csTmpBuf));

	/* sign */
	if (GetField_CString(hRequest, "sign", &csSign)) {
DEBUGLOG(("VerifyCPESign() sign from msg = [%s]\n", csSign));
	}

	md5sum(csTmpBuf, strlen(csTmpBuf), csOUT);
DEBUGLOG(("VerifyCPESign() sign = [%s]\n", csOUT));
	csTmpBuf[0] = '\0';

	L2U(csOUT, strlen(csOUT), csTmpBuf);
DEBUGLOG(("VerifyCPESign() sign = [%s]\n", csTmpBuf));

	/* verify sign */
	if (memcmp(csSign, csTmpBuf, 16) != 0) {
errlog("BOSecurity: verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext, "internal_error", iRet);
	}

	FREE_ME(csTmpBuf);
	FREE_ME(csOUT);
	return iRet;
}


int GenerateHXPaySign(hash_t *hContext, hash_t *hOut)
{
	int iRet = PD_OK;
	char *csPtr;
	char *csInput;
	char *csRsaPem;
	unsigned char csOutput[PD_TMP_MSG_BUF_LEN];
	unsigned int iOutputLength = 0;

DEBUGLOG(("GenerateHXPaySign()\n"));
	csInput = (char*) malloc (PD_MAX_BUFFER);
	csInput[0] = '\0';

// auth_data
	if (GetField_CString(hOut, "auth_data", &csPtr)) {
DEBUGLOG(("GenerateHXPaySign() auth_data = [%s]\n", csPtr));
		strcat(csInput, csPtr);
	}

// RSA - private key
	if (GetField_CString(hContext, "rsa_key", &csRsaPem)) {
DEBUGLOG(("GenerateHXPaySign() auth_key = [%s]\n", csRsaPem));
	}

	char csRsaPemPath[PD_MAX_FILE_LEN + 1];
	sprintf(csRsaPemPath, "%s/%s", getenv("CERT_PATH"), csRsaPem);

	iRet = sha1rsa_sign_new(csRsaPemPath, csInput, csOutput, &iOutputLength);
	char *csBuf;
	csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN);
	csBuf[0] = '\0';
	base64_encode(csOutput, iOutputLength, csBuf, PD_MAX_BUFFER);
DEBUGLOG(("GenerateHXPaySign() sign = [%s]\n", csBuf));
	PutField_CString(hOut, "sign", csBuf);
	FREE_ME(csBuf);

	FREE_ME(csInput);
DEBUGLOG(("GenerateHXPaySign() iRet = [%d]\n", iRet));
	return iRet;
}


int VerifyHXPaySign(hash_t *hContext, const hash_t *hRequest)
{
	int iRet = PD_OK;
	char *csRsaPem;
	char *csAuthData;
	char *csClearSig;
	unsigned char *csSig;
	int iSigLen;

DEBUGLOG(("VerifyHXPaySign()\n"));

/* auth_data */
	if (GetField_CString(hRequest, "auth_data", &csAuthData)) {
DEBUGLOG(("VerifyHXPaySign() auth_data = [%s]\n", csAuthData));
	}

/* sign */
	if (GetField_CString(hRequest, "sign", &csClearSig)) {
DEBUGLOG(("VerifyHXPaySign() sign = [%s]\n", csClearSig));
	}

/* RSA - public key */
	if (GetField_CString(hContext, "rsa_privatepem", &csRsaPem)) {
DEBUGLOG(("VerifyHXPaySign() auth_key = [%s]\n", csRsaPem));
	}

	char csRsaPemPath[PD_MAX_FILE_LEN + 1];
	sprintf(csRsaPemPath, "%s/%s", getenv("CERT_PATH"), csRsaPem);

DEBUGLOG(("VerifyHXPaySign() try to verify [%s]\n", csClearSig));
	csSig = (unsigned char*) malloc (PD_MAX_BUFFER);
	iSigLen = base64_decode(csClearSig, csSig, PD_MAX_BUFFER);
DEBUGLOG(("VerifyHXPaySign() try to verify sig data len = [%d]\n", iSigLen));
	iRet = sha1rsa_verify_new(csRsaPemPath, csAuthData, csSig, iSigLen);

	FREE_ME(csSig);
DEBUGLOG(("VerifyHXPaySign() iRet = [%d]\n", iRet));
        return iRet;
}


int GeneratePayEscapeSign(hash_t *hContext, hash_t *hOut)
{
	int iRet = PD_OK;
        char    *csData;
	char	csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char	*csRsaPem;
	char	*csPassPhrase;
	char	*csBuf;
	unsigned char 	csSignData[PD_TMP_MSG_BUF_LEN];
	unsigned int	iLen = 0;

DEBUGLOG(("GeneratePayEscapeSign()\n"));

/* auth_data*/
        if (GetField_CString(hOut,"auth_data",&csData)) {
DEBUGLOG(("GeneratePayEscapeSign() auth_data = [%s]\n",csData));
        }

/* rsapem */
	if (GetField_CString(hContext,"psp_privatepem",&csRsaPem)) {
DEBUGLOG(("GeneratePayEscapeSign privatepem = [%s]\n",csRsaPem));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("GeneratePayEscapeSign privatepempath = [%s]\n",csRsaPemPath));
	}
	else {
		iRet = INT_ERR;
	}
/* passphrase */
	if (GetField_CString(hContext,"psp_passphrase",&csPassPhrase)) {
DEBUGLOG(("GeneratePayEscapeSign PassPhrase = [%s]\n",csPassPhrase));
	}
	else {
		iRet = INT_ERR;
	}

	if (iRet == PD_OK) {
		sha256rsa_sign(csRsaPemPath,csPassPhrase,csData, csSignData, &iLen);
        
        	csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN);
        	csBuf[0]='\0';
		base64_encode(csSignData,iLen,csBuf,PD_MAX_BUFFER);
DEBUGLOG(("GeneratePayEscapeSign() sign             = [%s][%d]\n",csBuf, strlen(csBuf)));
		//csFinal = (char*) malloc (PD_TMP_BUF_LEN+1);
                //csFinal[0]='\0';
		//right_pad_space(csFinal,csBuf,PD_TMP_BUF_LEN);
                //csFinal[PD_TMP_BUF_LEN]='\0';

DEBUGLOG(("GeneratePayEscapeSign() sign = [%s][%d]\n",csBuf,strlen(csBuf)));
       		PutField_CString(hOut,"sign",csBuf);

//DEBUGLOG(("GeneratePayEscapeSign() sign (padded space)= [%s][%d]\n",csFinal,strlen(csFinal)));
       		//PutField_CString(hOut,"sign",csFinal);
        
        	FREE_ME(csBuf);
        	//FREE_ME(csFinal);
	}
DEBUGLOG(("GeneratePayEscapeSign() iRet = [%d]\n",iRet));


        return iRet;
}

int VerifyPayEscapeSign(hash_t *hContext, const hash_t *hRequest)
{
	int iRet = PD_OK;
	char	csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char	*csRsaPem;
	char	*csAuthData;
	char	*csClearSig;
	unsigned char	*csSig;
	int	iSigLen;
DEBUGLOG(("VerifyPayEscapeSign()\n"));

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csAuthData)) {
DEBUGLOG(("VerifyPayEscapeSign() auth_data = [%s]\n",csAuthData));
        }

/* sign */
        if (GetField_CString(hRequest,"sign",&csClearSig)) {
DEBUGLOG(("VerifyPayEscapeSign() sign= [%s]\n",csClearSig));
        }

/* publiccert */
	if (GetField_CString(hContext,"psp_publiccert",&csRsaPem)) {
DEBUGLOG(("VerifyPayEscapeSign publiccert = [%s]\n",csRsaPem));
		sprintf(csRsaPemPath,"%s/%s",getenv("CERT_PATH"),csRsaPem);
DEBUGLOG(("VerifyPayEscapeSign publiccertpath = [%s]\n",csRsaPemPath));
	}
	else {
DEBUGLOG(("VerifyPayEscapeSign publiccert is missing!!!\n"));
		iRet = INT_ERR;
	}

	

        if (iRet == PD_OK) {
DEBUGLOG(("VerifyPayEscapeSign try to verify [%s]\n",csClearSig));
		csSig = (unsigned char*) malloc (PD_MAX_BUFFER);
		iSigLen = base64_decode(csClearSig,csSig,PD_MAX_BUFFER);
DEBUGLOG(("VerifyPayEscapeSign try to verify sig date len = [%d]\n",iSigLen));
		iRet = sha256rsa_verify(csRsaPemPath,csAuthData,csSig,iSigLen);
		FREE_ME(csSig);
        }
DEBUGLOG(("VerifyPayEscapeSign() iRet = [%d]\n",iRet));


        return iRet;
}


int GenerateSHA256Sign(hash_t *hContext,
		hash_t* hOut)
{
	int	iRet = PD_OK;
	char	*csBuf, *csOUT;
	char	*csPtr;

DEBUGLOG(("BOSecurity:GenerateSHA256Sign()\n"));
	csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
	csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);

	csBuf[0] = '\0';
	csOUT[0] = '\0';

	char*	csPspChannel = NULL;
	if (GetField_CString(hContext,"psp_channel_code",&csPspChannel)) {
DEBUGLOG(("BOSecurity:GenerateSHA256Sign() psp_channel = [%s]\n",csPspChannel));
	}

/* auth_data */
	if (GetField_CString(hOut, "auth_data", &csPtr)) {
DEBUGLOG(("BOSecurity:GenerateSHA256Sign() auth_data = [%s]\n", csPtr));
		strcat(csBuf, csPtr);
	}

/* psp_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("BOSecurity:GenerateSHA256Sign() psp_key = [%s]\n", csPtr));

		if(!strcmp(csPspChannel,PD_CHANNEL_ZPAY_EC)
			|| !strcmp(csPspChannel,PD_CHANNEL_ZPAY_QR)
		){
			strcat(csBuf, csPtr);
		}
	}

DEBUGLOG(("BOSecurity:GenerateSHA256Sign() sign_data= [%s]\n",csBuf));
	sha256sum(csBuf, strlen(csBuf), csOUT);
	csBuf[0] = '\0';

		U2L(csOUT, strlen(csOUT), csBuf);
DEBUGLOG(("BOSecurity:GenerateSHA256Sign() sign             = [%s]\n", csOUT));
DEBUGLOG(("BOSecurity:GenerateSHA256Sign() sign             = [%s]\n", csBuf));
	PutField_CString(hOut, "sign", csBuf);

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateSHA256Sign() iRet = [%d]\n", iRet));

	return iRet;
}


int VerifySHA256Sign(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
	char*	csPtr;
	char*   csSign;

	char	*csOUT;
	char	*csTmpBuf;
	csTmpBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN +1);
	

	csTmpBuf[0] ='\0';
	char*   csPspChannel;
        if (GetField_CString(hContext,"return_psp_channel",&csPspChannel)) {
DEBUGLOG(("BOSecurity:VerifySHA256Sign psp_channel = [%s]\n",csPspChannel));
        }
/* auth data */
        if (GetField_CString(hRequest,"auth_data",&csPtr)) {
DEBUGLOG(("VerifySHA256Sign() auth_data= [%s]\n",csPtr));
                strcat(csTmpBuf,csPtr);
        }

/* psp_key */
        if (GetField_CString(hContext,"psp_key",&csPtr)) {
DEBUGLOG(("VerifySHA256Sign() psp_key= [%s]\n",csPtr));

		if (!strcmp(csPspChannel,PD_CHANNEL_ZPAY_EC)
			|| !strcmp(csPspChannel,PD_CHANNEL_ZPAY_QR)
		) {
			strcat(csTmpBuf,csPtr);
		}
        }

DEBUGLOG(("VerifySHA256Sign() sign_data= [%s]\n",csTmpBuf));

/* sign */
	if (GetField_CString(hRequest,"sign",&csSign)) {
DEBUGLOG(("VerifySHA256Sign() sign from msg = [%s]\n",csSign));
	}
	
	sha256sum(csTmpBuf,strlen(csTmpBuf),csOUT);
DEBUGLOG(("VerifySHA256Sign() sign             = [%s]\n",csOUT));
	csTmpBuf[0] = '\0';

		U2L(csOUT,strlen(csOUT),csTmpBuf);
DEBUGLOG(("VerifySHA256Sign() sign             = [%s]\n",csTmpBuf));

/* verify sign */
	if (memcmp(csSign,csTmpBuf,PD_SHA256_SUM_LEN) != 0) {
ERRLOG("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext,"internal_error",iRet);
	}

	FREE_ME(csTmpBuf);
	FREE_ME(csOUT);
	return iRet;
}

int GenerateOUPSign(hash_t *hContext, hash_t *hOut)
{
	int iRet = PD_OK;
	char *csData;
	char csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char *csRsaPem;
	char *csPassPhrase;
	char *csBuf;
	unsigned char csSignData[PD_TMP_MSG_BUF_LEN];
	unsigned int iLen = 0;

DEBUGLOG(("GenerateOUPSign()\n"));

	BOObjPtr = CreateObj(BOPtr, "BOSecurity", "GenerateSHA256Sign");
	iRet = (unsigned long)(*BOObjPtr)(hContext, hOut);

/* auth_data*/
	if (GetField_CString(hOut, "sign", &csData)) {
DEBUGLOG(("GenerateOUPSign() auth_data = [%s]\n", csData));
	}

/* rsapem */
	if (GetField_CString(hContext, "psp_privatepem", &csRsaPem)) {
DEBUGLOG(("GenerateOUPSign privatepem = [%s]\n", csRsaPem));
		sprintf(csRsaPemPath, "%s/%s", getenv("CERT_PATH"), csRsaPem);
DEBUGLOG(("GenerateOUPSign privatepempath = [%s]\n", csRsaPemPath));
	}
	else {
		iRet = INT_ERR;
	}

/* passphrase */
	if (GetField_CString(hContext, "psp_passphrase", &csPassPhrase)) {
DEBUGLOG(("GenerateOUPSign passPhrase = [%s]\n", csPassPhrase));
	}
	else {
		iRet = INT_ERR;
	}

	if (iRet == PD_OK) {
		sha256rsa_sign(csRsaPemPath, csPassPhrase, csData, csSignData, &iLen);

		csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN);
		csBuf[0] = '\0';
		base64_encode(csSignData, iLen, csBuf, PD_MAX_BUFFER);
DEBUGLOG(("GenerateOUPSign() sign = [%s][%d]\n", csBuf, strlen(csBuf)));
		PutField_CString(hOut, "sign", csBuf);

		FREE_ME(csBuf);
	}
DEBUGLOG(("GenerateOUPSign() iRet = [%d]\n", iRet));

	return iRet;
}


int VerifyOUPSign(hash_t *hContext, const hash_t *hRequest)
{
	int iRet = PD_OK;
	char csRsaPemPath[PD_MAX_FILE_LEN + 1];
	char *csRsaPem;
	char *csAuthData;
	char *csClearSig;
	unsigned char *csSig;
	int iSigLen;

	hash_t *hTmp;
	hTmp = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hTmp, 0);
	char *csTmp;

DEBUGLOG(("VerifyOUPSign()\n"));

/* auth_data */
	if (GetField_CString(hRequest, "auth_data", &csTmp)) {
DEBUGLOG(("VerifyOUPSign() auth_data = [%s]\n", csTmp));
		PutField_CString(hTmp, "auth_data", csTmp);
	}

	BOObjPtr = CreateObj(BOPtr, "BOSecurity", "GenerateSHA256Sign");
	iRet = (unsigned long)(*BOObjPtr)(hTmp, hTmp);

/* auth_data */
	if (GetField_CString(hTmp, "sign", &csAuthData)) {
DEBUGLOG(("VerifyOUPSign() auth_data = [%s]\n", csAuthData));
	}

/* sign */
	if (GetField_CString(hRequest, "sign", &csClearSig)) {
DEBUGLOG(("VerifyOUPSign() sign = [%s]\n", csClearSig));
	}

/* publiccert */
	if (GetField_CString(hContext, "psp_publiccert", &csRsaPem)) {
DEBUGLOG(("VerifyOUPSign publiccert = [%s]\n", csRsaPem));
		sprintf(csRsaPemPath, "%s/%s", getenv("CERT_PATH"), csRsaPem);
DEBUGLOG(("VerifyOUPSign publiccertpath = [%s]\n", csRsaPemPath));
	}
	else {
DEBUGLOG(("VerifyOUPSign publiccert is missing!!!\n"));
		iRet = INT_ERR;
	}

	if (iRet == PD_OK) {
DEBUGLOG(("VerifyOUPSign try to verify [%s]\n", csClearSig));
		csSig = (unsigned char*) malloc (PD_MAX_BUFFER);
		iSigLen = base64_decode(csClearSig, csSig, PD_MAX_BUFFER);
DEBUGLOG(("VerifyOUPSign try to verify sig date len = [%d]\n", iSigLen));
		iRet = sha256rsa_verify(csRsaPemPath, csAuthData, csSig, iSigLen);
		FREE_ME(csSig);
	}
DEBUGLOG(("VerifyOUPSign() iRet = [%d]\n", iRet));

	FREE_ME(hTmp);
	return iRet;
}


int GenerateSHA1Sign(hash_t *hContext, hash_t* hOut)
{
	int	iRet = PD_OK;
	char	*csPtr;
	char	*csBuf, *csOUT;

DEBUGLOG(("BOSecurity:GenerateSHA1Sign()\n"));
	csBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
	csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
	csBuf[0] = '\0';
	csOUT[0] = '\0';

	char	*csPspChannel = strdup("");
	if (GetField_CString(hContext, "psp_channel_code", &csPspChannel)) {
DEBUGLOG(("psp_channel = [%s]\n", csPspChannel));
	}

/* auth_data */
	if (GetField_CString(hOut, "auth_data", &csPtr)) {
DEBUGLOG(("auth_data = [%s]\n", csPtr));
		strcat(csBuf, csPtr);
	}

/* psp_key */
	if (GetField_CString(hContext, "psp_key", &csPtr)) {
DEBUGLOG(("psp_key = [%s]\n", csPtr));
		if (!strcmp(csPspChannel, PD_CHANNEL_SWIFTPAY_QR))
			strcat(csBuf, "key=");

		strcat(csBuf, csPtr);
	}
	else {
DEBUGLOG(("psp_key is missing***\n"));
	}

DEBUGLOG(("sign_data = [%s]\n", csBuf));

	sha1sum(csBuf, strlen(csBuf), csOUT);
	csBuf[0] = '\0';

	if (!strcmp(csPspChannel, PD_CHANNEL_SWIFTPAY_QR))
		L2U(csOUT, strlen(csOUT), csBuf);
	else
		U2L(csOUT, strlen(csOUT), csBuf);

DEBUGLOG(("BOSecurity:GenerateSHA1Sign() sign             = [%s]\n", csOUT));
DEBUGLOG(("BOSecurity:GenerateSHA1Sign() sign             = [%s]\n", csBuf));
	PutField_CString(hOut, "sign", csBuf);

	FREE_ME(csBuf);
	FREE_ME(csOUT);
DEBUGLOG(("BOSecurity:GenerateSHA1Sign() iRet = [%d]\n", iRet));

	return iRet;
}


int VerifySHA1Sign(hash_t *hContext, const hash_t* hRequest)
{
	int	iRet = PD_OK;
	char	*csPtr, *csSign;
	char	*csOUT, *csTmpBuf;

DEBUGLOG(("BOSecurity:VerifySHA1Sign()\n"));
	csOUT = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
	csTmpBuf = (char*) malloc (PD_TMP_MSG_BUF_LEN + 1);
	csTmpBuf[0] = '\0';

	char	*csPspChannel;
	if (!GetField_CString(hContext, "return_psp_channel", &csPspChannel)) {
DEBUGLOG(("psp_channel = [%s]\n", csPspChannel));
	}

/* auth data */
	if (GetField_CString(hRequest, "auth_data", &csPtr)) {
DEBUGLOG(("auth_data = [%s]\n", csPtr));
		strcat(csTmpBuf, csPtr);
	}

/* psp_key */
	if (GetField_CString(hContext, "psp_key", &csPtr)) {
DEBUGLOG(("psp_key = [%s]\n", csPtr));
		if (!strcmp(csPspChannel, PD_CHANNEL_SWIFTPAY_QR))
			strcat(csTmpBuf, "key=");

		strcat(csTmpBuf, csPtr);
	}
	else {
DEBUGLOG(("psp_key is missing!!!\n"));
	}

DEBUGLOG(("sign_data = [%s]\n", csTmpBuf));

/* sign */
	if (GetField_CString(hRequest, "sign", &csSign)) {
DEBUGLOG(("sign from msg = [%s]\n", csSign));
	}

	sha1sum(csTmpBuf, strlen(csTmpBuf), csOUT);
DEBUGLOG(("BOSecurity:VerifySHA1Sign() sign             = [%s]\n", csOUT));
	csTmpBuf[0] = '\0';

	if (!strcmp(csPspChannel, PD_CHANNEL_SWIFTPAY_QR))
		L2U(csOUT, strlen(csOUT), csTmpBuf);
	else
		U2L(csOUT, strlen(csOUT), csTmpBuf);
DEBUGLOG(("BOSecurity:VerifySHA1Sign() sign             = [%s]\n", csTmpBuf));

/* verify sign */
	if (memcmp(csSign, csTmpBuf, PD_SHA1_SUM_LEN) != 0) {
errlog("BOSecurity:verify sign error\n");
		iRet = INT_MAC_ERR;
		PutField_Int(hContext, "internal_error", iRet);
	}

	FREE_ME(csTmpBuf);
	FREE_ME(csOUT);
	return iRet;
}



int VerifyAESMac(hash_t *hContext,
                const hash_t* hRequest)
{
        int     iRet = PD_OK;
        char    *csEncTypePtr;
        char    *csMacPtr;
        char    *csDataPtr;
        char    *csKeyPtr;
        char    *csOut;
        unsigned long   lOutLen;
        char    *csMac;

DEBUGLOG(("VerifyAESMac()\n"));

/* enc_type */
        if (GetField_CString(hRequest,"enc_type",&csEncTypePtr)) {
DEBUGLOG(("VerifyAESMac enc_type = [%s]\n",csEncTypePtr));
        }
        else {
DEBUGLOG(("VerifyAESMac enc_type is missing!!!\n"));
ERRLOG("BOSecurity:VerifyAESMac enc_type is missing!!!\n");
                iRet = INT_ERR;
        }


/* key */
        if (GetField_CString(hContext,"key",&csKeyPtr)) {
DEBUGLOG(("VerifyAESMac key = [%s][%d]\n",csKeyPtr,strlen(csKeyPtr)));
        }
        else {
DEBUGLOG(("VerifyAESMac key is missing!!!\n"));
ERRLOG("BOSecurity:VerifyAESMac key missing!!!\n");
                iRet = INT_ERR;
        }

/* mac */
        if (GetField_CString(hRequest,"mac",&csMacPtr)) {
DEBUGLOG(("VerifyAESMac mac = [%s]\n",csMacPtr));
                lOutLen = strlen(csMacPtr) * 2;
        }
        else {
DEBUGLOG(("VerifyAESMac mac is missing!!!\n"));
ERRLOG("BOSecurity:VerifyAESMac mac is missing!!!\n");
                iRet = INT_ERR;
        }

/* auth_data */
        if (GetField_CString(hRequest,"auth_data",&csDataPtr)) {
DEBUGLOG(("VerifyAESMac auth_data = [%s]\n",csDataPtr));
        }
        else {
DEBUGLOG(("VerifyAESMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:VerifyAESMac auth_data is missing!!!\n");
                iRet = INT_ERR;
        }

        if (iRet == PD_OK) {
                csOut = (char*)malloc (PD_TMP_MSG_BUF_LEN +1);
                csMac = (char*)malloc (PD_TMP_MSG_BUF_LEN +1);
                AES_CMAC((unsigned char*) csKeyPtr,(unsigned char*)csDataPtr,strlen(csDataPtr),(unsigned char*)csOut,&lOutLen);
                Hex2Ascii(csMac,(unsigned char*)csOut,lOutLen);
DEBUGLOG(("VerifyAESMac MAC = [%s][%d]\n",csMac,strlen(csMac)));


DEBUGLOG(("VerifyAESMac to try compare\n"));
                csOut[0] = '\0';
                U2L(csMac,strlen(csMac),csOut);
DEBUGLOG(("VerifyAESMac MAC = [%s][%d] from msg [%s]\n",csOut,strlen(csOut),csMacPtr));
                if (memcmp(csMacPtr,csOut,strlen(csOut)) != 0) {
ERRLOG("BOSecurity:VerifyAESMac error\n");
DEBUGLOG(("VerifyAESMac error\n"));
                        iRet = INT_MAC_ERR;
                }

                FREE_ME(csOut);
                FREE_ME(csMac);
        }

DEBUGLOG(("VerifyAESMac normal return  = [%d]\n",iRet));
        return iRet;
}


int GenerateAESMac(hash_t *hContext,
                hash_t* hOut)
{

        int     iRet = PD_OK;
        char    *csEncTypePtr;
        char    *csDataPtr;
        char    *csKeyPtr;
        char    *csOut;
        unsigned long   lOutLen;
        char    *csMac;

DEBUGLOG(("GenerateAESMac()\n"));

/* enc_type */
        if (GetField_CString(hOut,"enc_type",&csEncTypePtr)) {
DEBUGLOG(("GenerateAESMac enc_type = [%s]\n",csEncTypePtr));
        }
        else {
DEBUGLOG(("GenerateAESMac enc_type is missing!!!\n"));
ERRLOG("BOSecurity:GenerateAESMac enc_type is missing!!!\n");
                iRet = INT_ERR;
        }


/* key */
        if (GetField_CString(hContext,"key",&csKeyPtr)) {
DEBUGLOG(("GenerateAESMac key = [%s][%d]\n",csKeyPtr,strlen(csKeyPtr)));
        }
        else {
DEBUGLOG(("GenerateAESMac key is missing!!!\n"));
ERRLOG("BOSecurity:GenerateAESMac key missing!!!\n");
                iRet = INT_ERR;
        }

/* auth_data */
        if (GetField_CString(hOut,"auth_data",&csDataPtr)) {
DEBUGLOG(("GenerateAESMac auth_data = [%s]\n",csDataPtr));
        }
        else {
DEBUGLOG(("GenerateAESMac auth_data is missing!!!\n"));
ERRLOG("BOSecurity:GenerateAESMac auth_data is missing!!!\n");
                iRet = INT_ERR;
        }

        if (iRet == PD_OK) {
                csOut = (char*)malloc (PD_TMP_MSG_BUF_LEN +1);
                csMac = (char*)malloc (PD_TMP_MSG_BUF_LEN +1);
                AES_CMAC((unsigned char*) csKeyPtr,(unsigned char*)csDataPtr,strlen(csDataPtr),(unsigned char*)csOut,&lOutLen);
                Hex2Ascii(csMac,(unsigned char*)csOut,lOutLen);
DEBUGLOG(("GenerateAESMac MAC = [%s][%d]\n",csMac,strlen(csMac)));

DEBUGLOG(("GenerateAESMac to lower letter\n"));
                csOut[0] = '\0';
                U2L(csMac,strlen(csMac),csOut);
DEBUGLOG(("GenerateAESMac MAC = [%s][%d]\n",csOut,strlen(csOut)));
                PutField_CString(hOut,"mac",csOut);

                FREE_ME(csOut);
                FREE_ME(csMac);
        }

DEBUGLOG(("GenerateAESMac normal return  = [%d]\n",iRet));
        return iRet;
}
