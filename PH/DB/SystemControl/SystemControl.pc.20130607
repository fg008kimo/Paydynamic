/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2010/07/19              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "SystemControl.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void SystemControl(char    cdebug)
{
	cDebug = cdebug;
}

int GetAllCodes(recordset_t* myRec)
{

	hash_t *myHash;
	EXEC SQL WHENEVER SQLERROR GOTO getallcodes_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;	
	
	EXEC SQL BEGIN DECLARE SECTION;
		varchar	v_code[PD_CODE_LEN + 1];
		varchar	v_value[PD_VALUE_LEN + 1];

		short	ind_code = -1;
		short	ind_value = -1;
	EXEC SQL END DECLARE SECTION;

//DEBUGLOG(("SystemControl::GetAllCoes()\n"));

	EXEC SQL DECLARE c_cursor_getallcodes CURSOR FOR
		SELECT 	sys_code,
			sys_val	
                FROM 	SYSTEM_CONTROL;


	EXEC SQL OPEN c_cursor_getallcodes;
        do {    
        	EXEC SQL FETCH c_cursor_getallcodes
              	INTO
			:v_code:ind_code,
			:v_value:ind_value;

		if (SQLCODE == SQL_NOT_FOUND) { 
                	break;
             	}

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

		if (ind_code >= 0) {
			v_code.arr[v_code.len] ='\0';
			PutField_CString(myHash,"code",(const char*)v_code.arr);
//DEBUGLOG(("GetAllCodes Code = [%s]\n",v_code.arr)); 
		}
		if (ind_value >= 0) {
			v_value.arr[v_value.len] ='\0';
			PutField_CString(myHash,"value",(const char*)v_value.arr);
//DEBUGLOG(("GetAllCodes value = [%s]\n",v_value.arr)); 
		}
		RecordSet_Add(myRec,myHash);
	}
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getallcodes;


/* DEBUGLOG(("GetAllCode Normal Exit\n")); */
	return  PD_OK;

getallcodes_error:
//DEBUGLOG(("getallodes_error code %d\n", sqlca.sqlcode));
//DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getallcodes;
        return PD_ERR;
}

int FindCode(const char* code,
                unsigned char* value)
{
        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_code[PD_CODE_LEN];

                varchar v_value[PD_VALUE_LEN +1 ];
                short   ind_value = -1;

        EXEC SQL END DECLARE SECTION;

        hv_code.len = strlen(code);
        memcpy(hv_code.arr,code,hv_code.len);
/* DEBUGLOG(("FindCode: code = [%.*s]\n",hv_code.len,hv_code.arr)); */

/*
	if (!strcmp(code,"CTPHDATE") ) {
        	EXEC SQL SELECT to_char(sysdate,'YYYYMMDD')
               	    INTO :v_value:ind_value
                FROM DUAL;
	}
	else {
*/
       	EXEC SQL SELECT sys_val
             	    INTO :v_value:ind_value
                FROM SYSTEM_CONTROL
                WHERE SYS_CODE = :hv_code;
//	}

        if (ind_value >= 0) {
                v_value.arr[v_value.len] = '\0';
                strcpy((char*)value,(const char*)v_value.arr);
/* DEBUGLOG(("value = [%s]\n",value)); */
                return FOUND;
        }
/* DEBUGLOG(("Code  NOT FOUND\n")); */
        return NOT_FOUND;
find_error:
//DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
//DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}

int Update(const unsigned char* code,
		const unsigned char* value)
{
        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		short   hv_return_value;
                varchar hv_code[PD_CODE_LEN];
                varchar hv_value[PD_VALUE_LEN];
		varchar	hv_update_user[PD_USER_LEN];

        EXEC SQL END DECLARE SECTION;

        hv_code.len = strlen((const char*)code);
        memcpy(hv_code.arr,code,hv_code.len);
/* DEBUGLOG(("update: code = [%.*s]\n",hv_code.len,hv_code.arr)); */

        hv_value.len = strlen((const char*)value);
        memcpy(hv_value.arr,value,hv_value.len);
/* DEBUGLOG(("update: value = [%.*s]\n",hv_value.len,hv_value.arr)); */

	hv_update_user.len = strlen(PD_UPDATE_USER);
        memcpy(hv_update_user.arr,PD_UPDATE_USER,hv_update_user.len);
/* DEBUGLOG(("update: update_user = [%.*s]\n",hv_update_user.len,hv_update_user.arr)); */
	EXEC SQL EXECUTE
                BEGIN
                :hv_return_value := sp_system_control_update(
					:hv_code,
					:hv_value,
					:hv_update_user);

                END;
        END-EXEC;

/* DEBUGLOG(("Update: RET = [%d]\n",hv_return_value)); */
        if (hv_return_value == SP_OK) {
                return PD_OK;
        }

        
        if (hv_return_value == SP_OTHER_ERR) {
ERRLOG("System_Control:update: SP_OTHER_ERR TxnAbort\n");
//DEBUGLOG(("Update: SP_OTHER_ERR TxnAbort\n"));
                return PD_OTHER_ERR;
        }


        if (hv_return_value == SP_ERR) {
ERRLOG("System_Control:update: SP_ERR TxnAbort\n");
//DEBUGLOG(("Update: SP_ERR TxnAbort\n"));
                return PD_ERR;
        }

        return PD_OK;

update_error:
//DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
//DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_ERR;
}

