/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2018/03/07              Elvis Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "internal.h"
#include "OLAutoUploadJobStatus.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;


void OLAutoUploadJobStatus(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hRls)
{
        int     iTmp;
        char    *csTmp;
        char    cTmp;

        EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_nature_path[PD_TMP_BUF_LEN];
                varchar         hv_provider_path[PD_TMP_BUF_LEN];
                varchar         hv_process_bank[PD_TMP_BUF_LEN];
		int		hv_exclude_mode;
                int             hv_job_seq;
                char            hv_status;
                varchar         hv_create_user[PD_USER_LEN];

                short           ind_nature_path = -1;
                short           ind_provider_path = -1;
                short           ind_process_bank = -1;
                short           ind_exclude_mode = -1;
                short           ind_job_seq = -1;
                short           ind_status = -1;
                short           ind_create_user = -1;

                short           hv_return_value;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

	if(GetField_CString(hRls,"nature_path",&csTmp))
        {
                hv_nature_path.len = strlen(csTmp);
                strncpy((char *)hv_nature_path.arr, csTmp, hv_nature_path.len);
                ind_nature_path = 0;
DEBUGLOG(("Add:nature_path = [%.*s]\n",hv_nature_path.len,hv_nature_path.arr));
        }

        if(GetField_CString(hRls,"provider_path",&csTmp))
        {
                hv_provider_path.len = strlen(csTmp);
                strncpy((char *)hv_provider_path.arr, csTmp, hv_provider_path.len);
                ind_provider_path = 0;
DEBUGLOG(("Add:provider_path = [%.*s]\n",hv_provider_path.len,hv_provider_path.arr));
        }

        if(GetField_CString(hRls,"process_bank",&csTmp))
        {
                hv_process_bank.len = strlen(csTmp);
                strncpy((char *)hv_process_bank.arr, csTmp, hv_process_bank.len);
                ind_process_bank = 0;
DEBUGLOG(("Add:process_bank = [%.*s]\n",hv_process_bank.len,hv_process_bank.arr));
        }

        if(GetField_Int(hRls,"exclude_mode", &iTmp))
        {
                hv_exclude_mode = iTmp;
                ind_exclude_mode = 0;
DEBUGLOG(("Add:exclude_mode = [%d]\n",hv_exclude_mode));
        }

        if(GetField_Int(hRls,"job_seq", &iTmp))
        {
                hv_job_seq = iTmp;
                ind_job_seq = 0;
DEBUGLOG(("Add:job_seq = [%d]\n",hv_job_seq));
        }

	if(GetField_Char(hRls, "status", &cTmp)) {
                hv_status = cTmp;
                ind_status = 0;
DEBUGLOG(("Add:status = [%c]\n",hv_status));
        }

        if(GetField_CString(hRls,"create_user",&csTmp))
        {
                hv_create_user.len = strlen(csTmp);
                strncpy((char *)hv_create_user.arr, csTmp, hv_create_user.len);
                ind_create_user = 0;
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));
        }

	EXEC SQL EXECUTE
                BEGIN

                :hv_return_value := sp_ol_auto_upl_job_status_ins(
                                        :hv_nature_path:ind_nature_path,
                                        :hv_provider_path:ind_provider_path,
                                        :hv_process_bank:ind_process_bank,
                                        :hv_exclude_mode:ind_exclude_mode,
                                        :hv_job_seq:ind_job_seq,
                                        :hv_status:ind_status,
                                        :hv_create_user:ind_create_user);

                 END;
        END-EXEC;

	DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
                DEBUGLOG(("Add:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
                ERRLOG("OLAutoUploadJobStatus_Add: SP_OTHER_ERR TxnAbort\n");
                DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
                ERRLOG("OLAutoUploadJobStatus_Add: SP_ERR TxnAbort\n");
                DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
                return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLAutoUploadJobStatus_Add: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int UpdateStatus(const hash_t *hRls)
{
	int     iTmp;
        char    *csTmp;
        char    cTmp;

        EXEC SQL WHENEVER SQLERROR GOTO updatestatus_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_nature_path[PD_TMP_BUF_LEN];
                varchar         hv_provider_path[PD_TMP_BUF_LEN];
                varchar         hv_process_bank[PD_TMP_BUF_LEN];
                int             hv_exclude_mode;
                int             hv_job_seq;
                char            hv_status;
                varchar         hv_update_user[PD_USER_LEN];

                short           ind_nature_path = -1;
                short           ind_provider_path = -1;
                short           ind_process_bank = -1;
                short           ind_exclude_mode = -1;
                short           ind_job_seq = -1;
                short           ind_status = -1;
                short           ind_update_user = -1;

                short   hv_return_value;
        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateStatus: Begin\n"));
	
        if(GetField_CString(hRls,"nature_path",&csTmp))
        {
                hv_nature_path.len = strlen(csTmp);
                strncpy((char *)hv_nature_path.arr, csTmp, hv_nature_path.len);
                ind_nature_path = 0;
DEBUGLOG(("UpdateStatus:nature_path = [%.*s]\n",hv_nature_path.len,hv_nature_path.arr));
        } else {
DEBUGLOG(("UpdateStatus:nature_path is missing\n"));
ERRLOG("OLAutoUploadJobStatus::UpdateStatus: nature_path is missing\n");
                return PD_ERR;
        }

        if(GetField_CString(hRls,"provider_path",&csTmp))
        {
                hv_provider_path.len = strlen(csTmp);
                strncpy((char *)hv_provider_path.arr, csTmp, hv_provider_path.len);
                ind_provider_path = 0;
DEBUGLOG(("UpdateStatus:provider_path = [%.*s]\n",hv_provider_path.len,hv_provider_path.arr));
        } else {
DEBUGLOG(("UpdateStatus:provider_path is missing\n"));
ERRLOG("OLAutoUploadJobStatus::UpdateStatus: provider_path is missing\n");
                return PD_ERR;
        }

        if(GetField_CString(hRls,"process_bank",&csTmp))
        {
                hv_process_bank.len = strlen(csTmp);
                strncpy((char *)hv_process_bank.arr, csTmp, hv_process_bank.len);
                ind_process_bank = 0;
DEBUGLOG(("UpdateStatus:process_bank = [%.*s]\n",hv_process_bank.len,hv_process_bank.arr));
        } else {
DEBUGLOG(("UpdateStatus:process_bank is missing\n"));
ERRLOG("OLAutoUploadJobStatus::UpdateStatus: process_bank is missing\n");
                return PD_ERR;
        }

        if(GetField_Int(hRls,"exclude_mode", &iTmp))
        {
                hv_exclude_mode = iTmp;
                ind_exclude_mode = 0;
DEBUGLOG(("UpdateStatus:exclude_mode = [%d]\n",hv_exclude_mode));
        } else {
DEBUGLOG(("UpdateStatus:exclude_mode is missing\n"));
ERRLOG("OLAutoUploadJobStatus::UpdateStatus: exclude_mode is missing\n");
                return PD_ERR;
	}

        if(GetField_Int(hRls,"job_seq", &iTmp))
        {
                hv_job_seq = iTmp;
                ind_job_seq = 0;
DEBUGLOG(("UpdateStatus:job_seq = [%d]\n",hv_job_seq));
        } else {
DEBUGLOG(("UpdateStatus:job_seq is missing\n"));
ERRLOG("OLAutoUploadJobStatus::UpdateStatus: job_seq is missing\n");
                return PD_ERR;
	}

        if(GetField_Char(hRls, "status", &cTmp)) {
                hv_status = cTmp;
                ind_status = 0;
DEBUGLOG(("UpdateStatus:status = [%c]\n",hv_status));
        } else {
DEBUGLOG(("UpdateStatus:status is missing\n"));
ERRLOG("OLAutoUploadJobStatus::UpdateStatus: status is missing\n");
                return PD_ERR;
        }

        if(GetField_CString(hRls,"update_user",&csTmp))
        {
                hv_update_user.len = strlen(csTmp);
                strncpy((char *)hv_update_user.arr, csTmp, hv_update_user.len);
                ind_update_user = 0;
DEBUGLOG(("UpdateStatus:update_user = [%.*s]\n",hv_update_user.len,hv_update_user.arr));
        } else {
DEBUGLOG(("UpdateStatus:update_user is missing\n"));
ERRLOG("OLAutoUploadJobStatus::UpdateStatus: update_user is missing\n");
                return PD_ERR;
        }

	
        EXEC SQL EXECUTE
                BEGIN

                :hv_return_value := sp_ol_auto_upl_job_status_upd(
                                        :hv_nature_path:ind_nature_path,
                                        :hv_provider_path:ind_provider_path,
                                        :hv_process_bank:ind_process_bank,
                                        :hv_exclude_mode:ind_exclude_mode,
                                        :hv_job_seq:ind_job_seq,
                                        :hv_status:ind_status,
                                        :hv_update_user:ind_update_user);

                 END;
        END-EXEC;

        DEBUGLOG(("UpdateStatus:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
                DEBUGLOG(("UpdateStatus:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
                ERRLOG("OLAutoUploadJobStatus_UpdateStatus: SP_OTHER_ERR TxnAbort\n");
                DEBUGLOG(("UpdateStatus: SP_OTHER_ERR TxnAbort\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
                ERRLOG("OLAutoUploadJobStatus_UpdateStatus: SP_ERR TxnAbort\n");
                DEBUGLOG(("UpdateStatus: SP_ERR TxnAbort\n"));
                return PD_ERR;
        }

updatestatus_error:
DEBUGLOG(("updatestatus_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLAutoUploadJobStatus_UpdateStatus: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}


int GetStatus(hash_t *hRls)
{
	int     iCnt = 0;
       	int	iTmp = 0;
	char    *csTmp = NULL;

        EXEC SQL WHENEVER SQLERROR GOTO getstatus_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_nature_path[PD_TMP_BUF_LEN];
                varchar         hv_provider_path[PD_TMP_BUF_LEN];
                varchar         hv_process_bank[PD_TMP_BUF_LEN];
                int             hv_exclude_mode;

		short   	hv_return_value;

                int             v_job_seq;
                char            v_status;

                short           ind_job_seq = -1;
                short           ind_status = -1;

		SQL_CURSOR      c_cursor_getstatus;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("GetStatus: Begin\n"));
	
        if(GetField_CString(hRls,"nature_path",&csTmp))
        {
                hv_nature_path.len = strlen(csTmp);
                strncpy((char *)hv_nature_path.arr, csTmp, hv_nature_path.len);
DEBUGLOG(("GetStatus:nature_path = [%.*s]\n",hv_nature_path.len,hv_nature_path.arr));
        } else {
DEBUGLOG(("GetStatus:nature_path is missing\n"));
ERRLOG("OLAutoUploadJobStatus::GetStatus: nature_path is missing\n");
                return PD_ERR;
        }

        if(GetField_CString(hRls,"provider_path",&csTmp))
        {
                hv_provider_path.len = strlen(csTmp);
                strncpy((char *)hv_provider_path.arr, csTmp, hv_provider_path.len);
DEBUGLOG(("GetStatus:provider_path = [%.*s]\n",hv_provider_path.len,hv_provider_path.arr));
        } else {
DEBUGLOG(("GetStatus:provider_path is missing\n"));
ERRLOG("OLAutoUploadJobStatus::GetStatus: provider_path is missing\n");
                return PD_ERR;
        }

        if(GetField_CString(hRls,"process_bank",&csTmp))
        {
                hv_process_bank.len = strlen(csTmp);
                strncpy((char *)hv_process_bank.arr, csTmp, hv_process_bank.len);
DEBUGLOG(("GetStatus:process_bank = [%.*s]\n",hv_process_bank.len,hv_process_bank.arr));
        } else {
DEBUGLOG(("GetStatus:process_bank is missing\n"));
ERRLOG("OLAutoUploadJobStatus::GetStatus: process_bank is missing\n");
                return PD_ERR;
        }

        if(GetField_Int(hRls,"exclude_mode", &iTmp))
        {
                hv_exclude_mode = iTmp;
DEBUGLOG(("GetStatus:exclude_mode = [%d]\n",hv_exclude_mode));
        } else {
DEBUGLOG(("GetStatus:exclude_mode is missing\n"));
ERRLOG("OLAutoUploadJobStatus::GetStatus: exclude_mode is missing\n");
                return PD_ERR;
	}

	EXEC SQL ALLOCATE       :c_cursor_getstatus;	
        EXEC SQL EXECUTE
                BEGIN

                :hv_return_value := sp_ol_auto_upl_job_status_get(
                                        :hv_nature_path,
                                        :hv_provider_path,
                                        :hv_process_bank,
                                        :hv_exclude_mode,
					:c_cursor_getstatus);

                 END;
        END-EXEC;

DEBUGLOG(("GetStatus:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
		for (;;) {

                        ind_job_seq = -1;
                        ind_status = -1;

                        EXEC SQL WHENEVER NOTFOUND DO break;
                        EXEC SQL FETCH :c_cursor_getstatus

                        INTO
                                :v_job_seq:ind_job_seq,
                                :v_status:ind_status;

                        if (SQLCODE == SQL_NOT_FOUND) {
                                break;
                        }

/* job_seq */
                        if(ind_job_seq>=0){
                                PutField_Int(hRls,"job_seq",v_job_seq);
DEBUGLOG((" job_seq = [%d]\n",v_job_seq));
                        }

/* status */
                        if(ind_status>=0){
                                PutField_Char(hRls,"status",v_status);
DEBUGLOG((" status = [%c]\n",v_status));
                        }

                        iCnt++;
		}

                DEBUGLOG(("GetStatus:Found\n"));
                return PD_FOUND;
        }
	else if (hv_return_value == SP_NOT_FOUND)
        {
		DEBUGLOG(("GetStatus:Not Found\n"));
                return PD_NOT_FOUND;
        }
        else if (hv_return_value == SP_OTHER_ERR)  {
                ERRLOG("OLAutoUploadJobStatus_GetStatus: SP_OTHER_ERR TxnAbort\n");
                DEBUGLOG(("GetStatus: SP_OTHER_ERR TxnAbort\n"));
                return PD_OTHER_ERR;
        }
        else if (hv_return_value == SP_ERR)  {
                ERRLOG("OLAutoUploadJobStatus_GetStatus: SP_ERR TxnAbort\n");
                DEBUGLOG(("GetStatus: SP_ERR TxnAbort\n"));
                return PD_ERR;
        }

	EXEC SQL CLOSE :c_cursor_getstatus;
        EXEC SQL FREE :c_cursor_getstatus;

getstatus_error:
DEBUGLOG(("getstatus_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLAutoUploadJobStatus_GetStatus: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_getstatus;
        EXEC SQL FREE :c_cursor_getstatus;
        return PD_ERR;
}
