/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/04/11              LokMan Chow
Changed FindBalancebyCccy return type to hash_t*   2011/05/30		   Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "SebBalance.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;
void SebBalance(char    cdebug)
{
        cDebug = cdebug;
}


int Add(const hash_t *hRls)
{
	char            *csTmp;
	double          dTmp;


	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

	short           hv_return_value;

	varchar         hv_from_ccy[PD_CCY_ID_LEN];
	varchar         hv_bank_ccy[PD_CCY_ID_LEN];
	double          hv_bank_bal;
	double		hv_dsp_bal;
	double          hv_rate;
	double          hv_ratio;
	varchar         hv_add_user[PD_USER_LEN];

	short           ind_from_ccy = -1;
	short           ind_bank_ccy = -1;
	short           ind_bank_bal = -1;
	short		ind_dsp_bal = -1;
	short           ind_rate = -1;
	short           ind_ratio = -1;
	short           ind_add_user = -1;

	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));


/* from_ccy */
        if (GetField_CString(hRls,"from_ccy",&csTmp)) {
                hv_from_ccy.len = strlen(csTmp);
                memcpy(hv_from_ccy.arr,csTmp,hv_from_ccy.len);
                ind_from_ccy = 0;
DEBUGLOG(("Add:from_ccy = [%.*s]\n",hv_from_ccy.len,hv_from_ccy.arr));
        }

/* bank_ccy */
        if (GetField_CString(hRls,"bank_ccy",&csTmp)) {
                hv_bank_ccy.len = strlen(csTmp);
                memcpy(hv_bank_ccy.arr,csTmp,hv_bank_ccy.len);
                ind_bank_ccy = 0;
DEBUGLOG(("Add:bank_ccy = [%.*s]\n",hv_bank_ccy.len,hv_bank_ccy.arr));
        }


/* bank_bal   */
        if (GetField_Double(hRls,"bank_bal",&dTmp)) {
                hv_bank_bal= dTmp;
                ind_bank_bal = 0;
DEBUGLOG(("Add:bank_bal = [%f]\n",hv_bank_bal));
        }

/* dsp_bal   */
        if (GetField_Double(hRls,"dsp_bal",&dTmp)) {
                hv_dsp_bal= dTmp;
                ind_dsp_bal = 0;
DEBUGLOG(("Add:dsp_bal = [%f]\n",hv_dsp_bal));
        }



/* rate   */
        if (GetField_Double(hRls,"rate",&dTmp)) {
                hv_rate= dTmp;
                ind_rate = 0;
DEBUGLOG(("Add:rate = [%f]\n",hv_rate));
        }

/* ratio   */
        if (GetField_Double(hRls,"ratio",&dTmp)) {
                hv_ratio= dTmp;
                ind_ratio = 0;
DEBUGLOG(("Add:ratio = [%f]\n",hv_ratio));
        }

/* user */
        if (GetField_CString(hRls,"add_user",&csTmp)) {
                hv_add_user.len = strlen(csTmp);
                memcpy(hv_add_user.arr,csTmp,hv_add_user.len);
                ind_add_user = 0;
DEBUGLOG(("Add:add_user = [%.*s]\n",hv_add_user.len,hv_add_user.arr));
        }

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_seb_balance_insert(
					:hv_from_ccy:ind_from_ccy,
					:hv_bank_ccy:ind_bank_ccy,
					:hv_bank_bal:ind_bank_bal,
					:hv_dsp_bal:ind_dsp_bal,
					:hv_rate:ind_rate,
					:hv_ratio:ind_ratio,
					:hv_add_user:ind_add_user);
		END;
	END-EXEC;


DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK) {
DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("SebBalance_Add: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("SebBalance_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
                TxnAbort();
                return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("SebBalance_Add: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_INTERNAL_ERR TxnAbort\n"));
        TxnAbort();
        return PD_INTERNAL_ERR;
}



int FindBalanceByCcy(const char* csFromCcy,const char* csBankCcy,hash_t* hRec)
{

	int	iRet = PD_NOT_FOUND;
        EXEC SQL WHENEVER SQLERROR GOTO find_bal_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_from_ccy[PD_CCY_ID_LEN];
		varchar		hv_bank_ccy[PD_CCY_ID_LEN];

		double		v_bank_bal;
		double		v_dsp_bal;
		double		v_rate;
		double		v_ratio;

		short		ind_bank_bal= -1;
		short		ind_dsp_bal= -1;
		short		ind_rate= -1;
		short		ind_ratio= -1;


        EXEC SQL END DECLARE SECTION;

	hv_from_ccy.len = strlen(csFromCcy);
	memcpy(hv_from_ccy.arr,csFromCcy,hv_from_ccy.len);
DEBUGLOG(("FindBalance from_ccy = [%.*s]\n",hv_from_ccy.len,hv_from_ccy.arr));

	hv_bank_ccy.len = strlen(csBankCcy);
	memcpy(hv_bank_ccy.arr,csBankCcy,hv_bank_ccy.len);
DEBUGLOG(("FindBalance bank_ccy = [%.*s]\n",hv_bank_ccy.len,hv_bank_ccy.arr));


        EXEC SQL DECLARE c_cursor_find_bal CURSOR FOR
		select s_bank_bal,
		       s_dsp_bal,
		       s_rate,
                       s_ratio
  		  from seb_balance
                 where s_bank_ccy = :hv_bank_ccy
                   and s_from_ccy = :hv_from_ccy;


        EXEC SQL OPEN c_cursor_find_bal;
        do {
                EXEC SQL FETCH c_cursor_find_bal
                INTO
			:v_bank_bal:ind_bank_bal,
			:v_dsp_bal:ind_dsp_bal,
			:v_rate:ind_rate,
			:v_ratio:ind_ratio;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }


/* bank_bal */
                if (ind_bank_bal >= 0) { 
                        PutField_Double(hRec,"bank_bal",v_bank_bal);
DEBUGLOG(("FindBalance bank_bal = [%f]\n",v_bank_bal));
		}
/* dsp_bal */
                if (ind_dsp_bal >= 0) { 
                        PutField_Double(hRec,"dsp_bal",v_dsp_bal);
DEBUGLOG(("FindBalance dsp_bal = [%f]\n",v_dsp_bal));
		}
/* rate */
                if (ind_rate >= 0) {
                        PutField_Double(hRec,"rate",v_rate);
DEBUGLOG(("FindBalance rate = [%f]\n",v_rate));
                }

/* ratio */  
                if (ind_ratio >= 0) {
                        PutField_Double(hRec,"ratio",v_ratio);
DEBUGLOG(("FindBalance ratio = [%f]\n",v_ratio));
                }  
                   
		iRet = PD_FOUND;
		break; //*****************only one now
	}
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_find_bal;

	if(iRet==PD_FOUND){
DEBUGLOG(("FindBalance Normal Exit\n")); 
	}
	else{
DEBUGLOG(("FindBalance Not found\n"));
	}

        return  iRet;

find_bal_error:
DEBUGLOG(("find_bal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("SebBalance_Find: SP_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_find_bal;
        return PD_ERR;
}


int FindAllBalance(recordset_t* myRec)
{

	int	iRet = PD_NOT_FOUND;
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO find_allbal_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		v_from_ccy[PD_CCY_ID_LEN+1];
		varchar		v_bank_ccy[PD_CCY_ID_LEN+1];
		double		v_bank_bal;
		double		v_rate;
		double		v_ratio;

		short		ind_from_ccy= -1;
		short		ind_bank_ccy= -1;
		short		ind_bank_bal= -1;
		short		ind_rate= -1;
		short		ind_ratio= -1;


        EXEC SQL END DECLARE SECTION;


        EXEC SQL DECLARE c_cursor_find_allbal CURSOR FOR
		select s_from_ccy,
		       s_bank_ccy,
		       s_bank_bal,
		       s_rate,
                       s_ratio
  		  from seb_balance;


        EXEC SQL OPEN c_cursor_find_allbal;
        do {
                EXEC SQL FETCH c_cursor_find_allbal
                INTO
			:v_from_ccy:ind_from_ccy,
			:v_bank_ccy:ind_bank_ccy,
			:v_bank_bal:ind_bank_bal,
			:v_rate:ind_rate,
			:v_ratio:ind_ratio;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* from_ccy */
                if (ind_from_ccy >= 0) { 
                        PutField_CString(myHash,"from_ccy",(const char*)v_from_ccy.arr);
DEBUGLOG(("FindBalance from_ccy = [%.*s]\n",v_from_ccy.len,v_from_ccy.arr));
		}

/* bank_ccy */
                if (ind_bank_ccy >= 0) { 
                        PutField_CString(myHash,"bank_ccy",(const char*)v_bank_ccy.arr);
DEBUGLOG(("FindBalance bank_ccy = [%.*s]\n",v_bank_ccy.len,v_bank_ccy.arr));
		}


/* bank_bal */
                if (ind_bank_bal >= 0) { 
                        PutField_Double(myHash,"bank_bal",v_bank_bal);
DEBUGLOG(("FindBalance bank_bal = [%f]\n",v_bank_bal));
		}
/* rate */
                if (ind_rate >= 0) {
                        PutField_Double(myHash,"rate",v_rate);
DEBUGLOG(("FindBalance rate = [%f]\n",v_rate));
                }

/* ratio */  
                if (ind_ratio >= 0) {
                        PutField_Double(myHash,"ratio",v_ratio);
DEBUGLOG(("FindBalance ratio = [%f]\n",v_ratio));
                }  
                   
		iRet = PD_FOUND;
		RecordSet_Add(myRec,myHash);
	}
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_find_allbal;

	if(iRet==PD_FOUND){
DEBUGLOG(("FindAllBalance Normal Exit\n")); 
	}
	else{
DEBUGLOG(("FindAllBalance Not found\n"));
	}

        return  iRet;

find_allbal_error:
DEBUGLOG(("find_allbal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("SebBalance_FindAll: SP_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_find_allbal;
        return PD_ERR;
}


int FindBankBalanceInfo(const char* csBankCcy,recordset_t* myRec)
{

	int	iRet = PD_OK;
	int	iCnt = 0;
	hash_t*	myHash;

        EXEC SQL WHENEVER SQLERROR GOTO find_info_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_bank_ccy[PD_CCY_ID_LEN];

		varchar		v_from_ccy[PD_CCY_ID_LEN+1];
		double		v_bank_bal;
		double		v_dsp_bal;
		double		v_rate;
		double		v_ratio;

		short		ind_bank_bal= -1;
		short		ind_dsp_bal= -1;
		short		ind_rate= -1;
		short		ind_ratio= -1;
		short		ind_from_ccy= -1;


        EXEC SQL END DECLARE SECTION;

	hv_bank_ccy.len = strlen(csBankCcy);
	memcpy(hv_bank_ccy.arr,csBankCcy,hv_bank_ccy.len);
DEBUGLOG(("FindBankBalanceInfo bank_ccy = [%.*s]\n",hv_bank_ccy.len,hv_bank_ccy.arr));


        EXEC SQL DECLARE c_cursor_find_info CURSOR FOR
		select	s_from_ccy,
		 	s_bank_bal,
			s_dsp_bal,
			s_rate,
			s_ratio
		from	seb_balance
		where	s_bank_ccy = :hv_bank_ccy;

        EXEC SQL OPEN c_cursor_find_info;
        do {
                EXEC SQL FETCH c_cursor_find_info
                INTO
			:v_from_ccy:ind_from_ccy,
			:v_bank_bal:ind_bank_bal,
			:v_dsp_bal:ind_dsp_bal,
			:v_rate:ind_rate,
			:v_ratio:ind_ratio;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);


/* from_ccy */
		if(ind_from_ccy >= 0) {
			PutField_CString(myHash,"from_ccy",(const char*)v_from_ccy.arr);
DEBUGLOG(("FindBankBalanceInfo v_from_ccy = [%.*s]\n",v_from_ccy.len,v_from_ccy.arr));
		}

/* bank_bal */
                if (ind_bank_bal >= 0) { 
                        PutField_Double(myHash,"bank_bal",v_bank_bal);
DEBUGLOG(("FindBankBalanceInfo bank_bal = [%f]\n",v_bank_bal));
		}
/* dsp_bal */
                if (ind_dsp_bal >= 0) { 
                        PutField_Double(myHash,"dsp_bal",v_dsp_bal);
DEBUGLOG(("FindBankBalanceInfo dsp_bal = [%f]\n",v_dsp_bal));
		}
/* rate */
                if (ind_rate >= 0) {
                        PutField_Double(myHash,"rate",v_rate);
DEBUGLOG(("FindBankBalanceInfo rate = [%f]\n",v_rate));
                }

/* ratio */  
                if (ind_ratio >= 0) {
                        PutField_Double(myHash,"ratio",v_ratio);
DEBUGLOG(("FindBankBalanceInfo ratio = [%f]\n",v_ratio));
                }  

		RecordSet_Add(myRec,myHash);
		iCnt ++;

	}
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_find_info;

	if(iCnt>0){
DEBUGLOG(("FindBankBalanceInfo Normal Exit [%d]\n",iRet)); 
	}
	else{
		iRet = PD_ERR;
DEBUGLOG(("FindBankBalanceInfo Not found [%d]\n",iRet));
	}

        return  iRet;

find_info_error:
DEBUGLOG(("find_info_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("SebBalance_FindBankBalanceInfo: SP_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_find_info;
        return PD_ERR;
}



int UpdateBankBalance(const char* csFromCcy,const char* csBankCcy,double dAmt)
{

        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_from_ccy[PD_CCY_ID_LEN];
		varchar		hv_bank_ccy[PD_CCY_ID_LEN];
		double		hv_bank_bal;

		short		ind_bank_bal= -1;
		short		ind_from_ccy= -1;
		short		ind_bank_ccy= -1;

		short           hv_return_value;

        EXEC SQL END DECLARE SECTION;

	hv_from_ccy.len = strlen(csFromCcy);
	memcpy(hv_from_ccy.arr,csFromCcy,hv_from_ccy.len);
	ind_from_ccy = 0;
DEBUGLOG(("UpdateBankBalance from_ccy = [%.*s]\n",hv_from_ccy.len,hv_from_ccy.arr));

	hv_bank_ccy.len = strlen(csBankCcy);
	memcpy(hv_bank_ccy.arr,csBankCcy,hv_bank_ccy.len);
	ind_bank_ccy = 0;
DEBUGLOG(("UpdateBankBalance bank_ccy = [%.*s]\n",hv_bank_ccy.len,hv_bank_ccy.arr));

	hv_bank_bal=dAmt;
	ind_bank_bal = 0;
DEBUGLOG(("UpdateBankBalance bank_bal = [%lf]\n",hv_bank_bal));

	EXEC SQL EXECUTE
            BEGIN

                :hv_return_value := sp_seb_balance_update_bal(
                                :hv_from_ccy:ind_from_ccy,
                                :hv_bank_ccy:ind_bank_ccy,
                                :hv_bank_bal:ind_bank_bal);

            END;
        END-EXEC;

DEBUGLOG(("UpdateBankBalance:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
DEBUGLOG(("UpdateBankBalance:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("SebBlance::UpdateBankBalance: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateBankBalance: SP_OTHER_ERR TxnAbort\n"));
                TxnAbort();
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("SebBlance::UpdateBankBalance: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateBankBalance: SP_ERR TxnAbort\n"));
                TxnAbort();
                return PD_ERR;
        }

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        TxnAbort();
        return PD_ERR;
}
