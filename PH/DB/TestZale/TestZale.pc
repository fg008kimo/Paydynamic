/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2019/08/26              Zale Ni
Add UpdateReturn Function                          2020/02/20              [ZBL]
Regex Testing                                      2021/07/30              [ZBL]
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include <regex.h>
#include "TestZale.h"
#include "common.h"
#include "dbutility.h"
#include "internal.h"
#include "utilitys.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

static char cDebug;

void TestZale(char cdebug)
{
	cDebug = cdebug;
}

int Add(const hash_t * hRls)
{
	char	cTmp;
	char	* csTmp;
	double	dTmp;
	int	iTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_txn_code[PD_TXN_CODE_LEN];
		char		hv_group;
		int		hv_flag;
		double		hv_value;
		varchar		hv_remark[PD_REMARK_LEN];
		varchar		hv_create_user[PD_USER_LEN];

		short		ind_txn_code = -1;
		short		ind_group = -1;
		short		ind_flag = -1;
		short		ind_value = -1;
		short		ind_remark = -1;
		short		ind_create_user = -1;

		short		hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

	/* txn_code */
	if (GetField_CString(hRls, "txn_code", &csTmp))
	{
		hv_txn_code.len = strlen(csTmp);
		strncpy((char *)hv_txn_code.arr, csTmp, hv_txn_code.len);
		ind_txn_code = 0;

DEBUGLOG(("Add: txn_code = [%.*s]\n", hv_txn_code.len, hv_txn_code.arr));
	}

	/* group */
	if (GetField_Char(hRls, "group", &cTmp))
	{
		hv_group = cTmp;
		ind_group = 0;

DEBUGLOG(("Add: group = [%c]\n", hv_group));
	}

	/* flag */
	if (GetField_Int(hRls, "flag", &iTmp))
	{
		hv_flag = iTmp;
		ind_flag = 0;

DEBUGLOG(("Add: flag = [%d]\n", hv_flag));
	}

	/* value */
	if (GetField_Double(hRls, "value", &dTmp))
	{
		hv_value = dTmp;
		ind_value = 0;

DEBUGLOG(("Add: value = [%lf]\n", hv_value));
	}

	/* remark */
	if (GetField_CString(hRls, "remark", &csTmp))
	{
		hv_remark.len = strlen(csTmp);
		strncpy((char *)hv_remark.arr, csTmp, hv_remark.len);
		ind_remark = 0;

DEBUGLOG(("Add: remark = [%.*s]\n", hv_remark.len, hv_remark.arr));
	}

	/* create_user */
	if (GetField_CString(hRls, "create_user", &csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char *)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;

DEBUGLOG(("Add: create_user = [%.*s]\n", hv_create_user.len, hv_create_user.arr));
	}

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_test_zale_insert(
				:hv_txn_code:ind_txn_code,
				:hv_group:ind_group,
				:hv_flag:ind_flag,
				:hv_value:ind_value,
				:hv_remark:ind_remark,
				:hv_create_user:ind_create_user);
		END;
	END-EXEC;

DEBUGLOG(("Add: Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("Add: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)
	{
ERRLOG("TestZale_Add: SP_OTHER_ERR\n");
DEBUGLOG(("Add: SP_OTHER_ERR\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)
	{
ERRLOG("TestZale_Add: SP_ERR\n");
DEBUGLOG(("Add: SP_ERR\n"));
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("TestZale_Add: SP_INTERNAL_ERR\n");
DEBUGLOG(("Add: SP_INTERNAL_ERR\n"));
	return PD_INTERNAL_ERR;
}

int IsValid()
{
	//const char	* csPattern = "[a-z0-9_-]";
	char		csTarget[PD_TMP_BUF_LEN];
	const char	* csPattern = "[a-z0-9_-\\+]";
	const size_t	sMatch = 1;
	int		iRet = SUCCESS;
	int		iStatus;
	regex_t		rePreg;
	regmatch_t	reResult[1];

	strcpy(csTarget, "99+_ap");
DEBUGLOG(("IsValid: Target = [%s]\n", csTarget));

	iRet = regcomp(&rePreg, csPattern, REG_EXTENDED | REG_ICASE);

	if (iRet != SUCCESS)
		return PD_ERR;

	iStatus = regexec(&rePreg, csTarget, sMatch, reResult, 0);

	if (iStatus == REG_NOMATCH)
	{
DEBUGLOG(("IsValid: Invalid characters within the target = [%s]\n", csTarget));
	}
	else if (iStatus == 0)
	{
DEBUGLOG(("IsValid: Valid target = [%s]\n", csTarget));
	}
	else
	{
		char csErrorMsg[256];

		regerror(iStatus, &rePreg, csErrorMsg, sizeof(csErrorMsg));
DEBUGLOG(("IsValid: Error meessage = [%s]\n", csErrorMsg));
	}

	regfree(&rePreg);

	return PD_OK;
}

int GetByTxnCode(const char * csTxnCode, hash_t * hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getbytxncode_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_txn_code[PD_TXN_CODE_LEN];

		char		v_group;
		int		v_flag;
		double		v_value;
		varchar		v_remark[PD_REMARK_LEN + 1];

		short		ind_group = -1;
		short		ind_flag = -1;
		short		ind_value = -1;
		short		ind_remark = -1;
	EXEC SQL END DECLARE SECTION;

	/* txn_code */
	hv_txn_code.len = strlen(csTxnCode);
	memcpy(hv_txn_code.arr, csTxnCode, hv_txn_code.len);
DEBUGLOG(("GetByTxnCode: csTxnCode = [%.*s]\n", hv_txn_code.len, hv_txn_code.arr));

	EXEC SQL SELECT tz_group, 
			tz_flag, 
			tz_value, 
			tz_remark
		INTO	:v_group:ind_group, 
			:v_flag:ind_flag, 
			:v_value:ind_value, 
			:v_remark:ind_remark
		FROM test_zale
		WHERE tz_txn_code = :hv_txn_code;

	/* group */
	if (ind_group >= 0)
	{
DEBUGLOG(("GetByTxnCode group = [%c]\n", v_group));
		PutField_Char(hRec, "group", v_group);

		/* flag */
		if (ind_flag >= 0)
		{
DEBUGLOG(("GetByTxnCode flag = [%d]\n", v_flag));
			PutField_Int(hRec, "flag", v_flag); 
		}

		/* value */
		if (ind_value >= 0)
		{
DEBUGLOG(("GetByTxnCode value = [%lf]\n", v_value));
			PutField_Double(hRec, "value", v_value);
		}

		/* remark */
		if (ind_remark >= 0)
		{
			v_remark.arr[v_remark.len] = '\0';
DEBUGLOG(("GetByTxnCode remark = [%s]\n", v_remark.arr));
			PutField_CString(hRec, "remark", (const char *)v_remark.arr);
		}

DEBUGLOG(("GetByTxnCode Normal Exit\n"));
		return PD_FOUND;
	}
	else
	{
DEBUGLOG(("GetByTxnCode Not Found\n"));
		return PD_NOT_FOUND;
	}

getbytxncode_error:
DEBUGLOG(("getbytxncode_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int GetByGroup(const char cGroup, recordset_t * myRec)
{
	hash_t  * myHash;
	int	iCnt = 0;

	EXEC SQL WHENEVER SQLERROR GOTO getbygroup_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		char		hv_group;

		varchar		v_txn_code[PD_TXN_CODE_LEN + 1];
		int		v_flag;
		double		v_value;
		varchar		v_remark[PD_REMARK_LEN + 1];

		short		ind_txn_code = -1;
		short		ind_flag = -1;
		short		ind_value = -1;
		short		ind_remark = -1;
	EXEC SQL END DECLARE SECTION;

	/* group */
	hv_group = cGroup;
DEBUGLOG(("GetByGroup: cGroup = [%c]\n", hv_group));

	EXEC SQL DECLARE c_cursor_getbygroup CURSOR FOR 
		SELECT  tz_txn_code, 
			tz_flag, 
			tz_value, 
			tz_remark
		FROM test_zale
		WHERE tz_group = :hv_group;

	EXEC SQL OPEN c_cursor_getbygroup;
	do
	{
		EXEC SQL FETCH c_cursor_getbygroup
			INTO	:v_txn_code:ind_txn_code, 
				:v_flag:ind_flag, 
				:v_value:ind_value, 
				:v_remark:ind_remark;

		if (SQLCODE == SQL_NOT_FOUND)
			break;

		myHash = (hash_t *)malloc(sizeof(hash_t));
		hash_init(myHash, 0);

		/* txn_code */
		if (ind_txn_code >= 0)
		{
			v_txn_code.arr[v_txn_code.len] = '\0';
DEBUGLOG(("GetByGroup txn_code = [%s]\n", v_txn_code.arr));
			PutField_CString(myHash, "txn_code", (const char *)v_txn_code.arr);
		}

		/* flag */
		if (ind_flag >= 0)
		{
DEBUGLOG(("GetByGroup flag = [%d]\n", v_flag));
			PutField_Int(myHash, "flag", v_flag);
		}

		/* value */
		if (ind_value >= 0)
		{
DEBUGLOG(("GetByGroup value = [%lf]\n", v_value));
			PutField_Double(myHash, "value", v_value);
		}

		/* remark */
		if (ind_remark >= 0)
		{
			v_remark.arr[v_remark.len] = '\0';
DEBUGLOG(("GetByGroup remark = [%s]\n", v_remark.arr));
			PutField_CString(myHash, "remark", (const char *)v_remark.arr);
		}

		iCnt++;
		RecordSet_Add(myRec, myHash);
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getbygroup;

	if (iCnt > 0)
	{
DEBUGLOG(("GetByGroup Normal Exit\n"));
		return PD_FOUND;
	}
	else
	{
DEBUGLOG(("GetByGroup Normal Exit, Not Found\n"));
		return PD_NOT_FOUND;
	}

getbygroup_error:
DEBUGLOG(("getbygroup_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getbygroup;
	return PD_ERR;
}

int Update(const hash_t * hRls)
{
	char	cTmp;
	char	* csTmp;
	char	* csTxnCode;
	double	dTmp = 0.0;
	int	iTmp = 0;

	EXEC SQL WHENEVER SQLERROR GOTO update_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_dynstmt[1024];
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));

	csTmp = (char *)malloc(128);

	strcpy((char *)hv_dynstmt.arr, "UPDATE test_zale SET tz_update_timestamp = SYSDATE");
	hv_dynstmt.len = strlen((const char *)hv_dynstmt.arr);

	/* txn_code */
	if (GetField_CString(hRls, "txn_code", &csTxnCode))
	{
DEBUGLOG(("Update: txn_code = [%s]\n", csTxnCode));
	}
	else
	{
		FREE_ME(csTmp);
DEBUGLOG(("Update txn_code not found\n"));

		return INT_ERR;
	}

	/* group */
	if (GetField_Char(hRls, "group", &cTmp))
	{
		sprintf(csTmp, "%c", cTmp);
		strcat((char *)hv_dynstmt.arr, ", tz_group = '");
		strcat((char *)hv_dynstmt.arr, csTmp);
		strcat((char *)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("Update: group = [%c]\n", cTmp));
	}

	/* flag */
	if (GetField_Int(hRls, "flag", &iTmp))
	{
		sprintf(csTmp, "%d", iTmp);
		strcat((char *)hv_dynstmt.arr, ", tz_flag = ");
		strcat((char *)hv_dynstmt.arr, csTmp);
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("Update: flag = [%d]\n", iTmp));
	}

	/* value */
	if (GetField_Double(hRls, "value", &dTmp))
	{
		sprintf(csTmp, "%lf", dTmp);
		strcat((char *)hv_dynstmt.arr, ", tz_value = ");
		strcat((char *)hv_dynstmt.arr, csTmp);
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("Update: value = [%lf]\n", dTmp));
	}

	/* remark */
	if (GetField_CString(hRls, "remark", &csTmp))
	{
		strcat((char *)hv_dynstmt.arr, ", tz_remark = '");
		strcat((char *)hv_dynstmt.arr, csTmp);
		strcat((char *)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("Update: remark = [%s]\n", csTmp));
	}

	/* update_user */
	if (GetField_CString(hRls, "create_user", &csTmp))
	{
		strcat((char *)hv_dynstmt.arr, ", tz_update_user = '");
		strcat((char *)hv_dynstmt.arr, csTmp);
		strcat((char *)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("Update: update_user = [%s]\n", csTmp));
	}

	strcat((char *)hv_dynstmt.arr, " WHERE tz_txn_code = '");
	strcat((char *)hv_dynstmt.arr, csTxnCode);
	strcat((char *)hv_dynstmt.arr, "'");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("Update SQL = [%.*s]\n", hv_dynstmt.len, hv_dynstmt.arr));

	EXEC SQL PREPARE PS FROM :hv_dynstmt;
	EXEC SQL EXECUTE PS;

	FREE_ME(csTmp);

DEBUGLOG(("Update Normal Exit\n"));
	return PD_OK;

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("TestZale_Update: SP_INTERNAL_ERR\n");
DEBUGLOG(("Update: SP_INTERNAL_ERR\n"));
	return PD_INTERNAL_ERR;
}

int UpdateReturn(const hash_t * hIn, hash_t * hOut)
{
	char	* csTxnCode;
	double	dValue = 0.0;

	EXEC SQL WHENEVER SQLERROR GOTO update_return_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_txn_code[PD_TXN_CODE_LEN];
		double		hv_value;

		char		v_group;
		int		v_flag;
		double		v_value;
		varchar		v_remark[PD_REMARK_LEN];

		short		ind_txn_code = -1;
		short		ind_group = -1;
		short		ind_flag = -1;
		short		ind_i_value = -1;
		short		ind_o_value = -1;
		short		ind_remark = -1;

		short		hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateReturn: Begin\n"));

	/* txn_code */
	if (GetField_CString(hIn, "txn_code", &csTxnCode))
	{
		hv_txn_code.len = strlen(csTxnCode);
		memcpy(hv_txn_code.arr, csTxnCode, hv_txn_code.len);
		strncpy((char *)hv_txn_code.arr, csTxnCode, hv_txn_code.len);
		ind_txn_code = 0;

DEBUGLOG(("UpdateReturn: txn_code = [%.*s]\n", hv_txn_code.len, hv_txn_code.arr));
	}
	else
	{
DEBUGLOG(("UpdateReturn txn_code not found\n"));

		return INT_ERR;
	}

	/* value */
	if (GetField_Double(hIn, "value", &dValue))
	{
		hv_value = dValue;
		ind_i_value = 0;

DEBUGLOG(("UpdateReturn: value = [%lf]\n", hv_value));
	}

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_test_zale_update_return(
				:hv_txn_code:ind_txn_code, 
				:hv_value:ind_i_value, 
				:v_group:ind_group, 
				:v_flag:ind_flag, 
				:v_value:ind_o_value, 
				:v_remark:ind_remark);
		END;
	END-EXEC;

DEBUGLOG(("UpdateReturn: Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK)
	{
		if (ind_group >= 0)
		{
DEBUGLOG(("UpdateReturn group = [%c]\n", v_group));
			PutField_Char(hOut, "group", v_group);
		}

		/* flag */
		if (ind_flag >= 0)
		{
DEBUGLOG(("UpdateReturn flag = [%d]\n", v_flag));
			PutField_Int(hOut, "flag", v_flag); 
		}

		/* value */
		if (ind_o_value >= 0)
		{
DEBUGLOG(("UpdateReturn value = [%lf]\n", v_value));
			PutField_Double(hOut, "value", v_value);
		}

		/* remark */
		if (ind_remark >= 0)
		{
			v_remark.arr[v_remark.len] = '\0';
DEBUGLOG(("UpdateReturn remark = [%s]\n", v_remark.arr));
			PutField_CString(hOut, "remark", (const char *)v_remark.arr);
		}

DEBUGLOG(("UpdateReturn: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)
	{
ERRLOG("TestZale_UpdateReturn: SP_OTHER_ERR\n");
DEBUGLOG(("UpdateReturn: SP_OTHER_ERR\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)
	{
ERRLOG("TestZale_UpdateReturn: SP_ERR\n");
DEBUGLOG(("UpdateReturn: SP_ERR\n"));
		return PD_ERR;
	}

update_return_error:
DEBUGLOG(("update_return_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("TestZale_UpdateReturn: SP_INTERNAL_ERR\n");
DEBUGLOG(("UpdateReturn: SP_INTERNAL_ERR\n"));
	return PD_INTERNAL_ERR;
}

int UpdateReturnCursor(const hash_t * hIn, hash_t * hOut)
{
	char	* csTxnCode;
	double	dValue = 0.0;
	int	iRet = PD_OK;

	EXEC SQL WHENEVER SQLERROR GOTO update_return_cursor_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_txn_code[PD_TXN_CODE_LEN];
		double		hv_value;

		SQL_CURSOR	v_cursor;
		/* sp_test_update_return_c2 */
		/*
		struct
		{
			char	v_group;
			int	v_flag;
			double	v_value;
			varchar	v_remark[PD_REMARK_LEN];
		} updated_info;
		*/
		/* sp_test_update_return_c3 */
		char		v_group;
		int			v_flag;
		double		v_value;
		varchar		v_remark[PD_REMARK_LEN];

		short		ind_txn_code = -1;
		short		ind_value = -1;
		/* sp_test_update_return_c2 */
		/*
		struct
		{
			short	ind_group;
			short	ind_flag;
			short	ind_value;
			short	ind_remark;
		} updated_info_ind;
		*/
		/* sp_test_update_return_c3 */
		short		ind_group = -1;
		short		ind_flag = -1;
		short		ind_o_value = -1;
		short		ind_remark = -1;

		short		hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateReturnCursor: Begin\n"));

	/* txn_code */
	if (GetField_CString(hIn, "txn_code", &csTxnCode))
	{
		hv_txn_code.len = strlen(csTxnCode);
		memcpy(hv_txn_code.arr, csTxnCode, hv_txn_code.len);
		strncpy((char *)hv_txn_code.arr, csTxnCode, hv_txn_code.len);
		ind_txn_code = 0;

DEBUGLOG(("UpdateReturnCursor: txn_code = [%.*s]\n", hv_txn_code.len, hv_txn_code.arr));
	}
	else
	{
DEBUGLOG(("UpdateReturnCursor txn_code not found\n"));

		return INT_ERR;
	}

	/* value */
	if (GetField_Double(hIn, "value", &dValue))
	{
		hv_value = dValue;
		ind_value = 0;

DEBUGLOG(("UpdateReturnCursor: value = [%lf]\n", hv_value));
	}

	/* Allocate the cursor variable */
	EXEC SQL ALLOCATE :v_cursor;

	EXEC SQL EXECUTE
		BEGIN
//			:hv_return_value := sp_test_zale_update_return_c2(
			:hv_return_value := sp_test_zale_update_return_c3(
				:hv_txn_code:ind_txn_code, 
				:hv_value:ind_value, 
				:v_cursor);
		END;
	END-EXEC;

DEBUGLOG(("UpdateReturnCursor: Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK)
	{
		/* sp_test_update_return_c2 */
		/*
		EXEC SQL FETCH :v_cursor 
			INTO :updated_info:updated_info_ind;
		*/
		/* sp_test_update_return_c3 */
		EXEC SQL FETCH :v_cursor 
			INTO	:v_group:ind_group, 
					:v_flag:ind_flag, 
					:v_value:ind_o_value, 
					:v_remark:ind_remark;

		/* sp_test_update_return_c2 */
		/* group */
		/*
		if (updated_info_ind.ind_group >= 0)
		{
DEBUGLOG(("UpdateReturnCursor group = [%c]\n", updated_info.v_group));
			PutField_Char(hOut, "group", updated_info.v_group);
		}
		*/
		/* flag */
		/*
		if (updated_info_ind.ind_flag >= 0)
		{
DEBUGLOG(("UpdateReturnCursor flag = [%d]\n", updated_info.v_flag));
			PutField_Int(hOut, "flag", updated_info.v_flag); 
		}
		*/
		/* value */
		/*
		if (updated_info_ind.ind_value >= 0)
		{
DEBUGLOG(("UpdateReturn value = [%lf]\n", updated_info.v_value));
			PutField_Double(hOut, "value", updated_info.v_value);
		}
		*/
		/* remark */
		/*
		if (updated_info_ind.ind_remark >= 0)
		{
			updated_info.v_remark.arr[updated_info.v_remark.len] = '\0';
DEBUGLOG(("UpdateReturn remark = [%s]\n", updated_info.v_remark.arr));
			PutField_CString(hOut, "remark", (const char *)(updated_info.v_remark.arr));
		}
		*/
		/* sp_test_update_return_c3 */
		/* group */
		if (ind_group >= 0)
		{
DEBUGLOG(("UpdateReturnCursor group = [%c]\n", v_group));
			PutField_Char(hOut, "group", v_group);
		}

		/* flag */
		if (ind_flag >= 0)
		{
DEBUGLOG(("UpdateReturnCursor flag = [%d]\n", v_flag));
			PutField_Int(hOut, "flag", v_flag); 
		}

		/* value */

		if (ind_o_value >= 0)
		{
DEBUGLOG(("UpdateReturn value = [%lf]\n", v_value));
			PutField_Double(hOut, "value", v_value);
		}

		/* remark */
		if (ind_remark >= 0)
		{
			v_remark.arr[v_remark.len] = '\0';
DEBUGLOG(("UpdateReturn remark = [%s]\n", v_remark.arr));
			PutField_CString(hOut, "remark", (const char *)(v_remark.arr));
		}

DEBUGLOG(("UpdateReturnCursor: Normal Exit\n"));
		iRet = PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)
	{
ERRLOG("TestZale_UpdateReturnCursor: SP_OTHER_ERR\n");
DEBUGLOG(("UpdateReturnCursor: SP_OTHER_ERR\n"));
		iRet = PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)
	{
ERRLOG("TestZale_UpdateReturnCursor: SP_ERR\n");
DEBUGLOG(("UpdateReturnCursor: SP_ERR\n"));
		iRet =  PD_ERR;
	}

	/* Close and free the cursor */
	EXEC SQL CLOSE :v_cursor;
	EXEC SQL FREE :v_cursor;

	return iRet;

update_return_cursor_error:
DEBUGLOG(("update_return_cursor_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :v_cursor;
	EXEC SQL FREE :v_cursor;
ERRLOG("TestZale_UpdateReturnCursor: SP_INTERNAL_ERR\n");
DEBUGLOG(("UpdateReturnCursor: SP_INTERNAL_ERR\n"));
	return PD_INTERNAL_ERR;
}
