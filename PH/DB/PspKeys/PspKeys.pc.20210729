/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/01/07              LokMan Chow
Add key_id					   2011/05/27		   Cody Chan
Add UID,PrivatePem,PublicCert and PassPhrse	   2011/11/11		   Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "PspKeys.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void PspKeys(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hPspKeys)
{
	char            *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_psp_id[PD_PSP_ID_LEN];
		varchar		hv_key_value[PD_MD5_KEY_LEN];
		varchar		hv_key[PD_MD5_KEY_LEN];
		varchar		hv_key_id[PD_KEY_ID_LEN];
		varchar		hv_key_uid[PD_KEY_UID_LEN];
		varchar		hv_privatepem[PD_PRIVATEPEM_LEN];
		varchar		hv_publiccert[PD_PUBLICCERT_LEN];
		varchar		hv_passphrase[PD_PASSPHRASE_LEN];
		varchar 	hv_create_user[PD_USER_LEN];
		varchar 	hv_effect_date[PD_DATE_LEN];


		short		ind_psp_id = -1;
		short		ind_key_value = -1;
		short		ind_key = -1;
		short		ind_key_id = -1;
		short		ind_key_uid = -1;
		short		ind_privatepem = -1;
		short		ind_publiccert = -1;
		short		ind_passphrase = -1;
		short		ind_create_user = -1;
		short		ind_effect_date = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Add: Begin\n"));


	if(GetField_CString(hPspKeys,"psp_id",&csTmp))
	{
		hv_psp_id.len = strlen(csTmp);
		strncpy((char*)hv_psp_id.arr, csTmp, hv_psp_id.len);
		ind_psp_id = 0;
	}
DEBUGLOG(("Add:psp_id = [%.*s]\n",hv_psp_id.len,hv_psp_id.arr));


	if(GetField_CString(hPspKeys,"key_value",&csTmp))
	{
		hv_key_value.len = strlen(csTmp);
		strncpy((char*)hv_key_value.arr, csTmp, hv_key_value.len);
		ind_key_value = 0;
	}
DEBUGLOG(("Add:key_value = [%.*s]\n",hv_key_value.len,hv_key_value.arr));

	if(GetField_CString(hPspKeys,"key",&csTmp))
	{
		hv_key.len = strlen(csTmp);
		strncpy((char*)hv_key.arr, csTmp, hv_key.len);
		ind_key = 0;
	}
DEBUGLOG(("Add:key = [%.*s]\n",hv_key.len,hv_key.arr));

	if(GetField_CString(hPspKeys,"key_id",&csTmp))
	{
		hv_key_id.len = strlen(csTmp);
		strncpy((char*)hv_key_id.arr, csTmp, hv_key_id.len);
		ind_key_id = 0;
	}
DEBUGLOG(("Add:key_id = [%.*s]\n",hv_key_id.len,hv_key_id.arr));

	if(GetField_CString(hPspKeys,"key_uid",&csTmp))
	{
		hv_key_uid.len = strlen(csTmp);
		strncpy((char*)hv_key_uid.arr, csTmp, hv_key_uid.len);
		ind_key_uid = 0;
	}
DEBUGLOG(("Add:key_uid = [%.*s]\n",hv_key_uid.len,hv_key_uid.arr));

	if(GetField_CString(hPspKeys,"privatepem",&csTmp))
	{
		hv_privatepem.len = strlen(csTmp);
		strncpy((char*)hv_privatepem.arr, csTmp, hv_privatepem.len);
		ind_privatepem = 0;
	}
DEBUGLOG(("Add:privatepem = [%.*s]\n",hv_privatepem.len,hv_privatepem.arr));

	if(GetField_CString(hPspKeys,"publiccert",&csTmp))
	{
		hv_publiccert.len = strlen(csTmp);
		strncpy((char*)hv_publiccert.arr, csTmp, hv_publiccert.len);
		ind_publiccert = 0;
	}
DEBUGLOG(("Add:publiccert = [%.*s]\n",hv_publiccert.len,hv_publiccert.arr));

	if(GetField_CString(hPspKeys,"passphrase",&csTmp))
	{
		hv_passphrase.len = strlen(csTmp);
		strncpy((char*)hv_passphrase.arr, csTmp, hv_passphrase.len);
		ind_passphrase = 0;
	}
DEBUGLOG(("Add:passphrase = [%.*s]\n",hv_passphrase.len,hv_passphrase.arr));

	if(GetField_CString(hPspKeys,"create_user",&csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));

	if(GetField_CString(hPspKeys,"effect_date",&csTmp))
	{
		hv_effect_date.len = strlen(csTmp);
		strncpy((char*)hv_effect_date.arr, csTmp, hv_effect_date.len);
		ind_effect_date= 0;
	}
DEBUGLOG(("Add:effect_date = [%.*s]\n",hv_effect_date.len,hv_effect_date.arr));


	FREE_ME(csTmp);


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_psp_keys_insert(
				:hv_psp_id:ind_psp_id,
				:hv_key:ind_key,
				:hv_key_value:ind_key_value,
				:hv_key_id:ind_key_id,
				:hv_key_uid:ind_key_uid,
				:hv_privatepem:ind_privatepem,
				:hv_publiccert:ind_publiccert,
				:hv_passphrase:ind_passphrase,
				:hv_create_user:ind_create_user,
				to_date(:hv_effect_date:ind_effect_date,'yyyymmdd'));

	    END;
	END-EXEC;


	DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("PspKeys_Add: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("PspKeys_Add: SP_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

add_error:
	DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;


}




int Delete(const char* psp_id, const char* key)
{
	EXEC SQL WHENEVER SQLERROR GOTO delete_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
	        varchar	hv_key[PD_KEY_NAME_LEN];
		varchar hv_psp_id[PD_PSP_ID_LEN];

		short	hv_return_value;
	EXEC SQL END DECLARE SECTION;


	hv_key.len = strlen((const char*)key);
	memcpy(hv_key.arr,key,hv_key.len);
DEBUGLOG(("Delete: key = [%.*s]\n",hv_key.len,hv_key.arr));

	hv_psp_id.len = strlen((const char*)psp_id);
	memcpy(hv_psp_id.arr,psp_id,hv_psp_id.len);
DEBUGLOG(("Delete: psp_id = [%.*s]\n",hv_psp_id.len,hv_psp_id.arr));

	EXEC SQL EXECUTE
	    BEGIN
		
		:hv_return_value := sp_psp_keys_delete(
				:hv_psp_id,
				:hv_key);

	    END;
	END-EXEC;


	DEBUGLOG(("Delete:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("Delete:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("PspKeys_Delete: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Delete: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("PspKeys_Delete: SP_ERR TxnAbort\n");
DEBUGLOG(("Delete: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

delete_error:
	DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;

}


int GetPspKey(const char* csPspId,const char* csKey,
                recordset_t* myRec)
{
	int iRet = 0;
                
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getpspkey_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_psp_id[PD_PSP_ID_LEN];
		varchar		hv_key[PD_KEY_NAME_LEN + 1];
                
		varchar		v_key_value[PD_MD5_KEY_LEN + 1];
		varchar		v_key_id[PD_KEY_ID_LEN +1];
		varchar		v_key_uid[PD_KEY_UID_LEN +1];
		varchar		v_privatepem[PD_PRIVATEPEM_LEN +1];
		varchar		v_publiccert[PD_PUBLICCERT_LEN +1];
		varchar		v_passphrase[PD_PASSPHRASE_LEN +1];

		short		ind_key_value = -1;
		short		ind_key_id = -1;
		short		ind_key_uid = -1;
		short		ind_privatepem = -1;
		short		ind_publiccert = -1;
		short		ind_passphrase = -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_psp_id.len = strlen(csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);
DEBUGLOG(("GetPspKey psp_id = [%.*s]\n",hv_psp_id.len,hv_psp_id.arr));
        
        hv_key.len = strlen(csKey);
        memcpy(hv_key.arr,csKey,hv_key.len);
DEBUGLOG(("GetPspKey key = [%.*s]\n",hv_key.len,hv_key.arr));
        
        EXEC SQL DECLARE c_cursor_getpspkey CURSOR FOR
                select 
		       	key_value,
		       	key_id,
		        key_uid,
		       	privatepem,
			publiccert,
			passphrase
                  from psp_keys
		 where psp_id = :hv_psp_id
		 and   key = :hv_key
		 AND   effect_date  =
                        (SELECT max(effect_date)
                           FROM psp_keys
                          WHERE psp_id = :hv_psp_id
                            AND key = :hv_key
                            AND effect_date <= sysdate);



        EXEC SQL OPEN c_cursor_getpspkey;
        do {
                EXEC SQL FETCH c_cursor_getpspkey
                INTO
			:v_key_value:ind_key_value,
			:v_key_id:ind_key_id,
			:v_key_uid:ind_key_uid,
			:v_privatepem:ind_privatepem,
			:v_publiccert:ind_publiccert,
			:v_passphrase:ind_passphrase;

                if (SQLCODE == SQL_NOT_FOUND) {
			iRet = SQL_NOT_FOUND;
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);


/* key */
                if (ind_key_value >= 0) {
                        v_key_value.arr[v_key_value.len] = '\0';
                        PutField_CString(myHash,"key_value",(const char*)v_key_value.arr);
DEBUGLOG(("GetPspKey key_value = [%s]\n",v_key_value.arr));
                }
/* key_id */
                if (ind_key_id >= 0) {
                        v_key_id.arr[v_key_id.len] = '\0';
                        PutField_CString(myHash,"key_id",(const char*)v_key_id.arr);
DEBUGLOG(("GetPspKey key_id = [%s]\n",v_key_id.arr));
                }
/* key_uid */
                if (ind_key_uid >= 0) {
                        v_key_uid.arr[v_key_uid.len] = '\0';
                        PutField_CString(myHash,"key_uid",(const char*)v_key_uid.arr);
DEBUGLOG(("GetPspKey key_uid = [%s]\n",v_key_uid.arr));
                }
/* privatepem */
                if (ind_privatepem >= 0) {
                        v_privatepem.arr[v_privatepem.len] = '\0';
                        PutField_CString(myHash,"privatepem",(const char*)v_privatepem.arr);
DEBUGLOG(("GetPspKey privatepem = [%s]\n",v_privatepem.arr));
                }
/* publiccert */
                if (ind_publiccert >= 0) {
                        v_publiccert.arr[v_publiccert.len] = '\0';
                        PutField_CString(myHash,"publiccert",(const char*)v_publiccert.arr);
DEBUGLOG(("GetPspKey publiccert = [%s]\n",v_publiccert.arr));
                }
/* passphrase */
                if (ind_passphrase >= 0) {
                        v_passphrase.arr[v_passphrase.len] = '\0';
                        PutField_CString(myHash,"passphrase",(const char*)v_passphrase.arr);
DEBUGLOG(("GetPspKey passphrase = [%s]\n",v_passphrase.arr));
                }



                RecordSet_Add(myRec,myHash);
		break; //**************** only one now
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getpspkey;

	

DEBUGLOG(("GetPspKey Normal Exit\n"));
        if(iRet==0) return  PD_OK;
	else	return iRet;

getpspkey_error:
DEBUGLOG(("getpspkey_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getpspkey;
        return PD_ERR;
}


