/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/08/31              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "RulePayoutPsp.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void RulePayoutPsp(char    cdebug)
{
        cDebug = cdebug;
}


int GetRulePayoutPspWithPriority(recordset_t* myRec)
{
	hash_t *myHash;
	int	iCnt=0;

        EXEC SQL WHENEVER SQLERROR GOTO grppwp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         v_bank_name[PD_BANK_NAME_LEN+1];
                varchar         v_psp_id[PD_PSP_ID_LEN+1];
                varchar         v_opr_type[PD_OPERATOR_TYPE_LEN + 1];
                double          v_total_amt;

                short           ind_bank_name = -1;
                short           ind_opr_type = -1;
		short		ind_psp_id = -1;
                short           ind_total_amt = -1;

        EXEC SQL END DECLARE SECTION;


        EXEC SQL DECLARE c_cursor_grppwp CURSOR FOR
		select	rp_bank_name,
			rp_operator_type,
			rp_psp_id,
			rp_total_amt
		from	rule_payout_psp,
			psp_detail
		where	rp_psp_id = psp_id
		and	disabled = 0
		and	status = 'O'
		and	txn_type in ('A','P')
		order by rp_priority;

        EXEC SQL OPEN c_cursor_grppwp;
        do {
                EXEC SQL FETCH c_cursor_grppwp
                INTO	:v_bank_name:ind_bank_name,
                        :v_opr_type:ind_opr_type,
			:v_psp_id:ind_psp_id,
                        :v_total_amt:ind_total_amt;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("GetRulePayoutPspWithPriority found record\n"));
		iCnt++;

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

/* bank_name */
                if (ind_bank_name>= 0) {
                        v_bank_name.arr[v_bank_name.len] = '\0';
                        PutField_CString(myHash,"bank_name",(const char*)v_bank_name.arr);
DEBUGLOG(("GetRulePayoutPspWithPriority bank_name = [%s]\n",v_bank_name.arr));
                }

/* opr_type */
                if (ind_opr_type >= 0) {
                        v_opr_type.arr[v_opr_type.len] = '\0';
                        PutField_CString(myHash,"operator_type",(const char*)v_opr_type.arr);
DEBUGLOG(("GetRulePayoutPspWithPriority operator_type = [%s]\n",v_opr_type.arr));
                }

/* psp_id */
                if (ind_psp_id >= 0) {
                        v_psp_id.arr[v_psp_id.len] = '\0';
                        PutField_CString(myHash,"psp_id",(const char*)v_psp_id.arr);
DEBUGLOG(("GetRulePayoutPspWithPriority psp_id = [%s]\n",v_psp_id.arr));
                }

/* total_amt */
                if (ind_total_amt >= 0) {
                        PutField_Double(myHash,"total_amt",v_total_amt);
DEBUGLOG(("GetRulePayoutPspWithPriority total_amt = [%f]\n",v_total_amt));
                }

		RecordSet_Add(myRec,myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_grppwp;

	if(iCnt>0){
DEBUGLOG(("GetRulePayoutPspWithPriority Normal Exit\n"));
        	return  PD_OK;
	}
	else{
DEBUGLOG(("GetRulePayoutPspWithPriority Normal Exit, Not found\n"));
		return PD_ERR;
	}

grppwp_error:
DEBUGLOG(("grppwp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("RulePayoutPsp_GetWithPriority: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_grppwp;
        return PD_ERR;
}


int GetExistingPsp(recordset_t* myRec)
{
	hash_t *myHash;
	int	iCnt=0;

        EXEC SQL WHENEVER SQLERROR GOTO getpsp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         v_psp_id[PD_PSP_ID_LEN+1];

		short		ind_psp_id = -1;

        EXEC SQL END DECLARE SECTION;


        EXEC SQL DECLARE c_cursor_getpsp CURSOR FOR
                select	unique rp_psp_id
		from	rule_payout_psp,
			psp_detail
		where	rp_psp_id = psp_id
		and	status = 'O'
		and	disabled = 0;

        EXEC SQL OPEN c_cursor_getpsp;
        do {
                EXEC SQL FETCH c_cursor_getpsp
                INTO	
			:v_psp_id:ind_psp_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("GetExistingPsp found record\n"));
		iCnt++;

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

/* psp_id */
                if (ind_psp_id >= 0) {
                        v_psp_id.arr[v_psp_id.len] = '\0';
                        PutField_CString(myHash,"psp_id",(const char*)v_psp_id.arr);
DEBUGLOG(("GetExistingPsp psp_id = [%s]\n",v_psp_id.arr));
                }

		RecordSet_Add(myRec,myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getpsp;

	if(iCnt>0){
DEBUGLOG(("GetExistingPsp Normal Exit\n"));
        	return  PD_OK;
	}
	else{
DEBUGLOG(("GetExistingPsp Normal Exit, Not found\n"));
		return PD_ERR;
	}

getpsp_error:
DEBUGLOG(("getpsp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("RulePayoutPsp_GetPsp: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getpsp;
        return PD_ERR;
}
