/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/08              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "HoldAmount.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void HoldAmount(char    cdebug)
{
        cDebug = cdebug;
}


int GetAllHold(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                const char* csServiceCode,
		recordset_t* myRec)
{
	int iRet = PD_OK;
	int iCnt = 0;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO get_all_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;

		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];	
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];

                varchar         v_type[PD_HOLD_TYPE_LEN+1];                
		double		v_total_hold;
		double		v_holded;
		double		v_remain;

		short		ind_type= -1;
		short		ind_total_hold= -1;
		short		ind_holded= -1;
		short		ind_remain= -1;
        
        EXEC SQL END DECLARE SECTION;
        
	hv_merchant_id.len = strlen(csMerchantId);
        strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
DEBUGLOG(("GetAllHold:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_country_id.len = strlen(csCountryId);
        strncpy((char *)hv_country_id.arr, csCountryId, hv_country_id.len);
DEBUGLOG(("GetAllHold:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));
        
        hv_ccy_id.len = strlen(csCcy);
        strncpy((char *)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
DEBUGLOG(("GetAllHold:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        
        hv_service_code.len = strlen(csServiceCode);
        strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
DEBUGLOG(("GetAllHold:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));


	EXEC SQL DECLARE c_cursor_getall CURSOR FOR
		select	hv_type,
			hv_total_hold,
			hv_holded_amt,
			hv_hold_remain
		from	hold_amount
		where	hv_state != 'C'
		and	hv_merchant_id = :hv_merchant_id
                and	hv_currency_id = :hv_ccy_id
                and	hv_country_id = :hv_country_id
                and	hv_service_code = :hv_service_code
		order by hv_type;

	EXEC SQL OPEN c_cursor_getall;
	do{
		EXEC SQL FETCH c_cursor_getall
		INTO
			:v_type:ind_type,
			:v_total_hold:ind_total_hold,
			:v_holded:ind_holded,
			:v_remain:ind_remain;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

		if(ind_type>=0){
			v_type.arr[v_type.len]='\0';
			PutField_CString(myHash,"hold_type",(const char *)v_type.arr);
DEBUGLOG(("GetAllHold hold_type = [%s]\n",v_type.arr));
		}
		
		if(ind_total_hold<0)
			v_total_hold = 0.0;
		PutField_Double(myHash,"total_hold",v_total_hold);
DEBUGLOG(("GetAllHold total_hold = [%f]\n",v_total_hold));

		if(ind_holded<0)
			v_holded = 0.0;
		PutField_Double(myHash,"holded_amt",v_holded);
DEBUGLOG(("GetAllHold holded_amt = [%f]\n",v_holded));

		if(ind_remain<0)
			v_remain = 0.0;
		PutField_Double(myHash,"hold_remain",v_remain);
DEBUGLOG(("GetAllHold hold_remain = [%f]\n",v_remain));

		RecordSet_Add(myRec,myHash);

	}while(PD_TRUE);
	
	EXEC SQL CLOSE c_cursor_getall;

	if (iCnt > 0 ) {
DEBUGLOG(("GetAllHold Normal Exit\n"));
	}
	else {
DEBUGLOG(("GetAllHold Normal Exit, Not Found\n"));
		iRet = PD_ERR;
	}

	return iRet;

get_all_error:
DEBUGLOG(("get_all_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getall;
        return PD_ERR;
}


int GetHoldByType(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                const char* csServiceCode,
		const char* csType,
		double  *dHoldedAmt,
		double	*dHoldRemain)
{
	int iRet = PD_OK;
	*dHoldedAmt = 0.0;
	*dHoldRemain = 0.0;

        EXEC SQL WHENEVER SQLERROR GOTO get_holdbytype_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];	
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
                varchar         hv_type[PD_HOLD_TYPE_LEN];
                
		double		v_holded_amt;
		double		v_hold_remain;

		short		ind_holded_amt= -1;
		short		ind_hold_remain= -1;
        
        
        EXEC SQL END DECLARE SECTION;

	hv_merchant_id.len = strlen(csMerchantId);
        strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
DEBUGLOG(("GetHoldByType:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_country_id.len = strlen(csCountryId);
        strncpy((char *)hv_country_id.arr, csCountryId, hv_country_id.len);
DEBUGLOG(("GetHoldByType:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));
        
        hv_ccy_id.len = strlen(csCcy);
        strncpy((char *)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
DEBUGLOG(("GetHoldByType:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        
        hv_service_code.len = strlen(csServiceCode);
        strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
DEBUGLOG(("GetHoldByType:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));        

        hv_type.len = strlen(csType);
        memcpy(hv_type.arr,csType,hv_type.len);
DEBUGLOG(("GetHoldByType type = [%.*s]\n",hv_type.len,hv_type.arr));
        
        EXEC SQL 
                select	hv_holded_amt,
			hv_hold_remain
		into	:v_holded_amt:ind_holded_amt,
			:v_hold_remain:ind_hold_remain
                from	hold_amount
		where	hv_type = :hv_type
		and	hv_state != 'C'
		and     hv_merchant_id = :hv_merchant_id
                and     hv_currency_id = :hv_ccy_id
                and     hv_country_id = :hv_country_id
                and     hv_service_code = :hv_service_code;

	if(ind_holded_amt>=0){
		*dHoldedAmt = v_holded_amt;
	}
	else{
DEBUGLOG(("GetHoldByType Holed Amt Not Found\n"));
		iRet = PD_ERR;
	}
DEBUGLOG(("GetHoldByType holded_amt = [%f]\n",*dHoldedAmt));

	if(ind_hold_remain>=0){
		*dHoldRemain = v_hold_remain;
	}
	else{
DEBUGLOG(("GetHoldByType Hole Remain Not Found\n"));
		iRet = PD_ERR;
	}
DEBUGLOG(("GetHoldByType hold_remain = [%f]\n",*dHoldRemain));

	
DEBUGLOG(("GetHoldByType iRet = [%i]\n",iRet));
	return iRet;

get_holdbytype_error:
DEBUGLOG(("get_holdbytype_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}



int UpdateHoldAmount(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                const char* csServiceCode,
		const char* csType,
                double  dAmt,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updatehold_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];	
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		varchar		hv_type[PD_HOLD_TYPE_LEN];
		double		hv_amt;
		varchar 	hv_update_user[PD_USER_LEN];

		short           ind_merchant_id = -1;
                short           ind_country_id = -1;
                short           ind_ccy_id = -1;
                short           ind_service_code = -1;
		short		ind_type = -1;
		short		ind_amt = -1;
		short		ind_update_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


DEBUGLOG(("UpdateHoldAmount: Begin\n"));

	hv_merchant_id.len = strlen(csMerchantId);
        strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
        ind_merchant_id = 0;
DEBUGLOG(("UpdateHoldAmount:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_country_id.len = strlen(csCountryId);
        strncpy((char *)hv_country_id.arr, csCountryId, hv_country_id.len);
        ind_country_id = 0;
DEBUGLOG(("UpdateHoldAmount:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));
        
        hv_ccy_id.len = strlen(csCcy);
        strncpy((char *)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
        ind_ccy_id = 0;
DEBUGLOG(("UpdateHoldAmount:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

        hv_service_code.len = strlen(csServiceCode);
        strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
        ind_service_code = 0;
DEBUGLOG(("UpdateHoldAmount:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_type.len = strlen(csType);
	strncpy((char *)hv_type.arr, csType, hv_type.len);
	ind_type = 0;
DEBUGLOG(("UpdateHoldAmount: hold type = [%.*s]\n",hv_type.len,hv_type.arr));

	hv_amt= dAmt;
	ind_amt= 0;
DEBUGLOG(("UpdatIntransit:amt = [%f]\n",hv_amt));

	hv_update_user.len = strlen(csUser);
	strncpy((char *)hv_update_user.arr, csUser, hv_update_user.len);
	ind_update_user = 0;
DEBUGLOG(("UpdateHoldAmount:update_user = [%.*s]\n",hv_update_user.len,hv_update_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_hold_amt_update(
				:hv_merchant_id:ind_merchant_id,
                                :hv_country_id:ind_country_id,
                                :hv_ccy_id:ind_ccy_id,
                                :hv_service_code:ind_service_code,
				:hv_type:ind_type,
				:hv_amt:ind_amt,
				:hv_update_user:ind_update_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdateHoldAmount:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdateHoldAmount:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("HoldAmount::UpdateHoldAmount: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateHoldAmount: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("HoldAmount::UpdateHoldAmount: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateHoldAmount: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updatehold_error:
DEBUGLOG(("updatehold_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;


}
