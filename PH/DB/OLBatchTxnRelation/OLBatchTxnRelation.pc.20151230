/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/01/09              Dirk Wong
Add GetTxnId, GetBatchId and CheckSingleBatchId	   2015/01/14		   Elvis Wong	
Add CheckIsHoldDepositBatch			   2015/03/20		   Elvis Wong
Add CheckIsPSPSettlementBatch			   2015/03/31		   Elvis Wong
Add CheckIsProviderChargeBatch			   	
Add CheckIsInputTxnId				   
Add CheckIsReviveTxnId				   
Add GetBatchSubType	
Add GetBatchIdByRTAscOrder		  	   
Add GetNumOfBatchId
Del CheckSingleBatchId				   2015/04/28		   Elvis Wong	
Add batch_sub_type and txn_type			 
Modify GetNumOfBatchId
and GetTxnId
and GetBatchId and GetBatchIdByRTAscOrder  	   2015/05/13              Elvis Wong	
Change GetBatchSubType to GetBatchTypeInfo
Modify CheckIsInputTxnId
Change CheckIsReviveTxnId to CheckIsRegenTxnId
Del txn_type
Add is_input_txn and is_regen_txn		   2015/05/14              Elvis Wong
Add CheckIsSMSBankDepositBatch			   2015/07/07              Elvis Wong
Add CheckIsDepositChargebackRevBatch	   	   2015/10/30              Elvis Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLBatchTxnRelation.h"
#include "common.h"
#include "internal.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void OLBatchTxnRelation(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hRls)
{
	int	iTmp;

	char	cTmp;
	char*	csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		char		hv_batch_type;
		char		hv_batch_sub_type;
		varchar		hv_batch_id[PD_TXN_SEQ_LEN];
		char		hv_txn_level;
		int		hv_is_input_txn;
		int		hv_is_regen_txn;
		varchar		hv_txn_id[PD_TXN_SEQ_LEN];
		varchar         hv_create_user[PD_USER_LEN];

		short		ind_batch_type = -1;
		short		ind_batch_sub_type = -1;
		short		ind_batch_id = -1;
		short		ind_txn_level = -1;
		short		ind_is_input_txn = -1;
		short		ind_is_regen_txn = -1;
		short		ind_txn_id = -1;
		short		ind_create_user = -1;

		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;
DEBUGLOG(("Add: Begin\n"));

	if (GetField_Char(hRls,"batch_type",&cTmp)) {
		hv_batch_type = cTmp;
		ind_batch_type = 0;
DEBUGLOG(("Add: batch_type = [%c]\n",hv_batch_type));
	}

	if (GetField_CString(hRls,"batch_id",&csTmp)) {
		hv_batch_id.len = strlen(csTmp);
		strncpy((char*)hv_batch_id.arr, csTmp, hv_batch_id.len);
		ind_batch_id = 0;
DEBUGLOG(("Add: batch_id = [%s]\n",(char*)hv_batch_id.arr));
	}

	if (GetField_Char(hRls,"txn_level",&cTmp)) {
		hv_txn_level = cTmp;
		ind_txn_level = 0;
DEBUGLOG(("Add: txn_level =  [%c]\n",hv_txn_level));
	}

	if (GetField_CString(hRls,"txn_id",&csTmp)) {
		hv_txn_id.len = strlen(csTmp);
		strncpy((char*)hv_txn_id.arr, csTmp, hv_txn_id.len);
		ind_txn_id = 0;
DEBUGLOG(("Add: txn_id = [%s]\n",(char*)hv_txn_id.arr));
	}

	if (GetField_Char(hRls,"batch_sub_type",&cTmp)) {
                hv_batch_sub_type = cTmp;
                ind_batch_sub_type = 0;
DEBUGLOG(("Add: batch_sub_type = [%c]\n",hv_batch_sub_type));
        } else {
                hv_batch_sub_type = 'R';
                ind_batch_sub_type = 0;
DEBUGLOG(("Add: batch_sub_type = [%c]\n",hv_batch_sub_type));
        }

	if (GetField_Int(hRls,"is_input_txn",&iTmp)) {
                hv_is_input_txn = iTmp;
                ind_is_input_txn = 0;
DEBUGLOG(("Add: is_input_txn =  [%d]\n",hv_is_input_txn));
        } else {
                hv_is_input_txn = 0;
                ind_is_input_txn = 0;
DEBUGLOG(("Add: is_input_txn =  [%d]\n",hv_is_input_txn));
        }

	if (GetField_Int(hRls,"is_regen_txn",&iTmp)) {
                hv_is_regen_txn = iTmp;
                ind_is_regen_txn = 0;
DEBUGLOG(("Add: is_regen_txn =  [%d]\n",hv_is_regen_txn));
        } else {
                hv_is_regen_txn = 0;
                ind_is_regen_txn = 0;
DEBUGLOG(("Add: is_regen_txn =  [%d]\n",hv_is_regen_txn));
        }

	if(GetField_CString(hRls,"create_user",&csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Add: create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_ol_batch_tx_relation_insert(
						:hv_batch_type:ind_batch_type,
						:hv_batch_id:ind_batch_id,
						:hv_txn_level:ind_txn_level,
						:hv_txn_id:ind_txn_id,
						:hv_batch_sub_type:ind_batch_sub_type,
						:hv_is_input_txn:ind_is_input_txn,
						:hv_is_regen_txn:ind_is_regen_txn,
                                                :hv_create_user:ind_create_user);
		END;
	END-EXEC;

	DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("OLBatchTxnRelation_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	} 

	if (hv_return_value == SP_ERR)  {
ERRLOG("OLBatchTxnRelation_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation_Add: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int GetTxnId(const hash_t* hRls, recordset_t* rRecordSet)
{
        int iRet = PD_OK;

        char *csTmp;
        char cTmp;

        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO gettxnid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		char            hv_batch_type;
		char            hv_batch_sub_type;
                varchar         hv_batch_id[PD_TXN_SEQ_LEN];
                char            hv_txn_level;

                varchar         v_txn_id[PD_TXN_SEQ_LEN];
                short           ind_txn_id = -1;
        EXEC SQL END DECLARE SECTION;

/* batch_type */
	if (GetField_Char(hRls, "batch_type", &cTmp)) {
                hv_batch_type = cTmp;
DEBUGLOG(("GetTxnId: batch_type = [%c]\n", hv_batch_type));
        }

/* batch_sub_type */
        if (GetField_Char(hRls, "batch_sub_type", &cTmp)) {
                hv_batch_sub_type = cTmp;
DEBUGLOG(("GetTxnId: batch_sub_type = [%c]\n", hv_batch_sub_type));
        }

/* batch_id */
        if (GetField_CString(hRls,"batch_id",&csTmp)) {
                hv_batch_id.len = strlen(csTmp);
                strncpy((char*)hv_batch_id.arr, csTmp, hv_batch_id.len);
DEBUGLOG(("GetTxnId: batch_id = [%s]\n",(char*)hv_batch_id.arr));
        }

/* txn_level */
	if (GetField_Char(hRls, "txn_level", &cTmp)) {
                hv_txn_level = cTmp;
DEBUGLOG(("GetTxnId: txn_level = [%c]\n", hv_txn_level));
        }

	EXEC SQL DECLARE c_cursor_gettxnid CURSOR FOR
                SELECT  obtr_txn_id
                FROM    ol_batch_txn_relation
                WHERE   obtr_batch_type = :hv_batch_type
                AND   	obtr_batch_sub_type = :hv_batch_sub_type
                AND     obtr_batch_id = :hv_batch_id
		AND	obtr_txn_level = :hv_txn_level
		ORDER BY obtr_relation_timestamp DESC;
        EXEC SQL OPEN c_cursor_gettxnid;

	for (;;) {
                EXEC SQL FETCH c_cursor_gettxnid
                INTO	:v_txn_id:ind_txn_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash, 0);

		// txn_id
                if (ind_txn_id >= 0) {
                        v_txn_id.arr[v_txn_id.len] = '\0';
                        PutField_CString(myHash, "txn_id", (const char*)v_txn_id.arr);
DEBUGLOG(("GetTxnId: txn_id = [%s]\n", (const char*)v_txn_id.arr));
                }

                RecordSet_Add(rRecordSet, myHash);
        }

	EXEC SQL CLOSE c_cursor_gettxnid;

DEBUGLOG(("GetTxnId: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

gettxnid_error:
DEBUGLOG(("gettxnid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation gettxnid_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_gettxnid;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}


int GetBatchId(const hash_t* hRls, recordset_t* rRecordSet)
{
        int iRet = PD_OK;

        char *csTmp;
        char cTmp;

        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getbatchid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                char            hv_txn_level;
                varchar         hv_txn_id[PD_TXN_SEQ_LEN];

                char            v_batch_type;
                char            v_batch_sub_type;
                varchar         v_batch_id[PD_TXN_SEQ_LEN];
                short           ind_batch_type = -1;
                short           ind_batch_sub_type = -1;
                short           ind_batch_id = -1;
        EXEC SQL END DECLARE SECTION;

/* txn_level */
	if (GetField_Char(hRls, "txn_level", &cTmp)) {
                hv_txn_level = cTmp;
DEBUGLOG(("GetBatchId: txn_level = [%c]\n", hv_txn_level));
        }

/* txn_id */
        if (GetField_CString(hRls,"txn_id",&csTmp)) {
                hv_txn_id.len = strlen(csTmp);
                strncpy((char*)hv_txn_id.arr, csTmp, hv_txn_id.len);
DEBUGLOG(("GetBatchId: txn_id = [%s]\n",(char*)hv_txn_id.arr));
        }

	EXEC SQL DECLARE c_cursor_getbatchid CURSOR FOR
                SELECT  obtr_batch_type,
			obtr_batch_sub_type,
			obtr_batch_id
                FROM    ol_batch_txn_relation
                WHERE   obtr_txn_level = :hv_txn_level
                AND     obtr_txn_id = :hv_txn_id
		ORDER BY obtr_relation_timestamp DESC;
        EXEC SQL OPEN c_cursor_getbatchid;

	for (;;) {
                EXEC SQL FETCH c_cursor_getbatchid
                INTO    :v_batch_type:ind_batch_type,
			:v_batch_sub_type:ind_batch_sub_type,
			:v_batch_id:ind_batch_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash, 0);
		
		// batch_type
		if (ind_batch_type >= 0) {
                        PutField_Char(myHash, "batch_type",v_batch_type);
DEBUGLOG(("GetBatchId batch_type = [%c]\n", v_batch_type));
                }

                // batch_sub_type
                if (ind_batch_sub_type >= 0) {
                        PutField_Char(myHash, "batch_sub_type",v_batch_sub_type);
DEBUGLOG(("GetBatchId batch_sub_type = [%c]\n", v_batch_sub_type));
                }

		// batch_id
                if (ind_batch_id >= 0) {
                        v_batch_id.arr[v_batch_id.len] = '\0';
                        PutField_CString(myHash, "batch_id", (const char*)v_batch_id.arr);
DEBUGLOG(("GetBatchId: batch_id = [%s]\n", (const char*)v_batch_id.arr));
                }

                RecordSet_Add(rRecordSet, myHash);
        }

	EXEC SQL CLOSE c_cursor_getbatchid;

DEBUGLOG(("GetBatchId: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

getbatchid_error:
DEBUGLOG(("getbatchid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation getbatchid_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_getbatchid;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int GetNumOfBatchId(hash_t* hRls)
{
	int iRet = PD_ERR;

        char *csTmp;
        char cTmp;

        EXEC SQL WHENEVER SQLERROR GOTO getnumofbatchid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                char            hv_txn_level;
                varchar         hv_txn_id[PD_TXN_SEQ_LEN];

		int     	v_cnt;
        EXEC SQL END DECLARE SECTION;

/* txn_level */
        if (GetField_Char(hRls, "txn_level", &cTmp)) {
                hv_txn_level = cTmp;
DEBUGLOG(("GetNumOfBatchId: txn_level = [%c]\n", hv_txn_level));
        }

/* txn_id */
        if (GetField_CString(hRls,"txn_id",&csTmp)) {
                hv_txn_id.len = strlen(csTmp);
                strncpy((char*)hv_txn_id.arr, csTmp, hv_txn_id.len);
DEBUGLOG(("GetNumOfBatchId: txn_id = [%s]\n",(char*)hv_txn_id.arr));
        }

        EXEC SQL        SELECT  COUNT(*)
                        INTO    :v_cnt
                        FROM    ol_batch_txn_relation
                        WHERE   obtr_txn_level = :hv_txn_level
                	AND     obtr_txn_id = :hv_txn_id;

        if (v_cnt>=0) {
                iRet = PD_OK;
		PutField_Int(hRls, "cnt", v_cnt);
DEBUGLOG(("GetNumOfBatchId: cnt = [%d]\n", v_cnt));
        }

DEBUGLOG(("GetNumOfBatchId() Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

getnumofbatchid_error:
DEBUGLOG(("getnumofbatchid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int CheckIsHoldDepositBatch(const char *csBatchId)
{
        int iRet = PD_FALSE;

        int iCnt = 0;

        EXEC SQL WHENEVER SQLERROR GOTO chkisholddsibatch_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar 	hv_batch_id[PD_TXN_SEQ_LEN];

		int     vCnt;
        EXEC SQL END DECLARE SECTION;

// batch_id
        hv_batch_id.len = strlen(csBatchId);
        strncpy((char*)hv_batch_id.arr, csBatchId, hv_batch_id.len);
DEBUGLOG(("CheckIsHoldDepositBatch batch_id = [%s]\n",(char*)hv_batch_id.arr));

        EXEC SQL DECLARE c_cursor_chkisholddsibatch CURSOR FOR
 		SELECT  count(1)
		FROM    ol_batch_txn_relation
		LEFT JOIN ol_txn_header
		ON       obtr_txn_id = oth_txn_id
		WHERE    obtr_batch_type = 'G'
		AND      obtr_txn_level = 'T'
		AND      obtr_batch_id = :hv_batch_id
		AND      oth_txn_code = 'VOD'
		UNION
		SELECT  count(1)
		FROM    ol_batch_txn_relation
		LEFT JOIN ol_baid_txn
		ON       obtr_txn_id = obt_txn_id
		WHERE    obtr_batch_type = 'G'
		AND      obtr_txn_level = 'S'
		AND      obtr_batch_id = :hv_batch_id
		AND      obt_txn_code = 'VOD';
        EXEC SQL OPEN c_cursor_chkisholddsibatch;

        for (;;) {
                EXEC SQL FETCH c_cursor_chkisholddsibatch
                INTO    :vCnt;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                iCnt += vCnt;
        }
	
	EXEC SQL CLOSE c_cursor_chkisholddsibatch;

        if (iCnt > 0) {
                iRet = PD_TRUE;
DEBUGLOG(("CheckIsHoldDepositBatch found one record, it's hold deposit batch\n"));
        }

DEBUGLOG(("CheckIsHoldDepositBatch: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

chkisholddsibatch_error:
DEBUGLOG(("chkisholddsibatch_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation chkisholddsibatch_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_chkisholddsibatch;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int CheckIsPSPSettlementBatch(const char *csBatchId)
{
        int iRet = PD_FALSE;

        int iCnt = 0;

        EXEC SQL WHENEVER SQLERROR GOTO chkispspsettbatch_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar 	hv_batch_id[PD_TXN_SEQ_LEN];

		int     vCnt;
        EXEC SQL END DECLARE SECTION;

// batch_id
        hv_batch_id.len = strlen(csBatchId);
        strncpy((char*)hv_batch_id.arr, csBatchId, hv_batch_id.len);
DEBUGLOG(("CheckIsPSPSettlementBatch batch_id = [%s]\n",(char*)hv_batch_id.arr));

        EXEC SQL DECLARE c_cursor_chkispspsettbatch CURSOR FOR
 		SELECT  count(1)
		FROM    ol_batch_txn_relation
		LEFT JOIN ol_txn_header
		ON       obtr_txn_id = oth_txn_id
		WHERE    obtr_batch_type = 'G'
		AND      obtr_txn_level = 'T'
		AND      obtr_batch_id = :hv_batch_id
		AND      oth_txn_code in ('OPT', 'PPT', 'PST')
		UNION
		SELECT  count(1)
		FROM    ol_batch_txn_relation
		LEFT JOIN ol_baid_txn
		ON       obtr_txn_id = obt_txn_id
		WHERE    obtr_batch_type = 'G'
		AND      obtr_txn_level = 'S'
		AND      obtr_batch_id = :hv_batch_id
		AND      obt_txn_code in ('OPT', 'PPT', 'PST');
        EXEC SQL OPEN c_cursor_chkispspsettbatch;

        for (;;) {
                EXEC SQL FETCH c_cursor_chkispspsettbatch
                INTO    :vCnt;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                iCnt += vCnt;
        }
	
	EXEC SQL CLOSE c_cursor_chkispspsettbatch;

        if (iCnt > 0) {
                iRet = PD_TRUE;
DEBUGLOG(("CheckIsPSPSettlementBatch found one record, it's psp settlement batch\n"));
        }

DEBUGLOG(("CheckIsPSPSettlementBatch: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

chkispspsettbatch_error:
DEBUGLOG(("chkispspsettbatch_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation chkispspsettbatch_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_chkispspsettbatch;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int CheckIsProviderChargeBatch(const char *csBatchId)
{
        int iRet = PD_FALSE;

        int iCnt = 0;

        EXEC SQL WHENEVER SQLERROR GOTO chkispdrchrbatch_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar 	hv_batch_id[PD_TXN_SEQ_LEN];

		int     vCnt;
        EXEC SQL END DECLARE SECTION;

// batch_id
        hv_batch_id.len = strlen(csBatchId);
        strncpy((char*)hv_batch_id.arr, csBatchId, hv_batch_id.len);
DEBUGLOG(("CheckIsProviderChargeBatch batch_id = [%s]\n",(char*)hv_batch_id.arr));

        EXEC SQL DECLARE c_cursor_chkispdrchrbatch CURSOR FOR
 		SELECT  count(1)
		FROM    ol_batch_txn_relation
		LEFT JOIN ol_txn_header
		ON       obtr_txn_id = oth_txn_id
		WHERE    obtr_batch_type in ('G', 'C')
		AND      obtr_txn_level = 'T'
		AND      obtr_batch_id = :hv_batch_id
		AND      oth_txn_code in ('CPO', 'CPD', 'PPC', 'CGP', 'OPR')
		UNION
		SELECT  count(1)
		FROM    ol_batch_txn_relation
		LEFT JOIN ol_baid_txn
		ON       obtr_txn_id = obt_txn_id
		WHERE    obtr_batch_type in ('G', 'C')
		AND      obtr_txn_level = 'S'
		AND      obtr_batch_id = :hv_batch_id
		AND      obt_txn_code in ('CPO', 'CPD', 'PPC', 'CGP', 'OPR');
        EXEC SQL OPEN c_cursor_chkispdrchrbatch;

        for (;;) {
                EXEC SQL FETCH c_cursor_chkispdrchrbatch
                INTO    :vCnt;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                iCnt += vCnt;
        }
	
	EXEC SQL CLOSE c_cursor_chkispdrchrbatch;

        if (iCnt > 0) {
                iRet = PD_TRUE;
DEBUGLOG(("CheckIsProviderChargeBatch found one record, it's provider charge batch\n"));
        }

DEBUGLOG(("CheckIsProviderChargeBatch: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

chkispdrchrbatch_error:
DEBUGLOG(("chkispdrchrbatch_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation chkispdrchrbatch_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_chkispdrchrbatch;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int CheckIsInputTxnId(const hash_t* hRls)
{
        int iRet = PD_FALSE;

        char *csTmp;
        char cTmp;

        EXEC SQL WHENEVER SQLERROR GOTO chkisinputtxnid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                char            hv_batch_type;
                char            hv_batch_sub_type;
                varchar         hv_batch_id[PD_TXN_SEQ_LEN];
                char            hv_txn_level;
                varchar         hv_txn_id[PD_TXN_SEQ_LEN];
		int         	hv_is_input_txn;

                int     	vCnt;	
        EXEC SQL END DECLARE SECTION;

/* batch_type */
        if (GetField_Char(hRls, "batch_type", &cTmp)) {
                hv_batch_type = cTmp;
DEBUGLOG(("CheckIsInputTxnId: batch_type = [%c]\n", hv_batch_type));
        }

/* batch_sub_type */
        if (GetField_Char(hRls, "batch_sub_type", &cTmp)) {
                hv_batch_sub_type = cTmp;
DEBUGLOG(("CheckIsInputTxnId: batch_sub_type = [%c]\n", hv_batch_sub_type));
        }

/* batch_id */
        if (GetField_CString(hRls,"batch_id",&csTmp)) {
                hv_batch_id.len = strlen(csTmp);
                strncpy((char*)hv_batch_id.arr, csTmp, hv_batch_id.len);
DEBUGLOG(("CheckIsInputTxnId: batch_id = [%s]\n",(char*)hv_batch_id.arr));
        }

/* txn_level */
        if (GetField_Char(hRls, "txn_level", &cTmp)) {
                hv_txn_level = cTmp;
DEBUGLOG(("CheckIsInputTxnId: txn_level = [%c]\n", hv_txn_level));
        }

/* txn_id */
        if (GetField_CString(hRls,"txn_id",&csTmp)) {
                hv_txn_id.len = strlen(csTmp);
                strncpy((char*)hv_txn_id.arr, csTmp, hv_txn_id.len);
DEBUGLOG(("CheckIsInputTxnId: txn_id = [%s]\n",(char*)hv_txn_id.arr));
        }

/* is_input_txn */
	hv_is_input_txn = 1;	

        EXEC SQL        SELECT  count(1)
			INTO	vCnt
                        FROM    ol_batch_txn_relation
                        WHERE   obtr_batch_type = :hv_batch_type	
                       	AND   	obtr_batch_sub_type = :hv_batch_sub_type	
                        AND     obtr_batch_id = :hv_batch_id
			AND	obtr_txn_level = :hv_txn_level
                        AND     obtr_txn_id = :hv_txn_id
			AND	obtr_is_input_txn = :hv_is_input_txn;

	if (vCnt == 1) {
                iRet = PD_TRUE;
DEBUGLOG(("CheckIsInputTxnId Found!!!\n"));
        }

DEBUGLOG(("CheckIsInputTxnId Normal Exit [%d]\n", iRet));
        return iRet;

chkisinputtxnid_error:
DEBUGLOG(("chkisinputtxnid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int CheckIsRegenTxnId(const hash_t* hRls)
{
        int iRet = PD_FALSE;

        char *csTmp;
        char cTmp;

        EXEC SQL WHENEVER SQLERROR GOTO chkisregentxnid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                char            hv_batch_type;
                char            hv_batch_sub_type;
                varchar         hv_batch_id[PD_TXN_SEQ_LEN];
                char            hv_txn_level;
                varchar         hv_txn_id[PD_TXN_SEQ_LEN];
		char         	hv_is_regen_txn;

                int     	vCnt;	
        EXEC SQL END DECLARE SECTION;

/* batch_type */
        if (GetField_Char(hRls, "batch_type", &cTmp)) {
                hv_batch_type = cTmp;
DEBUGLOG(("CheckIsRegenTxnId: batch_type = [%c]\n", hv_batch_type));
        }

/* batch_sub_type */
        if (GetField_Char(hRls, "batch_sub_type", &cTmp)) {
                hv_batch_sub_type = cTmp;
DEBUGLOG(("CheckIsRegenTxnId: batch_sub_type = [%c]\n", hv_batch_sub_type));
        }

/* batch_id */
        if (GetField_CString(hRls,"batch_id",&csTmp)) {
                hv_batch_id.len = strlen(csTmp);
                strncpy((char*)hv_batch_id.arr, csTmp, hv_batch_id.len);
DEBUGLOG(("CheckIsRegenTxnId: batch_id = [%s]\n",(char*)hv_batch_id.arr));
        }

/* txn_level */
        if (GetField_Char(hRls, "txn_level", &cTmp)) {
                hv_txn_level = cTmp;
DEBUGLOG(("CheckIsRegenTxnId: txn_level = [%c]\n", hv_txn_level));
        }

/* txn_id */
        if (GetField_CString(hRls,"txn_id",&csTmp)) {
                hv_txn_id.len = strlen(csTmp);
                strncpy((char*)hv_txn_id.arr, csTmp, hv_txn_id.len);
DEBUGLOG(("CheckIsRegenTxnId: txn_id = [%s]\n",(char*)hv_txn_id.arr));
        }

/* is_regen_txn */
	hv_is_regen_txn = 1;	

        EXEC SQL        SELECT  count(1)
			INTO	vCnt
                        FROM    ol_batch_txn_relation
                        WHERE   obtr_batch_type = :hv_batch_type	
                        AND	obtr_batch_sub_type = :hv_batch_sub_type	
                        AND     obtr_batch_id = :hv_batch_id
			AND	obtr_txn_level = :hv_txn_level
                        AND     obtr_txn_id = :hv_txn_id
			AND	obtr_is_regen_txn = :hv_is_regen_txn;

	if (vCnt == 1) {
                iRet = PD_TRUE;
DEBUGLOG(("CheckIsRegenTxnId Found!!!\n"));
        }

DEBUGLOG(("CheckIsRegenTxnId Normal Exit [%d]\n", iRet));
        return iRet;

chkisregentxnid_error:
DEBUGLOG(("chkisregentxnid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int GetBatchTypeInfo(hash_t* hRls)
{
        int iRet = PD_NOT_FOUND;

        char *csTmp;

	int iCnt = 0;

        EXEC SQL WHENEVER SQLERROR GOTO getbatchtypeinfo_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_batch_id[PD_TXN_SEQ_LEN];

		char            v_batch_type;
		char            v_batch_sub_type;
                short           ind_batch_type = -1;
                short           ind_batch_sub_type = -1;
        EXEC SQL END DECLARE SECTION;

/* batch_id */
        if (GetField_CString(hRls,"batch_id",&csTmp)) {
                hv_batch_id.len = strlen(csTmp);
                strncpy((char*)hv_batch_id.arr, csTmp, hv_batch_id.len);
DEBUGLOG(("GetBatchTypeInfo: batch_id = [%s]\n",(char*)hv_batch_id.arr));
        }

	EXEC SQL DECLARE c_cursor_getbatchtypeinfo CURSOR FOR
                SELECT  obtr_batch_type,
			obtr_batch_sub_type
                FROM    ol_batch_txn_relation
                WHERE   obtr_batch_id = :hv_batch_id;
        EXEC SQL OPEN c_cursor_getbatchtypeinfo;

	for (;;) {
                EXEC SQL FETCH c_cursor_getbatchtypeinfo
                INTO    :v_batch_type:ind_batch_type,
                	:v_batch_sub_type:ind_batch_sub_type;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if (iCnt > 1) {
			break;
		}

		iCnt++;

		// batch_type
                if (ind_batch_type >= 0) {
                        PutField_Char(hRls, "batch_type",v_batch_type);
DEBUGLOG(("GetBatchTypeInfo batch_type = [%c]\n", v_batch_type));
                }

		// batch_sub_type
                if (ind_batch_sub_type >= 0) {
                        PutField_Char(hRls, "batch_sub_type",v_batch_sub_type);
DEBUGLOG(("GetBatchTypeInfo batch_sub_type = [%c]\n", v_batch_sub_type));
		}
        }

	EXEC SQL CLOSE c_cursor_getbatchtypeinfo;

	if (iCnt > 0) {
                iRet = PD_FOUND;
DEBUGLOG(("GetBatchTypeInfo FOUND\n"));
        } else {
                iRet = PD_NOT_FOUND;
DEBUGLOG(("GetBatchTypeInfo NOT FOUND!!!\n"));
        }

DEBUGLOG(("GetBatchTypeInfo: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

getbatchtypeinfo_error:
DEBUGLOG(("getbatchtypeinfo_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation getbatchtypeinfo_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_getbatchtypeinfo;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int GetBatchIdByRTAscOrder(const hash_t* hRls, recordset_t* rRecordSet)
{
        int iRet = PD_OK;

        char *csTmp;
        char cTmp;

        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getbatchidbyasc_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                char            hv_txn_level;
                varchar         hv_txn_id[PD_TXN_SEQ_LEN];

                char            v_batch_type;
                char            v_batch_sub_type;
                varchar         v_batch_id[PD_TXN_SEQ_LEN];
                short           ind_batch_type = -1;
                short           ind_batch_sub_type = -1;
                short           ind_batch_id = -1;
        EXEC SQL END DECLARE SECTION;

/* txn_level */
	if (GetField_Char(hRls, "txn_level", &cTmp)) {
                hv_txn_level = cTmp;
DEBUGLOG(("GetBatchIdByRTAscOrder: txn_level = [%c]\n", hv_txn_level));
        }

/* txn_id */
        if (GetField_CString(hRls,"txn_id",&csTmp)) {
                hv_txn_id.len = strlen(csTmp);
                strncpy((char*)hv_txn_id.arr, csTmp, hv_txn_id.len);
DEBUGLOG(("GetBatchIdByRTAscOrder: txn_id = [%s]\n",(char*)hv_txn_id.arr));
        }

	EXEC SQL DECLARE c_cursor_getbatchidbyasc CURSOR FOR
                SELECT  obtr_batch_type,
			obtr_batch_sub_type,
			obtr_batch_id
                FROM    ol_batch_txn_relation
                WHERE   obtr_txn_level = :hv_txn_level
                AND     obtr_txn_id = :hv_txn_id
		ORDER BY obtr_relation_timestamp ASC;
        EXEC SQL OPEN c_cursor_getbatchidbyasc;

	for (;;) {
                EXEC SQL FETCH c_cursor_getbatchidbyasc
                INTO    :v_batch_type:ind_batch_type,
			:v_batch_sub_type:ind_batch_sub_type,
			:v_batch_id:ind_batch_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash, 0);

		// batch_type
                if (ind_batch_type >= 0) {
                        PutField_Char(myHash, "batch_type",v_batch_type);
DEBUGLOG(("GetBatchIdByRTAscOrder batch_type = [%c]\n", v_batch_type));
                }

                // batch_sub_type
                if (ind_batch_sub_type >= 0) {
                        PutField_Char(myHash, "batch_sub_type",v_batch_sub_type);
DEBUGLOG(("GetBatchIdByRTAscOrder batch_sub_type = [%c]\n", v_batch_sub_type));
                }

		// batch_id
                if (ind_batch_id >= 0) {
                        v_batch_id.arr[v_batch_id.len] = '\0';
                        PutField_CString(myHash, "batch_id", (const char*)v_batch_id.arr);
DEBUGLOG(("GetBatchIdByRTAscOrder: batch_id = [%s]\n", (const char*)v_batch_id.arr));
                }

                RecordSet_Add(rRecordSet, myHash);
        }

	EXEC SQL CLOSE c_cursor_getbatchidbyasc;

DEBUGLOG(("GetBatchIdByRTAscOrder: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

getbatchidbyasc_error:
DEBUGLOG(("getbatchidbyasc_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation getbatchidbyasc_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_getbatchidbyasc;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int CheckIsSMSBankDepositBatch(const char *csBatchId)
{
        int iRet = PD_FALSE;

        EXEC SQL WHENEVER SQLERROR GOTO chkissmsbkdsibatch_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_batch_id[PD_TXN_SEQ_LEN];

                varchar		v_input_channel[PD_INPUT_CHANNEL_LEN];
                varchar		v_statement_ref[PD_TXN_SEQ_LEN];

		short           ind_input_channel = -1;	
		short           ind_statement_ref = -1;	
        EXEC SQL END DECLARE SECTION;

// batch_id
        hv_batch_id.len = strlen(csBatchId);
        strncpy((char*)hv_batch_id.arr, csBatchId, hv_batch_id.len);
DEBUGLOG(("CheckIsSMSBankDepositBatch batch_id = [%s]\n",(char*)hv_batch_id.arr));

	EXEC SQL DECLARE c_cursor_chkissmsbkdsibatch CURSOR FOR
        	SELECT  olsd_input_channel,
			olsd_statement_ref
                FROM    ol_batch_txn_relation,
                        ol_baid_txn,
                        ol_statement_detail
                WHERE	obtr_batch_id = :hv_batch_id 
		AND	obtr_txn_id = obt_txn_id
                AND     obtr_batch_type = 'G'
                AND     obtr_txn_level = 'S'   
                AND     obt_stat_txn_id = olsd_stat_txn_id
                AND     obt_txn_code = 'OBD';
	EXEC SQL OPEN c_cursor_chkissmsbkdsibatch;

	for (;;) {
                EXEC SQL FETCH c_cursor_chkissmsbkdsibatch
                INTO    :v_input_channel:ind_input_channel,
                	:v_statement_ref:ind_statement_ref;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if (ind_input_channel >= 0) {
			v_input_channel.arr[v_input_channel.len] = '\0';
DEBUGLOG(("CheckIsSMSBankDepositBatch input_channel = [%s]\n", (const char*)v_input_channel.arr));

			if (!strcmp((const char*)v_input_channel.arr, PD_SMS_STATEMENT)) {
				if (ind_statement_ref >= 0) {
DEBUGLOG(("CheckIsSMSBankDepositBatch statement_ref = [%s]\n", (const char*)v_statement_ref.arr));

				} else {
DEBUGLOG(("CheckIsSMSBankDepositBatch statement_ref = [NULL]\n"));
					iRet = PD_TRUE;
					break;
				}
                	}
		}
        }

        EXEC SQL CLOSE c_cursor_chkissmsbkdsibatch;

DEBUGLOG(("CheckIsSMSBankDepositBatch: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

chkissmsbkdsibatch_error:
DEBUGLOG(("chkissmsbkdsibatch_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation chkissmsbkdsibatch_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_chkissmsbkdsibatch;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int CheckIsDepositChargebackRevBatch(const char *csBatchId)
{
        int iRet = PD_FALSE;

        int iCnt = 0;

        EXEC SQL WHENEVER SQLERROR GOTO chkisdsicbrevbatch_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar 	hv_batch_id[PD_TXN_SEQ_LEN];

		int     vCnt;
        EXEC SQL END DECLARE SECTION;

// batch_id
        hv_batch_id.len = strlen(csBatchId);
        strncpy((char*)hv_batch_id.arr, csBatchId, hv_batch_id.len);
DEBUGLOG(("CheckIsDepositChargebackRevBatch batch_id = [%s]\n",(char*)hv_batch_id.arr));

        EXEC SQL DECLARE c_cursor_chkisdsicbrevbatch CURSOR FOR
 		SELECT  count(1)
		FROM    ol_batch_txn_relation
		LEFT JOIN ol_txn_header
		ON       obtr_txn_id = oth_txn_id
		WHERE    obtr_batch_type = 'G'
		AND      obtr_txn_level = 'T'
		AND      obtr_batch_id = :hv_batch_id
		AND      oth_txn_code = 'DCR'
		UNION
		SELECT  count(1)
		FROM    ol_batch_txn_relation
		LEFT JOIN ol_baid_txn
		ON       obtr_txn_id = obt_txn_id
		WHERE    obtr_batch_type = 'G'
		AND      obtr_txn_level = 'S'
		AND      obtr_batch_id = :hv_batch_id
		AND      obt_txn_code = 'DCR';
        EXEC SQL OPEN c_cursor_chkisdsicbrevbatch;

        for (;;) {
                EXEC SQL FETCH c_cursor_chkisdsicbrevbatch
                INTO    :vCnt;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                iCnt += vCnt;
        }
	
	EXEC SQL CLOSE c_cursor_chkisdsicbrevbatch;

        if (iCnt > 0) {
                iRet = PD_TRUE;
DEBUGLOG(("CheckIsDepositChargebackRevBatch found one record, it's deposit chargeback rev batch\n"));
        }

DEBUGLOG(("CheckIsDepositChargebackRevBatch: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

chkisdsicbrevbatch_error:
DEBUGLOG(("chkisdsicbrevbatch_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchTxnRelation chkisdsicbrevbatch_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_chkisdsicbrevbatch;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

