/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/06/25              Stan Poon
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "BankTxnCheck.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void BankTxnCheck(char    cdebug)
{
        cDebug = cdebug;
}


int GetAllBankCheck(recordset_t *myRec)
{
	int 	iCnt = 0;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getbanktxn_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		v_party_id[PD_PSP_ID_LEN + 1];
		varchar		v_bank_code[PD_BANK_CODE_LEN + 1];
		varchar		v_cutoff_time[PD_DATETIME_LEN + 1];
		int		v_check_count;
		int		v_min_success_count;
		int		v_start_buffer_period;
		int		v_min_total;

		short		ind_party_id = -1;
		short		ind_bank_code = -1;
		short		ind_cutoff_time = -1;
		short		ind_check_count = -1;
		short		ind_min_success_count = -1;
		short		ind_start_buffer_period = -1;
		short		ind_min_total = -1;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE c_cursor_getbanktxn CURSOR FOR
		SELECT	BC_PARTY_ID,
			BC_BANK_CODE,
			TO_CHAR(BC_CUTOFF_CHECKING_TIME,'YYYYMMDDHH24MISS'),
			BC_CHECK_COUNT,
			BC_MIN_SUCCESS_COUNT,
			BC_START_BUFFER_PERIOD,
			BC_MIN_TOTAL
		FROM	BANK_TXN_CHECK
		WHERE	BC_DISABLED = 0
		ORDER by BC_BANK_CODE;

        EXEC SQL OPEN c_cursor_getbanktxn;
        do {
		EXEC SQL FETCH c_cursor_getbanktxn
		INTO	:v_party_id:ind_party_id,
			:v_bank_code:ind_bank_code,
			:v_cutoff_time:ind_cutoff_time,
			:v_check_count:ind_check_count,
			:v_min_success_count:ind_min_success_count,
			:v_start_buffer_period:ind_start_buffer_period,
			:v_min_total:ind_min_total;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}	

		iCnt++;

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* party_id */	
		if (ind_party_id >= 0) {
			v_party_id.arr[v_party_id.len] = '\0';
			PutField_CString(myHash, "party_id", (const char *)v_party_id.arr);
DEBUGLOG(("GetAllBankCheck party_id = [%s]\n",v_party_id.arr));
		}

/* bank_code */	
		if (ind_bank_code >= 0) {
			v_bank_code.arr[v_bank_code.len] = '\0';
			PutField_CString(myHash, "bank_code", (const char *)v_bank_code.arr);
DEBUGLOG(("GetAllBankCheck bank_code = [%s]\n",v_bank_code.arr));
		}

/* cutoff_time */	
		if (ind_cutoff_time >= 0) {
			v_cutoff_time.arr[v_cutoff_time.len] = '\0';
			PutField_CString(myHash, "cutoff_time", (const char *)v_cutoff_time.arr);
DEBUGLOG(("GetAllBankCheck cutoff_time = [%s]\n",v_cutoff_time.arr));
		}

/* check_count */
		if (ind_check_count >= 0) {
			PutField_Int(myHash, "check_count", v_check_count);
DEBUGLOG(("GetAllBankCheck check_count = [%d]\n", v_check_count));
		}

/* min_success_count */
		if (ind_min_success_count >= 0) {
			PutField_Int(myHash, "min_success_count", v_min_success_count);
DEBUGLOG(("GetAllBankCheck min_success_count = [%d]\n", v_min_success_count));
		}

/* start_buffer_period */
		if (ind_start_buffer_period >= 0) {
			PutField_Int(myHash, "start_buffer_period", v_start_buffer_period);
DEBUGLOG(("GetAllBankCheck start_buffer_period = [%d]\n", v_start_buffer_period));
		}

/* min_total */
		if (ind_min_total >= 0) {
			PutField_Int(myHash, "min_total", v_min_total);
DEBUGLOG(("GetAllBankCheck min_total = [%d]\n", v_min_total));
		}
	
		RecordSet_Add(myRec, myHash);
	}
	while (PD_TRUE);
	EXEC SQL CLOSE c_cursor_getbanktxn;

        if (iCnt > 0 ) {
DEBUGLOG(("GetAllBankCheck Normal Exit\n"));
                return  PD_OK;
        }
        else {
DEBUGLOG(("GetAllBankCheck Normal Exit, Not Found\n"));
                return PD_NOT_FOUND;
        }

getbanktxn_error:
DEBUGLOG(("getbanktxn_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getbanktxn;
        return PD_ERR;

}

int GetAllBankCheckByBank(recordset_t *myRec, char *csBankCode)
{
	int 	iCnt = 0;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getbanktxnbybank_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_bank_code[PD_BANK_CODE_LEN];

		varchar		v_party_id[PD_PSP_ID_LEN + 1];
		varchar		v_cutoff_time[PD_DATETIME_LEN + 1];
		int		v_check_count;
		int		v_min_success_count;
		int		v_start_buffer_period;
		int		v_min_total;

		short		ind_party_id = -1;
		short		ind_cutoff_time = -1;
		short		ind_check_count = -1;
		short		ind_min_success_count = -1;
		short		ind_start_buffer_period = -1;
		short		ind_min_total = -1;

        EXEC SQL END DECLARE SECTION;

	hv_bank_code.len = strlen(csBankCode);
	memcpy(hv_bank_code.arr,csBankCode,hv_bank_code.len);
DEBUGLOG(("GetAllBankCheckByBank hv_bank_code=[%.*s]\n",hv_bank_code.len,hv_bank_code.arr));

        EXEC SQL DECLARE c_cursor_getbankTxnbybank CURSOR FOR
		SELECT	BC_PARTY_ID,
			TO_CHAR(BC_CUTOFF_CHECKING_TIME,'YYYYMMDDHH24MISS'),
			BC_CHECK_COUNT,
			BC_MIN_SUCCESS_COUNT,
			BC_START_BUFFER_PERIOD,
			BC_MIN_TOTAL
		FROM	BANK_TXN_CHECK
		WHERE	BC_DISABLED = 0
		AND	BC_BANK_CODE = :hv_bank_code;

        EXEC SQL OPEN c_cursor_getbankTxnbybank;
        do {
		EXEC SQL FETCH c_cursor_getbankTxnbybank
		INTO	:v_party_id:ind_party_id,
			:v_cutoff_time:ind_cutoff_time,
			:v_check_count:ind_check_count,
			:v_min_success_count:ind_min_success_count,
			:v_start_buffer_period:ind_start_buffer_period,
			:v_min_total:ind_min_total;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}	

		iCnt++;

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* party_id */	
		if (ind_party_id >= 0) {
			v_party_id.arr[v_party_id.len] = '\0';
			PutField_CString(myHash, "party_id", (const char *)v_party_id.arr);
DEBUGLOG(("GetAllBankCheckByBank party_id = [%s]\n",v_party_id.arr));
		}

/* cutoff_time */	
		if (ind_cutoff_time >= 0) {
			v_cutoff_time.arr[v_cutoff_time.len] = '\0';
			PutField_CString(myHash, "cutoff_time", (const char *)v_cutoff_time.arr);
DEBUGLOG(("GetAllBankCheckByBank cutoff_time = [%s]\n",v_cutoff_time.arr));
		}

/* check_count */
		if (ind_check_count >= 0) {
			PutField_Int(myHash, "check_count", v_check_count);
DEBUGLOG(("GetAllBankCheckByBank check_count = [%d]\n", v_check_count));
		}

/* min_success_count */
		if (ind_min_success_count >= 0) {
			PutField_Int(myHash, "min_success_count", v_min_success_count);
DEBUGLOG(("GetAllBankCheckByBank min_success_count = [%d]\n", v_min_success_count));
		}

/* start_buffer_period */
		if (ind_start_buffer_period >= 0) {
			PutField_Int(myHash, "start_buffer_period", v_start_buffer_period);
DEBUGLOG(("GetAllBankCheckByBank start_buffer_period = [%d]\n", v_start_buffer_period));
		}

/* min_total */
		if (ind_min_total >= 0) {
			PutField_Int(myHash, "min_total", v_min_total);
DEBUGLOG(("GetAllBankCheckByBank min_total = [%d]\n", v_min_total));
		}
	
		RecordSet_Add(myRec, myHash);
	}
	while (PD_TRUE);
	EXEC SQL CLOSE c_cursor_getbankTxnbybank;

        if (iCnt > 0 ) {
DEBUGLOG(("GetAllBankCheckByBank Normal Exit\n"));
                return  PD_OK;
        }
        else {
DEBUGLOG(("GetAllBankCheckByBank Normal Exit, Not Found\n"));
                return PD_NOT_FOUND;
        }

getbanktxnbybank_error:
DEBUGLOG(("getbanktxnbybank_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getbankTxnbybank;
        return PD_ERR;

}
