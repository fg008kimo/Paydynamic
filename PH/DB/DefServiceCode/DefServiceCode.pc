/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/04/13             Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "DefServiceCode.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void DefServiceCode(char    cdebug)
{
	cDebug = cdebug;
}

int GetServiceCodeDetail(const char* csServiceCode,recordset_t* myRec)
{

	hash_t *myHash;
	EXEC SQL WHENEVER SQLERROR GOTO getservicecodedetail_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;	
	
	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_service_code[PD_SERVICE_CODE_LEN + 1];

		//varchar	v_ccy_id[PD_CCY_ID_LEN +1];
		//varchar	v_country[PD_COUNTRY_CODE_LEN +1];
		//int	v_ignore_nack;
		int	v_void_payout_with_fee;
		int	v_allow_bal_negative;

		//short	ind_ccy_id = -1;
		//short	ind_country = -1;
		//short	ind_ignore_nack = -1;
		short	ind_void_payout_with_fee = -1;
		short	ind_allow_bal_negative = -1;

	EXEC SQL END DECLARE SECTION;

	hv_service_code.len= strlen(csServiceCode);
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);

	EXEC SQL DECLARE c_cursor_getservicecodedetail CURSOR FOR
		SELECT 	//sc_ccy_id,
			//sc_txn_country,
			//sc_ignore_nack,
			sc_void_payout_with_fee,
			sc_allow_bal_negative
                FROM 	def_service_code
 	       WHERE    sc_code = :hv_service_code;

	EXEC SQL OPEN c_cursor_getservicecodedetail;
        do {    
        	EXEC SQL FETCH c_cursor_getservicecodedetail
              	INTO
			//:v_ccy_id:ind_ccy_id,
			//:v_country:ind_country,
			//:v_ignore_nack:ind_ignore_nack,
			:v_void_payout_with_fee:ind_void_payout_with_fee,
			:v_allow_bal_negative:ind_allow_bal_negative;

		if (SQLCODE == SQL_NOT_FOUND) { 
                	break;
             	}

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

/*
		if (ind_ccy_id >= 0) {
			v_ccy_id.arr[v_ccy_id.len] ='\0';
			PutField_CString(myHash,"ccy",(const char*)v_ccy_id.arr);
DEBUGLOG(("GetServiceCodeDetail ccy_id = [%s]\n",v_ccy_id.arr)); 
		}
*/

/*
		if (ind_country >= 0) {
			v_country.arr[v_country.len] ='\0';
			PutField_CString(myHash,"country",(const char*)v_country.arr);
DEBUGLOG(("GetServiceCodeDetail country = [%s]\n",v_country.arr)); 
		}
*/
/*
		if (ind_ignore_nack >= 0) {
			PutField_Int(myHash,"ignore_nack",v_ignore_nack);
DEBUGLOG(("GetServiceCodeDetail ignore_nack = [%d]\n",v_ignore_nack)); 
		}
*/
		if (ind_void_payout_with_fee>= 0) {
			PutField_Int(myHash,"VPFEE",v_void_payout_with_fee);
DEBUGLOG(("GetServiceCodeDetail void_payout_with_fee = [%d]\n",v_void_payout_with_fee)); 
		}
		if (ind_allow_bal_negative >= 0) {
			PutField_Int(myHash,"allow_bal_negative",v_allow_bal_negative);
DEBUGLOG(("GetServiceCodeDetail allow_bal_negatvie = [%d]\n",v_allow_bal_negative)); 
		}

		RecordSet_Add(myRec,myHash);
	}
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getservicecodedetail;


DEBUGLOG(("GetServiceCodeDetail Normal Exit\n")); 
	return  PD_OK;

getservicecodedetail_error:
DEBUGLOG(("getservicecodedetail_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getservicecodedetail;
        return PD_ERR;
}

int Update(const hash_t *hRls)
{

        char*   csTmp;
        char*   csBuf;
        char*   csServiceCode;
	int	iTmp;

        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

        varchar         hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update def_service_code set sc_update_timestamp  = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

        GetField_CString(hRls,"service_code",&csServiceCode);
DEBUGLOG(("Update:service_code = [%s]\n",csServiceCode));

/* name */
        if (GetField_CString(hRls,"name",&csTmp)) {
DEBUGLOG(("Update:name = [%s]\n",csTmp));
                strcat((char*)hv_dynstmt.arr, ",sc_desc = '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

/* use_lb */
        if (GetField_Int(hRls,"use_lb",&iTmp)) {
DEBUGLOG(("Update:use_lb = [%d]\n",iTmp));
                sprintf(csBuf,"%d",iTmp);
                strcat((char*)hv_dynstmt.arr, ",sc_use_lb = '");
                strcat((char*)hv_dynstmt.arr, csBuf);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

/* select_bank */
        if (GetField_Int(hRls,"select_bank",&iTmp)) {
DEBUGLOG(("Update:select_bank = [%d]\n",iTmp));
                sprintf(csBuf,"%d",iTmp);
                strcat((char*)hv_dynstmt.arr, ",sc_select_bank = '");
                strcat((char*)hv_dynstmt.arr, csBuf);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

/* update user */
        if (GetField_CString(hRls,"update_user",&csTmp)) {
DEBUGLOG(("Update:update_user = [%s]\n",csTmp));
                strcat((char*)hv_dynstmt.arr, ",sc_update_user = '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

	strcat((char *)hv_dynstmt.arr, " WHERE sc_code = '");
        strcat((char *)hv_dynstmt.arr, csServiceCode);
        strcat((char *)hv_dynstmt.arr, "'");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);

DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("DefServiceCode_Update: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Update: SP_INTERNAL_ERR TxnAbort\n"));
        return PD_ERR; 
}
