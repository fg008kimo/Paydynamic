/*
Partnerdelight (c)2014. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/11/24              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "internal.h"
#include "dbutility.h"
#include "OLStmtMatchFilter.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char cDebug;

void OLStmtMatchFilter(char cdebug)
{
	cDebug = cdebug;
}


int GetStmtMatchFilter(const hash_t *hMatchRule, const hash_t *hMatchAction, recordset_t *myRec)
{
	int iRet = PD_OK;
	int iCnt = 0;
	int iTmp;
	char *csTmp;

	hash_t *myHash;

	EXEC SQL WHENEVER SQLERROR GOTO getstmtmatchfilter_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_action_type[PD_ENGINE_ACTION_LEN];
		int hv_action_filter_id;
		varchar hv_first_party[PD_ENGINE_PARTY_LEN];
		varchar hv_second_party[PD_ENGINE_PARTY_LEN];

		int v_sequence;
		int v_group;
		varchar v_party[PD_ENGINE_PARTY_LEN + 1];
		varchar v_filter[PD_STMT_MATCH_FILTER_LEN + 1];
		varchar v_operator[PD_ENGINE_COMPARE_OPERATOR_LEN + 1];
		varchar v_value[PD_STMT_MATCH_VALUE_LEN + 1];
		int v_from_input;
		int v_to_output;
		varchar v_special_handling[50 + 1];
		varchar v_left_operand[PD_MAX_BUFFER + 1];
		varchar v_right_operand[PD_MAX_BUFFER + 1];

		short ind_sequence = -1;
		short ind_group = -1;
		short ind_party = -1;
		short ind_filter = -1;
		short ind_operator = -1;
		short ind_value = -1;
		short ind_from_input = -1;
		short ind_to_output = -1;
		short ind_special_handling = -1;
		short ind_left_operand = -1;
		short ind_right_operand = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hMatchRule, "action_type", &csTmp)) {
		hv_action_type.len = strlen(csTmp);
		strncpy((char*)hv_action_type.arr, csTmp, hv_action_type.len);
DEBUGLOG(("GetStmtMatchFilter action_type = [%.*s]\n", hv_action_type.len, (const char*)hv_action_type.arr));
	} else {
DEBUGLOG(("GetStmtMatchFilter action_type not found!\n"));
		iRet = PD_ERR;
	}

	if (GetField_Int(hMatchRule, "action_filter_id", &iTmp)) {
		hv_action_filter_id = iTmp;
DEBUGLOG(("GetStmtMatchFilter action_filter_id = [%d]\n", hv_action_filter_id));
	} else {
DEBUGLOG(("GetStmtMatchFilter action_filter_id not found!\n"));
		iRet = PD_ERR;
	}

	if (GetField_CString(hMatchAction, "first_party", &csTmp)) {
		hv_first_party.len = strlen(csTmp);
		strncpy((char*)hv_first_party.arr, csTmp, hv_first_party.len);
DEBUGLOG(("GetStmtMatchFilter first_party = [%.*s]\n", hv_first_party.len, (const char*)hv_first_party.arr));
	} else {
DEBUGLOG(("GetStmtMatchFilter first_party not found!\n"));
		iRet = PD_ERR;
	}

	if (GetField_CString(hMatchAction, "second_party", &csTmp)) {
		hv_second_party.len = strlen(csTmp);
		strncpy((char*)hv_second_party.arr, csTmp, hv_second_party.len);
DEBUGLOG(("GetStmtMatchFilter second_party = [%.*s]\n", hv_second_party.len, (const char*)hv_second_party.arr));
	} else {
DEBUGLOG(("GetStmtMatchFilter second_party not found!\n"));
		iRet = PD_ERR;
	}

	EXEC SQL DECLARE c_getstmtmatchfilter CURSOR FOR
		SELECT	OSMF_SEQUENCE,
			OSMF_GROUP,
			OSMF_PARTY,
			OSMF_FILTER,
			OSMF_OPERATOR,
			OSMF_VALUE,
			OSMF_FROM_INPUT,
			OSMF_TO_OUTPUT,
			OSMF_SPECIAL_HANDLING,
			DECODE(OSMF_PARTY, 'both',
				(SELECT OSMM_FIELD FROM OL_STMT_MATCH_FILTER_MAP
					WHERE OSMM_ACTION_TYPE = :hv_action_type AND OSMM_PARTY = :hv_first_party AND OSMM_FILTER = OSMF_FILTER),
				(SELECT OSMM_FIELD FROM OL_STMT_MATCH_FILTER_MAP
					WHERE OSMM_ACTION_TYPE = :hv_action_type AND OSMM_PARTY = OSMF_PARTY AND OSMM_FILTER = OSMF_FILTER)
			) LEFT_OPERAND,
			DECODE (OSMF_PARTY, 'both',
				(SELECT OSMM_FIELD FROM OL_STMT_MATCH_FILTER_MAP
					WHERE OSMM_ACTION_TYPE = :hv_action_type AND OSMM_PARTY = :hv_second_party AND OSMM_FILTER = OSMF_FILTER),
				(SELECT DECODE(OSMF_OPERATOR, 'is', OSMF_VALUE, DECODE(OSMM_ADD_SINGLE_QUOTE, 0, OSMF_VALUE, ''''||OSMF_VALUE||'''')) FROM OL_STMT_MATCH_FILTER_MAP
					WHERE OSMM_ACTION_TYPE = :hv_action_type AND OSMM_PARTY = OSMF_PARTY AND OSMM_FILTER = OSMF_FILTER)
			) RIGHT_OPERAND
		FROM	OL_STMT_MATCH_FILTER
		WHERE	OSMF_ACTION_FILTER_ID = :hv_action_filter_id
		AND	OSMF_DISABLED = 0
		ORDER BY	OSMF_SEQUENCE,
				OSMF_GROUP;

	if (iRet == PD_OK) {
		EXEC SQL OPEN c_getstmtmatchfilter;

		for (;;) {
			EXEC SQL FETCH c_getstmtmatchfilter
			INTO	:v_sequence:ind_sequence,
				:v_group:ind_group,
				:v_party:ind_party,
				:v_filter:ind_filter,
				:v_operator:ind_operator,
				:v_value:ind_value,
				:v_from_input:ind_from_input,
				:v_to_output:ind_to_output,
				:v_special_handling:ind_special_handling,
				:v_left_operand:ind_left_operand,
				:v_right_operand:ind_right_operand;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			iCnt++;

			myHash = (hash_t*) malloc (sizeof(hash_t));
			hash_init(myHash, 0);

			// sequence
			if (ind_sequence >= 0) {
				PutField_Int(myHash, "sequence", v_sequence);
DEBUGLOG(("GetStmtMatchFilter sequence = [%d]\n", v_sequence));
			}

			// group
			if (ind_group >= 0) {
				PutField_Int(myHash, "group", v_group);
DEBUGLOG(("GetStmtMatchFilter group = [%d]\n", v_group));
			}

			// party
			if (ind_party >= 0) {
				v_party.arr[v_party.len] = '\0';
				PutField_CString(myHash, "party", (const char*)v_party.arr);
DEBUGLOG(("GetStmtMatchFilter party = [%s]\n", (const char*)v_party.arr));
			}

			// filter
			if (ind_filter >= 0) {
				v_filter.arr[v_filter.len] = '\0';
				PutField_CString(myHash, "filter", (const char*)v_filter.arr);
DEBUGLOG(("GetStmtMatchFilter filter = [%s]\n", (const char*)v_filter.arr));
			}

			// operator
			if (ind_operator >= 0) {
				v_operator.arr[v_operator.len] = '\0';
				PutField_CString(myHash, "operator", (const char*)v_operator.arr);
DEBUGLOG(("GetStmtMatchFilter operator = [%s]\n", (const char*)v_operator.arr));
			}

			// value
			if (ind_value >= 0) {
				v_value.arr[v_value.len] = '\0';
				PutField_CString(myHash, "value", (const char*)v_value.arr);
DEBUGLOG(("GetStmtMatchFilter value = [%s]\n", (const char*)v_value.arr));
			}

			// from_input
			if (ind_from_input >= 0) {
				PutField_Int(myHash, "from_input", v_from_input);
DEBUGLOG(("GetStmtMatchFilter from_input = [%d]\n", v_from_input));
			}

			// to_output
			if (ind_to_output >= 0) {
				PutField_Int(myHash, "to_output", v_to_output);
DEBUGLOG(("GetStmtMatchFilter to_output = [%d]\n", v_to_output));
			}

			// special_handling
			if (ind_special_handling >= 0) {
				v_special_handling.arr[v_special_handling.len] = '\0';
				PutField_CString(myHash, "special_handling", (const char*)v_special_handling.arr);
DEBUGLOG(("GetStmtMatchFilter special_handling = [%s]\n", (const char*)v_special_handling.arr));
			}

			// left_operand
			if (ind_left_operand >= 0) {
				v_left_operand.arr[v_left_operand.len] = '\0';
				PutField_CString(myHash, "left_operand", (const char*)v_left_operand.arr);
DEBUGLOG(("GetStmtMatchFilter left_operand = [%s]\n", (const char*)v_left_operand.arr));
			}

			// right_operand
			if (ind_right_operand >= 0) {
				v_right_operand.arr[v_right_operand.len] = '\0';
				PutField_CString(myHash, "right_operand", (const char*)v_right_operand.arr);
DEBUGLOG(("GetStmtMatchFilter right_operand = [%s]\n", (const char*)v_right_operand.arr));
			}

			RecordSet_Add(myRec, myHash);
		}

		EXEC SQL CLOSE c_getstmtmatchfilter;

		if (iCnt == 0) {
DEBUGLOG(("GetStmtMatchFilter not found\n"));
ERRLOG("OLStmtMatchFilter:: GetStmtMatchFilter not found\n");
			iRet = PD_ERR;
		}
	}

DEBUGLOG(("GetStmtMatchFilter Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getstmtmatchfilter_error:
DEBUGLOG(("getstmtmatchfilter_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLStmtMatchFilter getstmtmatchfilter_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_getstmtmatchfilter;
	return PD_ERR;
}
