/*
Partnerdelight (c)2014. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/11/21              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "internal.h"
#include "dbutility.h"
#include "OLStmtMatchAction.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char cDebug;

void OLStmtMatchAction(char cdebug)
{
	cDebug = cdebug;
}


int GetStmtMatchAction(const hash_t *hMatchRule, hash_t *myHash)
{
	int iRet = PD_OK;
	int iCnt = 0;
	char *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO getstmtmatchaction_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_action_type[PD_ENGINE_ACTION_LEN];

		varchar v_first_party[PD_ENGINE_PARTY_LEN + 1];
		varchar v_second_party[PD_ENGINE_PARTY_LEN + 1];

		short ind_first_party = -1;
		short ind_second_party = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hMatchRule, "action_type", &csTmp)) {
		hv_action_type.len = strlen(csTmp);
		strncpy((char*)hv_action_type.arr, csTmp, hv_action_type.len);
DEBUGLOG(("GetStmtMatchAction action_type = [%.*s]\n", hv_action_type.len, (const char*)hv_action_type.arr));
	} else {
DEBUGLOG(("GetStmtMatchAction action_type not found!\n"));
		iRet = PD_ERR;
	}

	EXEC SQL DECLARE c_getstmtmatchaction CURSOR FOR
		SELECT	OSMA_FIRST_PARTY,
			OSMA_SECOND_PARTY
		FROM	OL_STMT_MATCH_ACTION
		WHERE	OSMA_ACTION_TYPE = :hv_action_type 
		AND	OSMA_DISABLED = 0;

	if (iRet == PD_OK) {
		EXEC SQL OPEN c_getstmtmatchaction;

		for (;;) {
			EXEC SQL FETCH c_getstmtmatchaction
			INTO	:v_first_party:ind_first_party,
				:v_second_party:ind_second_party;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			iCnt++;

			// first_party
			if (ind_first_party >= 0) {
				v_first_party.arr[v_first_party.len] = '\0';
				PutField_CString(myHash, "first_party", (const char*)v_first_party.arr);
DEBUGLOG(("GetStmtMatchAction first_party = [%s]\n", (const char*)v_first_party.arr));
			}

			// second_party
			if (ind_second_party >= 0) {
				v_second_party.arr[v_second_party.len] = '\0';
				PutField_CString(myHash, "second_party", (const char*)v_second_party.arr);
DEBUGLOG(("GetStmtMatchAction second_party = [%s]\n", (const char*)v_second_party.arr));
			}

			break;
		}

		EXEC SQL CLOSE c_getstmtmatchaction;

		if (iCnt == 0) {
DEBUGLOG(("GetStmtMatchAction not found\n"));
ERRLOG("OLStmtMatchAction:: GetStmtMatchAction not found\n");
			iRet = PD_ERR;
		}
	}

DEBUGLOG(("GetStmtMatchAction Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getstmtmatchaction_error:
DEBUGLOG(("getstmtmatchaction_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLStmtMatchAction getstmtmatchaction_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_getstmtmatchaction;
	return PD_ERR;
}
