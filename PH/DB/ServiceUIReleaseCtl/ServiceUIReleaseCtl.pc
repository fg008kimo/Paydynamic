/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/10/03              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "ServiceUIReleaseCtl.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void ServiceUIReleaseCtl(char cdebug)
{
        cDebug = cdebug;
}

int GetCtlTag(hash_t* hTag)
{
	int iRet = PD_OK;
	int iCnt = 0;
	char	csTag[PD_TAG_LEN+1];

        EXEC SQL WHENEVER SQLERROR GOTO tag_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		int	hv_disabled;
		int	hv_new_ui;
	
                varchar v_tag[PD_TAG_LEN];

                short   ind_tag = -1;
                short   ind_disabled = -1;
                short   ind_new_ui = -1;

        EXEC SQL END DECLARE SECTION;

	hv_disabled=0;
        ind_disabled = 0;

	hv_new_ui=1;
        ind_new_ui= 0;

	EXEC SQL DECLARE c_cursor_gettag CURSOR FOR
		select	rc_tag
		from	service_ui_release_ctl
		where	rc_new_ui = :hv_new_ui
		and	rc_disabled = :hv_disabled
		group by rc_tag;

	EXEC SQL OPEN c_cursor_gettag;
	do {
                EXEC SQL FETCH c_cursor_gettag
                INTO
			:v_tag:ind_tag;
	
		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if(ind_tag>=0){
			v_tag.arr[v_tag.len] = '\0';
			sprintf(csTag,"ctl_tag_%d",iCnt);
			PutField_CString(hTag,csTag,(const char*)v_tag.arr);
DEBUGLOG(("GetCtlTag ctl_tag_%d = [%s]\n",iCnt,v_tag.arr));
			iCnt++;
			PutField_Int(hTag,"tag_cnt",iCnt);
		}

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_gettag;

DEBUGLOG(("GetCtlTag iRet = [%d]\n",iRet));
	return iRet;

tag_error:
DEBUGLOG(("tag_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_gettag;
    	return PD_ERR;
}

int MatchCtlValue(const char* csTag,
		  const char* csInputValue)
{
	int iRet = PD_FALSE;

        EXEC SQL WHENEVER SQLERROR GOTO match_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		int	hv_disabled;
		int	hv_new_ui;
                varchar hv_tag[PD_TAG_LEN];
                varchar hv_value[PD_VALUE_LEN+1];

		int	v_cnt;
                short   ind_cnt = -1;

        EXEC SQL END DECLARE SECTION;

	hv_disabled=0;

	hv_new_ui=1;

	hv_tag.len = strlen((const char*)csTag);
        memcpy(hv_tag.arr,csTag,hv_tag.len);
DEBUGLOG(("MatchCtlValue : Tag = [%.*s]\n",hv_tag.len,hv_tag.arr));

	hv_value.len = strlen((const char*)csInputValue);
        memcpy(hv_value.arr,csInputValue,hv_value.len);
DEBUGLOG(("MatchCtlValue: InputValue = [%.*s]\n",hv_value.len,hv_value.arr));

	EXEC SQL
		select	count(1)
		into	:v_cnt:ind_cnt
		from	service_ui_release_ctl
		where	rc_new_ui = :hv_new_ui
		and	rc_disabled = :hv_disabled
		and	rc_tag = :hv_tag
		and	rc_value = substr(:hv_value, length(:hv_value));

	if(ind_cnt<0)
		v_cnt = 0;

	if(v_cnt>0){
		iRet = PD_TRUE;
	}

DEBUGLOG(("MatchCtlValue iRet = [%d]\n",iRet));
	return iRet;

match_error:
DEBUGLOG(("match_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    	EXEC SQL WHENEVER SQLERROR CONTINUE;
    	return PD_FALSE;
}
