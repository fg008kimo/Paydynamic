/*
Partnerdelight (c)2014. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/01/07              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "internal.h"
#include "dbutility.h"
#include "OLStmtMatchRuleGroup.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char cDebug;

void OLStmtMatchRuleGroup(char cdebug)
{
	cDebug = cdebug;
}


int GetStmtMatchRule(const hash_t *hContext, recordset_t *myRec)
{
	int iRet = PD_OK;
	int iCnt = 0;
	int iTmp;

	hash_t *myHash;

	EXEC SQL WHENEVER SQLERROR GOTO getstmtmatchrule_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		int hv_rule_id;

		int v_sub_rule_id;
		varchar v_first_baid_txn_code[PD_TXN_CODE_LEN + 1];
		varchar v_second_baid_txn_code[PD_TXN_CODE_LEN + 1];
		varchar v_next_engine_action[PD_ENGINE_ACTION_LEN + 1];
		varchar v_next_engine_txn_code[PD_TXN_CODE_LEN + 1];
		varchar v_next_engine_recon_type[PD_ENGINE_RECON_TYPE_LEN + 1];

		short ind_sub_rule_id = -1;
		short ind_first_baid_txn_code = -1;
		short ind_second_baid_txn_code = -1;
		short ind_next_engine_action = -1;
		short ind_next_engine_txn_code = -1;
		short ind_next_engine_recon_type = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_Int(hContext, "rule_id", &iTmp)) {
		hv_rule_id = iTmp;
DEBUGLOG(("GetStmtMatchRule rule_id = [%d]\n", hv_rule_id));
	} else {
DEBUGLOG(("GetStmtMatchRule rule_id not found!\n"));
		iRet = PD_ERR;
	}

	EXEC SQL DECLARE c_getstmtmatchrule CURSOR FOR
		SELECT	OSMG_SUB_RULE_ID,
			OSMG_FIRST_BAID_TXN_CODE,
			OSMG_SECOND_BAID_TXN_CODE,
			OSMG_NEXT_ENGINE_ACTION,
			OSMG_NEXT_ENGINE_TXN_CODE,
			OSMG_NEXT_ENGINE_RECON_TYPE
		FROM	OL_STMT_MATCH_RULE_GROUP
		WHERE	OSMG_RULE_ID = :hv_rule_id
		AND	OSMG_DISABLED = 0
		ORDER BY	OSMG_SUB_RULE_ID;

	if (iRet == PD_OK) {
		EXEC SQL OPEN c_getstmtmatchrule;

		for (;;) {
			EXEC SQL FETCH c_getstmtmatchrule
			INTO	:v_sub_rule_id:ind_sub_rule_id,
				:v_first_baid_txn_code:ind_first_baid_txn_code,
				:v_second_baid_txn_code:ind_second_baid_txn_code,
				:v_next_engine_action:ind_next_engine_action,
				:v_next_engine_txn_code:ind_next_engine_txn_code,
				:v_next_engine_recon_type:ind_next_engine_recon_type;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			iCnt++;

			myHash = (hash_t*) malloc (sizeof(hash_t));
			hash_init(myHash, 0);

			// sub_rule_id
			if (ind_sub_rule_id >= 0) {
				PutField_Int(myHash, "sub_rule_id", v_sub_rule_id);
DEBUGLOG(("GetStmtMatchRule sub_rule_id = [%d]\n", v_sub_rule_id));
			}

			// first_baid_txn_code
			if (ind_first_baid_txn_code >= 0) {
				v_first_baid_txn_code.arr[v_first_baid_txn_code.len] = '\0';
				PutField_CString(myHash, "first_baid_txn_code", (const char*)v_first_baid_txn_code.arr);
DEBUGLOG(("GetStmtMatchRule first_baid_txn_code = [%s]\n", (const char*)v_first_baid_txn_code.arr));
			}

			// second_baid_txn_code
			if (ind_second_baid_txn_code >= 0) {
				v_second_baid_txn_code.arr[v_second_baid_txn_code.len] = '\0';
				PutField_CString(myHash, "second_baid_txn_code", (const char*)v_second_baid_txn_code.arr);
DEBUGLOG(("GetStmtMatchRule second_baid_txn_code = [%s]\n", (const char*)v_second_baid_txn_code.arr));
			}

			// next_engine_action
			if (ind_next_engine_action >= 0) {
				v_next_engine_action.arr[v_next_engine_action.len] = '\0';
				PutField_CString(myHash, "next_engine_action", (const char*)v_next_engine_action.arr);
DEBUGLOG(("GetStmtMatchRule next_engine_action = [%s]\n", (const char*)v_next_engine_action.arr));
			}

			// next_engine_txn_code
			if (ind_next_engine_txn_code >= 0) {
				v_next_engine_txn_code.arr[v_next_engine_txn_code.len] = '\0';
				PutField_CString(myHash, "next_engine_txn_code", (const char*)v_next_engine_txn_code.arr);
DEBUGLOG(("GetStmtMatchRule next_engine_txn_code = [%s]\n", (const char*)v_next_engine_txn_code.arr));
			}

			// next_engine_recon_type
			if (ind_next_engine_recon_type >= 0) {
				v_next_engine_recon_type.arr[v_next_engine_recon_type.len] = '\0';
				PutField_CString(myHash, "next_engine_recon_type", (const char*)v_next_engine_recon_type.arr);
DEBUGLOG(("GetStmtMatchRule next_engine_recon_type = [%s]\n", (const char*)v_next_engine_recon_type.arr));
			}

			RecordSet_Add(myRec, myHash);
		}

		EXEC SQL CLOSE c_getstmtmatchrule;

		if (iCnt == 0) {
DEBUGLOG(("GetStmtMatchRule not found\n"));
ERRLOG("OLStmtMatchRuleGroup:: GetStmtMatchRule not found\n");
			iRet = PD_ERR;
		}
	}

DEBUGLOG(("GetStmtMatchRule Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getstmtmatchrule_error:
DEBUGLOG(("getstmtmatchrule_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLStmtMatchRuleGroup getstmtmatchrule_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_getstmtmatchrule;
	return PD_ERR;
}

