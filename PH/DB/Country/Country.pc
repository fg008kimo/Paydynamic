/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/27              Cody Chan
Add system_support				   2012/12/14		   Stan Poon
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "Country.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void Country(char    cdebug)
{
	cDebug = cdebug;
}

int GetAllCountry(recordset_t* myRec)
{

	hash_t *myHash;
	EXEC SQL WHENEVER SQLERROR GOTO getallcountry_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;	
	
	EXEC SQL BEGIN DECLARE SECTION;
		varchar	v_country_code[PD_COUNTRY_CODE_LEN + 1];

		short	ind_country_code = -1;
	EXEC SQL END DECLARE SECTION;


	EXEC SQL DECLARE c_cursor_getallcountry CURSOR FOR
		SELECT 	country_code
                FROM 	country
	         WHERE disabled = 0 AND system_support = 1;


	EXEC SQL OPEN c_cursor_getallcountry;
        do {    
        	EXEC SQL FETCH c_cursor_getallcountry
              	INTO
			:v_country_code:ind_country_code;

		if (SQLCODE == SQL_NOT_FOUND) { 
                	break;
             	}

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

		if (ind_country_code >= 0) {
			v_country_code.arr[v_country_code.len] ='\0';
			PutField_CString(myHash,"country_code",(const char*)v_country_code.arr);
DEBUGLOG(("GetAllCountry product = [%s]\n",v_country_code.arr)); 
		}
		RecordSet_Add(myRec,myHash);
	}
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getallcountry;


DEBUGLOG(("GetAllCountry Normal Exit\n")); 
	return  PD_OK;

getallcountry_error:
DEBUGLOG(("getallcountry_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getallcountry;
        return PD_ERR;
}

int FindCountry(const char* csCountry)
{
	int	iRet = PD_NOT_FOUND;

	EXEC SQL WHENEVER SQLERROR GOTO getcountry_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;	
	
	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_country[PD_COUNTRY_LEN +1];
		short	v_cnt;

		short	ind_country = -1;

	EXEC SQL END DECLARE SECTION;

	hv_country.len = strlen(csCountry);
	memcpy(hv_country.arr,csCountry,hv_country.len);

	ind_country = 0;

DEBUGLOG(("FindCountry country = [%s]\n",csCountry));

	EXEC SQL DECLARE c_cursor_getcountry CURSOR FOR
		SELECT 	count(*)
                FROM 	country
	        WHERE country_code = :hv_country:ind_country
	          AND disabled = 0 And system_support = 1;


	EXEC SQL OPEN c_cursor_getcountry;
        do {    
        	EXEC SQL FETCH c_cursor_getcountry
              	INTO
			:v_cnt;

		if (SQLCODE == SQL_NOT_FOUND) { 
                	break;
             	}

		if (v_cnt > 0) {
			iRet = PD_FOUND;
		}
	}
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getcountry;


DEBUGLOG(("GetCountry Normal Exit = [%d]\n",iRet)); 
	return  iRet;

getcountry_error:
DEBUGLOG(("getcountry_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getcountry;
        return iRet;
}

