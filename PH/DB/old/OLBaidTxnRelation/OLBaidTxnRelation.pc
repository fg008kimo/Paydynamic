/*
Partnerdelight (c)2014. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/12/27              Virginia Yun
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLBaidTxnRelation.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void OLBaidTxnRelation(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hRelation)
{
	char	*csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_txn_id[PD_TXN_SEQ_LEN];
		varchar		hv_baid_txn_id[PD_TXN_SEQ_LEN];
		varchar		hv_create_user[PD_USER_LEN];

		short		ind_txn_id = -1;
		short		ind_baid_txn_id = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;

	EXEC SQL END DECLARE SECTION;


DEBUGLOG(("Add: Begin\n"));

	if(GetField_CString(hRelation, "txn_seq", &csTmp))
	{
		hv_txn_id.len = strlen(csTmp);
		strncpy((char*)hv_txn_id.arr, csTmp, hv_txn_id.len);
		ind_txn_id = 0;
DEBUGLOG(("Add:txn_id = [%.*s]\n", hv_txn_id.len, hv_txn_id.arr));
	}

	if(GetField_CString(hRelation, "baid_txn_seq", &csTmp))
	{
		hv_baid_txn_id.len = strlen(csTmp);
		strncpy((char*)hv_baid_txn_id.arr, csTmp, hv_baid_txn_id.len);
		ind_baid_txn_id = 0;
DEBUGLOG(("Add:baid_txn_id = [%.*s]\n", hv_baid_txn_id.len, hv_baid_txn_id.arr));
	}

	if(GetField_CString(hRelation, "create_user", &csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));
	}

	EXEC SQL EXECUTE
	    BEGIN
		:hv_return_value := sp_ol_baid_txn_relation_insert(
				:hv_txn_id:ind_txn_id,
				:hv_baid_txn_id:ind_baid_txn_id,
				:hv_create_user:ind_create_user);
	    END;
	END-EXEC;

DEBUGLOG(("Add:Ret = [%d]\n", hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("OLBaidTxnRelation_Add: SP_OTHER_ERR \n");
DEBUGLOG(("Add: SP_OTHER_ERR \n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("OLBaidTxnRelation_Add: SP_ERR \n");
DEBUGLOG(("Add: SP_ERR \n"));
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBaidTxnRelation_Add: SP_INTERNAL_ERR \n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int GetRelationByTxn(const char *csTxnID,
		recordset_t *myRec)
{
	hash_t	*myHash;
	int	iCnt = 0;

	EXEC SQL WHENEVER SQLERROR GOTO getrelationbytxn_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		short		hv_return_value;

		varchar         hv_txn_id[PD_TXN_SEQ_LEN];
		short		ind_txn_id = -1;

		varchar		v_baid_txn_id[PD_TXN_SEQ_LEN + 1];
		short		ind_baid_txn_id = -1;

		SQL_CURSOR      c_cursor_relationbytxn;

	EXEC SQL END DECLARE SECTION;

	hv_txn_id.len = strlen(csTxnID);
	memcpy(hv_txn_id.arr, csTxnID, hv_txn_id.len);
DEBUGLOG(("GetRelationByTxn txn_id = [%.*s]\n", hv_txn_id.len, hv_txn_id.arr));
	ind_txn_id = 0;

	EXEC SQL ALLOCATE       :c_cursor_relationbytxn;
	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_ol_txn_2_btxn_relation(
							:hv_txn_id:ind_txn_id,
							:c_cursor_relationbytxn);
		END;
	END-EXEC;

DEBUGLOG(("GetRelationByTxn open cursor ++++++++++++++++++++++++++++++++++++++\n"));
        if (hv_return_value > 0)  {
DEBUGLOG(("GetRelationByTxn Found\n"));
		EXEC SQL WHENEVER NOTFOUND DO break;
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
			hash_init(myHash,0);

			ind_baid_txn_id = -1;

			EXEC SQL FETCH :c_cursor_relationbytxn
			INTO :v_baid_txn_id:ind_baid_txn_id;

			iCnt++;

			if (ind_baid_txn_id >= 0) {
				v_baid_txn_id.arr[v_baid_txn_id.len] = '\0';
DEBUGLOG(("GetRelationByTxn [%d] baid_txn_id = [%s]\n", iCnt, v_baid_txn_id.arr));
				PutField_CString(myHash, "baid_txn_id",(const char*)v_baid_txn_id.arr);
			}

			RecordSet_Add(myRec, myHash);
		}

		EXEC SQL CLOSE :c_cursor_relationbytxn;
		EXEC SQL FREE :c_cursor_relationbytxn;
DEBUGLOG(("GetRelationByTxn Close cursor-------------------------------------\n"));
		return PD_OK;
	}
	else {
DEBUGLOG(("GetRelationByTxn Not Found\n"));
		EXEC SQL CLOSE :c_cursor_relationbytxn;
		EXEC SQL FREE :c_cursor_relationbytxn;
DEBUGLOG(("GetRelationByTxn Close cursor\n"));
		return PD_ERR;
	}

getrelationbytxn_error:
ERRLOG("OLBaidTxnRelationByTxn::getrelationbytxn_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("getrelationbytxn_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_relationbytxn;
	EXEC SQL FREE :c_cursor_relationbytxn;
	return PD_ERR;
}

int GetRelationByBaidTxn(const char *csBaidTxnID,
		recordset_t *myRec)
{
	hash_t	*myHash;
	int	iCnt = 0;

	EXEC SQL WHENEVER SQLERROR GOTO getrelationbybaidtxn_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		short		hv_return_value;

		varchar         hv_baid_txn_id[PD_TXN_SEQ_LEN];
		short		ind_baid_txn_id = -1;

		varchar		v_txn_id[PD_TXN_SEQ_LEN + 1];
		short		ind_txn_id = -1;

		SQL_CURSOR      c_cursor_relationbybaidtxn;

	EXEC SQL END DECLARE SECTION;

	hv_baid_txn_id.len = strlen(csBaidTxnID);
	memcpy(hv_baid_txn_id.arr, csBaidTxnID, hv_baid_txn_id.len);
DEBUGLOG(("GetRelationByBaidTxn baid_txn_id = [%.*s]\n", hv_baid_txn_id.len, hv_baid_txn_id.arr));
	ind_txn_id = 0;

	EXEC SQL ALLOCATE       :c_cursor_relationbybaidtxn;
	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_ol_btxn_2_txn_relation(
							:hv_baid_txn_id:ind_baid_txn_id,
							:c_cursor_relationbybaidtxn);
		END;
	END-EXEC;

DEBUGLOG(("GetRelationByBaidTxn open cursor ++++++++++++++++++++++++++++++++++++++\n"));
        if (hv_return_value > 0)  {
DEBUGLOG(("GetRelationByBaidTxn Found\n"));
		EXEC SQL WHENEVER NOTFOUND DO break;
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
			hash_init(myHash,0);

			ind_baid_txn_id = -1;

			EXEC SQL FETCH :c_cursor_relationbybaidtxn
			INTO :v_txn_id:ind_txn_id;

			iCnt++;

			if (ind_txn_id >= 0) {
				v_txn_id.arr[v_txn_id.len] = '\0';
DEBUGLOG(("GetRelationByBaidTxn [%d] txn_id = [%s]\n", iCnt, v_txn_id.arr));
				PutField_CString(myHash, "txn_id",(const char*)v_txn_id.arr);
			}

			RecordSet_Add(myRec, myHash);
		}

		EXEC SQL CLOSE :c_cursor_relationbybaidtxn;
		EXEC SQL FREE :c_cursor_relationbybaidtxn;
DEBUGLOG(("GetRelationByBaidTxn Close cursor-------------------------------------\n"));
		return PD_OK;
	}
	else {
DEBUGLOG(("GetRelationByBaidTxn Not Found\n"));
		EXEC SQL CLOSE :c_cursor_relationbybaidtxn;
		EXEC SQL FREE :c_cursor_relationbybaidtxn;
DEBUGLOG(("GetRelationByBaidTxn Close cursor\n"));
		return PD_ERR;
	}

getrelationbybaidtxn_error:
ERRLOG("OLBaidTxnRelationByBaidTxn::getrelationbybaidtxn_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("getrelationbybaidtxn_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_relationbybaidtxn;
	EXEC SQL FREE :c_cursor_relationbybaidtxn;
	return PD_ERR;
}



