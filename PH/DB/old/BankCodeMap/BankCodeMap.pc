/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/02/23              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "BankCodeMap.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void BankCodeMap(char    cdebug)
{
        cDebug = cdebug;
}


int BankCodeMap(const unsigned char* csInputBankCode,
		recordset_t* myRec)
{

	int iRet = NOT_FOUND;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO map_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_bank_code[PD_BANK_CODE_LEN];
		char	hv_disabled;

                varchar v_int_bank_code[PD_BANK_CODE_LEN+1];
                varchar v_country[PD_COUNTRY_LEN+1];
		varchar	v_bank_name[PD_BANK_NAME_LEN+1];

                short   ind_int_bank_code = -1;
		short	ind_country = -1;
		short	ind_bank_name = -1;
        EXEC SQL END DECLARE SECTION;

        hv_bank_code.len = strlen(csInputBankCode);
        memcpy(hv_bank_code.arr,csInputBankCode,hv_bank_code.len);
DEBUGLOG(("BankCodeMap: Txn Code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr)); 

	hv_disabled='0';

	EXEC SQL DECLARE c_cursor_map CURSOR FOR
        	select  internal_bank_code,
			country,
			bank_name
                from	bank_code_mappings
                where vnc_bank_code=:hv_bank_code
		and   disabled=:hv_disabled
		and   effect_date <=sysdate;


	EXEC SQL OPEN c_cursor_map;
	do{	
		EXEC SQL FETCH c_cursor_map
                INTO
			:v_int_bank_code:ind_int_bank_code,
			:v_country:ind_country,
			:v_bank_name:ind_bank_name;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

        	if (ind_int_bank_code >= 0) {
                	v_int_bank_code.arr[v_int_bank_code.len] = '\0';
			PutField_CString(myHash,"internal_bank_code",v_int_bank_code.arr);
DEBUGLOG(("internal_bank_code = [%.*s]\n",v_int_bank_code.len,v_int_bank_code.arr));
		}
 
       	 	if (ind_country >= 0) {
               	 	v_country.arr[v_country.len] = '\0';
			PutField_CString(myHash,"country",v_country.arr);
DEBUGLOG(("country = [%.*s]\n",v_country.len,v_country.arr)); 
		}

       	 	if (ind_bank_name>= 0) {
               	 	v_bank_name.arr[v_bank_name.len] = '\0';
			PutField_CString(myHash,"bank_name",v_bank_name.arr);
DEBUGLOG(("bank_name = [%.*s]\n",v_bank_name.len,v_bank_name.arr)); 
		}

		iRet = FOUND;
		RecordSet_Add(myRec,myHash);

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_map;

	if(iRet == FOUND){
DEBUGLOG(("BankCodeMap success = [%d]\n",iRet));
	}
	else{
DEBUGLOG(("BankCodeMap failed = [%d]\n",iRet));
	}

	return iRet;

map_error:
DEBUGLOG(("map_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}

