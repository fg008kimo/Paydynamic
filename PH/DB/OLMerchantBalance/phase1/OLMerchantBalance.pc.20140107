/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/09/11              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLMerchantBalance.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void OLMerchantBalance(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
		const char* csServiceCode,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_service_code = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


DEBUGLOG(("Add: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("Add:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy((char *)hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("Add:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy((char *)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("Add:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_service_code.len = strlen(csServiceCode);
	strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("Add:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_create_user.len = strlen(csUser);
	strncpy((char *)hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_ol_merchant_balance_insert(
				:hv_merchant_id:ind_merchant_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_country_id:ind_country_id,
				:hv_service_code:ind_service_code,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("OLMerchantBlance::Add: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		//TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("OLMerchantBlance::Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		//TxnAbort();
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetCurrentValues(const char* csMerchantID,
                        const char* csCurrencyId,
                        const char* csCountryId,
                        const char* csServiceCode,
                        hash_t *hVal)
{
        int iRet = PD_OK;

        EXEC SQL WHENEVER SQLERROR GOTO getcurrval_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
                varchar         hv_ccy_id[PD_CCY_ID_LEN];
                varchar         hv_country_id[PD_COUNTRY_LEN];
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];

                double          v_current_bal;
                double          v_total_hold;
                double          v_in_intransit;
                double          v_out_intransit;

                short           ind_current_bal= -1;
                short           ind_total_hold= -1;
                short           ind_in_intransit= -1;
                short           ind_out_intransit= -1;

        EXEC SQL END DECLARE SECTION;

        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetCurrentValues merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetCurrentValues ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("GetCurrentValues country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetCurrentValues service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

        EXEC SQL DECLARE c_cursor_getcurrval CURSOR FOR
                select  
                        om_current_bal,
                        om_total_hold,
                        om_total_in_intransit,
                        om_total_out_intransit
                  from  ol_merchant_balance
                 where  om_merchant_id = :hv_merchant_id
                   and  om_currency_id = :hv_ccy_id
                   and  om_country_id = :hv_country_id
                   and  om_service_code = :hv_service_code;

        EXEC SQL OPEN c_cursor_getcurrval;
        do {
                EXEC SQL FETCH c_cursor_getcurrval
                INTO
                        :v_current_bal:ind_current_bal,
                        :v_total_hold:ind_total_hold,
                        :v_in_intransit:ind_in_intransit,
                        :v_out_intransit:ind_out_intransit;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

//current_bal
                if(ind_current_bal<0)
                        v_current_bal = 0.0;
                PutField_Double(hVal,"current_bal",v_current_bal);
DEBUGLOG(("GetCurrentValues current_bal = [%f]\n",v_current_bal));


//total_hold
                if(ind_total_hold<0)
                        v_total_hold= 0;
                PutField_Double(hVal,"total_hold",v_total_hold);
DEBUGLOG(("GetCurrentValues total_hold = [%f]\n",v_total_hold));


//in_intransit
                if(ind_in_intransit<0)
                        v_in_intransit= 0;
                PutField_Double(hVal,"in_intransit",v_in_intransit);
DEBUGLOG(("GetCurrentValues in_intransit = [%f]\n",v_in_intransit));

//out_intransit
                if(ind_out_intransit<0)
                        v_out_intransit= 0;
                PutField_Double(hVal,"out_intransit",v_out_intransit);
DEBUGLOG(("GetCurrentValues out_intransit = [%f]\n",v_out_intransit));

        }

        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getcurrval;

DEBUGLOG(("GetCurrentValues Normal Exit\n"));
        return iRet;

getcurrval_error:
DEBUGLOG(("getcurrval_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getcurrval;
        return PD_ERR;
}


int UpdateCurrBal(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                const char* csServiceCode,
                double  dAmt,
                const char cType,
                const char* csUser)

{
        EXEC SQL WHENEVER SQLERROR GOTO updatecurrbal_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
                varchar         hv_country_id[PD_COUNTRY_LEN];
                varchar         hv_ccy_id[PD_CCY_ID_LEN];
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];
                double          hv_amt;
                varchar         hv_create_user[PD_USER_LEN];

                short           ind_merchant_id = -1;
                short           ind_country_id = -1;
                short           ind_ccy_id = -1;
                short           ind_service_code = -1;
                short           ind_amt = -1;
                short           ind_create_user = -1;

                short           hv_return_value;
        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateCurrBal: Begin\n"));

        hv_merchant_id.len = strlen(csMerchantId);
        strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
        ind_merchant_id = 0;
DEBUGLOG(("UpdateCurrBal:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

        hv_country_id.len = strlen(csCountryId);
        strncpy((char *)hv_country_id.arr, csCountryId, hv_country_id.len);
        ind_country_id = 0;
DEBUGLOG(("UpdateCurrBal:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

        hv_ccy_id.len = strlen(csCcy);
        strncpy((char *)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
        ind_ccy_id = 0;
DEBUGLOG(("UpdateCurrBal:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

        hv_service_code.len = strlen(csServiceCode);
        strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
        ind_service_code = 0;
DEBUGLOG(("UpdateCurrBal:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

        if(cType==PD_IND_DEBIT){
                hv_amt = (-1)*(dAmt);
        }
	else{
        	hv_amt= dAmt;
	}
        ind_amt= 0;
DEBUGLOG(("UpdateCurrBal:net amt = [%f]\n",hv_amt));
DEBUGLOG(("UpdateCurrBal:type = [%c]\n",cType));

        hv_create_user.len = strlen(csUser);
        strncpy((char *)hv_create_user.arr, csUser, hv_create_user.len);
        ind_create_user = 0;
DEBUGLOG(("UpdateCurrBal:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


        EXEC SQL EXECUTE
            BEGIN

                :hv_return_value := sp_ol_merchant_bal_upd_bal(
                                :hv_merchant_id:ind_merchant_id,
                                :hv_country_id:ind_country_id,
                                :hv_ccy_id:ind_ccy_id,
                                :hv_service_code:ind_service_code,
                                :hv_amt:ind_amt,
                                :hv_create_user:ind_create_user);

            END;
        END-EXEC;


DEBUGLOG(("UpdateCurrBal:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK){
DEBUGLOG(("UpdateCurrBal:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateCurrBal: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateCurrBal: SP_OTHER_ERR TxnAbort\n"));
                TxnAbort();
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateCurrBal: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateCurrBal: SP_ERR TxnAbort\n"));
                TxnAbort();
                return PD_ERR;
        }

updatecurrbal_error:
DEBUGLOG(("updatecurrbal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        TxnAbort();
        return PD_ERR;
}

int UpdateHoldBalance(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                const char* csServiceCode,
                double  dAmt,
                const char  cType,
                const char* csUser)

{
        EXEC SQL WHENEVER SQLERROR GOTO updatehold_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
                varchar         hv_country_id[PD_COUNTRY_LEN];
                varchar         hv_ccy_id[PD_CCY_ID_LEN];
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];
                double          hv_hold;
                varchar         hv_create_user[PD_USER_LEN];


                short           ind_merchant_id = -1;
                short           ind_country_id = -1;
                short           ind_ccy_id = -1;
                short           ind_service_code = -1;
                short           ind_hold = -1;
                short           ind_create_user = -1;

                short           hv_return_value;
        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateHoldBalance: Begin\n"));

        hv_merchant_id.len = strlen(csMerchantId);
        strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
        ind_merchant_id = 0;
DEBUGLOG(("UpdateHoldBalance:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

        hv_country_id.len = strlen(csCountryId);
        strncpy((char *)hv_country_id.arr, csCountryId, hv_country_id.len);
        ind_country_id = 0;
DEBUGLOG(("UpdateHoldBalance:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

        hv_ccy_id.len = strlen(csCcy);
        strncpy((char *)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
        ind_ccy_id = 0;
DEBUGLOG(("UpdateHoldBalance:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

        hv_service_code.len = strlen(csServiceCode);
        strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
        ind_service_code = 0;
DEBUGLOG(("UpdateHoldBalance:ccy_id = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

        if(cType==PD_HOLD)
        	hv_hold= dAmt;
	else
        	hv_hold= (-1)*dAmt;
        ind_hold= 0;
DEBUGLOG(("UpdateHoldBalance:net hold = [%f]\n",hv_hold));
DEBUGLOG(("UpdateHoldBalance:hold_type = [%c]\n",cType));

        hv_create_user.len = strlen(csUser);
        strncpy((char *)hv_create_user.arr, csUser, hv_create_user.len);
        ind_create_user = 0;
DEBUGLOG(("UpdateHoldBalance:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
		BEGIN

			:hv_return_value := sp_ol_merchant_bal_upd_hold(
                                        :hv_merchant_id:ind_merchant_id,
                                        :hv_country_id:ind_country_id,
                                        :hv_ccy_id:ind_ccy_id,
                                        :hv_service_code:ind_service_code,
                                        :hv_hold:ind_hold,
                                        :hv_create_user:ind_create_user);

		END;
	END-EXEC;

DEBUGLOG(("UpdateHoldBalance:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
DEBUGLOG(("UpdateHoldBalance:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateHoldBalance: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateHoldBalance: SP_OTHER_ERR TxnAbort\n"));
                TxnAbort();
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateHoldBalance: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateHoldBalance: SP_ERR TxnAbort\n"));
                TxnAbort();
                return PD_ERR;
        }

updatehold_error:
DEBUGLOG(("updatehold_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        TxnAbort();
        return PD_ERR;
}

int UpdateInTransit(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                const char* csServiceCode,
                double  dAmt,
                const char  cType,
                const char* csDirection,
                const char* csUser)

{

        EXEC SQL WHENEVER SQLERROR GOTO upd_sett_intransit_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
                varchar         hv_country_id[PD_COUNTRY_LEN];
                varchar         hv_ccy_id[PD_CCY_ID_LEN];
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];
                double          hv_amt;
                varchar         hv_user[PD_USER_LEN];

                short           ind_merchant_id = -1;
                short           ind_country_id = -1;
                short           ind_ccy_id = -1;
                short           ind_service_code = -1;
                short           ind_amt = -1;
                short           ind_user = -1;

                short           hv_return_value;
        EXEC SQL END DECLARE SECTION;


DEBUGLOG(("UpdateInTransit: Begin\n"));

        hv_merchant_id.len = strlen(csMerchantId);
        strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
        ind_merchant_id = 0;

        hv_country_id.len = strlen(csCountryId);
        strncpy((char *)hv_country_id.arr, csCountryId, hv_country_id.len);
        ind_country_id = 0;

        hv_ccy_id.len = strlen(csCcy);
        strncpy((char *)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
        ind_ccy_id = 0;

        hv_service_code.len = strlen(csServiceCode);
        strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
        ind_service_code = 0;

        if(cType==PD_IND_DEBIT){
                hv_amt = (-1)*(dAmt);
                ind_amt= 0;
        }
        else{
                hv_amt = dAmt;
                ind_amt= 0;
        }
DEBUGLOG(("UpdateInTransit:net_amt = [%f]\n",hv_amt));
DEBUGLOG(("UpdateInTransit:type => [%c]\n",cType));

        hv_user.len = strlen(csUser);
        strncpy((char *)hv_user.arr, csUser, hv_user.len);
        ind_user = 0;

	if(!strcmp(csDirection,PD_TRANSFER_IN)){
                EXEC SQL EXECUTE
                   BEGIN

                        :hv_return_value := sp_ol_merch_bal_in_intransit(
                                :hv_merchant_id:ind_merchant_id,
                                :hv_country_id:ind_country_id,
                                :hv_ccy_id:ind_ccy_id,
                                :hv_service_code:ind_service_code,
                                :hv_amt:ind_amt,
                                :hv_user:ind_user);

                   END;
                END-EXEC;
	}
	else if(!strcmp(csDirection,PD_TRANSFER_OUT)){
                EXEC SQL EXECUTE
                   BEGIN

                        :hv_return_value := sp_ol_merch_bal_out_intransit(
                                :hv_merchant_id:ind_merchant_id,
                                :hv_country_id:ind_country_id,
                                :hv_ccy_id:ind_ccy_id,
                                :hv_service_code:ind_service_code,
                                :hv_amt:ind_amt,
                                :hv_user:ind_user);

                   END;
                END-EXEC;
	}


        if (hv_return_value == SP_OK)        {
DEBUGLOG(("UpdateInTransit:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateInTransit: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateInTransit: SP_OTHER_ERR TxnAbort\n"));
                TxnAbort();
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateInTransit: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateInTransit: SP_ERR TxnAbort\n"));
                TxnAbort();
                return PD_ERR;
        }
upd_sett_intransit_error:
DEBUGLOG(("upd_sett_intransit_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        TxnAbort();
        return PD_ERR;
}

int GetOpenBalanceForUpdate(hash_t* hContext,
                const char* csMerchantID,
                const char* csCurrencyId,
                const char* csCountryId,
                const char* csServiceCode)
{
        int iRet = PD_OK;
        double dBal = 0.0;
        double dHold = 0.0;
        double dInIntransit = 0.0;
        double dOutIntransit = 0.0;


        EXEC SQL WHENEVER SQLERROR GOTO getopenbalforupdate_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
                varchar         hv_ccy_id[PD_CCY_ID_LEN];
                varchar         hv_country_id[PD_COUNTRY_LEN];
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];

                double          v_current_bal;
                double          v_total_hold;
                double          v_in_intransit;
                double          v_out_intransit;

                short           ind_current_bal= -1;
                short           ind_total_hold= -1;
                short           ind_in_intransit = -1;
                short           ind_out_intransit = -1;

        EXEC SQL END DECLARE SECTION;

        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetOpenBalanceForUpdate merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetOpenBalanceForUpdate ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("GetOpenBalanceForUpdate country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetOpenBalanceForUpdate service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));


        EXEC SQL DECLARE c_cursor_getopenbalforupdate CURSOR FOR
                select  om_current_bal,
                        om_total_hold,
                        om_total_in_intransit,
                        om_total_out_intransit
                  from ol_merchant_balance
                 where om_merchant_id = :hv_merchant_id
                   and om_currency_id = :hv_ccy_id
                   and om_country_id = :hv_country_id
                   and om_service_code = :hv_service_code
                 for update;


        EXEC SQL OPEN c_cursor_getopenbalforupdate;
        do {
                EXEC SQL FETCH c_cursor_getopenbalforupdate
                INTO
                        :v_current_bal:ind_current_bal,
                        :v_total_hold:ind_total_hold,
                        :v_in_intransit:ind_in_intransit,
                        :v_out_intransit:ind_out_intransit;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if(ind_current_bal<0) {
                        v_current_bal = 0.0;
                }
                if(ind_total_hold<0) {
                        v_total_hold= 0.0;
                }
                if(ind_in_intransit <0) {
                        v_in_intransit = 0.0;
                }
                if(ind_out_intransit <0) {
                        v_out_intransit = 0.0;
                }


                dBal = v_current_bal;
                dHold = v_total_hold;
                dInIntransit = v_in_intransit;
                dOutIntransit = v_out_intransit;
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getopenbalforupdate;

DEBUGLOG(("GetOpenBalanceForUpdate open_bal = [%f]\n",dBal));
                PutField_Double(hContext,"merchant_open_bal",dBal);
DEBUGLOG(("GetOpenBalanceForUpdate total_hold = [%f]\n",dHold));
                PutField_Double(hContext,"total_hold",dHold);
DEBUGLOG(("GetOpenBalanceForUpdate in_intransit = [%f]\n",dInIntransit));
                PutField_Double(hContext,"in_intransit",dInIntransit);
DEBUGLOG(("GetOpenBalanceForUpdate out_intransit = [%f]\n",dOutIntransit));
                PutField_Double(hContext,"out_intransit",dOutIntransit);

DEBUGLOG(("GetOpenBalanceForUpdate Normal Exit\n"));
        return iRet;

getopenbalforupdate_error:
DEBUGLOG(("getopenbalforupdate_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getopenbalforupdate;
        return PD_ERR;
}


int GetCurrBalance(const char* csMerchantID,
                   const char* csCurrencyId,
		   const char* csCountryId,
		   const char* csServiceCode,
		   double  *dBal)
{
        *dBal = 0.0;
        int iRet = PD_OK;

        EXEC SQL WHENEVER SQLERROR GOTO getcurrbal_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
                varchar         hv_ccy_id[PD_CCY_ID_LEN];
                varchar         hv_country_id[PD_COUNTRY_LEN];
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];

                double          v_current_bal;
                double          v_total_hold;

                short           ind_current_bal= -1;
                short           ind_total_hold= -1;


        EXEC SQL END DECLARE SECTION;

        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetCurrBalance merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetCurrBalance ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("GetCurrBalance country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetCurrBalance service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

        EXEC SQL DECLARE c_cursor_getcurrbal CURSOR FOR
                select  om_current_bal,
                        om_total_hold
                  from ol_merchant_balance
                 where om_merchant_id = :hv_merchant_id
                   and om_currency_id = :hv_ccy_id
                   and om_country_id = :hv_country_id
                   and om_service_code = :hv_service_code;

        EXEC SQL OPEN c_cursor_getcurrbal;
        do {
                EXEC SQL FETCH c_cursor_getcurrbal
                INTO
                        :v_current_bal:ind_current_bal,
                        :v_total_hold:ind_total_hold;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

// balance
                if(ind_current_bal<0)
                        v_current_bal= 0.0;
                if(ind_total_hold<0)
                        v_total_hold= 0.0;

                *dBal=v_current_bal-v_total_hold;
DEBUGLOG(("GetCurrBalance balance = [%f]\n",*dBal));

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getcurrbal;

DEBUGLOG(("GetCurrBalance Normal Exit\n"));
        return iRet;

getcurrbal_error:
DEBUGLOG(("getcurrbal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getcurrbal;
        return PD_ERR;
}
