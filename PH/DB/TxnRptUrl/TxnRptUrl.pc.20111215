/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/08/15              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "TxnRptUrl.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void TxnRptUrl(char    cdebug)
{
        cDebug = cdebug;
}


int GetRptUrl(const char* csTxnCode,
                const char* csServiceCode,
                const char* csTxnCountry,
                const char* csLanguage,
                const char* csPayMethod ,
		recordset_t* myRec)
{
	int iRet = PD_ERR;
	char csURL[PD_TMP_BUF_LEN + 1];
                
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO geturl_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_txn_code[PD_TXN_CODE_LEN];
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];
		varchar         hv_country[PD_COUNTRY_LEN];
		varchar         hv_language[PD_LANGUAGE_LEN];
               	varchar        	hv_pay_method[PD_SELECTED_PAY_METHOD_LEN];
		int		hv_disabled;
                
                varchar         v_method[PD_METHOD_LEN + 1];
                varchar         v_path[PD_VALUE_LEN + 1];
                varchar         v_url[PD_VALUE_LEN + 1];

                short           ind_method = -1;
                short           ind_path = -1;
                short           ind_url = -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_txn_code.len = strlen(csTxnCode);
        memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
DEBUGLOG(("GetRptUrl txn_code = [%.*s]\n",hv_txn_code.len,hv_txn_code.arr));
        
        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetRptUrl service_code= [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_country.len = strlen(csTxnCountry);
        memcpy(hv_country.arr,csTxnCountry,hv_country.len);
DEBUGLOG(("GetRptUrl country = [%.*s]\n",hv_country.len,hv_country.arr));

	hv_language.len = strlen(csLanguage);
        memcpy(hv_language.arr,csLanguage,hv_language.len);
DEBUGLOG(("GetRptUrl language = [%.*s]\n",hv_language.len,hv_language.arr));

	hv_pay_method.len = strlen(csPayMethod);
        memcpy(hv_pay_method.arr,csPayMethod,hv_pay_method.len);
DEBUGLOG(("GetRptUrl pay_method = [%.*s]\n",hv_pay_method.len,hv_pay_method.arr));

	hv_disabled=0;

        EXEC SQL DECLARE c_cursor_geturl CURSOR FOR
                select	a.method,
			a.path,
			b.url
		from	txn_rpt_url a,
			service b
		where	a.txn_code = :hv_txn_code
		and	a.service_code = :hv_service_code
		and	a.service_code = b.code
		and     b.txn_country=:hv_country
		and     a.language=:hv_language
		and	a.pay_method = :hv_pay_method
		and	a.disabled = :hv_disabled
		and	b.disabled = :hv_disabled
		AND   	b.effect_date  =
                        (SELECT max(effect_date)
                           FROM service
                          WHERE code=:hv_service_code
			  and   txn_country=:hv_country
                            AND disabled=:hv_disabled
                            AND effect_date <= sysdate)
                AND   	a.effect_date  =
                        (SELECT max(effect_date)
                           FROM txn_rpt_url
                          WHERE txn_code=:hv_txn_code
                            AND service_code=:hv_service_code
			    AND pay_method = :hv_pay_method
                            AND disabled=:hv_disabled
			    AND language=:hv_language
                            AND effect_date <= sysdate);


        EXEC SQL OPEN c_cursor_geturl;
        do {
                EXEC SQL FETCH c_cursor_geturl
                INTO
                        :v_method:ind_method,
			:v_path:ind_path,
			:v_url:ind_url;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);
/* method */
                if (ind_method >= 0) {
                        v_method.arr[v_method.len] = '\0';
                        PutField_CString(myHash,"method",(const char*)v_method.arr);
DEBUGLOG(("GetRptUrl method = [%s]\n",v_method.arr));
                }

		if (ind_url >= 0) {
                        v_url.arr[v_url.len] = '\0';
                        strcpy((char*)csURL,(const char*)v_url.arr);
DEBUGLOG(("URL = [%s]\n",csURL));
                        if (ind_path >= 0) {
                                v_path.arr[v_path.len] = '\0';
DEBUGLOG(("PATH = [%.*s]\n",v_path.len,v_path.arr));
                                strcat((char*)csURL,(const char*)v_path.arr);
DEBUGLOG(("URL+PATH = [%s]\n",csURL));

				PutField_CString(myHash,"rpt_url",csURL);
DEBUGLOG(("GetRptUrl rpt_url = [%s]\n",csURL));
				iRet = PD_OK;
			}
			else
DEBUGLOG(("PATH NOT FOUND\n"));
                }
		else
DEBUGLOG(("URL NOT FOUND\n"));


                RecordSet_Add(myRec,myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_geturl;
	
	
DEBUGLOG(("GetRptUrl Normal Exit [%d]\n",iRet));

	return iRet;

geturl_error:
DEBUGLOG(("geturl_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_geturl;
        return PD_ERR;
}


