/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/11/03              Stan Poon
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include "common.h"
#include "internal.h"
#include "utilitys.h"
#include "dbutility.h"
#include "EmailFunctExclude.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char	cDebug;

void EmailFunctExclude(char	cdebug)
{
	cDebug = cdebug;
}


int GetFunctExclude(const hash_t *hRls, recordset_t *myRec)
{
	int iRet = NOT_FOUND;
	char *csTmp;

	hash_t *hRec;

	EXEC SQL WHENEVER SQLERROR GOTO getexclude_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_funct[PD_EML_FUNCT_LEN];
		varchar	v_tagname[PD_EML_TAGNAME_LEN + 1];
		varchar	v_type[PD_EML_TYPE_LEN + 1];
		varchar	v_operator[PD_EML_OPERATOR_LEN + 1];
		varchar	v_value[PD_EML_VALUE_LEN + 1];

		short	ind_tagname = -1;
		short	ind_type = -1;
		short	ind_operator = -1;
		short	ind_value = -1;

	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hRls,"funct",&csTmp)) {
		hv_funct.len = strlen(csTmp);
		strncpy((char*)hv_funct.arr, csTmp, hv_funct.len);
DEBUGLOG(("GetFunctExclude funct = [%.*s]\n", hv_funct.len, hv_funct.arr));
	}

	EXEC SQL DECLARE getfunctexclude CURSOR FOR
		SELECT	EFE_TAGNAME,
			EFE_TYPE,
			EFE_OPERATOR,
			EFE_VALUE
		FROM	EMAIL_FUNCT_EXCLUDE
		WHERE	EFE_FUNCT = :hv_funct
		ORDER BY EFE_TAGNAME, EFE_TYPE, EFE_OPERATOR;

	EXEC SQL OPEN getfunctexclude;
	for (;;) {
		EXEC SQL FETCH getfunctexclude
		INTO	:v_tagname:ind_tagname,
			:v_type:ind_type,
			:v_operator:ind_operator,
			:v_value:ind_value;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iRet = FOUND;

		hRec = (hash_t*) malloc (sizeof(hash_t));
		hash_init(hRec, 0);

		if (ind_tagname >= 0) {
			v_tagname.arr[v_tagname.len]='\0';
			PutField_CString(hRec,"tagname",(char*)v_tagname.arr);
DEBUGLOG(("GetFunctExclude() tagname = [%s]\n",(char*)v_tagname.arr));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("GetFunctExclude() tagname NOT FOUND!!!\n"));
		}

		if (ind_type >= 0) {
			v_type.arr[v_type.len]='\0';
			PutField_CString(hRec,"type",(char*)v_type.arr);
DEBUGLOG(("GetFunctExclude() type = [%s]\n",(char*)v_type.arr));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("GetFunctExclude() type NOT FOUND!!!\n"));
		}

		if (ind_operator >= 0) {
			v_operator.arr[v_operator.len]='\0';
			PutField_CString(hRec,"operator",(char*)v_operator.arr);
DEBUGLOG(("GetFunctExclude() operator = [%s]\n",(char*)v_operator.arr));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("GetFunctExclude() operator NOT FOUND!!!\n"));
		}

		if (ind_value >= 0) {
			v_value.arr[v_value.len]='\0';
			PutField_CString(hRec,"value",(char*)v_value.arr);
DEBUGLOG(("GetFunctExclude() value = [%s]\n",(char*)v_value.arr));
		} else {
			iRet = PD_ERR;
DEBUGLOG(("GetFunctExclude() value NOT FOUND!!!\n"));
		}

		RecordSet_Add(myRec,hRec);
	}
	EXEC SQL CLOSE getfunctexclude;

DEBUGLOG(("GetFunctExclude() Normal Exit iRet = [%d]\n",iRet));
	return iRet;

getexclude_error:
DEBUGLOG(("getexclude_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL CLOSE getfunctexclude;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

