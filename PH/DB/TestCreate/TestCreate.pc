/*
PDProTech(c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2019/11/14              Caroline Yeh
update UpdateWithGet				   2020/02/19		   MSN
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "TestCreate.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "internal.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;


void TestCreate(char cdebug){
	cDebug = cdebug;
}

int Get(const char cKey,   hash_t * myHash)
{


	int iRet = PD_NOT_FOUND;

	EXEC SQL WHENEVER SQLERROR GOTO get_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		char            hv_key;
		char            v_key;
		varchar         v_field[20];
		int             v_disabled;
		double          v_amount;
		varchar         v_ccy[PD_CCY_ID_LEN];
		
		short		ind_key = -1;
		short		ind_field = -1;
    		short		ind_amount = -1;
    		short		ind_disabled = -1;
    		short		ind_ccy = -1;

	EXEC SQL END DECLARE SECTION;

	hv_key = cKey;
DEBUGLOG(("Get key = [%c]\n",hv_key));

	EXEC SQL
		select	tc_field,
			tc_disabled,
			tc_amount,
			tc_ccy,
			tc_key
        into	:v_field:ind_field,
                    :v_disabled:ind_disabled,
                    :v_amount:ind_amount,
                    :v_ccy:ind_ccy,
                    :v_key:ind_key
		from	test_create
		where	tc_key =:hv_key;

	if(ind_key>=0){

	/*field*/
		if(ind_field>=0){
			v_field.arr[v_field.len]='\0';
			PutField_CString(myHash,"field",(const char*)v_field.arr);
DEBUGLOG(("Get field=[%s]\n",v_field.arr));
		}
	/*disabled*/
		if(ind_disabled>=0){
			PutField_Int(myHash,"disabled",v_disabled);
DEBUGLOG(("Get disabled = [%d]\n",v_disabled));
		}

	/*amount*/
		if(ind_amount>=0){
			PutField_Double(myHash,"amount",v_amount);
DEBUGLOG(("Get amount= [%lf]\n",v_amount));
		}

	/*currency id*/
		if(ind_ccy>=0){
			v_ccy.arr[v_ccy.len]='\0';
			PutField_CString(myHash,"currency_id",(const char*)v_ccy.arr);
DEBUGLOG(("Get currency id=[%s]\n",v_ccy.arr));
		}

		iRet = PD_FOUND;
	}

DEBUGLOG(("Get: Finished iRet = [%d]\n",iRet));
	return iRet;

	
get_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("TestCreate_Get: SP_INTERNAL_ERR\n");
EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;

}




int     Add(const hash_t *hRls)
{
        char            cTmp;
        char            *csTmp;
        int             iTmp;
        double          dTmp;

        EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                char            hv_key;
                varchar         hv_field[20];
                int             hv_disabled;
                double          hv_amount;
                varchar         hv_user[PD_USER_LEN+1];
                varchar         hv_currency_id[PD_CCY_ID_LEN];

		short           ind_key = -1;
		short		ind_field = -1;
		short		ind_amount = -1;
		short		ind_disabled = -1;
		short		ind_user = -1;
		short		ind_currency_id = -1;

		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Add: Begin\n"));

	/*key*/
        if(GetField_Char(hRls,"key",&cTmp)){
                hv_key=cTmp;
                ind_key = 0;
	DEBUGLOG(("Add: key = [%c]\n", hv_key));
        }

	/*field*/
        if(GetField_CString(hRls,"field",&csTmp)){
                hv_field.len = strlen(csTmp);
                memcpy(hv_field.arr, csTmp, hv_field.len);
                ind_field= 0;
		DEBUGLOG(("Add:field = [%.*s]\n",hv_field.len,hv_field.arr));
        }

	/*disabled*/
        if (GetField_Int(hRls,"disabled",&iTmp)) {
                hv_disabled = iTmp;
                ind_disabled = 0;
		DEBUGLOG(("Add:disabled = [%d]\n",hv_disabled));
        }

	/*amount*/
        if (GetField_Double(hRls,"amount",&dTmp)) {
                hv_amount= dTmp;
                ind_amount= 0;
		DEBUGLOG(("Add:amount = [%lf]\n",hv_amount));
        }

	/*user*/
        if(GetField_CString(hRls,"add_user",&csTmp)){
                hv_user.len = strlen(csTmp);
                memcpy(hv_user.arr, csTmp, hv_user.len);
                ind_user= 0;
		DEBUGLOG(("Add:user = [%.*s]\n",hv_user.len,hv_user.arr));
        }
	/*currency_id*/
        if(GetField_CString(hRls,"currency_id",&csTmp)){
                hv_currency_id.len = strlen(csTmp);
                memcpy(hv_currency_id.arr, csTmp, hv_currency_id.len);
                ind_currency_id= 0;
		DEBUGLOG(("Add:currency_id = [%.*s]\n",hv_currency_id.len,hv_currency_id.arr));
        }
	EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_test_create_insert(
                                        :hv_key:ind_key,
                                        :hv_field:ind_field,
                                        :hv_amount:ind_amount,
                                        :hv_disabled:ind_disabled,
                                        :hv_user:ind_user,
                                        :hv_currency_id:ind_currency_id
                                        );
                END;
        END-EXEC;

	DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
                DEBUGLOG(("Add:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
                ERRLOG("TestCreate_Add: SP_OTHER_ERR \n");
                DEBUGLOG(("Add: SP_OTHER_ERR \n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
                ERRLOG("TestCreate_Add: SP_ERR \n");
                DEBUGLOG(("Add: SP_ERR \n"));
                return PD_ERR;
        }

	add_error:
		DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
		DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
		ERRLOG("TestCreate_Add: SP_INTERNAL_ERR \n");
        	EXEC SQL WHENEVER SQLERROR CONTINUE;
        	return PD_ERR;

}


int UpdateByKey(const char cKey,const hash_t *hRls)
{
	char*   csBuf;
	int	iTmp = 0;
	double	dTmp = 0.0;

	EXEC SQL WHENEVER SQLERROR GOTO update_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar		hv_dynstmt[1024];

	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Update: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update test_create set tc_update_timestamp = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

	if(GetField_CString(hRls,"field",&csBuf)){
		DEBUGLOG(("Update:field = [%s]\n",csBuf));
		strcat((char*)hv_dynstmt.arr, ",tc_field = '");
		strcat((char*)hv_dynstmt.arr, csBuf);
		strcat((char*)hv_dynstmt.arr, "'");
	}

	if(GetField_Int(hRls,"disabled",&iTmp)){
		DEBUGLOG(("Update:disabled = [%d]\n",iTmp));
		sprintf(csBuf,"%d",iTmp);
		strcat((char*)hv_dynstmt.arr, ",tc_disabled =");
		strcat((char*)hv_dynstmt.arr, csBuf);
	}

	if(GetField_Double(hRls,"amount",&dTmp)){
		DEBUGLOG(("Update:amount = [%lf]\n",dTmp));
		sprintf(csBuf,"%f",dTmp);
		strcat((char*)hv_dynstmt.arr, ",tc_amount =");
		strcat((char*)hv_dynstmt.arr, csBuf);
	}

	if(GetField_CString(hRls,"currency_id",&csBuf)){
		DEBUGLOG(("Update:currency_id = [%s]\n",csBuf));
		strcat((char*)hv_dynstmt.arr, ",tc_ccy = '");
		strcat((char*)hv_dynstmt.arr, csBuf);
		strcat((char*)hv_dynstmt.arr, "'");
	}

	if(GetField_CString(hRls,"update_user",&csBuf)){
		DEBUGLOG(("Update: update_user = [%s]\n",csBuf));
		strcat((char*)hv_dynstmt.arr, ",tc_update_user= '");
		strcat((char*)hv_dynstmt.arr, csBuf);
		strcat((char*)hv_dynstmt.arr, "'");
	}

	sprintf(csBuf,"%c",cKey);
	strcat((char*)hv_dynstmt.arr, " WHERE tc_key = '");
	strcat((char*)hv_dynstmt.arr, csBuf);
	strcat((char*)hv_dynstmt.arr, "'");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

	DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));


	EXEC SQL PREPARE PS FROM :hv_dynstmt;
	EXEC SQL EXECUTE PS;

	FREE_ME(csBuf);

	DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;

	update_error:
		DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
		DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
		ERRLOG("Test_Create_Update: SP_INTERNAL_ERR\n");
	        EXEC SQL WHENEVER SQLERROR CONTINUE;
        	return PD_INTERNAL_ERR;
}


int UpdateWithGet(hash_t *hIn,   hash_t *hOut)
{
	int	iRet = PD_ERR;
	char	cPtr;
	int	iPtr;
	double	dPtr;
	char	*csPtr;

	EXEC SQL WHENEVER SQLERROR GOTO upd_get;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		short           hv_return_value;

		char            hv_key;
		varchar         hv_field[20];
		varchar         hv_ccy[PD_CCY_ID_LEN];
		int             hv_disabled;
		double          hv_amount;
		varchar         v_out_field[20];
		varchar         v_out_ccy[PD_CCY_ID_LEN + 1];
		int             v_out_disabled;
		double          v_out_amount;
		
		short		ind_key = -1;
		short		ind_field = -1;
    		short		ind_ccy = -1;
    		short		ind_amount = -1;
    		short		ind_disabled = -1;
		short		ind_out_field = -1;
    		short		ind_out_ccy = -1;
    		short		ind_out_amount = -1;
    		short		ind_out_disabled = -1;

		SQL_CURSOR	c_cursor_dt;

	EXEC SQL END DECLARE SECTION;

	if(GetField_Char(hIn, "key", &cPtr)){
		hv_key = cPtr;
		ind_key = 0;
DEBUGLOG(("UpdateWithGet:key = [%c]\n",hv_key));
	}

	if(GetField_CString(hIn, "field", &csPtr)){
		hv_field.len = strlen(csPtr);
		strncpy((char *)hv_field.arr, csPtr, hv_field.len);
		ind_field = 0;
DEBUGLOG(("UpdateWithGet:field = [%.*s]\n",hv_field.len,hv_field.arr));
	}

	if(GetField_CString(hIn, "currency_id", &csPtr)){
		hv_ccy.len = strlen(csPtr);
		strncpy((char *)hv_ccy.arr, csPtr, hv_ccy.len);
		ind_ccy = 0;
DEBUGLOG(("UpdateWithGet:ccy = [%.*s]\n",hv_ccy.len,hv_ccy.arr));
	}

	if(GetField_Int(hIn, "disabled", &iPtr)){
		hv_disabled = iPtr;
		ind_disabled = 0;
DEBUGLOG(("UpdateWithGet:disabled = [%d]\n",hv_disabled));
	}
	if(GetField_Double(hIn, "amount", &dPtr)){
		hv_amount = dPtr;
		ind_amount = 0;
DEBUGLOG(("UpdateWithGet:amount = [%lf]\n",hv_amount));
	}

	EXEC SQL ALLOCATE	:c_cursor_dt;

        EXEC SQL EXECUTE
            BEGIN

                :hv_return_value := sp_test_update_with_get(
				:hv_key:ind_key,
				:hv_field:ind_field,
				:hv_ccy:ind_ccy,
				:hv_disabled:ind_disabled,
				:hv_amount:ind_amount,
                                :c_cursor_dt);

            END;
        END-EXEC;


DEBUGLOG(("UpdateWithGet return_value = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
	{
		EXEC SQL FETCH :c_cursor_dt
			INTO   
				:v_out_field:ind_out_field,
                                :v_out_ccy:ind_out_ccy,
                                :v_out_disabled:ind_out_disabled,
                                :v_out_amount:ind_out_amount;


		/*field*/
		if(ind_out_field >= 0){
			v_out_field.arr[v_out_field.len]='\0';
			PutField_CString(hOut, "field", (const char*)v_out_field.arr);
DEBUGLOG(("UpdateWithGet out_field = [%s]\n",v_out_field.arr));
		}

		/*currency id*/
		if(ind_out_ccy >= 0){
			v_out_ccy.arr[v_out_ccy.len]='\0';
			PutField_CString(hOut, "ccy", (const char*)v_out_ccy.arr);
DEBUGLOG(("UpdateWithGet out_ccy = [%s]\n",v_out_ccy.arr));
		}

		/*disabled*/
		if(ind_out_disabled >= 0){
			PutField_Int(hOut, "disabled", v_out_disabled);
DEBUGLOG(("UpdateWithGet out_disabled = [%d]\n",v_out_disabled));
		}

		/*amount*/
		if(ind_out_amount >= 0){
			PutField_Double(hOut, "amount", v_out_amount);
DEBUGLOG(("UpdateWithGet out_amount = [%lf]\n",v_out_amount));
		}

		iRet = PD_OK;
	}
	else{
DEBUGLOG(("UpdateWithGet Failed!!\n"));
	}


	EXEC SQL CLOSE :c_cursor_dt;
	EXEC SQL FREE :c_cursor_dt;

DEBUGLOG(("UpdateWithGet: Finished iRet = [%d]\n",iRet));
	return iRet;

	
upd_get:
DEBUGLOG(("upd_get code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("TestCreate_UpdateWithGet: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_dt;
	EXEC SQL FREE :c_cursor_dt;
	return PD_ERR;

}

