/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/05/09              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "RuleTxnLimit.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RuleTxnLimit(char    cdebug)
{
        cDebug = cdebug;
}


int Find(const char* csTxnCode,
        const char* csCountryId,
	const char* csChannelCode,
	const char* csServiceCode,
	const char* csPayMethod,
        const char* csCcy,
        const char* csPartyId,
	const char* csPartyClientId,
	recordset_t *myRec)
{
	int iRet;
	hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
    
        EXEC SQL BEGIN DECLARE SECTION;
                short           hv_return_value;

		varchar		hv_txn_code[PD_TXN_CODE_LEN];
		varchar		hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_channel_code[PD_CHANNEL_CODE_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		varchar		hv_pay_method[PD_PAY_METHOD_LEN];
		varchar		hv_ccy[PD_CCY_ID_LEN];
		varchar		hv_party_id[PD_MERCHANT_ID_LEN];
		varchar		hv_party_client_id[PD_CLIENT_ID_LEN];


		double		v_min_value;
		double		v_max_value;
		
		short		ind_txn_code = -1;
		short		ind_country_id = -1;
		short		ind_channel_code = -1;
		short		ind_service_code = -1;
		short		ind_pay_method = -1;
		short		ind_ccy = -1;
		short		ind_party_id = -1;
		short		ind_party_client_id = -1;

		short		ind_min_value = -1;
		short		ind_max_value = -1;
		
		SQL_CURSOR	c_cursor_find;
    
        EXEC SQL END DECLARE SECTION;

        hv_txn_code.len = strlen(csTxnCode);
        memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
DEBUGLOG(("Find txn_code = [%.*s]\n",hv_txn_code.len,hv_txn_code.arr));
	ind_txn_code = 0;


        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("Find country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));
	ind_country_id = 0;

        hv_channel_code.len = strlen(csChannelCode);
        memcpy(hv_channel_code.arr,csChannelCode,hv_channel_code.len);
DEBUGLOG(("Find channel_code = [%.*s]\n",hv_channel_code.len,hv_channel_code.arr));
	ind_channel_code = 0;

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("Find service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
	ind_service_code = 0;

        hv_pay_method.len = strlen(csPayMethod);
        memcpy(hv_pay_method.arr,csPayMethod,hv_pay_method.len);
DEBUGLOG(("Find pay_method = [%.*s]\n",hv_pay_method.len,hv_pay_method.arr));
	ind_pay_method = 0;

        hv_ccy.len = strlen(csCcy);
        memcpy(hv_ccy.arr,csCcy,hv_ccy.len);
DEBUGLOG(("Find ccy = [%.*s]\n",hv_ccy.len,hv_ccy.arr));
	ind_ccy = 0;

        hv_party_id.len = strlen(csPartyId);
        memcpy(hv_party_id.arr,csPartyId,hv_party_id.len);
DEBUGLOG(("Find party_id = [%.*s]\n",hv_party_id.len,hv_party_id.arr));
	ind_party_id = 0;

        hv_party_client_id.len = strlen(csPartyClientId);
        memcpy(hv_party_client_id.arr,csPartyClientId,hv_party_client_id.len);
DEBUGLOG(("Find party_client_id = [%.*s]\n",hv_party_client_id.len,hv_party_client_id.arr));
	ind_party_client_id = 0;
    
	EXEC SQL ALLOCATE	:c_cursor_find;

        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := rule_txn_limit_pkg.find(:hv_txn_code:ind_txn_code,
								:hv_country_id:ind_country_id,
								:hv_channel_code:ind_channel_code,
								:hv_service_code:ind_service_code,
								:hv_pay_method:ind_pay_method,
								:hv_ccy:ind_ccy,
								:hv_party_id:ind_party_id,
								:hv_party_client_id:ind_party_client_id,
								:c_cursor_find);
                END;
        END-EXEC;


        if (hv_return_value > 0)  {
DEBUGLOG(("find :: record found\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
	                hash_init(myHash,0);

			ind_min_value = -1;
			ind_max_value = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
		     	EXEC SQL FETCH :c_cursor_find  
			INTO 	:v_min_value:ind_min_value,
				:v_max_value:ind_max_value; 


			if (ind_min_value >= 0 ) {
DEBUGLOG(("find min_value = [%f]\n",v_min_value));
				PutField_Double(myHash,"min_value",v_min_value);
			}
			if (ind_max_value >= 0 ) {
DEBUGLOG(("find max_value = [%f]\n",v_max_value));
				PutField_Double(myHash,"max_value",v_max_value);
			}
			RecordSet_Add(myRec,myHash);

		}
		iRet =  PD_OK;
        }
	else {
		iRet =  PD_ERR;
DEBUGLOG(("find :: record not found\n"));
	}

	EXEC SQL CLOSE :c_cursor_find;
	EXEC SQL FREE :c_cursor_find;

	return iRet;


find_error:
ERRLOG("RuleTxnLimit::find_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_find;
	EXEC SQL FREE :c_cursor_find;
        return PD_ERR;
}
