/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/05/09              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "RuleTxnLimit.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RuleTxnLimit(char    cdebug)
{
        cDebug = cdebug;
}


int Find(const char* csTxnCode,
        const char* csCountryId,
        const char* csCcy,
        const char* csPartyId,
	recordset_t *myRec)
{
	int iRet;
	hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
    
        EXEC SQL BEGIN DECLARE SECTION;
                short           hv_return_value;

		varchar		hv_txn_code[PD_TXN_CODE_LEN];
		varchar		hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy[PD_CCY_ID_LEN];
		varchar		hv_party_id[PD_MERCHANT_ID_LEN];


		char		v_type;
		varchar		v_category[PD_CATEGORY_LEN];
		double		v_value;
		
		short		ind_txn_code = -1;
		short		ind_country_id = -1;
		short		ind_ccy = -1;
		short		ind_party_id = -1;

		short		ind_type = -1;
		short		ind_category = -1;
		short		ind_value = -1;
		
		SQL_CURSOR	c_cursor_find;
    
        EXEC SQL END DECLARE SECTION;

        hv_txn_code.len = strlen(csTxnCode);
        memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
DEBUGLOG(("Find txn_code = [%.*s]\n",hv_txn_code.len,hv_txn_code.arr));
	ind_txn_code = 0;


        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("Find country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));
	ind_country_id = 0;

        hv_ccy.len = strlen(csCcy);
        memcpy(hv_ccy.arr,csCcy,hv_ccy.len);
DEBUGLOG(("Find ccy = [%.*s]\n",hv_ccy.len,hv_ccy.arr));
	ind_ccy = 0;

        hv_party_id.len = strlen(csPartyId);
        memcpy(hv_party_id.arr,csPartyId,hv_party_id.len);
DEBUGLOG(("Find party_id = [%.*s]\n",hv_party_id.len,hv_party_id.arr));
	ind_party_id = 0;
    
	EXEC SQL ALLOCATE	:c_cursor_find;

        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := rule_txn_limit_pkg.find(:hv_txn_code:ind_txn_code,
								:hv_country_id:ind_country_id,
								:hv_ccy:ind_ccy,
								:hv_party_id:ind_party_id,
								:c_cursor_find);
                END;
        END-EXEC;


        if (hv_return_value > 0)  {
DEBUGLOG(("find :: record found\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
	                hash_init(myHash,0);

			ind_type = -1;
			ind_category = -1;
			ind_value = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
		     	EXEC SQL FETCH :c_cursor_find  
			INTO	:v_type:ind_type,
				:v_category:ind_category,
				:v_value:ind_value; 

			if (ind_type >= 0 ) {
DEBUGLOG(("find type = [%c]\n",v_type));
				PutField_Char(myHash,"type",v_type);
			}

			if (ind_category >= 0 ) {
				v_category.arr[v_category.len] = '\0';
DEBUGLOG(("find category = [%s]\n",v_category.arr));
				PutField_CString(myHash,"category",v_category.arr);
			}
			if (ind_value >= 0 ) {
DEBUGLOG(("find value = [%f]\n",v_value));
				PutField_Double(myHash,"value",v_value);
			}
			RecordSet_Add(myRec,myHash);

		}
		iRet =  PD_OK;
        }
	else {
		iRet =  PD_ERR;
DEBUGLOG(("find :: record not found\n"));
	}

	EXEC SQL CLOSE :c_cursor_find;

	return iRet;


find_error:
ERRLOG("RuleTxnLimit::find_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_find;
        return PD_ERR;
}
