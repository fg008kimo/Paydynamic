/*
Partnerdelight (c)2015. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version					   2015/11/10              Elvis Wong
Add GetBatchHeader				   2015/11/19		   Dirk Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "internal.h"
#include "MiBatchHeader.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void MiBatchHeader(char    cdebug)
{
        cDebug = cdebug;
}



int Add(const hash_t *hRls)
{
	char            *csTmp;
	char            cTmp;


	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

	short           hv_return_value;

	varchar         hv_batch_id[PD_MI_BATCH_ID_LEN];
	varchar         hv_process_type[PD_MI_PROCESS_TYPE_LEN];
	char		hv_status;
	varchar         hv_add_user[PD_USER_LEN];

	short           ind_batch_id = -1;
	short           ind_process_type = -1;
	short           ind_status = -1;
	short           ind_add_user = -1;

	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));


/* batch_id */
        if (GetField_CString(hRls,"batch_id",&csTmp)) {
                hv_batch_id.len = strlen(csTmp);
                memcpy(hv_batch_id.arr,csTmp,hv_batch_id.len);
                ind_batch_id = 0;
DEBUGLOG(("Add:batch_id = [%.*s]\n",hv_batch_id.len,hv_batch_id.arr));
        }

/* process_type */
        if (GetField_CString(hRls,"process_type",&csTmp)) {
                hv_process_type.len = strlen(csTmp);
                memcpy(hv_process_type.arr,csTmp,hv_process_type.len);
                ind_process_type = 0;
DEBUGLOG(("Add:process_type = [%.*s]\n",hv_process_type.len,hv_process_type.arr));
        }

/* status */
        if (GetField_Char(hRls,"status",&cTmp)) {
                hv_status = cTmp;
                ind_status = 0;
DEBUGLOG(("Add:status = [%c]\n",hv_status));
        }

/* user */
        if (GetField_CString(hRls,"add_user",&csTmp)) {
                hv_add_user.len = strlen(csTmp);
                memcpy(hv_add_user.arr,csTmp,hv_add_user.len);
                ind_add_user = 0;
DEBUGLOG(("Add:add_user = [%.*s]\n",hv_add_user.len,hv_add_user.arr));
        }

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_mi_batch_header_insert(
					:hv_batch_id:ind_batch_id,
					:hv_process_type:ind_process_type,
					:hv_status:ind_status,
					:hv_add_user:ind_add_user);
		END;
	END-EXEC;


DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK) {
DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MiBatchHeader_Add: SP_OTHER_ERR\n");
DEBUGLOG(("Add: SP_OTHER_ERR\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MiBatchHeader_Add: SP_ERR\n");
DEBUGLOG(("Add: SP_ERR\n"));
                return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("MiBatchHeader_Add: SP_INTERNAL_ERR\n");
DEBUGLOG(("Add: SP_INTERNAL_ERR\n"));
        return PD_INTERNAL_ERR;
}


int GetBatchHeader(const char* csBatchId, hash_t* hRec)
{
        int     iRet = PD_NOT_FOUND;
DEBUGLOG(("GetBatchHeader()\n"));

        EXEC SQL WHENEVER SQLERROR GOTO getbatchheader_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_batch_id[PD_MI_BATCH_ID_LEN];

                varchar         v_batch_id[PD_MI_BATCH_ID_LEN+1];
		varchar		v_process_type[PD_MI_PROCESS_TYPE_LEN+1];
		char		v_status;

		short		ind_batch_id = -1;
		short		ind_process_type = -1;
		short		ind_status = -1;

        EXEC SQL END DECLARE SECTION;

/* batch_id */
	hv_batch_id.len = strlen(csBatchId);
	memcpy(hv_batch_id.arr,csBatchId,hv_batch_id.len);
DEBUGLOG(("GetBatchHeader batch_id = [%.*s]\n",hv_batch_id.len,hv_batch_id.arr));

        EXEC SQL DECLARE c_cursor_getbatchheader CURSOR FOR
		SELECT	bh_batch_id,
			bh_process_type,
			bh_status
	        FROM	mi_batch_header
		WHERE	bh_batch_id = :hv_batch_id;

        EXEC SQL OPEN c_cursor_getbatchheader;
        do {
                EXEC SQL FETCH c_cursor_getbatchheader
                INTO
			:v_batch_id:ind_batch_id,
			:v_process_type:ind_process_type,
			:v_status:ind_status;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                iRet = PD_FOUND;

/* batch_id */
                if (ind_batch_id >= 0) {
                        v_batch_id.arr[v_batch_id.len] ='\0';
DEBUGLOG(("GetBatchHeader batch_id = [%s]\n",v_batch_id.arr));
			PutField_CString(hRec,"batch_id",(const char*) v_batch_id.arr);
                }

/* process_type */
                if (ind_process_type >= 0) {
                        v_process_type.arr[v_process_type.len] ='\0';
DEBUGLOG(("GetBatchHeader process_type = [%s]\n",v_process_type.arr));
			PutField_CString(hRec,"process_type",(const char*) v_process_type.arr);
                }

/* status */
		if (ind_status >= 0) {
DEBUGLOG(("GetBatchHeader status = [%c]\n",v_status));
			PutField_Char(hRec,"status",v_status);
		}

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getbatchheader;

DEBUGLOG(("GetBatchHeader() normal return iRet = [%d]\n",iRet));
        return iRet;

getbatchheader_error:
DEBUGLOG(("psppartyid_error code %d\n", sqlca.sqlcode));
ERRLOG("DBMiBatchHeader::getbatchheader_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getbatchheader;
        return PD_ERR;
}

int Update(const hash_t *hRec)
{
        char*   csBuf;
        char*   csBatchId;
        char*   csTmp;
        char    cTmp;

        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar         hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;


DEBUGLOG(("Update: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update mi_batch_header set bh_update_timestamp = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

        if(GetField_CString(hRec,"batch_id",&csBatchId)){
DEBUGLOG(("Update:batch_id = [%s]\n",csBatchId));
        }

        if(GetField_Char(hRec,"status",&cTmp)){
DEBUGLOG(("Update: status = [%c]\n",cTmp));
                sprintf(csBuf,"%c",cTmp);
                strcat((char*)hv_dynstmt.arr, ",bh_status = '");
                strcat((char*)hv_dynstmt.arr, csBuf);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }
        if (GetField_CString(hRec,"update_user",&csTmp)) {
DEBUGLOG(("Update: update_user = [%s]\n",csTmp));
                strcat((char*)hv_dynstmt.arr, ",bh_update_user = '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

        strcat((char*)hv_dynstmt.arr, " WHERE bh_batch_id= '");
        strcat((char*)hv_dynstmt.arr, csBatchId);
	strcat((char*)hv_dynstmt.arr, "'");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));


        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);

DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("DBMiBatchHeader Update: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return INT_ERR;
}
