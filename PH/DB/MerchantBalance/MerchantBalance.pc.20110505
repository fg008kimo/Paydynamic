/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/01/07              LokMan Chow
Add UpdateFloat					   2011/04/15		   Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MerchantBalance.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MerchantBalance(char    cdebug)
{
        cDebug = cdebug;
}

int UpdateFloat(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                double  dFloat,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updatefloat_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		double		hv_float;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_float = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Add: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("UpdateFloat:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateFloat:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateFloat:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_float= dFloat;
	ind_float= 0;
DEBUGLOG(("UpdatFloat:float = [%f]\n",hv_float));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateFloat:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merchant_balance_insert_fl(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_float:ind_float,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdateFloat:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdateFloat:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateFloat: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateFloat: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateFloat: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateFloat: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updatefloat_error:
DEBUGLOG(("updatefloat_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;


}


int UpdatePayoutBal(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                double  dBal,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updatepayoutbal_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		double		hv_bal;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_bal = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Update: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("UpdatePayoutBal:merchant id = [%.*s][%d]\n",hv_merchant_id.len,hv_merchant_id.arr,hv_merchant_id.len));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdatePayoutBal:country_id = [%.*s][%d]\n",hv_country_id.len,hv_country_id.arr,hv_country_id.len));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdatePayoutBal:ccy_id = [%.*s][%d]\n",hv_ccy_id.len,hv_ccy_id.arr,hv_ccy_id.len));

	hv_bal= dBal;
	ind_bal= 0;
DEBUGLOG(("UpdatePayoutBal:payout bal = [%f]\n",hv_bal));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdatePayoutBal:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merchant_balance_update_pb(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_bal:ind_bal,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdatePayoutBal:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdatePayoutBal:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdatePayoutBal: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdatePayoutBal: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdatePayoutBal: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdatePayoutBal: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updatepayoutbal_error:
DEBUGLOG(("updatepayoutbal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}



int UpdateSettlementBal(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                double  dBal,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updatesetbal_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		double		hv_bal;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_bal = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Update: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("UpdateSettlementBal:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateSettlementBal:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateSettlementBal:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_bal= dBal;
	ind_bal= 0;
DEBUGLOG(("UpdateSettlementBal:settlement bal = [%f]\n",hv_bal));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateSettlementBal:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merchant_balance_update_sb(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_bal:ind_bal,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdateSettlementBal:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdateSettlementBal:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateSettlementBal: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateSettlementBal: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateSettlementBal: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateSettlementBal: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updatesetbal_error:
DEBUGLOG(("updatesetbal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}



double GetCurrentBalance(const char* csMerchantID,const char* csCurrencyId)
{
	double dResult = 0;
                
        EXEC SQL WHENEVER SQLERROR GOTO get_curr_bal_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
                
		double		v_payout_balance;
		double		v_settlement_balance;
		double		v_total_tfr_hold;
		double		v_total_payout_hold;
		double		v_total_settlement_hold;

		short		ind_payout_balance= -1;
		short		ind_settlement_balance= -1;
		short		ind_total_tfr_hold= -1;
		short		ind_total_payout_hold= -1;
		short		ind_total_settlement_hold= -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetCurrentBalance merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetCurrentBalance ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        
        EXEC SQL DECLARE c_cursor_get_curr_bal CURSOR FOR
                select	m_payout_bal,
			m_settlement_bal,
			m_total_tfr_hold,
			m_total_payout_hold,
			m_total_settlement_hold
                  from merchant_balance
		 where m_merchant_id = :hv_merchant_id
		   and m_currency_id = :hv_ccy_id;


        EXEC SQL OPEN c_cursor_get_curr_bal;
        do {
                EXEC SQL FETCH c_cursor_get_curr_bal
                INTO
			:v_payout_balance:ind_payout_balance,
			:v_settlement_balance:ind_settlement_balance,
			:v_total_tfr_hold:ind_total_tfr_hold,
			:v_total_payout_hold:ind_total_payout_hold,
			:v_total_settlement_hold:ind_total_settlement_hold;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

// balance
                if( (ind_payout_balance<0)||(ind_settlement_balance<0)||(ind_total_tfr_hold<0)||(ind_total_payout_hold<0)||(ind_total_settlement_hold<0)){
			dResult = 0;
		}

		else{
			dResult=v_payout_balance+v_settlement_balance-v_total_tfr_hold-v_total_payout_hold-v_total_settlement_hold;
DEBUGLOG(("GetCurrentBalance balance = [%f]\n",dResult));
		}

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_get_curr_bal;

	if(dResult!=0){
DEBUGLOG(("GetCurrentBalance Normal Exit\n"));
	}
	else{
DEBUGLOG(("GetCurrentBalance Error\n"));
	}
	return dResult;

get_curr_bal_error:
DEBUGLOG(("get_curr_bal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_get_curr_bal;
        return 0;
}


double GetAviBalanceForPayout(const char* csMerchantID,const char* csCurrencyId)
{
	double dResult = 0;
                
        EXEC SQL WHENEVER SQLERROR GOTO getavibalancepayout_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN + 1];
                
		double		v_payout_balance;
		double		v_total_payout_hold;

		short		ind_payout_balance= -1;
		short		ind_total_payout_hold= -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetAviBalanceForPayout merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetAviBalanceForPayout ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        
        EXEC SQL DECLARE c_cursor_getavibalancepayout CURSOR FOR
                select	m_payout_bal,
			m_total_payout_hold
                  from merchant_balance
		 where m_merchant_id = :hv_merchant_id
		   and m_currency_id = :hv_ccy_id
		 for update;


        EXEC SQL OPEN c_cursor_getavibalancepayout;
        do {
                EXEC SQL FETCH c_cursor_getavibalancepayout
                INTO
			:v_payout_balance:ind_payout_balance,
			:v_total_payout_hold:ind_total_payout_hold;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

// balance
                if( (ind_payout_balance<0)||(ind_total_payout_hold<0))
			dResult = 0;

		else{
			dResult=v_payout_balance-v_total_payout_hold;
DEBUGLOG(("GetAviBalanceForPayout balance = [%f]\n",dResult));
		}

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getavibalancepayout;

	if(dResult!=0){
DEBUGLOG(("GetAviBalanceForPayout Normal Exit\n"));
	}
	else{
DEBUGLOG(("GetAviBalanceForPayout Error\n"));
	}
	return dResult;

getavibalancepayout_error:
DEBUGLOG(("getavibalancepayout_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getavibalancepayout;
        return 0;
}

double GetAviBalanceForSettlement(const char* csMerchantID,const char* csCurrencyId)
{
	double dResult= 0;
                
        EXEC SQL WHENEVER SQLERROR GOTO getavibalanceset_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN + 1];
                
		double		v_settlement_balance;
		double		v_total_tfr_hold;
		double		v_total_settlement_hold;

		short		ind_settlement_balance= -1;
		short		ind_total_tfr_hold= -1;
		short		ind_total_settlement_hold= -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetAviBalanceForSettlement merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetAviBalanceForSettlement ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        
        EXEC SQL DECLARE c_cursor_getavibalanceset CURSOR FOR
                select	
			m_settlement_bal,
			m_total_tfr_hold,
			m_total_settlement_hold
                  from merchant_balance
		 where m_merchant_id = :hv_merchant_id
		   and m_currency_id = :hv_ccy_id
		 for update;


        EXEC SQL OPEN c_cursor_getavibalanceset;
        do {
                EXEC SQL FETCH c_cursor_getavibalanceset
                INTO
			:v_settlement_balance:ind_settlement_balance,
			:v_total_tfr_hold:ind_total_tfr_hold,
			:v_total_settlement_hold:ind_total_settlement_hold;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

// balance
                if( (ind_settlement_balance<0)||(ind_total_tfr_hold<0)||(ind_total_settlement_hold<0))
			dResult = 0;

		else{
			dResult=v_settlement_balance-v_total_tfr_hold-v_total_settlement_hold;
DEBUGLOG(("GetAviBalanceForSettlement balance = [%f]\n",dResult));
		}

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getavibalanceset;

	if(dResult!=0){
DEBUGLOG(("GetAviBalanceForSettlement Normal Exit\n"));
	}
	else{
DEBUGLOG(("GetAviBalanceForSettlement Error\n"));
	}
	return dResult;

getavibalanceset_error:
DEBUGLOG(("getavibalanceset_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getavibalanceset;
        return 0;
}

int UpdateReserved(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                double  dFloat,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updatereserved_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		double		hv_float;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_float = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("UpdateReserved: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("UpdateReserved:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateReserved:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateReserved:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_float= dFloat;
	ind_float= 0;
DEBUGLOG(("UpdatReserved:float = [%f]\n",hv_float));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateReserved:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merchant_balance_insert_rs(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_float:ind_float,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdateReserved:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdateReserved:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateReserved: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateReserved: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateReserved: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateReserved: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updatereserved_error:
DEBUGLOG(("updateReserved_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;


}


double GetCurrentFloat(const char* csMerchantID,const char* csCurrencyId, const char* csCountryId)
{
	double dResult = 0;
                
        EXEC SQL WHENEVER SQLERROR GOTO getcurrfloat_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar         hv_country_id[PD_COUNTRY_LEN];
                
		double		v_total_float;

		short		ind_total_float = -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetCurrentFloat merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetCurrentFloat ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        
        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("GetCurrentFloat country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));
        
        EXEC SQL DECLARE c_cursor_getcurrfloat CURSOR FOR
                select m_total_float
                  from merchant_balance
		 where m_merchant_id = :hv_merchant_id
		   and m_currency_id = :hv_ccy_id
		   and m_country_id = :hv_country_id;

        EXEC SQL OPEN c_cursor_getcurrfloat;
        do {
                EXEC SQL FETCH c_cursor_getcurrfloat
                INTO
			:v_total_float:ind_total_float;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

//float 
                if(ind_total_float<0)
			dResult = 0;

		else{
			dResult=v_total_float;
DEBUGLOG(("GetCurrentFloat float = [%f]\n",dResult));
		}

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getcurrfloat;

	if(dResult!=0){
DEBUGLOG(("GetCurrentFloat Normal Exit\n"));
	}
	else{
DEBUGLOG(("GetCurrentFloat Error\n"));
	}
	return dResult;

getcurrfloat_error:
DEBUGLOG(("getcurrfloat_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getcurrfloat;
        return 0;
}

