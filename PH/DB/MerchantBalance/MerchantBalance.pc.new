/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/01/07              LokMan Chow
Add UpdateFloat					   2011/04/15		   Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MerchantBalance.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MerchantBalance(char    cdebug)
{
        cDebug = cdebug;
}

int UpdateFloat(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
		const char* csServiceCode,
                double  dFloat,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updatefloat_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		double		hv_float;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_service_code = -1;
		short		ind_float = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Add: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("UpdateFloat:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateFloat:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateFloat:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_service_code.len = strlen(csServiceCode);
	strncpy(hv_service_code.arr, csServiceCode, hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("UpdateFloat:ccy_id = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_float= dFloat;
	ind_float= 0;
DEBUGLOG(("UpdatFloat:float = [%f]\n",hv_float));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateFloat:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merchant_balance_insert_fl(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_service_code:ind_service_code,
				:hv_float:ind_float,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdateFloat:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdateFloat:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateFloat: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateFloat: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateFloat: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateFloat: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updatefloat_error:
DEBUGLOG(("updatefloat_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;


}


int ReleaseAvalBal(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
		const char* csServiceCode,
                double  dBal,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO releaseavalbal_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		double		hv_bal;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_service_code = -1;
		short		ind_bal = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Update: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("ReleaseAvalBal:merchant id = [%.*s][%d]\n",hv_merchant_id.len,hv_merchant_id.arr,hv_merchant_id.len));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("ReleaseAvalBal:country_id = [%.*s][%d]\n",hv_country_id.len,hv_country_id.arr,hv_country_id.len));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("ReleaseAvalBal:ccy_id = [%.*s][%d]\n",hv_ccy_id.len,hv_ccy_id.arr,hv_ccy_id.len));

	hv_service_code.len = strlen(csServiceCode);
	strncpy(hv_service_code.arr, csServiceCode, hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("ReleaseAvalBal:service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len));

	hv_bal= dBal;
	ind_bal= 0;
DEBUGLOG(("ReleaseAvalBal:payout bal = [%f]\n",hv_bal));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("ReleaseAvalBal:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merchant_balance_release(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_service_code:ind_service_code,
				:hv_bal:ind_bal,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("ReleaseAvalBal:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("ReleaseAvalBal:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::ReleaseAvalBal: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("ReleaseAvalBal: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::ReleaseAvalBal: SP_ERR TxnAbort\n");
DEBUGLOG(("ReleaseAvalBal: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

releaseavalbal_error:
DEBUGLOG(("releaseavalbal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}



int GetAvalBalanceForPayout(const char* csMerchantID,
			const char* csCurrencyId,
			const char* csCountryId,
			const char* csServiceCode,
			double	*dPayoutBal)
{
	*dPayoutBal = 0.0;
	int iRet = PD_FOUND;
                
        EXEC SQL WHENEVER SQLERROR GOTO getavalbalancepayout_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
                
		double		v_balance;
		double		v_total_payout_hold;
		double		v_payout_in_transit;

		short		ind_balance= -1;
		short		ind_total_payout_hold= -1;
		short		ind_payout_in_transit= -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetAvalBalanceForPayout merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetAvalBalanceForPayout ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        
        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("GetAvalBalanceForPayout country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetAvalBalanceForPayout service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
        
        EXEC SQL DECLARE c_cursor_getavalbalancepayout CURSOR FOR
                select	m_aval_bal,
			m_total_payout_hold,
			m_payout_in_transit
                  from merchant_balance
		 where m_merchant_id = :hv_merchant_id
		   and m_currency_id = :hv_ccy_id
		   and m_country_id = :hv_country_id
		   and m_service_code = :hv_service_code
		 for update;


        EXEC SQL OPEN c_cursor_getavalbalancepayout;
        do {
                EXEC SQL FETCH c_cursor_getavalbalancepayout
                INTO
			:v_balance:ind_balance,
			:v_total_payout_hold:ind_total_payout_hold,
			:v_payout_in_transit:ind_payout_in_transit;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

// balance
                if(ind_balance<0)
			*dPayoutBal = 0.0;

		else{
			*dPayoutBal=v_balance-v_total_payout_hold-v_payout_in_transit;
DEBUGLOG(("GetAvalBalanceForPayout balance = [%f]\n",*dPayoutBal));
		}

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getavalbalancepayout;

	if(*dPayoutBal!=0){
DEBUGLOG(("GetAvalBalanceForPayout Normal Exit\n"));
	}
	else{
DEBUGLOG(("GetAvalBalanceForPayout Error\n"));
		iRet = PD_NOT_FOUND;
	}
	return iRet;

getavalbalancepayout_error:
DEBUGLOG(("getavalbalancepayout_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getavalbalancepayout;
	TxnAbort();
        return PD_ERR;
}

int GetAvalBalanceForSettlement(const char* csMerchantID,
				const char* csCurrencyId,
				const char* csCountryId,
				const char* csServiceCode,
				double* dSettlemantBal)
{
               
	*dSettlemantBal = 0.0;
        int iRet = PD_FOUND;
 
        EXEC SQL WHENEVER SQLERROR GOTO getavalbalanceset_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN + 1];
		varchar		hv_country_id[PD_COUNTRY_LEN + 1];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN + 1];
                
		double		v_balance;
		double		v_total_tfr_hold;
		double		v_total_settlement_hold;
		double		v_settlement_in_transit;

		short		ind_balance= -1;
		short		ind_total_tfr_hold= -1;
		short		ind_total_settlement_hold= -1;
		short		ind_settlement_in_transit= -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetAvalBalanceForSettlement merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetAvalBalanceForSettlement ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        
        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("GetAvalBalanceForSettlement country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetAvalBalanceForSettlement service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
        
        EXEC SQL DECLARE c_cursor_getavalbalanceset CURSOR FOR
                select	
			m_aval_bal,
			m_total_tfr_hold,
			m_total_settlement_hold,
			m_settlement_in_transit
                  from merchant_balance
		 where m_merchant_id = :hv_merchant_id
		   and m_currency_id = :hv_ccy_id
		   and m_country_id = :hv_country_id
		   and m_service_code = :hv_service_code
		 for update;


        EXEC SQL OPEN c_cursor_getavalbalanceset;
        do {
                EXEC SQL FETCH c_cursor_getavalbalanceset
                INTO
			:v_balance:ind_balance,
			:v_total_tfr_hold:ind_total_tfr_hold,
			:v_total_settlement_hold:ind_total_settlement_hold,
			:v_settlement_in_transit:ind_settlement_in_transit;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

// balance
                if(ind_balance<0)
			*dSettlemantBal = 0.0;
		else{
			*dSettlemantBal=v_balance-v_total_tfr_hold-v_total_settlement_hold-v_settlement_in_transit;
DEBUGLOG(("GetAvalBalanceForSettlement balance = [%f]\n",*dSettlemantBal));
		}

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getavalbalanceset;

	if(*dSettlemantBal!=0){
DEBUGLOG(("GetAvalBalanceForSettlement Normal Exit\n"));
	}
	else{
DEBUGLOG(("GetAvalBalanceForSettlement Error\n"));
		iRet = PD_NOT_FOUND;
	}
	return iRet;

getavalbalanceset_error:
DEBUGLOG(("getavalbalanceset_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getavalbalanceset;
	TxnAbort();
        return PD_ERR;
}

int UpdateReserved(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                const char* csServiceCode,
                double  dFloat,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updatereserved_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		double		hv_float;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_service_code = -1;
		short		ind_float = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("UpdateReserved: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("UpdateReserved:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateReserved:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateReserved:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_service_code.len = strlen(csServiceCode);
	strncpy(hv_service_code.arr, csServiceCode, hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("UpdateReserved:ccy_id = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_float= dFloat;
	ind_float= 0;
DEBUGLOG(("UpdatReserved:float = [%f]\n",hv_float));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateReserved:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merchant_balance_insert_rs(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_service_code:ind_service_code,
				:hv_float:ind_float,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdateReserved:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdateReserved:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateReserved: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateReserved: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateReserved: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateReserved: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updatereserved_error:
DEBUGLOG(("updateReserved_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;


}


int GetCurrentValues(const char* csMerchantID,
			const char* csCurrencyId, 
			const char* csCountryId,
			const char* csServiceCode,
			hash_t *hVal)
{
	int iRet = PD_OK;
                
        EXEC SQL WHENEVER SQLERROR GOTO getcurrval_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar         hv_country_id[PD_COUNTRY_LEN];
		varchar         hv_service_code[PD_SERVICE_CODE_LEN];
                
		double		v_total_float;
		double		v_aval_bal;
		double		v_total_reserved_amount;
		double		v_total_tfr_hold;
		double		v_total_payout_hold;
		double		v_total_settlement_hold;
		double		v_payout_in_transit;
		double		v_settlement_in_transit;

		short		ind_total_float = -1;
		short		ind_aval_bal= -1;
		short		ind_total_reserved_amount= -1;
		short		ind_total_tfr_hold= -1;
		short		ind_total_payout_hold= -1;
		short		ind_total_settlement_hold= -1;
		short		ind_payout_in_transit= -1;
		short		ind_settlement_in_transit= -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetCurrentValues merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_ccy_id.len = strlen(csCurrencyId);
        memcpy(hv_ccy_id.arr,csCurrencyId,hv_ccy_id.len);
DEBUGLOG(("GetCurrentValues ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        
        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("GetCurrentValues country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetCurrentValues service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
        
        EXEC SQL DECLARE c_cursor_getcurrval CURSOR FOR
                select 	m_total_float,
			m_aval_bal,
			m_total_reserved_amount,
			m_total_tfr_hold,
			m_total_payout_hold,
			m_total_settlement_hold,
			m_payout_in_transit,
			m_settlement_in_transit
                  from 	merchant_balance
		 where 	m_merchant_id = :hv_merchant_id
		   and 	m_currency_id = :hv_ccy_id
		   and	m_country_id = :hv_country_id
		   and	m_service_code = :hv_service_code;

        EXEC SQL OPEN c_cursor_getcurrval;
        do {
                EXEC SQL FETCH c_cursor_getcurrval
                INTO
			:v_total_float:ind_total_float,
			:v_aval_bal:ind_aval_bal,
			:v_total_reserved_amount:ind_total_reserved_amount,
			:v_total_tfr_hold:ind_total_tfr_hold,
			:v_total_payout_hold:ind_total_payout_hold,
			:v_total_settlement_hold:ind_total_settlement_hold,
			:v_payout_in_transit:ind_payout_in_transit,
			:v_settlement_in_transit:ind_settlement_in_transit;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

//total_float 
                if(ind_total_float<0)
			v_total_float = 0;
		PutField_Double(hVal,"total_float",v_total_float);
DEBUGLOG(("GetCurrentValues float = [%f]\n",v_total_float));
		
//aval_bal
                if(ind_aval_bal<0)
			v_aval_bal = 0;
		PutField_Double(hVal,"aval_bal",v_aval_bal);
DEBUGLOG(("GetCurrentValues aval_bal = [%f]\n",v_aval_bal));

//total_reserved_amount
                if(ind_total_reserved_amount<0)
			v_total_reserved_amount= 0;
		PutField_Double(hVal,"total_reserved_amount",v_total_reserved_amount);
DEBUGLOG(("GetCurrentValues total_reserved_amount = [%f]\n",v_total_reserved_amount));

//total_tfr_hold
                if(ind_total_tfr_hold<0)
			v_total_tfr_hold= 0;
		PutField_Double(hVal,"total_tfr_hold",v_total_tfr_hold);
DEBUGLOG(("GetCurrentValues total_tfr_hold = [%f]\n",v_total_tfr_hold));

//total_payout_hold
                if(ind_total_payout_hold<0)
			v_total_payout_hold= 0;
		PutField_Double(hVal,"total_payout_hold",v_total_payout_hold);
DEBUGLOG(("GetCurrentValues total_payout_hold = [%f]\n",v_total_payout_hold));

//total_settlement_hold
                if(ind_total_settlement_hold<0)
			v_total_settlement_hold= 0;
		PutField_Double(hVal,"total_settlement_hold",v_total_settlement_hold);
DEBUGLOG(("GetCurrentValues total_settlement_hold = [%f]\n",v_total_settlement_hold));


//payout_in_transit
                if(ind_payout_in_transit<0)
			v_payout_in_transit = 0;
		PutField_Double(hVal,"payout_in_transit",v_payout_in_transit);
DEBUGLOG(("GetCurrentValues payout_in_transit = [%f]\n",v_payout_in_transit));

//settlement_in_transit
                if(ind_settlement_in_transit<0)
			v_settlement_in_transit = 0;
		PutField_Double(hVal,"settlement_in_transit",v_settlement_in_transit);
DEBUGLOG(("GetCurrentValues settlement_in_transit = [%f]\n",v_settlement_in_transit));
        }

        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getcurrval;

DEBUGLOG(("GetCurrentValues Normal Exit\n"));
	return iRet;

getcurrval_error:
DEBUGLOG(("getcurrval_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getcurrval;
        return PD_ERR;
}


int Balance2InTransit(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                const char* csServiceCode,
                double  dAmt,
		const char* csDirection,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO bal2int_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		double		hv_amt;
		varchar 	hv_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_service_code = -1;
		short		ind_amt = -1;
		short		ind_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


DEBUGLOG(("Balance2InTransit: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;

	hv_service_code.len = strlen(csServiceCode);
	strncpy(hv_service_code.arr, csServiceCode, hv_service_code.len);
	ind_service_code = 0;

	hv_amt= dAmt;
	ind_amt= 0;
DEBUGLOG(("Balance2InTransit:amt = [%f]\n",hv_amt));
DEBUGLOG(("Balance2InTransit:direction => [%s]\n",csDirection));

	hv_user.len = strlen(csUser);
	strncpy(hv_user.arr, csUser, hv_user.len);
	ind_user = 0;

	if(!strcmp(csDirection,PD_BAL2PINT)){

		EXEC SQL EXECUTE
	 	   BEGIN

			:hv_return_value := sp_merchant_balance_bal2pint(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_service_code:ind_service_code,
				:hv_amt:ind_amt,
				:hv_user:ind_user);

	    	   END;
		END-EXEC;
	}
	else if(!strcmp(csDirection,PD_PINT2BAL)){
		EXEC SQL EXECUTE
	 	   BEGIN

			:hv_return_value := sp_merchant_balance_pint2bal(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_service_code:ind_service_code,
				:hv_amt:ind_amt,
				:hv_user:ind_user);

	    	   END;
		END-EXEC;
	}
	else if(!strcmp(csDirection,PD_BAL2SINT)){
		EXEC SQL EXECUTE
                   BEGIN

                        :hv_return_value := sp_merchant_balance_bal2sint(
                                :hv_merchant_id:ind_merchant_id,
                                :hv_country_id:ind_country_id,
                                :hv_ccy_id:ind_ccy_id,
                                :hv_service_code:ind_service_code,
                                :hv_amt:ind_amt,
                                :hv_user:ind_user);

                   END;
                END-EXEC;
	}
	else if(!strcmp(csDirection,PD_SINT2BAL)){
			EXEC SQL EXECUTE
                   BEGIN

                        :hv_return_value := sp_merchant_balance_sint2bal(
                                :hv_merchant_id:ind_merchant_id,
                                :hv_country_id:ind_country_id,
                                :hv_ccy_id:ind_ccy_id,
                                :hv_service_code:ind_service_code,
                                :hv_amt:ind_amt,
                                :hv_user:ind_user);

                   END;
                END-EXEC;
	}
	else{
ERRLOG("MerchantBlance::Balance2InTransit: Invalid Direction\n");
DEBUGLOG(("Balance2InTransit: Invalid Direction[%s]\n",csDirection));
		TxnAbort();
		return PD_ERR;
	}


	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("Balance2InTransit:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::Balance2InTransit: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Balance2InTransit: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::Balance2InTransit: SP_ERR TxnAbort\n");
DEBUGLOG(("Balance2InTransit: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

bal2int_error:
DEBUGLOG(("bal2int_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;


}



int UpdateSettlementIntransit(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
		const char* csServiceCode,
                double  dAmt,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updatesintransit_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		double		hv_amt;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_service_code = -1;
		short		ind_amt = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("UpdateSettlementIntransit: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("UpdateSettlementIntransit:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateSettlementIntransit:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateSettlementIntransit:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_service_code.len = strlen(csServiceCode);
	strncpy(hv_service_code.arr, csServiceCode, hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("UpdateSettlementIntransit:ccy_id = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_amt= dAmt;
	ind_amt= 0;
DEBUGLOG(("UpdateSettlementIntransit:amt = [%f]\n",hv_amt));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateSettlementIntransit:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merch_balance_update_sint(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_service_code:ind_service_code,
				:hv_amt:ind_amt,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdateSettlementIntransit:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdateSettlementIntransit:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateSettlementIntransit: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateSettlementIntransit: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateSettlementIntransit: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateSettlementIntransit: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updatesintransit_error:
DEBUGLOG(("updatesettlementintransit_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}


int UpdatePayoutIntransit(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
		const char* csServiceCode,
                double  dAmt,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updateintransit_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		double		hv_amt;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_service_code = -1;
		short		ind_amt = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("UpdatePayoutIntransit: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("UpdatePayoutIntransit:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdatePayoutIntransit:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdatePayoutIntransit:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_service_code.len = strlen(csServiceCode);
	strncpy(hv_service_code.arr, csServiceCode, hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("UpdatePayoutIntransit:ccy_id = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_amt= dAmt;
	ind_amt= 0;
DEBUGLOG(("UpdatePayoutIntransit:amt = [%f]\n",hv_amt));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdatePayoutIntransit:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merch_balance_update_pint(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_service_code:ind_service_code,
				:hv_amt:ind_amt,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdatePayoutIntransit:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdatePayoutIntransit:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdatePayoutIntransit: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdatePayoutIntransit: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdatePayoutIntransit: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdatePayoutIntransit: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updateintransit_error:
DEBUGLOG(("updateintransit_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;


}



int VoidBalance(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
                const char* csServiceCode,
                double  dAmt,
		const char* csUser)
{
	EXEC SQL WHENEVER SQLERROR GOTO voidbalance_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		double		hv_amt;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_service_code = -1;
		short		ind_amt = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("VoidBalance: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("VoidBalance:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("VoidBalance:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("VoidBalance:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_service_code.len = strlen(csServiceCode);
	strncpy(hv_service_code.arr, csServiceCode, hv_service_code.len);
	ind_ccy_id = 0;
DEBUGLOG(("VoidBalance:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_amt= dAmt;
	ind_amt= 0;
DEBUGLOG(("VoidBalance:amt = [%f]\n",hv_amt));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("VoidBalance:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merchant_balance_void(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_service_code:ind_service_code,
				:hv_amt:ind_amt,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("VoidBalance:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("VoidBalance:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::VoidBalance: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("VoidBalance: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::VoidBalance: SP_ERR TxnAbort\n");
DEBUGLOG(("VoidBalance: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

voidbalance_error:
DEBUGLOG(("voidbalance_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}


int UpdateBalanceAndHold(const hash_t* hRls)
{
	char*   csBuf;
	char*	csMerchantId;
	char*	csCountryId;
	char*	csCcy;
	char*	csServiceCode;
	char*	csTmp;
	double	dTmp;

	EXEC SQL WHENEVER SQLERROR GOTO updatebalhold_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

	varchar 	hv_dynstmt[1024];
		
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateBalanceAndHold: Begin\n"));
	csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update merchant_balance set m_update_timestamp  = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

	GetField_CString(hRls,"merchant_id",&csMerchantId);
DEBUGLOG(("UpdateBalanceAndHold:merchant_id = [%s]\n",csMerchantId));
	GetField_CString(hRls,"country_id",&csCountryId);
DEBUGLOG(("UpdateBalanceAndHold:country_id = [%s]\n",csCountryId));
	GetField_CString(hRls,"ccy_id",&csCcy);
DEBUGLOG(("UpdateBalanceAndHold:ccy_id = [%s]\n",csCcy));
	GetField_CString(hRls,"service_code",&csServiceCode);
DEBUGLOG(("UpdateBalanceAndHold:service_code = [%s]\n",csServiceCode));

	if (GetField_Double(hRls,"aval_bal",&dTmp)) {
DEBUGLOG(("UpdateBalanceAndHold:aval_bal = [%f]\n",dTmp));
		sprintf(csBuf,"%f",dTmp);
		strcat((char*)hv_dynstmt.arr, ",m_aval_bal = ");
		strcat((char*)hv_dynstmt.arr, csBuf);
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

	if (GetField_Double(hRls,"payout_hold",&dTmp)) {
DEBUGLOG(("UpdateBalanceAndHold: payout_hold = [%f]\n",dTmp));
		sprintf(csBuf,"%f",dTmp);
		strcat((char*)hv_dynstmt.arr, ",m_total_payout_hold = ");
		strcat((char*)hv_dynstmt.arr, csBuf);
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

	if (GetField_Double(hRls,"settlement_hold",&dTmp)) {
DEBUGLOG(("UpdateBalanceAndHold: settlement_hold = [%f]\n",dTmp));
		sprintf(csBuf,"%f",dTmp);
		strcat((char*)hv_dynstmt.arr, ",m_total_settlement_hold = ");
		strcat((char*)hv_dynstmt.arr, csBuf);
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

	if (GetField_Double(hRls,"update_user",&csTmp)) {
DEBUGLOG(("UpdateBalanceAndHold:update_user = [%s]\n",csTmp));
		strcat((char*)hv_dynstmt.arr, ",m_update_user = '");
		strcat((char*)hv_dynstmt.arr, csTmp);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

	strcat((char *)hv_dynstmt.arr, " WHERE m_merchant_id= '");
        strcat((char *)hv_dynstmt.arr, csMerchantId);
        strcat((char *)hv_dynstmt.arr, "'");
        strcat((char *)hv_dynstmt.arr, " and ");
        strcat((char *)hv_dynstmt.arr, "m_currency_id= '");
        strcat((char *)hv_dynstmt.arr, csCcy);
        strcat((char *)hv_dynstmt.arr, "'");
        strcat((char *)hv_dynstmt.arr, " and ");
        strcat((char *)hv_dynstmt.arr, "m_country_id= '");
        strcat((char *)hv_dynstmt.arr, csCountryId);
        strcat((char *)hv_dynstmt.arr, "'");
        strcat((char *)hv_dynstmt.arr, " and ");
        strcat((char *)hv_dynstmt.arr, "m_service_code= '");
        strcat((char *)hv_dynstmt.arr, csServiceCode);
        strcat((char *)hv_dynstmt.arr, "'");

        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);


DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;



updatebalhold_error:
DEBUGLOG(("updatebalhold_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}

int UpdateSettlementBal(const char* csMerchantId,
                const char* csCountryId,
                const char* csCcy,
		const char* csServiceCode,
                double  dAmt,
		const char* csUser)

{

	EXEC SQL WHENEVER SQLERROR GOTO updatesettbal_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	        hv_country_id[PD_COUNTRY_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		double		hv_amt;
		varchar 	hv_create_user[PD_USER_LEN];


		short		ind_merchant_id = -1;
		short		ind_country_id = -1;
		short		ind_ccy_id = -1;
		short		ind_service_code = -1;
		short		ind_amt = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("UpdateSettlementBal: Begin\n"));


	hv_merchant_id.len = strlen(csMerchantId);
	strncpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("UpdateSettlementBal:merchant id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy(hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateSettlementBal:country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy(hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateSettlementBal:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));

	hv_service_code.len = strlen(csServiceCode);
	strncpy(hv_service_code.arr, csServiceCode, hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("UpdateSettlementBal:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_amt= dAmt;
	ind_amt= 0;
DEBUGLOG(("UpdateSettlementBal:amt = [%f]\n",hv_amt));

	hv_create_user.len = strlen(csUser);
	strncpy(hv_create_user.arr, csUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateSettlementBal:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merch_balance_update_aval(
				:hv_merchant_id:ind_merchant_id,
				:hv_country_id:ind_country_id,
				:hv_ccy_id:ind_ccy_id,
				:hv_service_code:ind_service_code,
				:hv_amt:ind_amt,
				:hv_create_user:ind_create_user);

	    END;
	END-EXEC;


DEBUGLOG(("UpdateSettlementBal:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("UpdateSettlementBal:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MerchantBlance::UpdateSettlementBal: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateSettlementBal: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MerchantBlance::UpdateSettlementBal: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateSettlementBal: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

updatesettbal_error:
DEBUGLOG(("updatesettbal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;


}


