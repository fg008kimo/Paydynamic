/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/03/01              LokMan Chow
update function					   2011/05/17		   LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "BankMapping.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void BankMapping(char    cdebug)
{
        cDebug = cdebug;
}

int e2iBankCodeMapping(const unsigned char* csInputBankCode, const unsigned char* csPspChannelId,
		const unsigned char* csCountry, char*  csOutputBankCode)
{

	int iRet = NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO map_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_bank_code[PD_BANK_CODE_LEN];
                varchar hv_psp_channel_id[PD_PSP_CHANNEL_CODE_LEN];
                varchar hv_country[PD_COUNTRY_LEN];
		char	hv_disabled;

                varchar v_int_bank_code[PD_BANK_CODE_LEN+1];

                short   ind_int_bank_code = -1;
        EXEC SQL END DECLARE SECTION;

        hv_bank_code.len = strlen((const char*)csInputBankCode);
        memcpy(hv_bank_code.arr,csInputBankCode,hv_bank_code.len);
DEBUGLOG(("e2iBankCodeMapping: Bank Code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr)); 

        hv_psp_channel_id.len = strlen((const char*)csPspChannelId);
        memcpy(hv_psp_channel_id.arr,csPspChannelId,hv_psp_channel_id.len);
DEBUGLOG(("e2iBankCodeMapping: Psp Channel Id = [%.*s]\n",hv_psp_channel_id.len,hv_psp_channel_id.arr)); 

        hv_country.len = strlen((const char*)csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("e2iBankCodeMapping: country = [%.*s]\n",hv_country.len,hv_country.arr)); 

	hv_disabled='0';
	
	EXEC SQL DECLARE c_cursor_map CURSOR FOR
		select  a.bm_int_bank_code
                from    bank_mapping a,
                        def_bank b
                where   a.bm_psp_channel_id =:hv_psp_channel_id
                and     a.bm_ext_bank_code =:hv_bank_code
                and     b.db_country =:hv_country
                and     a.bm_disabled =:hv_disabled
                AND     a.bm_effect_date  =
                        (SELECT max(bm_effect_date)
                           FROM bank_mapping
                          WHERE bm_psp_channel_id =:hv_psp_channel_id
                            AND bm_ext_bank_code =:hv_bank_code
                            AND bm_disabled =:hv_disabled
                            AND bm_effect_date <= sysdate)
                and     b.db_int_bank_code = a.bm_int_bank_code;

	EXEC SQL OPEN c_cursor_map;
	do{	
		EXEC SQL FETCH c_cursor_map
                INTO
			:v_int_bank_code:ind_int_bank_code;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }


		if (ind_int_bank_code >= 0) {
        	       	v_int_bank_code.arr[v_int_bank_code.len] = '\0';
			strcpy(csOutputBankCode,(const char*)v_int_bank_code.arr);
DEBUGLOG(("e2iBankCodeMapping: internal_bank_code = [%s]\n",csOutputBankCode));
			iRet = FOUND;
		}
 
		break;//only one

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_map;

	if(iRet == FOUND){
DEBUGLOG(("e2iBankCodeMapping success [%d]\n",iRet));
	}
	else{
DEBUGLOG(("e2iBankCodeMapping failed [%d]\n",iRet));
	}

	return iRet;

map_error:
DEBUGLOG(("map_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::map_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}


int i2eBankCodeMapping(const unsigned char* csInputBankCode, const unsigned char* csChannelId,
		const unsigned char* csCountry, char* csOutputBankCode)
{

	int iRet = NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO vmap_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_int_bank_code[PD_BANK_CODE_LEN];
                varchar hv_channel_id[PD_PSP_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];
		char	hv_disabled;

                varchar v_bank_code[PD_EXT_BANK_CODE_LEN+1];

                short   ind_bank_code = -1;
        EXEC SQL END DECLARE SECTION;

        hv_int_bank_code.len = strlen((const char *)csInputBankCode);
        memcpy(hv_int_bank_code.arr,csInputBankCode,hv_int_bank_code.len);
DEBUGLOG(("BankCodeMap: Internal Bank Code = [%.*s]\n",hv_int_bank_code.len,hv_int_bank_code.arr)); 

        hv_channel_id.len = strlen((const char *)csChannelId);
        memcpy(hv_channel_id.arr,csChannelId,hv_channel_id.len);
DEBUGLOG(("BankCodeMap: Channel Id= [%.*s]\n",hv_channel_id.len,hv_channel_id.arr)); 

        hv_country.len = strlen((const char *)csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("BankCodeMap: country = [%.*s]\n",hv_country.len,hv_country.arr)); 

	hv_disabled='0';

	EXEC SQL DECLARE c_cursor_vmap CURSOR FOR
        	select  bm_ext_bank_code
                from	bank_mapping
                where bm_int_bank_code=:hv_int_bank_code
		and   bm_psp_channel_id=:hv_channel_id
		and   bm_disabled=:hv_disabled
		AND   bm_effect_date  =
                        (SELECT max(bm_effect_date)
                           FROM bank_mapping
                          WHERE bm_int_bank_code=:hv_int_bank_code
                            AND bm_psp_channel_id=:hv_channel_id
                            AND bm_disabled=:hv_disabled
                            AND bm_effect_date <= sysdate)
		and   bm_country=:hv_country;


	EXEC SQL OPEN c_cursor_vmap;
	do{	
		EXEC SQL FETCH c_cursor_vmap
                INTO
			:v_bank_code:ind_bank_code;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

        	if (ind_bank_code >= 0) {
                	v_bank_code.arr[v_bank_code.len] = '\0';
			strcpy(csOutputBankCode,(const char*)v_bank_code.arr);
DEBUGLOG(("bank_code = [%s]\n",csOutputBankCode));
			iRet = FOUND;
		}

		break;/////only one 

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_vmap;

	if(iRet == FOUND){
DEBUGLOG(("BankCodeMap success [%d]\n",iRet));
	}
	else{
DEBUGLOG(("BankCodeMap failed [%d]\n",iRet));
	}

	return iRet;

vmap_error:
DEBUGLOG(("vmap_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::vmap_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_vmap;
    return NOT_FOUND;
}


int GetAcctIdByBank(const unsigned char* csBankCode,
		    recordset_t* myRec)
{
DEBUGLOG(("GetAcctIdByBank()\n"));
        int iRet = PD_OK;
        int     iCnt = 0;
        hash_t  *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO acct_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short   hv_return_value;

		varchar hv_bank_code[PD_BANK_CODE_LEN+1];

		varchar v_psp_id[PD_PSP_ID_LEN+1];
		varchar v_client_id[PD_CLIENT_ID_LEN+1];


		short   ind_bank_code= -1;
		short   ind_psp_id = -1;
		short   ind_client_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

/*bank_code*/
	hv_bank_code.len = strlen((const char*)csBankCode);
	memcpy(hv_bank_code.arr,csBankCode,hv_bank_code.len);
	ind_bank_code= 0;
DEBUGLOG(("GetAcctIdByBank: bank_code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr));	

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_bank_mapping_acct_id(:hv_bank_code:ind_bank_code,
                                                                    :c_cursor_id);
                END;
        END-EXEC;

        if (hv_return_value == 1 ) {
DEBUGLOG(("GetAcctIdByBank: Found!\n"));
                for (;;) {
                        myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);

			ind_psp_id = -1;
			ind_client_id = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
                        EXEC SQL FETCH :c_cursor_id
                        INTO    :v_psp_id:ind_psp_id,
                                :v_client_id:ind_client_id;

                        if (SQLCODE == SQL_NOT_FOUND) {
                                break;
                        }


			if (ind_psp_id >= 0) {
				v_psp_id.arr[v_psp_id.len]='\0';
DEBUGLOG(("GetAcctIdByBank: [%03d]psp_id = [%.*s]\n",iCnt,v_psp_id.len,v_psp_id.arr));
                                PutField_CString(myHash,"psp_id",(const char *)v_psp_id.arr);
                        }
                        if (ind_client_id >= 0) {
				v_client_id.arr[v_client_id.len]='\0';
DEBUGLOG(("GetAcctIdByBank: [%03d]client_id = [%.*s]\n",iCnt,v_client_id.len,v_client_id.arr));
                                PutField_CString(myHash,"client_id",(const char *)v_client_id.arr);
                        }

                        RecordSet_Add(myRec,myHash);
                        iCnt++;
		}

		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAcctIdByBank: exit with ok\n"));
                return iRet;
	}

	else if(hv_return_value == 9){
                EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAcctIdByBank: exit with error\n"));
                return PD_ERR;
        }
        else{
                EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAcctIdByBank: exit with ok, no record\n"));
                return PD_OK;
        }


        EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
        return iRet;

acct_error:
DEBUGLOG(("acct_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    	EXEC SQL WHENEVER SQLERROR CONTINUE;
    	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
    	return PD_ERR;
}
