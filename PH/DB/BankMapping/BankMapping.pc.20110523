/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/03/01              LokMan Chow
update function					   2011/05/17		   LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "BankMapping.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void BankMapping(char    cdebug)
{
        cDebug = cdebug;
}


int e2iBankCodeMapping(const unsigned char* csInputBankCode, const unsigned char* csMapId,
		const unsigned char* csCountry, char*  csOutputBankCode)
{

	int iRet = NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO map_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_bank_code[PD_BANK_CODE_LEN];
                varchar hv_map_id[PD_MERCHANT_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];
		char	hv_disabled;

                varchar v_int_bank_code[PD_BANK_CODE_LEN+1];

                short   ind_int_bank_code = -1;
        EXEC SQL END DECLARE SECTION;

        hv_bank_code.len = strlen(csInputBankCode);
        memcpy(hv_bank_code.arr,csInputBankCode,hv_bank_code.len);
DEBUGLOG(("BankCodeMap: Bank Code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr)); 

        hv_map_id.len = strlen(csMapId);
        memcpy(hv_map_id.arr,csMapId,hv_map_id.len);
DEBUGLOG(("BankCodeMap: Merchant Id= [%.*s]\n",hv_map_id.len,hv_map_id.arr)); 

        hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("BankCodeMap: country = [%.*s]\n",hv_country.len,hv_country.arr)); 

	hv_disabled='0';
	
	EXEC SQL DECLARE c_cursor_map CURSOR FOR
		select	a.int_bank_code
		from	bank_mapping a,
			def_bank b
		where	a.map_id=:hv_map_id
		and	a.ext_bank_code=:hv_bank_code
		and	b.db_country=:hv_country
		and	a.disabled=:hv_disabled
		and	a.effect_date <=sysdate
		and	b.db_int_bank_code = a.int_bank_code;

	EXEC SQL OPEN c_cursor_map;
	do{	
		EXEC SQL FETCH c_cursor_map
                INTO
			:v_int_bank_code:ind_int_bank_code;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }


		if (ind_int_bank_code >= 0) {
        	       	v_int_bank_code.arr[v_int_bank_code.len] = '\0';
			strcpy(csOutputBankCode,(const char*)v_int_bank_code.arr);
DEBUGLOG(("internal_bank_code = [%s]\n",csOutputBankCode));
			iRet = FOUND;
		}
 
		break;//only one

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_map;

	if(iRet == FOUND){
DEBUGLOG(("BankCodeMap success [%d]\n",iRet));
	}
	else{
DEBUGLOG(("BankCodeMap failed [%d]\n",iRet));
	}

	return iRet;

map_error:
DEBUGLOG(("map_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::map_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}



int i2eBankCodeMapping(const unsigned char* csInputBankCode, const unsigned char* csChannelId,
		const unsigned char* csCountry, char* csOutputBankCode)
{

	int iRet = NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO vmap_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_int_bank_code[PD_BANK_CODE_LEN];
                varchar hv_channel_id[PD_PSP_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];
		char	hv_disabled;

                varchar v_bank_code[PD_BANK_CODE_LEN+1];

                short   ind_bank_code = -1;
        EXEC SQL END DECLARE SECTION;

        hv_int_bank_code.len = strlen(csInputBankCode);
        memcpy(hv_int_bank_code.arr,csInputBankCode,hv_int_bank_code.len);
DEBUGLOG(("BankCodeMap: Internal Bank Code = [%.*s]\n",hv_int_bank_code.len,hv_int_bank_code.arr)); 

        hv_channel_id.len = strlen(csChannelId);
        memcpy(hv_channel_id.arr,csChannelId,hv_channel_id.len);
DEBUGLOG(("BankCodeMap: Channel Id= [%.*s]\n",hv_channel_id.len,hv_channel_id.arr)); 

        hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("BankCodeMap: country = [%.*s]\n",hv_country.len,hv_country.arr)); 

	hv_disabled='0';

	EXEC SQL DECLARE c_cursor_vmap CURSOR FOR
        	select  ext_bank_code
                from	bank_mapping
                where int_bank_code=:hv_int_bank_code
		and   psp_channel_id=:hv_channel_id
		and   disabled=:hv_disabled
		and   effect_date <=sysdate
		and   country=:hv_country;


	EXEC SQL OPEN c_cursor_vmap;
	do{	
		EXEC SQL FETCH c_cursor_vmap
                INTO
			:v_bank_code:ind_bank_code;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

        	if (ind_bank_code >= 0) {
                	v_bank_code.arr[v_bank_code.len] = '\0';
			strcpy(csOutputBankCode,(const char*)v_bank_code.arr);
DEBUGLOG(("bank_code = [%s]\n",csOutputBankCode));
			iRet = FOUND;
		}

		break;/////only one 

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_vmap;

	if(iRet == FOUND){
DEBUGLOG(("BankCodeMap success [%d]\n",iRet));
	}
	else{
DEBUGLOG(("BankCodeMap failed [%d]\n",iRet));
	}

	return iRet;

vmap_error:
DEBUGLOG(("vmap_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::vmap_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}

