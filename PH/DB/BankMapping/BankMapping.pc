/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/03/01              [MSN]
update function					   2011/05/17		   [MSN]
Add function for supporting card type		   2016/09/30		   [MSN]
Add GetNGBankCodeByPspId			   2017/10/12		   [WMC]		
Add GetMobileBankCodeByPspId			   2017/11/21		   [WMC]
Add Replicate                                      2021/07/27              [MIC]
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "BankMapping.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


static char cDebug;

void BankMapping(char    cdebug)
{
        cDebug = cdebug;
}


int Replicate(const hash_t *hRec)
{
	char            *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO replicate_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		
		varchar         hv_replicate_psp_id[PD_PSP_ID_LEN];
		varchar         hv_create_psp_id[PD_PSP_ID_LEN];
		varchar         hv_create_user[PD_USER_LEN];

		short		ind_replicate_psp_id = -1;
		short		ind_create_psp_id = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Replicate: Begin\n"));


	if(GetField_CString(hRec,"replicate_psp_id",&csTmp))
	{
		hv_replicate_psp_id.len = strlen(csTmp);
		strncpy((char*)hv_replicate_psp_id.arr, csTmp, hv_replicate_psp_id.len);
		ind_replicate_psp_id = 0;
	}
DEBUGLOG(("Replicate:replicate_psp_id = [%.*s]\n",hv_replicate_psp_id.len,hv_replicate_psp_id.arr));

	if(GetField_CString(hRec,"create_psp_id",&csTmp))
	{
		hv_create_psp_id.len = strlen(csTmp);
		strncpy((char*)hv_create_psp_id.arr, csTmp, hv_create_psp_id.len);
		ind_create_psp_id = 0;
	}
DEBUGLOG(("Replicate:create_psp_id = [%.*s]\n",hv_create_psp_id.len,hv_create_psp_id.arr));



	if(GetField_CString(hRec,"create_user",&csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Replicate:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));



	FREE_ME(csTmp);


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_bank_mapping_rpl(
				:hv_replicate_psp_id:ind_replicate_psp_id,
				:hv_create_psp_id:ind_create_psp_id,
				:hv_create_user:ind_create_user
				);

	    END;
	END-EXEC;


	DEBUGLOG(("Replicate:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Replicate:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("BankMapping_Replicate: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Replicate: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("BankMapping_Replicate: SP_ERR TxnAbort\n");
		DEBUGLOG(("Replicate: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

	if (hv_return_value == SP_NOT_FOUND)  {
		ERRLOG("BankMapping_Replicate: SP_NOT_FOUND TxnAbort\n");
		DEBUGLOG(("Replicate: SP_NOT_FOUND TxnAbort\n"));
		return PD_NOT_FOUND;
	}

replicate_error:
DEBUGLOG(("replicate_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping_Replicate: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;


}


int e2iBankCodeMapping(const unsigned char* csInputBankCode, const unsigned char* csPspChannelId,
		const unsigned char* csCountry, char*  csOutputBankCode)
{

	int iRet = NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO map_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_bank_code[PD_BANK_CODE_LEN];
                varchar hv_psp_channel_id[PD_PSP_CHANNEL_CODE_LEN];
                varchar hv_country[PD_COUNTRY_LEN];
		char	hv_disabled;

                varchar v_int_bank_code[PD_BANK_CODE_LEN+1];

                short   ind_int_bank_code = -1;
        EXEC SQL END DECLARE SECTION;

        hv_bank_code.len = strlen((const char*)csInputBankCode);
        memcpy(hv_bank_code.arr,csInputBankCode,hv_bank_code.len);
DEBUGLOG(("e2iBankCodeMapping: Bank Code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr)); 

        hv_psp_channel_id.len = strlen((const char*)csPspChannelId);
        memcpy(hv_psp_channel_id.arr,csPspChannelId,hv_psp_channel_id.len);
DEBUGLOG(("e2iBankCodeMapping: Psp Channel Id = [%.*s]\n",hv_psp_channel_id.len,hv_psp_channel_id.arr)); 

        hv_country.len = strlen((const char*)csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("e2iBankCodeMapping: country = [%.*s]\n",hv_country.len,hv_country.arr)); 

	hv_disabled='0';
	
	EXEC SQL DECLARE c_cursor_map CURSOR FOR
		select  a.bm_int_bank_code
                from    bank_mapping a,
                        def_bank b
                where   a.bm_psp_channel_id =:hv_psp_channel_id
                and     a.bm_ext_bank_code =:hv_bank_code
                and     b.db_country =:hv_country
                and     a.bm_disabled =:hv_disabled
                AND     a.bm_effect_date  =
                        (SELECT max(bm_effect_date)
                           FROM bank_mapping
                          WHERE bm_psp_channel_id =:hv_psp_channel_id
                            AND bm_ext_bank_code =:hv_bank_code
                            AND bm_disabled =:hv_disabled
                            AND bm_effect_date <= sysdate)
                and     b.db_int_bank_code = a.bm_int_bank_code;

	EXEC SQL OPEN c_cursor_map;
	do{	
		EXEC SQL FETCH c_cursor_map
                INTO
			:v_int_bank_code:ind_int_bank_code;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }


		if (ind_int_bank_code >= 0) {
        	       	v_int_bank_code.arr[v_int_bank_code.len] = '\0';
			strcpy(csOutputBankCode,(const char*)v_int_bank_code.arr);
DEBUGLOG(("e2iBankCodeMapping: internal_bank_code = [%s]\n",csOutputBankCode));
			iRet = FOUND;
		}
 
		break;//only one

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_map;

	if(iRet == FOUND){
DEBUGLOG(("e2iBankCodeMapping success [%d]\n",iRet));
	}
	else{
DEBUGLOG(("e2iBankCodeMapping failed [%d]\n",iRet));
	}

	return iRet;

map_error:
DEBUGLOG(("map_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::map_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}


int i2eBankCodeMapping(const unsigned char* csInputBankCode, const unsigned char* csChannelId,
		const unsigned char* csCountry, char* csOutputBankCode)
{

	int iRet = NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO vmap_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_int_bank_code[PD_BANK_CODE_LEN];
                varchar hv_channel_id[PD_PSP_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];
		char	hv_disabled;

                varchar v_bank_code[PD_EXT_BANK_CODE_LEN+1];

                short   ind_bank_code = -1;
        EXEC SQL END DECLARE SECTION;

        hv_int_bank_code.len = strlen((const char *)csInputBankCode);
        memcpy(hv_int_bank_code.arr,csInputBankCode,hv_int_bank_code.len);
DEBUGLOG(("BankCodeMap: Internal Bank Code = [%.*s]\n",hv_int_bank_code.len,hv_int_bank_code.arr)); 

        hv_channel_id.len = strlen((const char *)csChannelId);
        memcpy(hv_channel_id.arr,csChannelId,hv_channel_id.len);
DEBUGLOG(("BankCodeMap: Channel Id= [%.*s]\n",hv_channel_id.len,hv_channel_id.arr)); 

        hv_country.len = strlen((const char *)csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("BankCodeMap: country = [%.*s]\n",hv_country.len,hv_country.arr)); 

	hv_disabled='0';

	EXEC SQL DECLARE c_cursor_vmap CURSOR FOR
        	select  bm_ext_bank_code
                from	bank_mapping
                where bm_int_bank_code=:hv_int_bank_code
		and   bm_psp_channel_id=:hv_channel_id
		and   bm_disabled=:hv_disabled
		AND   bm_effect_date  =
                        (SELECT max(bm_effect_date)
                           FROM bank_mapping
                          WHERE bm_int_bank_code=:hv_int_bank_code
                            AND bm_psp_channel_id=:hv_channel_id
                            AND bm_disabled=:hv_disabled
                            AND bm_effect_date <= sysdate)
		and   bm_country=:hv_country;


	EXEC SQL OPEN c_cursor_vmap;
	do{	
		EXEC SQL FETCH c_cursor_vmap
                INTO
			:v_bank_code:ind_bank_code;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

        	if (ind_bank_code >= 0) {
                	v_bank_code.arr[v_bank_code.len] = '\0';
			strcpy(csOutputBankCode,(const char*)v_bank_code.arr);
DEBUGLOG(("bank_code = [%s]\n",csOutputBankCode));
			iRet = FOUND;
		}

		break;/////only one 

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_vmap;

	if(iRet == FOUND){
DEBUGLOG(("BankCodeMap success [%d]\n",iRet));
	}
	else{
DEBUGLOG(("BankCodeMap failed [%d]\n",iRet));
	}

	return iRet;

vmap_error:
DEBUGLOG(("vmap_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::vmap_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_vmap;
    return NOT_FOUND;
}


int GetAcctIdByBank(const unsigned char* csBankCode,
		    recordset_t* myRec)
{
DEBUGLOG(("GetAcctIdByBank()\n"));
        int iRet = PD_OK;
        int     iCnt = 0;
        hash_t  *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO acct_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short   hv_return_value;

		varchar hv_bank_code[PD_BANK_CODE_LEN+1];

		varchar v_psp_id[PD_PSP_ID_LEN+1];
		varchar v_client_id[PD_CLIENT_ID_LEN+1];


		short   ind_bank_code= -1;
		short   ind_psp_id = -1;
		short   ind_client_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

/*bank_code*/
	hv_bank_code.len = strlen((const char*)csBankCode);
	memcpy(hv_bank_code.arr,csBankCode,hv_bank_code.len);
	ind_bank_code= 0;
DEBUGLOG(("GetAcctIdByBank: bank_code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr));	

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_bank_mapping_acct_id(:hv_bank_code:ind_bank_code,
                                                                    :c_cursor_id);
                END;
        END-EXEC;

        if (hv_return_value == SP_ERR ) {
DEBUGLOG(("GetAcctIdByBank: Found!\n"));
                for (;;) {
                        myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);

			ind_psp_id = -1;
			ind_client_id = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
                        EXEC SQL FETCH :c_cursor_id
                        INTO    :v_psp_id:ind_psp_id,
                                :v_client_id:ind_client_id;

                        if (SQLCODE == SQL_NOT_FOUND) {
                                break;
                        }


			if (ind_psp_id >= 0) {
				v_psp_id.arr[v_psp_id.len]='\0';
DEBUGLOG(("GetAcctIdByBank: [%03d]psp_id = [%.*s]\n",iCnt,v_psp_id.len,v_psp_id.arr));
                                PutField_CString(myHash,"psp_id",(const char *)v_psp_id.arr);
                        }
                        if (ind_client_id >= 0) {
				v_client_id.arr[v_client_id.len]='\0';
DEBUGLOG(("GetAcctIdByBank: [%03d]client_id = [%.*s]\n",iCnt,v_client_id.len,v_client_id.arr));
                                PutField_CString(myHash,"client_id",(const char *)v_client_id.arr);
                        }

                        RecordSet_Add(myRec,myHash);
                        iCnt++;
		}

		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAcctIdByBank: exit with ok\n"));
                return iRet;
	}

	else if(hv_return_value == SP_OTHER_ERR){
                EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAcctIdByBank: exit with error\n"));
                return PD_ERR;
        }
        else{
                EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAcctIdByBank: exit with ok, no record\n"));
                return PD_OK;
        }


        EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
        return iRet;

acct_error:
DEBUGLOG(("acct_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    	EXEC SQL WHENEVER SQLERROR CONTINUE;
    	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
    	return PD_ERR;
}

int GetAllBankCodeByPspChannel(const unsigned char* csServiceCode,
				const unsigned char* csCountry,
				const unsigned char* csChannelId,
				recordset_t* myRec)
{
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO allbankcodepspchannel_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
                varchar hv_channel_id[PD_PSP_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];

                varchar v_bank_code[PD_BANK_CODE_LEN+1];

                short   ind_bank_code = -1;
        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char *)csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetAllBankCodeByPspChannel: Service Code = [%.*s]\n",hv_service_code.len,hv_service_code.arr)); 

        hv_channel_id.len = strlen((const char *)csChannelId);
        memcpy(hv_channel_id.arr,csChannelId,hv_channel_id.len);
DEBUGLOG(("GetAllBankCodeByPspChannel: Channel Id= [%.*s]\n",hv_channel_id.len,hv_channel_id.arr)); 

        hv_country.len = strlen((const char *)csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("GetAllBankCodeByPspChannel: country = [%.*s]\n",hv_country.len,hv_country.arr)); 


	EXEC SQL DECLARE c_cursor_bankpspchannel CURSOR FOR
		select bs_int_bank_code
                  from bank_desc, 
                       (SELECT bs_int_bank_code, bm_country
		  	  FROM bank_service_mapping, bank_mapping
			 WHERE bs_service_code = :hv_service_code
			   AND bs_int_bank_code = bm_int_bank_code
			   AND bm_psp_channel_id = :hv_channel_id
		           AND bm_country = :hv_country
			   AND bm_disabled = 0
			)
		  where bs_int_bank_code = internal_bank_code
                    and country = bm_country
		  order by fe_display_order, bs_int_bank_code;                    

	EXEC SQL OPEN c_cursor_bankpspchannel;
	do{	
		EXEC SQL FETCH c_cursor_bankpspchannel
                INTO
			:v_bank_code:ind_bank_code;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

		if (ind_bank_code >= 0) {
                        v_bank_code.arr[v_bank_code.len] ='\0';
                        PutField_CString(myHash,"bank_code",(const char*)v_bank_code.arr);
DEBUGLOG(("GetAllBankCodeByPspChannel bank_code = [%s]\n",v_bank_code.arr));
                }

		RecordSet_Add(myRec,myHash);

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_bankpspchannel;


	return PD_OK;

allbankcodepspchannel_error:
DEBUGLOG(("allbankcodepspchannel_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::allbankcodepspchannel_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_bankpspchannel;
    return PD_ERR;
}


int GetAllBankCodeByPspId(const unsigned char* csServiceCode,
			  const unsigned char* csCountry,
			  const unsigned char* csPspId,
			  recordset_t* myRec)
{
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO allbankcodepspid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
                varchar hv_psp_id[PD_PSP_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];

                varchar v_bank_code[PD_BANK_CODE_LEN+1];
		char	v_card_type;

                short   ind_bank_code = -1;
                short   ind_card_type = -1;
        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char *)csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetAllBankCodeByPspId: Service Code = [%.*s]\n",hv_service_code.len,hv_service_code.arr)); 

        hv_psp_id.len = strlen((const char *)csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);
DEBUGLOG(("GetAllBankCodeByPspId: Psp Id= [%.*s]\n",hv_psp_id.len,hv_psp_id.arr)); 

        hv_country.len = strlen((const char *)csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("GetAllBankCodeByPspId: country = [%.*s]\n",hv_country.len,hv_country.arr)); 


	EXEC SQL DECLARE c_cursor_bankpspid CURSOR FOR
		select	bs_int_bank_code, deposit_card_type
		from	psp_detail, bank_service_mapping, bank_mapping,bank_desc
		WHERE bs_service_code = :hv_service_code
		AND   bs_int_bank_code = bm_int_bank_code
		AND   psp_id = :hv_psp_id
		AND   bm_country = :hv_country
		AND   bm_disabled = 0
		AND   nvl(overrided_bank_code_channel,psp_channel_code) = bm_psp_channel_id
		AND   bs_int_bank_code = internal_bank_code
                and   country = bm_country
		group by deposit_card_type, bs_int_bank_code,fe_display_order
		order by fe_display_order;                    

	EXEC SQL OPEN c_cursor_bankpspid;
	do{	
		EXEC SQL FETCH c_cursor_bankpspid
                INTO
			:v_bank_code:ind_bank_code,
			:v_card_type:ind_card_type;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

		if (ind_bank_code >= 0) {
                        v_bank_code.arr[v_bank_code.len] ='\0';
                        PutField_CString(myHash,"bank_code",(const char*)v_bank_code.arr);
DEBUGLOG(("GetAllBankCodeByPspId bank_code = [%s]\n",v_bank_code.arr));
                }

		if (ind_card_type >= 0) {
                        PutField_Char(myHash,"card_type",v_card_type);
DEBUGLOG(("GetAllBankCodeByPspId card_type = [%c]\n",v_card_type));
                }


		RecordSet_Add(myRec,myHash);

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_bankpspid;


	return PD_OK;

allbankcodepspid_error:
DEBUGLOG(("allbankcodepspid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::allbankcodepspid_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_bankpspid;
    return PD_ERR;
}


int GetNGBankCodeByPspId(const unsigned char* csServiceCode,
			  const unsigned char* csCountry,
			  const unsigned char* csPspId,
			  recordset_t* myRec)
{
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO ngbankcodepspid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
                varchar hv_psp_id[PD_PSP_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];

                varchar v_bank_code[PD_BANK_CODE_LEN+1];
		char	v_card_type;

                short   ind_bank_code = -1;
                short   ind_card_type = -1;
        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char *)csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetNGBankCodeByPspId: Service Code = [%.*s]\n",hv_service_code.len,hv_service_code.arr)); 

        hv_psp_id.len = strlen((const char *)csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);
DEBUGLOG(("GetNGBankCodeByPspId: Psp Id= [%.*s]\n",hv_psp_id.len,hv_psp_id.arr)); 

        hv_country.len = strlen((const char *)csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("GetNGBankCodeByPspId: country = [%.*s]\n",hv_country.len,hv_country.arr)); 


	EXEC SQL DECLARE c_cursor_ngbankpspid CURSOR FOR
		select pgm_bank_code, deposit_card_type
		from	psp_detail, bank_service_mapping, bank_mapping, bank_desc, pid_bank_group_mapping
		WHERE bs_service_code = :hv_service_code
		AND   bs_int_bank_code = bm_int_bank_code
		AND   psp_id = :hv_psp_id
		AND   bm_country = :hv_country
		AND   pgm_service_code = bs_service_code
		AND   bm_disabled = 0
		AND   pgm_disabled = 0
		AND   nvl(overrided_bank_code_channel,psp_channel_code) = bm_psp_channel_id
		AND   bs_int_bank_code = internal_bank_code
		AND   ((pgm_bank_code = internal_bank_code) or (pgm_bank_code = bank_group))
                AND   country = bm_country
		group by deposit_card_type, pgm_bank_code
		order by pgm_bank_code;                    

	EXEC SQL OPEN c_cursor_ngbankpspid;
	do{	
		EXEC SQL FETCH c_cursor_ngbankpspid
                INTO
			:v_bank_code:ind_bank_code,
			:v_card_type:ind_card_type;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

		if (ind_bank_code >= 0) {
                        v_bank_code.arr[v_bank_code.len] ='\0';
                        PutField_CString(myHash,"bank_code",(const char*)v_bank_code.arr);
DEBUGLOG(("GetNGBankCodeByPspId bank_code = [%s]\n",v_bank_code.arr));
                }

		if (ind_card_type >= 0) {
                        PutField_Char(myHash,"card_type",v_card_type);
DEBUGLOG(("GetNGBankCodeByPspId card_type = [%c]\n",v_card_type));
                }


		RecordSet_Add(myRec,myHash);

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_ngbankpspid;


	return PD_OK;

ngbankcodepspid_error:
DEBUGLOG(("ngbankcodepspid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::ngbankcodepspid_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_ngbankpspid;
    return PD_ERR;
}


int GetMobileBankCodeByPspId(const unsigned char* csServiceCode,
			  const unsigned char* csCountry,
			  const unsigned char* csPspId,
			  recordset_t* myRec)
{
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO mobbankcodepspid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
                varchar hv_psp_id[PD_PSP_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];

                varchar v_bank_code[PD_BANK_CODE_LEN+1];
		char	v_card_type;

                short   ind_bank_code = -1;
                short   ind_card_type = -1;
        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char *)csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetMobileBankCodeByPspId: Service Code = [%.*s]\n",hv_service_code.len,hv_service_code.arr)); 

        hv_psp_id.len = strlen((const char *)csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);
DEBUGLOG(("GetMobileBankCodeByPspId: Psp Id= [%.*s]\n",hv_psp_id.len,hv_psp_id.arr)); 

        hv_country.len = strlen((const char *)csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("GetMobileBankCodeByPspId: country = [%.*s]\n",hv_country.len,hv_country.arr)); 


	EXEC SQL DECLARE c_cursor_mobbankpspid CURSOR FOR
		select pgm_bank_group, deposit_card_type
		from    psp_detail, bank_service_mapping, bank_mapping, bank_desc, pid_bank_group_mapping
		WHERE bs_service_code = :hv_service_code
		AND   bs_int_bank_code = bm_int_bank_code
		AND   psp_id = :hv_psp_id
		AND   bm_country = :hv_country
		AND   pgm_service_code = bs_service_code
		AND   bm_disabled = 0
		AND   pgm_disabled = 0
		AND   nvl(overrided_bank_code_channel,psp_channel_code) = bm_psp_channel_id
		AND   bs_int_bank_code = internal_bank_code
		AND   ((pgm_bank_code = internal_bank_code) or (pgm_bank_code = bank_group))
		AND   country = bm_country
		group by deposit_card_type, pgm_bank_group
		order by pgm_bank_group;

	EXEC SQL OPEN c_cursor_mobbankpspid;
	do{	
		EXEC SQL FETCH c_cursor_mobbankpspid
                INTO
			:v_bank_code:ind_bank_code,
			:v_card_type:ind_card_type;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

		if (ind_bank_code >= 0) {
                        v_bank_code.arr[v_bank_code.len] ='\0';
                        PutField_CString(myHash,"bank_code",(const char*)v_bank_code.arr);
DEBUGLOG(("GetMobileBankCodeByPspId bank_code = [%s]\n",v_bank_code.arr));
                }

		if (ind_card_type >= 0) {
                        PutField_Char(myHash,"card_type",v_card_type);
DEBUGLOG(("GetMobileBankCodeByPspId card_type = [%c]\n",v_card_type));
                }


		RecordSet_Add(myRec,myHash);

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_mobbankpspid;


	return PD_OK;

mobbankcodepspid_error:
DEBUGLOG(("mobbankcodepspid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::mobbankcodepspid_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_mobbankpspid;
    return PD_ERR;
}
