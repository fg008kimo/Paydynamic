/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/03/01              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "BankMapping.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void BankMapping(char    cdebug)
{
        cDebug = cdebug;
}


int e2iBankCodeMapping(const unsigned char* csInputBankCode, const unsigned char* csMapId,
		const unsigned char* csCountry, const unsigned char* csLanguage, recordset_t* myRec)
{

	int iRet = NOT_FOUND;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO map_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_bank_code[PD_BANK_CODE_LEN];
                varchar hv_map_id[PD_MERCHANT_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];
		varchar hv_language[PD_LANGUAGE_LEN];
		char	hv_disabled;

                varchar v_int_bank_code[PD_BANK_CODE_LEN+1];
		varchar	v_bank_name[PD_BANK_NAME_LEN+1];
		varchar	v_logo_path[PD_URL_LEN+1];

                short   ind_int_bank_code = -1;
		short	ind_logo_path = -1;
		short	ind_bank_name = -1;
        EXEC SQL END DECLARE SECTION;

        hv_bank_code.len = strlen(csInputBankCode);
        memcpy(hv_bank_code.arr,csInputBankCode,hv_bank_code.len);
DEBUGLOG(("BankCodeMap: Bank Code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr)); 

        hv_map_id.len = strlen(csMapId);
        memcpy(hv_map_id.arr,csMapId,hv_map_id.len);
DEBUGLOG(("BankCodeMap: Merchant Id= [%.*s]\n",hv_map_id.len,hv_map_id.arr)); 

        hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("BankCodeMap: country = [%.*s]\n",hv_country.len,hv_country.arr)); 

        hv_language.len = strlen(csLanguage);
        memcpy(hv_language.arr,csLanguage,hv_language.len);
DEBUGLOG(("BankCodeMap: language = [%.*s]\n",hv_language.len,hv_language.arr)); 

	hv_disabled='0';
	
	EXEC SQL
		select	int_bank_code
		into	:v_int_bank_code:ind_int_bank_code
		from	bank_mapping
		where	map_id=:hv_map_id
		and	ext_bank_code=:hv_bank_code
		and	country=:hv_country
		and	disabled=:hv_disabled
		and	effect_date <=sysdate;

	if ((SQLCODE == SQL_NOT_FOUND)|| (ind_int_bank_code < 0)) {
		v_int_bank_code.len = strlen(csInputBankCode);
        	memcpy(v_int_bank_code.arr,csInputBankCode,v_int_bank_code.len);
		ind_int_bank_code = 0;
	}


	EXEC SQL DECLARE c_cursor_map CURSOR FOR
        	select  bank_name,
			logo_path
                from	bank_desc
                where country=:hv_country
		and   language=:hv_language
		and   internal_bank_code=:v_int_bank_code;


		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

	EXEC SQL OPEN c_cursor_map;
	do{	
		EXEC SQL FETCH c_cursor_map
                INTO
			:v_bank_name:ind_bank_name,
			:v_logo_path:ind_logo_path;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

        	if (ind_int_bank_code >= 0) {
                	v_int_bank_code.arr[v_int_bank_code.len] = '\0';
			PutField_CString(myHash,"internal_bank_code",v_int_bank_code.arr);
DEBUGLOG(("internal_bank_code = [%.*s]\n",v_int_bank_code.len,v_int_bank_code.arr));
		}
 
       	 	if (ind_logo_path >= 0) {
               	 	v_logo_path.arr[v_logo_path.len] = '\0';
			PutField_CString(myHash,"logo_path",v_logo_path.arr);
DEBUGLOG(("logo_path = [%.*s]\n",v_logo_path.len,v_logo_path.arr)); 
		}

       	 	if (ind_bank_name>= 0) {
               	 	v_bank_name.arr[v_bank_name.len] = '\0';
			PutField_CString(myHash,"bank_name",v_bank_name.arr);
DEBUGLOG(("bank_name = [%.*s]\n",v_bank_name.len,v_bank_name.arr)); 
		}

		iRet = FOUND;
		RecordSet_Add(myRec,myHash);

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_map;

	if(iRet == FOUND){
DEBUGLOG(("BankCodeMap success = [%d]\n",iRet));
	}
	else{
DEBUGLOG(("BankCodeMap set EXT_BANK_CODE = INT_BANK_CODE\n"));
		PutField_CString(myHash,"internal_bank_code",csInputBankCode);
		iRet = FOUND;
		RecordSet_Add(myRec,myHash);
	}

DEBUGLOG(("iRet = [%d]\n",iRet));
	return iRet;

map_error:
DEBUGLOG(("map_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::map_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}



int i2eBankCodeMapping(const unsigned char* csInputBankCode, const unsigned char* csChannelId,
		const unsigned char* csCountry, char* csOutputBankCode)
{

	int iRet = NOT_FOUND;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO vmap_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_int_bank_code[PD_BANK_CODE_LEN];
                varchar hv_channel_id[PD_PSP_ID_LEN];
                varchar hv_country[PD_COUNTRY_LEN];
		varchar hv_language[PD_LANGUAGE_LEN];
		char	hv_disabled;

                varchar v_bank_code[PD_BANK_CODE_LEN+1];

                short   ind_bank_code = -1;
        EXEC SQL END DECLARE SECTION;

        hv_int_bank_code.len = strlen(csInputBankCode);
        memcpy(hv_int_bank_code.arr,csInputBankCode,hv_int_bank_code.len);
DEBUGLOG(("BankCodeMap: Internal Bank Code = [%.*s]\n",hv_int_bank_code.len,hv_int_bank_code.arr)); 

        hv_channel_id.len = strlen(csChannelId);
        memcpy(hv_channel_id.arr,csChannelId,hv_channel_id.len);
DEBUGLOG(("BankCodeMap: Channel Id= [%.*s]\n",hv_channel_id.len,hv_channel_id.arr)); 

        hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("BankCodeMap: country = [%.*s]\n",hv_country.len,hv_country.arr)); 

	hv_disabled='0';

	EXEC SQL DECLARE c_cursor_vmap CURSOR FOR
        	select  ext_bank_code
                from	bank_mapping
                where int_bank_code=:hv_int_bank_code
		and   channel_id=:hv_channel_id
		and   disabled=:hv_disabled
		and   effect_date <=sysdate
		and   country=:hv_country;


	EXEC SQL OPEN c_cursor_vmap;
	do{	
		EXEC SQL FETCH c_cursor_vmap
                INTO
			:v_bank_code:ind_bank_code;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

        	if (ind_bank_code >= 0) {
                	v_bank_code.arr[v_bank_code.len] = '\0';
			strcpy(csOutputBankCode,(const char*)v_bank_code.arr);
DEBUGLOG(("bank_code = [%s]\n",csOutputBankCode));
		}

		iRet = FOUND;
		break;/////only one 

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_vmap;

	if(iRet == FOUND){
DEBUGLOG(("BankCodeMap success = [%d]\n",iRet));
	}
	else{
DEBUGLOG(("BankCodeMap set INT_BANK_CODE = EXT_BANK_CODE\n"));
                strcpy(csOutputBankCode,csInputBankCode);
                iRet = FOUND;
                RecordSet_Add(myRec,myHash);
	}

	return iRet;

vmap_error:
DEBUGLOG(("vmap_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankMapping::vmap_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}

