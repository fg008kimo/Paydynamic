/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/08/19              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "ClientKeys.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void ClientKeys(char    cdebug)
{
        cDebug = cdebug;
}

int GetClientKey(const char* csClientID,const char* csKey,
                recordset_t* myRec)
{
	int iRet = 0;
                
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getclientkey_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_client_id[PD_CLIENT_ID_LEN];
		varchar		hv_key[PD_KEY_NAME_LEN + 1];
                
		varchar		v_key_value[PD_MD5_KEY_LEN + 1];

		short		ind_key_value = -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_client_id.len = strlen(csClientID);
        memcpy(hv_client_id.arr,csClientID,hv_client_id.len);
DEBUGLOG(("GetClientKey client_id = [%.*s]\n",hv_client_id.len,hv_client_id.arr));
        
        hv_key.len = strlen(csKey);
        memcpy(hv_key.arr,csKey,hv_key.len);
DEBUGLOG(("GetClientKey key = [%.*s]\n",hv_key.len,hv_key.arr));
        
        EXEC SQL DECLARE c_cursor_getclientkey CURSOR FOR
                select
		       ck_key_value
                  from client_keys
		 where ck_client_id = :hv_client_id
		 and   ck_key = :hv_key
		 AND   ck_effect_date  =
                        (SELECT max(ck_effect_date)
                           FROM client_keys
                          WHERE ck_client_id = :hv_client_id
                            AND ck_key = :hv_key
                            AND ck_effect_date <= sysdate);


        EXEC SQL OPEN c_cursor_getclientkey;
        do {
                EXEC SQL FETCH c_cursor_getclientkey
                INTO
			:v_key_value:ind_key_value;

                if (SQLCODE == SQL_NOT_FOUND) {
			iRet = SQL_NOT_FOUND;
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);


/* key */
                if (ind_key_value >= 0) {
                        v_key_value.arr[v_key_value.len] = '\0';
                        PutField_CString(myHash,"key_value",(const char*)v_key_value.arr);
DEBUGLOG(("GetClientKey key_value = [%s]\n",v_key_value.arr));
                }

                RecordSet_Add(myRec,myHash);
		break; //**************** only one now
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getclientkey;

	

DEBUGLOG(("GetClientKey Normal Exit\n"));
        if(iRet==0) return  PD_OK;
	else	return iRet;

getclientkey_error:
DEBUGLOG(("getclientkey_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getclientkey;
        return PD_ERR;
}


