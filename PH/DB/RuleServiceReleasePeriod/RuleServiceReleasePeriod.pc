/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/07/11              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "RuleServiceReleasePeriod.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;
void RuleServiceReleasePeriod(char    cdebug)
{
        cDebug = cdebug;
}


int FindPayoutAvaiPeriod(const char* csServiceCode,
        int     *iPeriod)
{
        EXEC SQL WHENEVER SQLERROR GOTO find_po_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
    
        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		varchar		hv_release_type[PD_RLS_TYPE_LEN];

		int		v_period;

		short		ind_period= -1;

        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindPayoutAvaiPeriod service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_release_type.len = strlen(PD_RLS_TYPE_AVAPO);
        memcpy(hv_release_type.arr, PD_RLS_TYPE_AVAPO, hv_release_type.len);
DEBUGLOG(("FindPayoutAvaiPeriod release_type = [%.*s]\n",hv_release_type.len,hv_release_type.arr));


        EXEC SQL EXECUTE
                BEGIN

		select  rs_release_period
                into    :v_period:ind_period
                from    rule_service_release_period
                where   rs_service_code=:hv_service_code
                and     rs_release_type=:hv_release_type
                and     rs_disabled = 0;

                END;
        END-EXEC;

        if (ind_period>= 0)  {
DEBUGLOG(("FindPayoutAvaiPeriod Found\n"));
		*iPeriod = v_period;
DEBUGLOG(("FindPayoutAvaiPeriod v_period = [%d]\n",*iPeriod));
                return PD_OK;
        }
        else {
DEBUGLOG(("FindPayoutAvaiPeriod Not Found\n"));
                return PD_ERR;
        }


find_po_error:
ERRLOG("RuleServiceReleasePeriod::find_po_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("find_po_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}


int FindSettlementFloatPeriod(const char* csServiceCode,
        int     *iPeriod)
{
        EXEC SQL WHENEVER SQLERROR GOTO find_st_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
    
        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		varchar         hv_release_type[PD_RLS_TYPE_LEN];

		int		v_period;

		short		ind_period= -1;

    
        EXEC SQL END DECLARE SECTION;


        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindSettlementFloatPeriod service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

        hv_release_type.len = strlen(PD_RLS_TYPE_SETTFT);
        memcpy(hv_release_type.arr, PD_RLS_TYPE_SETTFT, hv_release_type.len);
DEBUGLOG(("FindSettlementFloatPeriod release_type = [%.*s]\n",hv_release_type.len,hv_release_type.arr));


        EXEC SQL EXECUTE
                BEGIN

		select  rs_release_period
                into    :v_period:ind_period
                from    rule_service_release_period
                where   rs_service_code=:hv_service_code
		and     rs_release_type=:hv_release_type
                and     rs_disabled = 0;

                END;
        END-EXEC;

        if (ind_period>= 0)  {
DEBUGLOG(("FindSettlementFloatPeriod Found\n"));
		*iPeriod = v_period;
DEBUGLOG(("FindSettlementFloatPeriod v_period = [%d]\n",*iPeriod));
                return PD_OK;
        }
        else {
DEBUGLOG(("FindSettlementFloatPeriod Not Found\n"));
                return PD_ERR;
        }


find_st_error:
ERRLOG("RuleServiceReleasePeriod::find_st_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("find_st_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int FindReleasePeriod(const char* csServiceCode,
		      const char* csReleaseType,
		      int   *iPeriod)
{
        EXEC SQL WHENEVER SQLERROR GOTO find_rls_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
    
        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		varchar         hv_release_type[PD_RLS_TYPE_LEN];

		int		v_period;

		short		ind_period= -1;

        EXEC SQL END DECLARE SECTION;


        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindReleasePeriod service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

        hv_release_type.len = strlen(csReleaseType);
        memcpy(hv_release_type.arr, csReleaseType, hv_release_type.len);
DEBUGLOG(("FindReleasePeriod release_type = [%.*s]\n",hv_release_type.len,hv_release_type.arr));


        EXEC SQL EXECUTE
                BEGIN

		select  rs_release_period
                into    :v_period:ind_period
                from    rule_service_release_period
                where   rs_service_code=:hv_service_code
		and     rs_release_type=:hv_release_type
                and     rs_disabled = 0;

                END;
        END-EXEC;

        if (ind_period>= 0)  {
DEBUGLOG(("FindReleasePeriod Found\n"));
		*iPeriod = v_period;
DEBUGLOG(("FindReleasePeriod v_period = [%d]\n",*iPeriod));
                return PD_OK;
        }
        else {
DEBUGLOG(("FindReleasePeriod Not Found\n"));
                return PD_ERR;
        }


find_rls_error:
ERRLOG("RuleServiceReleasePeriod::find_rls_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("find_rls_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

