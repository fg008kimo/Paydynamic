/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/10/11              LokMan Chow
Update to BAID Bal                                 2014/01/02              Stan Poon
Refine                                             2014/07/02              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLBAIDBal.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char cDebug;

void OLBAIDBal(char cdebug)
{
 cDebug = cdebug;
}

int UpdateBalance(const char* csBAID,
		const char* csCountryId,
		const char* csCcy,
		char cType,
		double dAmt,
		char* csUpdateUser)
{
	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_baid[PD_BAID_LEN];
		varchar hv_country_id[PD_COUNTRY_LEN];
		varchar hv_ccy_id[PD_CCY_ID_LEN];
		double hv_balance;
		varchar hv_create_user[PD_USER_LEN];

		short ind_baid = -1;
		short ind_country_id = -1;
		short ind_ccy_id = -1;
		short ind_balance = -1;
		short ind_create_user = -1;

		short hv_return_value;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen(csBAID);
	strncpy((char*)hv_baid.arr, csBAID, hv_baid.len);
	ind_baid = 0;
DEBUGLOG(("UpdateBalance baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy((char*)hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateBalance country_id = [%.*s]\n", hv_country_id.len, hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy((char*)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateBalance ccy_id = [%.*s]\n", hv_ccy_id.len, hv_ccy_id.arr));

	if (cType == PD_IND_CREDIT) {
		hv_balance = dAmt;
DEBUGLOG(("UpdateBalance credit balance = [%f]\n", hv_balance));
	} else {
		hv_balance = (-1) * dAmt;
DEBUGLOG(("UpdateBalance debit balance = [%f]\n", (-1) * hv_balance));
	}
	ind_balance = 0;

	hv_create_user.len = strlen(csUpdateUser);
	strncpy((char*)hv_create_user.arr, csUpdateUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateBalance create_user = [%.*s]\n", hv_create_user.len, hv_create_user.arr));

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_ol_baid_bal_update(
								:hv_baid:ind_baid,
								:hv_country_id:ind_country_id,
								:hv_ccy_id:ind_ccy_id,
								:hv_balance:ind_balance,
								:hv_create_user:ind_create_user);
		END;
	END-EXEC;

DEBUGLOG(("UpdateBalance Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK) {
DEBUGLOG(("UpdateBalance Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
ERRLOG("OLBAIDBal_UpdateBalance: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateBalance: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
ERRLOG("OLBAIDBal_UpdateBalance: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateBalance: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBAIDBal_UpdateBalance: SP_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}


int UpdateHoldBalance(const char* csBAID,
		const char* csCountryId,
		const char* csCcy,
		char cType,
		double dAmt,
		char* csUpdateUser)
{
	EXEC SQL WHENEVER SQLERROR GOTO hold_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_baid[PD_BAID_LEN];
		varchar hv_country_id[PD_COUNTRY_LEN];
		varchar hv_ccy_id[PD_CCY_ID_LEN];
		double hv_hold;
		varchar hv_create_user[PD_USER_LEN];

		short ind_baid = -1;
		short ind_country_id = -1;
		short ind_ccy_id = -1;
		short ind_hold = -1;
		short ind_create_user = -1;

		short hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateHoldBalance: Begin\n"));

	hv_baid.len = strlen(csBAID);
	strncpy((char*)hv_baid.arr, csBAID, hv_baid.len);
	ind_baid = 0;
DEBUGLOG(("UpdateHoldBalance baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy((char*)hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateHoldBalance country_id = [%.*s]\n", hv_country_id.len, hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy((char*)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateHoldBalance ccy_id = [%.*s]\n", hv_ccy_id.len, hv_ccy_id.arr));

	hv_hold = dAmt;
	ind_hold = 0;
DEBUGLOG(("UpdateHoldBalance hold = [%f]\n", hv_hold));

	hv_create_user.len = strlen(csUpdateUser);
	strncpy((char*)hv_create_user.arr, csUpdateUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateHoldBalance create_user = [%.*s]\n", hv_create_user.len, hv_create_user.arr));

	if (cType == PD_HOLD) {
		EXEC SQL EXECUTE
			BEGIN
				:hv_return_value := sp_ol_baid_bal_credit_hold(
									:hv_baid:ind_baid,
									:hv_country_id:ind_country_id,
									:hv_ccy_id:ind_ccy_id,
									:hv_hold:ind_hold,
									:hv_create_user:ind_create_user);
			END;
		END-EXEC;
	} else {
		EXEC SQL EXECUTE
			BEGIN
				:hv_return_value := sp_ol_baid_bal_debit_hold(
									:hv_baid:ind_baid,
									:hv_country_id:ind_country_id,
									:hv_ccy_id:ind_ccy_id,
									:hv_hold:ind_hold,
									:hv_create_user:ind_create_user);
			END;
		END-EXEC;
	}

DEBUGLOG(("UpdateHoldBalance Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK) {
DEBUGLOG(("UpdateHoldBalance Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
ERRLOG("OLBAIDBal_UpdateHoldBalance: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateHoldBalance: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("OLBAIDBal_UpdateHoldBalance: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateHoldBalance: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

hold_error:
DEBUGLOG(("hold_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBAIDBal_UpdateHoldBalance: SP_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}


int GetBalance(const char* csBAID,
		const char* csCountryId,
		const char* csCurrencyId,
		hash_t *hVal)
{
	int iRet = PD_OK;

	EXEC SQL WHENEVER SQLERROR GOTO get_bal_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_baid[PD_BAID_LEN];
		varchar hv_country_id[PD_COUNTRY_LEN];
		varchar hv_ccy_id[PD_CCY_ID_LEN];
		double v_balance;
		double v_prepaid;
		double v_in_transit;
		double v_total_hold;

		short ind_balance = -1;
		short ind_prepaid = -1;
		short ind_in_transit = -1;
		short ind_total_hold = -1;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen(csBAID);
	memcpy(hv_baid.arr, csBAID, hv_baid.len);
DEBUGLOG(("GetBalance baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	hv_country_id.len = strlen(csCountryId);
	memcpy(hv_country_id.arr, csCountryId, hv_country_id.len);
DEBUGLOG(("GetBalance country_id = [%.*s]\n", hv_country_id.len, hv_country_id.arr));

	hv_ccy_id.len = strlen(csCurrencyId);
	memcpy(hv_ccy_id.arr, csCurrencyId, hv_ccy_id.len);
DEBUGLOG(("GetBalance ccy_id = [%.*s]\n", hv_ccy_id.len, hv_ccy_id.arr));

	EXEC SQL select	obab_bal,
			obab_prepaid,
			obab_in_transit,
			obab_total_hold
		into :v_balance:ind_balance,
			:v_prepaid:ind_prepaid,
			:v_in_transit:ind_in_transit,
			:v_total_hold:ind_total_hold
		from ol_baid_bal
		where obab_baid = :hv_baid
		and obab_country_id = :hv_country_id
		and obab_currency_id = :hv_ccy_id;

	// balance
	if (ind_balance < 0)
		v_balance = 0;
	PutField_Double(hVal, "balance", v_balance);
DEBUGLOG(("GetBalance balance = [%f]\n", v_balance));

	// prepaid
	if (ind_prepaid < 0)
		v_prepaid = 0;
	PutField_Double(hVal, "prepaid", v_prepaid);
DEBUGLOG(("GetBalance prepaid = [%f]\n", v_prepaid));

	// in_transit
	if (ind_in_transit < 0)
		v_in_transit = 0;
	PutField_Double(hVal, "in_transit", v_in_transit);
DEBUGLOG(("GetBalance in_transit = [%f]\n", v_in_transit));

	// total_hold
	if (ind_total_hold < 0)
		v_total_hold = 0;
	PutField_Double(hVal, "total_hold", v_total_hold);
DEBUGLOG(("GetBalance total_hold = [%f]\n", v_total_hold));

DEBUGLOG(("GetBalance Normal Exit\n"));
	return iRet;

get_bal_error:
DEBUGLOG(("get_bal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBAIDBal_Get: SP_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetBalanceForUpdate(const char* csBAID,
		const char* csCountryId,
		const char* csCurrencyId,
                hash_t *hVal)
{
	int iRet = PD_OK;

	EXEC SQL WHENEVER SQLERROR GOTO get_bal_update_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_baid[PD_BAID_LEN];
		varchar hv_country_id[PD_COUNTRY_LEN];
		varchar hv_ccy_id[PD_CCY_ID_LEN];
		double v_balance;
		double v_prepaid;
		double v_in_transit;
		double v_total_hold;
		
		short ind_balance = -1;
		short ind_prepaid = -1;
		short ind_in_transit = -1;
		short ind_total_hold = -1;
        EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen(csBAID);
	memcpy(hv_baid.arr, csBAID, hv_baid.len);
DEBUGLOG(("GetBalanceForUpdate baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	hv_country_id.len = strlen(csCountryId);
	memcpy(hv_country_id.arr, csCountryId, hv_country_id.len);
DEBUGLOG(("GetBalanceForUpdate country_id = [%.*s]\n", hv_country_id.len, hv_country_id.arr));

	hv_ccy_id.len = strlen(csCurrencyId);
	memcpy(hv_ccy_id.arr, csCurrencyId, hv_ccy_id.len);
DEBUGLOG(("GetBalanceForUpdate ccy_id = [%.*s]\n", hv_ccy_id.len, hv_ccy_id.arr));

	EXEC SQL select obab_bal,
			obab_prepaid,
			obab_in_transit,
			obab_total_hold
		into :v_balance:ind_balance,
			:v_prepaid:ind_prepaid,
			:v_in_transit:ind_in_transit,
			:v_total_hold:ind_total_hold
		from ol_baid_bal
		where obab_baid = :hv_baid
		and obab_country_id = :hv_country_id
		and obab_currency_id = :hv_ccy_id
		for update;

	// balance
	if (ind_balance < 0)
		v_balance = 0;
	PutField_Double(hVal, "balance", v_balance);
DEBUGLOG(("GetBalanceForUpdate balance = [%f]\n", v_balance));

	// prepaid
	if (ind_prepaid < 0)
		v_prepaid = 0;
	PutField_Double(hVal, "prepaid", v_prepaid);
DEBUGLOG(("GetBalanceForUpdate prepaid = [%f]\n", v_prepaid));

	// in_transit
	if (ind_in_transit < 0)
		v_in_transit = 0;
	PutField_Double(hVal, "in_transit", v_in_transit);
DEBUGLOG(("GetBalanceForUpdate in_transit = [%f]\n", v_in_transit));

	// totol_hold
	if (ind_total_hold < 0)
		v_total_hold = 0;
        PutField_Double(hVal, "total_hold", v_total_hold);
DEBUGLOG(("GetBalanceForUpdate total_hold = [%f]\n", v_total_hold));

DEBUGLOG(("GetBalanceForUpdate Normal Exit\n"));
	return iRet;

get_bal_update_error:
DEBUGLOG(("get_bal_update error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBAIDBal_Get: SP_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int GetAvalBaidBal(const char *csBaid,
		const char *csCurrencyId,
		const char *csCountryId,
		double *dBal)
{
	*dBal = 0.0;
	int iRet = PD_OK;

	EXEC sQL WHENEVER SQLERROR GOTO getavalbaidbal_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_baid[PD_BAID_LEN];
		varchar hv_ccy_id[PD_CCY_ID_LEN];
		varchar hv_country_id[PD_COUNTRY_LEN];

		double v_current_bal;
		double v_in_transit;
		double v_total_hold;

		short ind_current_bal = -1;
		short ind_in_transit = -1;
		short ind_total_hold = -1;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("GetAvalBaidBal csBaid = [%s]\n", csBaid));
DEBUGLOG(("GetAvalBaidBal csCurrencyId = [%s]\n", csCurrencyId));
DEBUGLOG(("GetAvalBaidBal csCountryId = [%s]\n", csCountryId));

	hv_baid.len = strlen(csBaid);
	memcpy(hv_baid.arr, csBaid, hv_baid.len);
DEBUGLOG(("GetAvalBaidBal baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	hv_ccy_id.len = strlen(csCurrencyId);
	memcpy(hv_ccy_id.arr, csCurrencyId, hv_ccy_id.len);
DEBUGLOG(("GetAvalPidBal ccy_id = [%.*s]\n", hv_ccy_id.len, hv_ccy_id.arr));

	hv_country_id.len = strlen(csCountryId);
	memcpy(hv_country_id.arr, csCountryId, hv_country_id.len);
DEBUGLOG(("GetAvalPidBal country_id = [%.*s]\n", hv_country_id.len, hv_country_id.arr));

	EXEC SQL DECLARE c_cursor_getavalbaidbal CURSOR FOR
		select	obab_bal,
			obab_in_transit,
			obab_total_hold
		from	ol_baid_bal
		where	obab_baid = :hv_baid
		and	obab_currency_id = :hv_ccy_id
		and	obab_country_id = :hv_country_id
		for update;

	EXEC SQL OPEN c_cursor_getavalbaidbal;
	do {
		EXEC SQL FETCH c_cursor_getavalbaidbal
		INTO
			:v_current_bal:ind_current_bal,
			:v_in_transit:ind_in_transit,
			:v_total_hold:ind_total_hold;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		// balance
		if ((ind_current_bal < 0) || (ind_in_transit < 0) || (ind_total_hold < 0))
			*dBal = 0.0;
		else {
			*dBal = v_current_bal - v_in_transit - v_total_hold;
DEBUGLOG(("GetAvalBaidBal balance = [%f]\n", *dBal));
		}
	}
	while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getavalbaidbal;

DEBUGLOG(("GetAvalBaidBal Normal Exit\n"));
	return iRet;

getavalbaidbal_error:
DEBUGLOG(("getavalbaidbal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getavalbaidbal;
	return PD_ERR;
}


int UpdatePrepaid(const char* csBAID,
		const char* csCountryId,
		const char* csCcy,
		char cType,
		double dAmt,
		char* csUpdateUser)
{
	EXEC SQL WHENEVER SQLERROR GOTO prepaid_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_baid[PD_BAID_LEN];
		varchar hv_country_id[PD_COUNTRY_LEN];
		varchar hv_ccy_id[PD_CCY_ID_LEN];
		double hv_prepaid;
		varchar hv_create_user[PD_USER_LEN];

		short ind_baid = -1;
		short ind_country_id = -1;
		short ind_ccy_id = -1;
		short ind_prepaid = -1;
		short ind_create_user = -1;

		short hv_return_value;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen(csBAID);
	strncpy((char*)hv_baid.arr, csBAID, hv_baid.len);
	ind_baid = 0;
DEBUGLOG(("UpdatePrepaid baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy((char*)hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdatePrepaid country_id = [%.*s]\n", hv_country_id.len, hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy((char*)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdatePrepaid ccy_id = [%.*s]\n", hv_ccy_id.len, hv_ccy_id.arr));

	if (cType == PD_IND_CREDIT) {
		hv_prepaid = dAmt;
DEBUGLOG(("UpdatePrepaid credit prepaid = [%f]\n", hv_prepaid));
	} else {
		hv_prepaid = (-1) * dAmt;
DEBUGLOG(("UpdatePrepaid debit prepaid = [%f]\n", (-1) * hv_prepaid));
	}
	ind_prepaid = 0;

	hv_create_user.len = strlen(csUpdateUser);
	strncpy((char*)hv_create_user.arr, csUpdateUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdatePrepaid create_user = [%.*s]\n", hv_create_user.len, hv_create_user.arr));

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_ol_baid_bal_prepaid_update(
								:hv_baid:ind_baid,
								:hv_country_id:ind_country_id,
								:hv_ccy_id:ind_ccy_id,
								:hv_prepaid:ind_prepaid,
								:hv_create_user:ind_create_user);
		END;
	END-EXEC;

DEBUGLOG(("UpdatePrepaid Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK) {
DEBUGLOG(("UpdatePrepaid Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
ERRLOG("OLBAIDBal_UpdatePrepaid: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdatePrepaid: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
ERRLOG("OLBAIDBal_UpdatePrepaid: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdatePrepaid: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

prepaid_error:
DEBUGLOG(("prepaid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBAIDBal_UpdatePrepaid: SP_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}


int UpdateInTransit(const char* csBAID,
		const char* csCountryId,
		const char* csCcy,
		char cType,
		double dAmt,
		char* csUpdateUser)
{
	EXEC SQL WHENEVER SQLERROR GOTO in_transit_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_baid[PD_BAID_LEN];
		varchar hv_country_id[PD_COUNTRY_LEN];
		varchar hv_ccy_id[PD_CCY_ID_LEN];
		double hv_in_transit;
		varchar hv_create_user[PD_USER_LEN];

		short ind_baid = -1;
		short ind_country_id = -1;
		short ind_ccy_id = -1;
		short ind_in_transit = -1;
		short ind_create_user = -1;

		short hv_return_value;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen(csBAID);
	strncpy((char*)hv_baid.arr, csBAID, hv_baid.len);
	ind_baid = 0;
DEBUGLOG(("UpdateInTransit baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	hv_country_id.len = strlen(csCountryId);
	strncpy((char*)hv_country_id.arr, csCountryId, hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("UpdateInTransit country_id = [%.*s]\n", hv_country_id.len, hv_country_id.arr));

	hv_ccy_id.len = strlen(csCcy);
	strncpy((char*)hv_ccy_id.arr, csCcy, hv_ccy_id.len);
	ind_ccy_id = 0;
DEBUGLOG(("UpdateInTransit ccy_id = [%.*s]\n", hv_ccy_id.len, hv_ccy_id.arr));

	if (cType == PD_IND_CREDIT) {
		hv_in_transit = dAmt;
DEBUGLOG(("UpdateInTransit credit in_transit = [%f]\n", hv_in_transit));
	} else {
		hv_in_transit = (-1) * dAmt;
DEBUGLOG(("UpdateInTransit debit in_transit = [%f]\n", (-1) * hv_in_transit));
	}
	ind_in_transit = 0;

	hv_create_user.len = strlen(csUpdateUser);
	strncpy((char*)hv_create_user.arr, csUpdateUser, hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("UpdateInTransit create_user = [%.*s]\n", hv_create_user.len, hv_create_user.arr));

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_ol_baid_bal_in_tran_update(
								:hv_baid:ind_baid,
								:hv_country_id:ind_country_id,
								:hv_ccy_id:ind_ccy_id,
								:hv_in_transit:ind_in_transit,
								:hv_create_user:ind_create_user);
		END;
	END-EXEC;

DEBUGLOG(("UpdateInTransit Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK) {
DEBUGLOG(("UpdateInTransit Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
ERRLOG("OLBAIDBal_UpdateInTransit: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateInTransit: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
ERRLOG("OLBAIDBal_UpdateInTransit: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateInTransit: SP_ERR TxnAbort\n"));
		TxnAbort();
		return PD_ERR;
	}

in_transit_error:
DEBUGLOG(("in_transit_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBAIDBal_UpdateInTransit: SP_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_ERR;
}

