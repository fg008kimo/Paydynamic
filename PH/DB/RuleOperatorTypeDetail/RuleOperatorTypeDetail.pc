/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/08/30              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "RuleOperatorTypeDetail.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void RuleOperatorTypeDetail(char    cdebug)
{
        cDebug = cdebug;
}


int GetRuleOperatorTypeDetail(const char* csOprType,
				recordset_t* myRec)
{
	hash_t *myHash;
	int	iCnt = 0;

        EXEC SQL WHENEVER SQLERROR GOTO getdetail_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_operator_type[PD_OPERATOR_TYPE_LEN];
                int             hv_disabled;

                varchar         v_remark[PD_REMARK_LEN+1];
		int             v_tier_id;
                double          v_amt_pct;
                double          v_amt_min;
                double          v_amt_max;

		short		ind_remark = -1;
		short           ind_tier_id = -1;
                short           ind_amt_pct = -1;
                short           ind_amt_min = -1;
		short		ind_amt_max = -1;

        EXEC SQL END DECLARE SECTION;

        hv_operator_type.len = strlen(csOprType);
        memcpy(hv_operator_type.arr,csOprType,hv_operator_type.len);
DEBUGLOG(("GetRuleOperatorTypeDetail operator_type = [%s]\n",hv_operator_type.arr));

	hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getdetail CURSOR FOR
                select rod_remark,
		       rod_tier_id,
                       rod_amt_pct,
                       rod_amt_min,
		       rod_amt_max
                  from rule_operator_type_detail,
		       rule_operator_type
                 where rod_type = :hv_operator_type
		 and   rot_type = rod_type
		 and   rod_disabled = :hv_disabled
		 and   rot_disabled = :hv_disabled;

        EXEC SQL OPEN c_cursor_getdetail;
        do {
                EXEC SQL FETCH c_cursor_getdetail
                INTO
			:v_remark:ind_remark,
			:v_tier_id:ind_tier_id,
                        :v_amt_pct:ind_amt_pct,
                        :v_amt_min:ind_amt_min,
			:v_amt_max:ind_amt_max;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("GetRuleOperatorTypeDetail found record\n"));
		iCnt ++;

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

/* remark */
                if (ind_remark >= 0) {
                        v_remark.arr[v_remark.len] = '\0';
                        PutField_CString(myHash,"remark",(const char*)v_remark.arr);
DEBUGLOG(("GetRuleOperatorTypeDetail remark = [%s]\n",v_remark.arr));
                }


/* tier_id */
                if (ind_tier_id >= 0) {
                        PutField_Int(myHash,"tier_id",v_tier_id);
DEBUGLOG(("GetRuleOperatorTypeDetail tier_id = [%d]\n",v_tier_id));
                }

/* amt_pct */
                if (ind_amt_pct >= 0) {
                        PutField_Double(myHash,"amt_pct",v_amt_pct);
DEBUGLOG(("GetRuleOperatorTypeDetail amt_pct = [%f]\n",v_amt_pct));
                }
/* amt_min */
                if (ind_amt_min >= 0) {
                        PutField_Double(myHash,"amt_min",v_amt_min);
DEBUGLOG(("GetRuleOperatorTypeDetail amt_min = [%f]\n",v_amt_min));
                }

/* amt_max */
                if (ind_amt_max >= 0) {
                        PutField_Double(myHash,"amt_max",v_amt_max);
DEBUGLOG(("GetRuleOperatorTypeDetail amt_max = [%f]\n",v_amt_max));
                }

		RecordSet_Add(myRec,myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getdetail;

	if(iCnt > 0){
DEBUGLOG(("GetRuleOperatorTypeDetail Normal Exit\n"));
        	return  PD_OK;
	}
	else{
DEBUGLOG(("GetRuleOperatorTypeDetail Normal Exit, Not found\n"));
		return PD_ERR;
	}

getdetail_error:
DEBUGLOG(("getdetail_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("RuleOperatorTypeDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getdetail;
        return PD_ERR;
}
