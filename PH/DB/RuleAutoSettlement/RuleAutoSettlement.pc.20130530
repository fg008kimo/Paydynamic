/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/11/06              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "RuleAutoSettlement.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;
void RuleAutoSettlement(char    cdebug)
{
        cDebug = cdebug;
}

int Add(hash_t *hRls)
{
        char            *csTmp;
        char            cTmp;
        double          dTmp;


        EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_desc[PD_NAME_LEN];
                char            hv_sett_type;
                varchar         hv_create_user[PD_USER_LEN];
                double          hv_sett_value;

                short           ind_desc = -1;
                short           ind_sett_type = -1;
                short           ind_create_user = -1;
                short           ind_sett_value = -1;

                short           hv_return_value;
		int		v_rule_id;

        EXEC SQL END DECLARE SECTION;


DEBUGLOG(("Add: Begin\n"));

        if(GetField_CString(hRls,"desc",&csTmp))
        {
                hv_desc.len = strlen(csTmp);
                strncpy((char *)hv_desc.arr, csTmp, hv_desc.len);
                ind_desc = 0;
DEBUGLOG(("Add:desc = [%.*s]\n",hv_desc.len,hv_desc.arr));
        }

        if (GetField_Char(hRls,"sett_type", &cTmp))
        {
                hv_sett_type = cTmp;
                ind_sett_type = 0;
DEBUGLOG(("Add:sett_type = [%c]\n",hv_sett_type));
        }

        if (GetField_Double(hRls, "sett_value", &dTmp))
        {
                hv_sett_value = dTmp;
                ind_sett_value = 0;
DEBUGLOG(("Add:sett_value = [%lf]\n",hv_sett_value));
        }

        if(GetField_CString(hRls,"create_user",&csTmp))
        {
                hv_create_user.len = strlen(csTmp);
                strncpy((char *)hv_create_user.arr, csTmp, hv_create_user.len);
                ind_create_user = 0;
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));
        }

        EXEC SQL EXECUTE
            BEGIN

                :hv_return_value := sp_rule_auto_sett_insert(
				:hv_sett_type:ind_sett_type,
				:hv_sett_value:ind_sett_value,
				:hv_desc:ind_desc,
				:hv_create_user:ind_create_user,
				:v_rule_id);


            END;
        END-EXEC;


DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
		PutField_Int(hRls, "auto_sett_id", v_rule_id);
DEBUGLOG(("Add:rule_id = [%d]\n", v_rule_id));

DEBUGLOG(("Add:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("RuleAutoSettlement_Add: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("RuleAutoSettlement_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int Update(const hash_t *hRls)
{
        char*     csTmp;
        char*     csBuf;
        char*     csRuleId;
        double  dTmp;
        int     iTmp;
	char	cTmp;

        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar        hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));

        csBuf = (char*) malloc (128);
        csRuleId = (char*) malloc (128);

        strcpy((char*)hv_dynstmt.arr,"update rule_auto_settlement set rs_update_timestamp  = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

/* auto_sett_id */
        if (GetField_Int(hRls, "auto_sett_id", &iTmp)) {
                sprintf(csRuleId, "%d", iTmp);
DEBUGLOG(("Update:auto_sett_id = [%d]\n",iTmp));
        }

/* desc */
        if (GetField_CString(hRls, "desc", &csTmp)) {
DEBUGLOG(("Update:desc = [%s]\n",csTmp));
                strcat((char*)hv_dynstmt.arr, ",rs_desc = '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

/* sett_value*/
        if (GetField_Double(hRls,"sett_value",&dTmp)) {
DEBUGLOG(("Update:sett_value = [%f]\n",dTmp));
                sprintf(csBuf,"%f",dTmp);
                strcat((char*)hv_dynstmt.arr, ",rs_value = ");
                strcat((char*)hv_dynstmt.arr, csBuf);
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

/* sett_type */
        if (GetField_Char(hRls, "sett_type", &cTmp)) {
DEBUGLOG(("Update:sett_type = [%c]\n",cTmp));
                sprintf(csBuf, "%c", cTmp);
                strcat((char*)hv_dynstmt.arr, ", rs_type = '");
                strcat((char*)hv_dynstmt.arr, csBuf);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

/*update_user*/
        if(GetField_CString(hRls,"update_user",&csTmp)){
DEBUGLOG(("Update:update_user = [%s]\n",csTmp));
                strcat((char*)hv_dynstmt.arr, ", rs_update_user= '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

        strcat((char *)hv_dynstmt.arr, " WHERE rs_id = ");
        strcat((char *)hv_dynstmt.arr, csRuleId);
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);
        FREE_ME(csRuleId);

DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("RuleAutoSettlement_Update: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Update: SP_INTERNAL_ERR TxnAbort\n"));
        return PD_INTERNAL_ERR;

}

/*
int GetIdDetail(int iId, recordset_t* myRec)
{
	hash_t *myHash;
	int	iRet = PD_NOT_FOUND;
	EXEC SQL WHENEVER SQLERROR GOTO getiddetail_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;	

	EXEC SQL BEGIN DECLARE SECTION;
		int	hv_id;
		
		char	v_schedule_mode;
		varchar	v_start_datetime[PD_DATETIME_LEN + 1];
		varchar	v_end_datetime[PD_DATETIME_LEN + 1];
		varchar	v_start_time[PD_TIME_LEN +1];
		varchar	v_end_time[PD_TIME_LEN +1];
		int	v_day;

		short	ind_schedule_mode = -1;
		short	ind_start_datetime = -1;
		short	ind_end_datetime = -1;
		short	ind_start_time = -1;
		short	ind_end_time = -1;
		short	ind_day = -1;

		

	EXEC SQL END DECLARE SECTION;

	hv_id = iId;
DEBUGLOG(("GetIdDetail id = [%d]\n",iId));

	EXEC SQL DECLARE c_cursor_getiddetail CURSOR FOR
		 SELECT rs_schedule_mode,
                        ro_start_datetime,
                        ro_end_datetime,
                        rt_start_time,
                        rt_end_time,
                        rt_day
 		  FROM (SELECT *
           		  FROM  rule_scheduler_header 
          		 WHERE rowid = 
           			(SELECT rowid
                    		   FROM rule_scheduler_header
                          	  WHERE rs_disabled = 0
                            	    AND rs_scheduler_id = :hv_id
                          	    AND rs_effect_datetime  <= sysdate) )
                  LEFT join rule_schedule_once
                     ON rs_scheduler_id = ro_scheduler_id
                    AND ro_disabled = 0
                  LEFT join rule_schedule_recur
                     ON rs_scheduler_id = rr_scheduler_id
                    AND rr_disabled = 0
                  LEFT join rule_recur_type
                     ON rr_recurring_id = rt_id
                    AND rt_disabled = 0;

	EXEC SQL OPEN c_cursor_getiddetail;
        do {
		EXEC SQL FETCH c_cursor_getiddetail 
		INTO
			:v_schedule_mode:ind_schedule_mode,
			:v_start_datetime:ind_start_datetime,
			:v_end_datetime:ind_end_datetime,
			:v_start_time:ind_start_time,
			:v_end_time:ind_end_time,
			:v_day:ind_day;


		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		iRet = PD_FOUND;

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

// schedule_mode 
		if (ind_schedule_mode >= 0) {
DEBUGLOG(("GetIdDetail schedule_mode = [%c]\n",v_schedule_mode));
			PutField_Char(myHash,"schedule_mode",v_schedule_mode);
		}		

// start_datetime
		if (ind_start_datetime >= 0) {
			v_start_datetime.arr[v_start_datetime.len] = '\0';
DEBUGLOG(("GetIdDetail start_datetime = [%s]\n",v_start_datetime.arr));
			PutField_CString(myHash,"start_datetime",(char*)v_start_datetime.arr);
		}		
// end_datetime
		if (ind_end_datetime >= 0) {
			v_end_datetime.arr[v_end_datetime.len] = '\0';
DEBUGLOG(("GetIdDetail end_datetime = [%s]\n",v_end_datetime.arr));
			PutField_CString(myHash,"end_datetime",(char*)v_end_datetime.arr);
		}		

// start_time
                if (ind_start_time >= 0) {
                        v_start_time.arr[v_start_time.len] = '\0';
DEBUGLOG(("GetIdDetail start_time = [%s]\n",v_start_time.arr));
                        PutField_CString(myHash,"start_time",(char*)v_start_time.arr);
                }
// end_time
                if (ind_end_time >= 0) {
                        v_end_time.arr[v_end_time.len] = '\0';
DEBUGLOG(("GetIdDetail end_time = [%s]\n",v_end_time.arr));
                        PutField_CString(myHash,"end_time",(char*)v_end_time.arr);
                }
// day
		if (ind_day >= 0) {
DEBUGLOG(("GetIdDetail day = [%d]\n",v_day));
			PutField_Int(myHash,"day",v_day);
		}


		RecordSet_Add(myRec,myHash);

	} 
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getiddetail;
	return PD_FOUND;
getiddetail_error:
DEBUGLOG(("getiddetail code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getiddetail;
        return PD_NOT_FOUND;
}
*/
