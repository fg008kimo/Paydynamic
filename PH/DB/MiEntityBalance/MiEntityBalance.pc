/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/11/02              [MSN]
PRD309 RSP lien function enhancement		   2021/04/13		   [ANC]
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "MiEntityBalance.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


static char cDebug;

void MiEntityBalance(char cdebug)
{
	cDebug = cdebug;
}


int Update(const hash_t *hRec)
{
	char *csTmp;
	double dTmp;
	char cBalType;

	EXEC SQL WHENEVER SQLERROR GOTO update_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_entity_id[PD_MMS_ENTITY_ID_LEN];
		varchar hv_ccy[PD_CCY_ID_LEN];
		varchar hv_country[PD_NATURE_ID_LEN];
		char	hv_bal_type;
		double hv_amount;
		varchar hv_update_user[PD_UPDATE_USER_LEN];

		short ind_entity_id = -1;
		short ind_ccy = -1;
		short ind_country = -1;
		short ind_bal_type = -1;
		short ind_amount = -1;
		short ind_update_user = -1;

		short hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));

	if (GetField_CString(hRec, "entity_id", &csTmp)) {
		hv_entity_id.len = strlen(csTmp);
		strncpy((char *)hv_entity_id.arr, csTmp, hv_entity_id.len);
		ind_entity_id = 0;
DEBUGLOG(("Update: entity_id = [%.*s]\n", hv_entity_id.len, hv_entity_id.arr));
	}


	if (GetField_CString(hRec, "ccy", &csTmp)) {
		hv_ccy.len = strlen(csTmp);
		strncpy((char *)hv_ccy.arr, csTmp, hv_ccy.len);
		ind_ccy = 0;
DEBUGLOG(("Update: ccy = [%.*s]\n", hv_ccy.len, hv_ccy.arr));
	}

	if (GetField_CString(hRec, "country", &csTmp)) {
		hv_country.len = strlen(csTmp);
		strncpy((char *)hv_country.arr, csTmp, hv_country.len);
		ind_country = 0;
DEBUGLOG(("Update: country = [%.*s]\n", hv_country.len, hv_country.arr));
	}

	if(GetField_Char(hRec,"bal_type",&cBalType)){
		hv_bal_type = cBalType;
		ind_bal_type = 0;
DEBUGLOG(("Update: balance_type = [%c]\n", cBalType));
	}

	if (GetField_Double(hRec, "txn_amt", &dTmp)) {
		hv_amount = dTmp;
		ind_amount = 0;
DEBUGLOG(("Update: txn_amt = [%f]\n", hv_amount));
	}

	if (GetField_CString(hRec, "update_user", &csTmp)) {
		hv_update_user.len = strlen(csTmp);
		strncpy((char *)hv_update_user.arr, csTmp, hv_update_user.len);
		ind_update_user = 0;
DEBUGLOG(("Update: update_user = [%.*s]\n", hv_update_user.len, hv_update_user.arr));
	}


	EXEC SQL EXECUTE
		BEGIN
		:hv_return_value := sp_mi_entity_balance_upd_new(
					:hv_entity_id:ind_entity_id,
					:hv_ccy:ind_ccy,
					:hv_country:ind_country,
					:hv_bal_type:ind_bal_type,
					:hv_amount:ind_amount,
					:hv_update_user:ind_update_user);
		END;
	END-EXEC;

DEBUGLOG(("Update: Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK) {
DEBUGLOG(("Update: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
ERRLOG("MiEntityBalance_Update: SP_OTHER_ERR\n");
DEBUGLOG(("Update: SP_OTHER_ERR\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
ERRLOG("MiEntityBalance_Update: SP_ERR\n");
DEBUGLOG(("Update: SP_ERR\n"));
		return PD_ERR;
	}

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MiEntityBalance_Update: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetEntityBalanceForUpdate(const hash_t *hRec, hash_t *myHash)
{
	int iRet = PD_OK;

	char *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO getentitybalance_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_entity_id[PD_MMS_ENTITY_ID_LEN];
		varchar hv_ccy[PD_CCY_ID_LEN];
		varchar	hv_country[PD_COUNTRY_LEN];

		double 	v_acct_bal;
		double 	v_intransit;
		double 	v_ar_bal;
		double 	v_lien_bal;

		short 	ind_acct_bal = -1;
		short 	ind_intransit = -1;
		short 	ind_ar_bal = -1;
		short 	ind_lien_bal = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hRec, "entity_id", &csTmp)) {
		hv_entity_id.len = strlen(csTmp);
		strncpy((char *)hv_entity_id.arr, csTmp, hv_entity_id.len);
DEBUGLOG(("GetEntityBalanceForUpdate: entity_id = [%.*s]\n", hv_entity_id.len, hv_entity_id.arr));
	}

	if (GetField_CString(hRec, "ccy", &csTmp)) {
		hv_ccy.len = strlen(csTmp);
		strncpy((char *)hv_ccy.arr, csTmp, hv_ccy.len);
DEBUGLOG(("GetEntityBalanceForUpdate: ccy = [%.*s]\n", hv_ccy.len, hv_ccy.arr));
	}

	if (GetField_CString(hRec, "country", &csTmp)) {
		hv_country.len = strlen(csTmp);
		strncpy((char *)hv_country.arr, csTmp, hv_country.len);
DEBUGLOG(("GetEntityBalanceForUpdate: country = [%.*s]\n", hv_country.len, hv_country.arr));
	}


	if (iRet == PD_OK) {
		EXEC SQL DECLARE c_getentitybalance CURSOR FOR
			SELECT	eb_acct_bal,
				eb_intransit,
				eb_ar_bal,
				eb_lien_bal
			FROM	mi_entity_balance
			WHERE	eb_entity_id = :hv_entity_id
			  AND	eb_currency = :hv_ccy
			  AND   eb_country = :hv_country
			FOR UPDATE;

		EXEC SQL OPEN c_getentitybalance;
		for (;;) {
			EXEC SQL FETCH c_getentitybalance
			INTO	:v_acct_bal:ind_acct_bal,
				:v_intransit:ind_intransit,
				:v_ar_bal:ind_ar_bal,
				:v_lien_bal:ind_lien_bal;

			if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("GetEntityBalanceForUpdate: SQL_NOT_FOUND for fetch c_getentitybalance\n"));
/* call init if record not found */
				v_acct_bal = 0.0;
				PutField_Double(myHash, "acct_bal", v_acct_bal);
DEBUGLOG(("GetEntityBalanceForUpdate acct_bal = [%f]\n", v_acct_bal));

				v_intransit = 0.0;
				PutField_Double(myHash, "intransit", v_intransit);
DEBUGLOG(("GetEntityBalanceForUpdate intransit = [%f]\n", v_intransit));

				v_ar_bal = 0.0;
				PutField_Double(myHash, "ar_bal", v_ar_bal);
DEBUGLOG(("GetEntityBalanceForUpdate ar_bal = [%f]\n", v_ar_bal));

				v_lien_bal = 0.0;
				PutField_Double(myHash, "lien_bal", v_lien_bal);
DEBUGLOG(("GetEntityBalanceForUpdate lien_bal = [%f]\n", v_lien_bal));

				break;
			}

			if (ind_acct_bal < 0) 
				v_acct_bal = 0.0;
			PutField_Double(myHash, "acct_bal", v_acct_bal);
DEBUGLOG(("GetEntityBalanceForUpdate acct_bal = [%f]\n", v_acct_bal));

			if (ind_intransit  < 0) 
				v_intransit = 0.0;
			PutField_Double(myHash, "intransit", v_intransit);
DEBUGLOG(("GetEntityBalanceForUpdate intransit = [%f]\n", v_intransit));

			if (ind_ar_bal < 0) 
				v_ar_bal = 0.0;
			PutField_Double(myHash, "ar_bal", v_ar_bal);
DEBUGLOG(("GetEntityBalanceForUpdate ar_bal = [%f]\n", v_ar_bal));

			if (ind_lien_bal < 0) 
				v_lien_bal = 0.0;
			PutField_Double(myHash, "lien_bal", v_lien_bal);
DEBUGLOG(("GetEntityBalanceForUpdate lien_bal = [%f]\n", v_lien_bal));

			break; //single record 

		}
		EXEC SQL CLOSE c_getentitybalance;
	}


DEBUGLOG(("GetEntityBalanceForUpdate Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getentitybalance_error:
DEBUGLOG(("getentitybalance_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MiEntityBalance getentitybalance_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE c_getentitybalance;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetEntityBalance(const hash_t *hRec, hash_t *myHash)
{
	int iRet = PD_OK;

	char *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO getcurrbal_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_entity_id[PD_MMS_ENTITY_ID_LEN];
		varchar hv_ccy[PD_CCY_ID_LEN];
		varchar	hv_country[PD_COUNTRY_LEN];

		double 	v_acct_bal;
		double 	v_intransit;
		double 	v_ar_bal;
		double 	v_lien_bal;

		short 	ind_acct_bal = -1;
		short 	ind_intransit = -1;
		short 	ind_ar_bal = -1;
		short 	ind_lien_bal = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hRec, "entity_id", &csTmp)) {
		hv_entity_id.len = strlen(csTmp);
		strncpy((char *)hv_entity_id.arr, csTmp, hv_entity_id.len);
DEBUGLOG(("GetEntityBalance: entity_id = [%.*s]\n", hv_entity_id.len, hv_entity_id.arr));
	}

	if (GetField_CString(hRec, "ccy", &csTmp)) {
		hv_ccy.len = strlen(csTmp);
		strncpy((char *)hv_ccy.arr, csTmp, hv_ccy.len);
DEBUGLOG(("GetEntityBalance: ccy = [%.*s]\n", hv_ccy.len, hv_ccy.arr));
	}

	if (GetField_CString(hRec, "country", &csTmp)) {
		hv_country.len = strlen(csTmp);
		strncpy((char *)hv_country.arr, csTmp, hv_country.len);
DEBUGLOG(("GetEntityBalance: country = [%.*s]\n", hv_country.len, hv_country.arr));
	}


	if (iRet == PD_OK) {
		EXEC SQL DECLARE c_getcurrbal CURSOR FOR
			SELECT	eb_acct_bal,
				eb_intransit,
				eb_ar_bal,
				eb_lien_bal
			FROM	mi_entity_balance
			WHERE	eb_entity_id = :hv_entity_id
			  AND	eb_currency = :hv_ccy
			  AND   eb_country = :hv_country;

		EXEC SQL OPEN c_getcurrbal;
		for (;;) {
			EXEC SQL FETCH c_getcurrbal
			INTO	:v_acct_bal:ind_acct_bal,
				:v_intransit:ind_intransit,
				:v_ar_bal:ind_ar_bal,
				:v_lien_bal:ind_lien_bal;

			if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("GetEntityBalance: SQL_NOT_FOUND for fetch c_getcurrbal\n"));
/* call init if record not found */
				v_acct_bal = 0.0;
				PutField_Double(myHash, "acct_bal", v_acct_bal);
DEBUGLOG(("GetEntityBalance acct_bal = [%f]\n", v_acct_bal));

				v_intransit = 0.0;
				PutField_Double(myHash, "intransit", v_intransit);
DEBUGLOG(("GetEntityBalance intransit = [%f]\n", v_intransit));

				v_ar_bal = 0.0;
				PutField_Double(myHash, "ar_bal", v_ar_bal);
DEBUGLOG(("GetEntityBalance ar_bal = [%f]\n", v_ar_bal));

				v_lien_bal = 0.0;
				PutField_Double(myHash, "lien_bal", v_lien_bal);
DEBUGLOG(("GetEntityBalance lien_bal = [%f]\n", v_lien_bal));

				break;
			}

			if (ind_acct_bal < 0) 
				v_acct_bal = 0.0;
			PutField_Double(myHash, "acct_bal", v_acct_bal);
DEBUGLOG(("GetEntityBalance acct_bal = [%f]\n", v_acct_bal));

			if (ind_intransit  < 0) 
				v_intransit = 0.0;
			PutField_Double(myHash, "intransit", v_intransit);
DEBUGLOG(("GetEntityBalance intransit = [%f]\n", v_intransit));

			if (ind_ar_bal < 0) 
				v_ar_bal = 0.0;
			PutField_Double(myHash, "ar_bal", v_ar_bal);
DEBUGLOG(("GetEntityBalance ar_bal = [%f]\n", v_ar_bal));

			if (ind_lien_bal < 0) 
				v_lien_bal = 0.0;
			PutField_Double(myHash, "lien_bal", v_lien_bal);
DEBUGLOG(("GetEntityBalance lien_bal = [%f]\n", v_lien_bal));

			break; //single record 

		}
		EXEC SQL CLOSE c_getcurrbal;
	}


DEBUGLOG(("GetEntityBalance Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getcurrbal_error:
DEBUGLOG(("getcurrbal_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MiEntityBalance getcurrbal_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE c_getcurrbal;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}
