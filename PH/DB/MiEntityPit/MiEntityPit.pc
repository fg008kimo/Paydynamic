/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version 			                   2015/11/04              Elvis Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MiEntityPit.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MiEntityPit(char    cdebug)
{
        cDebug = cdebug;
}

int GetPITInfoByEntityId(const char* csEntityId,
			 hash_t* hRec)
{
        EXEC SQL WHENEVER SQLERROR GOTO getpitinfo_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_entity_id[PD_PSP_MID_LEN];

                varchar         v_pit_id[PD_MI_PIT_ID_LEN+1];
                varchar         v_name[PD_NAME_LEN+1];
		varchar		v_product_code[PD_PRODUCT_CODE_LEN+1];
		varchar		v_status[PD_ACCOUNT_STATUS_LEN+1];

		short		ind_pit_id = -1;
                short           ind_name = -1;
		short		ind_product_code = -1;
		short		ind_status = -1;

        EXEC SQL END DECLARE SECTION;

// entity_id
        hv_entity_id.len = strlen(csEntityId);
        memcpy(hv_entity_id.arr,csEntityId,hv_entity_id.len);
DEBUGLOG(("GetPITInfoByEntityId entity_id = [%d][%.*s]\n",hv_entity_id.len,hv_entity_id.len,hv_entity_id.arr));

        EXEC SQL DECLARE c_cursor_getpitinfo CURSOR FOR
                select ep_pit_name,
		       ep_pit_id,
		       ep_product_code,
		       ep_pit_status
                  from mi_entity_pit 
                 where ep_entity_id= :hv_entity_id;

        EXEC SQL OPEN c_cursor_getpitinfo;
        do {
                EXEC SQL FETCH c_cursor_getpitinfo
                INTO
                        :v_name:ind_name,
			:v_pit_id:ind_pit_id,
			:v_product_code:ind_product_code,
			:v_status:ind_status;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("GetPITInfoByEntityId found record\n"));

/* name */
                if (ind_name >= 0) {
                        v_name.arr[v_name.len] = '\0';
                        PutField_CString(hRec,"pit_name",(const char*)v_name.arr);
DEBUGLOG(("GetPITInfoByEntityId pit_name = [%s]\n",v_name.arr));
                }


/* pit_id */
		if (ind_pit_id >= 0) {
                        v_pit_id.arr[v_pit_id.len] = '\0';
                        PutField_CString(hRec,"pit_id",(const char*)v_pit_id.arr);
DEBUGLOG(("GetPITInfoByEntityId pit_id = [%s]\n",v_pit_id.arr));
                }

/* status */
                if (ind_status >= 0) {
                        v_status.arr[v_status.len] = '\0';
                        PutField_CString(hRec,"status",(const char*)v_status.arr);
DEBUGLOG(("GetPITInfoByEntityId status = [%s]\n",v_status.arr));
                }

/* product_code */
                if (ind_product_code >= 0) {
                        v_product_code.arr[v_product_code.len] = '\0';
                        PutField_CString(hRec,"product_code",(const char*)v_product_code.arr);
DEBUGLOG(("GetPITInfoByEntityId product_code = [%s]\n",v_product_code.arr));
                }
		
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getpitinfo;


DEBUGLOG(("GetPITInfoByEntityId Normal Exit\n"));
        return  PD_OK;

getpitinfo_error:
DEBUGLOG(("getpitinfo_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MiEntityPit_Get: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getpitinfo;
        return PD_ERR;
}

int GetPITAcctInfoByEntityId(const char* csEntityId,
			     recordset_t* myRec)
{
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getpitacctinfo_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_entity_id[PD_PSP_MID_LEN];

                varchar         v_pit_id[PD_MI_PIT_ID_LEN+1];
                varchar         v_name[PD_NAME_LEN+1];
		varchar		v_product_code[PD_PRODUCT_CODE_LEN+1];
		varchar		v_status[PD_ACCOUNT_STATUS_LEN+1];
		varchar		v_bal_status[PD_ACCOUNT_STATUS_LEN+1];
		varchar		v_ccy[PD_CCY_ID_LEN +1];

                short           ind_pit_id = -1;
                short           ind_name = -1;
		short		ind_product_code = -1;
		short		ind_status = -1;
		short		ind_bal_status= -1;
		short		ind_ccy = -1;

        EXEC SQL END DECLARE SECTION;

// entity_id
        hv_entity_id.len = strlen(csEntityId);
        memcpy(hv_entity_id.arr,csEntityId,hv_entity_id.len);
DEBUGLOG(("GetPITAcctInfoByEntityId entity_id = [%d][%.*s]\n",hv_entity_id.len,hv_entity_id.len,hv_entity_id.arr));

        EXEC SQL DECLARE c_cursor_getpitacctinfo CURSOR FOR
                select ep_pit_id,
		       ep_pit_name,
		       ep_product_code,
		       ep_pit_status,
		       ba_status,
		       ba_currency
                  from mi_entity_pit, mi_entity_bal_acct
                 where ep_entity_id = :hv_entity_id
		 and   ep_entity_id = ba_entity_id;

        EXEC SQL OPEN c_cursor_getpitacctinfo;
        do {
                EXEC SQL FETCH c_cursor_getpitacctinfo
                INTO
                        :v_pit_id:ind_pit_id,
                        :v_name:ind_name,
			:v_product_code:ind_product_code,
			:v_status:ind_status,
			:v_bal_status:ind_bal_status,
			:v_ccy:ind_ccy;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("GetPITAcctInfoByEntityId found record\n"));

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash, 0);

/* pit_id */
		if (ind_pit_id >= 0) {
                        v_pit_id.arr[v_pit_id.len] = '\0';
                        PutField_CString(myHash,"pit_id",(const char*)v_pit_id.arr);
DEBUGLOG(("GetPITAcctInfoByEntityId pit_id = [%s]\n",v_pit_id.arr));
                }

/* name */
                if (ind_name >= 0) {
                        v_name.arr[v_name.len] = '\0';
                        PutField_CString(myHash,"pit_name",(const char*)v_name.arr);
DEBUGLOG(("GetPITAcctInfoByEntityId pit_name = [%s]\n",v_name.arr));
                }

/* ccy */
                if (ind_ccy>= 0) {
                        v_ccy.arr[v_ccy.len] = '\0';
                        PutField_CString(myHash,"ccy",(const char*)v_ccy.arr);
DEBUGLOG(("GetPITAcctInfoByEntityId ccy = [%s]\n",v_ccy.arr));
                }

/* status */
                if (ind_status >= 0) {
                        v_status.arr[v_status.len] = '\0';
                        PutField_CString(myHash,"status",(const char*)v_status.arr);
DEBUGLOG(("GetPITAcctInfoByEntityId status = [%s]\n",v_status.arr));
                }

/* bal_status */
                if (ind_bal_status >= 0) {
                        v_bal_status.arr[v_bal_status.len] = '\0';
                        PutField_CString(myHash,"bal_status",(const char*)v_bal_status.arr);
DEBUGLOG(("GetPITAcctInfoByEntityId balance status = [%s]\n",v_bal_status.arr));
                }

/* product_code */
                if (ind_product_code >= 0) {
                        v_product_code.arr[v_product_code.len] = '\0';
                        PutField_CString(myHash,"product_code",(const char*)v_product_code.arr);
DEBUGLOG(("GetPITAcctInfoByEntityId product_code = [%s]\n",v_product_code.arr));
                }

                RecordSet_Add(myRec, myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getpitacctinfo;


DEBUGLOG(("GetPITAcctInfoByEntityId Normal Exit\n"));
        return  PD_OK;

getpitacctinfo_error:
DEBUGLOG(("getpitacctinfo_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MiEntityPit_Get: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getpitacctinfo;
        return PD_ERR;
}
