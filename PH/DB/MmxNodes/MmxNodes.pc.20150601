/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/10/10              Virginia Yun
Add GetServerNode				   2012/02/20		   Virginia Yun
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MmxNodes.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MmxNodes(char    cdebug)
{
        cDebug = cdebug;
}

int Find(const unsigned char *csNodeId,
         char *cNodeType)
{
        int iRet = PD_NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO getnodetype_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_node_id[PD_MMS_NODE_ID_LEN];
                int             hv_disabled;

                char            v_node_type;
                short           ind_node_type = -1;

        EXEC SQL END DECLARE SECTION;

        hv_node_id.len = strlen((const char*)csNodeId);
        memcpy(hv_node_id.arr, csNodeId, hv_node_id.len);

DEBUGLOG(("Find node_id = [%d][%.*s]\n",hv_node_id.len,hv_node_id.len,hv_node_id.arr));
        hv_disabled = 0;


        EXEC SQL DECLARE c_cursor_getnodetype CURSOR FOR
                SELECT mn_node_type
                  FROM mmx_nodes
                 WHERE mn_node_id = :hv_node_id
                   AND mn_disabled = :hv_disabled;

        EXEC SQL OPEN c_cursor_getnodetype;
        do{
                EXEC SQL FETCH c_cursor_getnodetype
                INTO
                        :v_node_type:ind_node_type; 

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                } 

                iRet = PD_OK;

                if (ind_node_type >= 0) {
                        cNodeType[0] = v_node_type;
DEBUGLOG(("Find node_type = [%c]\n",*cNodeType));
                } 

        }while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getnodetype;

DEBUGLOG(("Find Normal Exit\n"));
     
        return iRet;


getnodetype_error:
DEBUGLOG(("getnodetype_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));

        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getnodetype;

        return PD_ERR;

}



int GetAllNodesByType(const char cNodeType,
		   recordset_t* myRec)
{
	int iRet = PD_NOT_FOUND;

	hash_t *myHash;
	int     iCnt = 0;

	EXEC SQL WHENEVER SQLERROR GOTO getallnodes_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		char	hv_node_type;
		varchar	v_node_id[PD_MMS_NODE_ID_LEN+1];
		varchar	v_mms_key[PD_MMS_KEY_LEN+1];
		
		short	ind_node_id = -1;
		short	ind_mms_key = -1;

	EXEC SQL END DECLARE SECTION;

	hv_node_type = cNodeType;
DEBUGLOG(("GetAllNodesByType node_type = [%c]\n",hv_node_type));

	EXEC SQL DECLARE c_cursor_getallnodes CURSOR FOR
		select	mn_node_id,
			mk_key
		from	mmx_nodes,
			mms_keys
		where	mn_node_type = :hv_node_type
		and	mn_node_id = mk_node_id
		and	mn_disabled = 0
		and	mk_disabled = 0
		order by mn_node_id;

	EXEC SQL OPEN c_cursor_getallnodes;
        do {
                EXEC SQL FETCH c_cursor_getallnodes
                INTO
			:v_node_id:ind_node_id,
			:v_mms_key:ind_mms_key;
		
		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                iCnt++;

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

		if (ind_node_id >= 0) {
                        v_node_id.arr[v_node_id.len] ='\0';
                        PutField_CString(myHash,"node_id",(const char*)v_node_id.arr);
DEBUGLOG(("GetAllNodesByType node_id = [%s]\n",v_node_id.arr));
                }

		if (ind_mms_key >= 0) {
                        v_mms_key.arr[v_mms_key.len] ='\0';
                        PutField_CString(myHash,"mms_key",(const char*)v_mms_key.arr);
DEBUGLOG(("GetAllNodesByType mms_key = [%s]\n",v_mms_key.arr));
                }

		RecordSet_Add(myRec,myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getallnodes;

	if (iCnt > 0 ) {
DEBUGLOG(("GetAllNodesByType Normal Exit\n"));
                return  PD_FOUND;
        }
        else {
DEBUGLOG(("GetAllNodesByType Normal Exit, Not Found\n"));
                return PD_NOT_FOUND;
        }

	return iRet;

getallnodes_error:
DEBUGLOG(("getallnodes_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getallnodes;

        return PD_ERR;
}



int GetServerNode(char *csNodeId)
{
        EXEC SQL WHENEVER SQLERROR GOTO getservernode_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                char    hv_node_type;

                varchar v_node_id[PD_MMS_NODE_ID_LEN+1];

                short   ind_node_id = -1;

        EXEC SQL END DECLARE SECTION;

        hv_node_type = PD_MMS_SERVER;
DEBUGLOG(("GetServerNode node_type = [%c]\n",hv_node_type));

	EXEC SQL select mn_node_id
		 into   :v_node_id:ind_node_id
		 from   mmx_nodes
		 where  mn_node_type = :hv_node_type
		 and    mn_disabled = 0;

	if (ind_node_id >= 0) {
		v_node_id.arr[v_node_id.len] = '\0';
		strcpy((char*) csNodeId, (char *)v_node_id.arr);
DEBUGLOG(("GetServerNode node_id = [%s]\n",csNodeId));
		return PD_FOUND;
	}
DEBUGLOG(("GetServerNode not found\n"));

	return PD_NOT_FOUND;

getservernode_error:
DEBUGLOG(("getservernode_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;

        return PD_ERR;
}
