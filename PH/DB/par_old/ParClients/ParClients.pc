/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/05/25              Virginia Yun
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "ParClients.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void ParClients(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hParClients)
{
	char            *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_company[PD_COMPANY_LEN];
		varchar		hv_client_id[PD_CLIENT_ID_LEN];
		varchar		hv_client_group[PD_DEF_CLIENT_GROUP_LEN];
		varchar		hv_create_user[PD_USER_LEN];
	
		short		ind_company = -1;
		short		ind_client_id = -1;
		short		ind_client_group = -1;
		short		ind_create_user = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Add: Begin\n"));

	if(GetField_CString(hParClients,"company",&csTmp))
	{
		hv_company.len = strlen(csTmp);
		strncpy((char *)hv_company.arr, csTmp, hv_company.len);
		ind_company = 0;
DEBUGLOG(("Add:company = [%.*s]\n",hv_company.len,hv_company.arr));
	}


	if(GetField_CString(hParClients,"client_id",&csTmp))
	{
		hv_client_id.len = strlen(csTmp);
		strncpy((char *)hv_client_id.arr, csTmp, hv_client_id.len);
		ind_client_id = 0;
DEBUGLOG(("Add:client = [%.*s]\n",hv_client_id.len,hv_client_id.arr));
	}

	if (GetField_CString(hParClients,"client_group", &csTmp))
	{
		hv_client_group.len = strlen(csTmp);
		strncpy((char *)hv_client_group.arr, csTmp, hv_client_group.len);
		ind_client_group = 0;
DEBUGLOG(("Add:client_group = [%.*s]\n",hv_client_group.len,hv_client_group.arr));

	}

	if(GetField_CString(hParClients,"create_user",&csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char *)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_par_clients_insert(
				:hv_company:ind_company,
				:hv_client_id:ind_client_id,
				:hv_client_group:ind_client_group,
				:hv_create_user:ind_create_user);
	    END;
	END-EXEC;


	DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("ParClients_Add: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("ParClients_Add: SP_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

add_error:
	DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;


}



int GetClientIDByCompanyName(const char* csCompanyName,
                recordset_t* myRec)
{
	int iRet = PD_OK;
                
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getclientid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_company_name[PD_COMPANY_LEN];

		varchar		v_client_id[PD_CLIENT_ID_LEN + 1];

		short		ind_client_id = -1;
        
        EXEC SQL END DECLARE SECTION;

	hv_company_name.len = strlen(csCompanyName);
        memcpy(hv_company_name.arr,csCompanyName,hv_company_name.len);
DEBUGLOG(("GetClientID company_name = [%.*s]\n",hv_company_name.len,hv_company_name.arr));

        EXEC SQL DECLARE c_cursor_getclientid CURSOR FOR
		select	pc_client_id
                  from par_clients
		 where pc_company_name = :hv_company_name; 

        EXEC SQL OPEN c_cursor_getclientid;
        do {
                EXEC SQL FETCH c_cursor_getclientid
                INTO
			:v_client_id:ind_client_id;

                if (SQLCODE == SQL_NOT_FOUND) {
			iRet = SQL_NOT_FOUND;
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

// client_id
                if (ind_client_id >= 0) {
                        v_client_id.arr[v_client_id.len] = '\0';
                        PutField_CString(myHash,"client_id",(const char*)v_client_id.arr);
DEBUGLOG(("GetClientID client_id = [%s]\n",v_client_id.arr));
                }

                RecordSet_Add(myRec,myHash);
		break; //**************** only one now
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getclientid;

	
DEBUGLOG(("GetClientID Normal Exit\n"));
        if(iRet==0) return  PD_OK;
	else	return iRet;

getclientid_error: 
DEBUGLOG(("getclientid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getclientid;
        return PD_ERR;
}

int GetClientIDByClientGroup(const char* csClientGroup,
                recordset_t* myRec)
{
        int iRet = PD_OK;
    
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getclientid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
    
        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_client_group[PD_DEF_CLIENT_GROUP_LEN];

                varchar         v_client_id[PD_CLIENT_ID_LEN + 1];

                short           ind_client_id = -1;

        EXEC SQL END DECLARE SECTION;

        hv_client_group.len = strlen(csClientGroup);
        memcpy(hv_client_group.arr,csClientGroup,hv_client_group.len);
DEBUGLOG(("GetClientIDByClientGroup clinet_group = [%.*s]\n",hv_client_group.len,hv_client_group.arr));

        EXEC SQL DECLARE c_cursor_getclientidbygroup CURSOR FOR
                select  pc_client_id
                  from par_clients
                 where pc_def_client_group = :hv_client_group;

        EXEC SQL OPEN c_cursor_getclientidbygroup;
        do {
                EXEC SQL FETCH c_cursor_getclientidbygroup
                INTO
                        :v_client_id:ind_client_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        iRet = SQL_NOT_FOUND;
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

// client_id
                if (ind_client_id >= 0) {
                        v_client_id.arr[v_client_id.len] = '\0';
                        PutField_CString(myHash,"client_id",(const char*)v_client_id.arr);
DEBUGLOG(("GetClientIDByClientGroup client_id = [%s]\n",v_client_id.arr));
                }

                RecordSet_Add(myRec,myHash);
                break; //**************** only one now
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getclientidbygroup;


DEBUGLOG(("GetClientIDByClientGroup Normal Exit\n"));
        if(iRet==0) return  PD_OK;
        else    return iRet;

getclientid_error:
DEBUGLOG(("getclientid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getclientidbygroup;
        return PD_ERR;
}

    


int GenClientID (char	*csClientPrefix, char csClientType,  char *csClientID)
{
        EXEC SQL WHENEVER SQLERROR GOTO gen_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_client_prefix[PD_CLIENT_ID_LEN];
                char    hv_client_type;

                varchar v_client_id[PD_CLIENT_ID_LEN + 1];
                short   ind_client_id = -1;

	EXEC SQL END DECLARE SECTION;

	hv_client_prefix.len = strlen(csClientPrefix);
	memcpy(hv_client_prefix.arr, csClientPrefix, hv_client_prefix.len);
DEBUGLOG(("GenClientID client_prefix = [%d][%.*s]\n",hv_client_prefix.len, hv_client_prefix.len, hv_client_prefix.arr));

	hv_client_type = csClientType;

/*
	hv_client_type.len = strlen(csClientType);
	memcpy(hv_client_type.arr, csClientType, hv_client_type.len);
DEBUGLOG(("GenClientID client_type = [%d][%.*s]\n",hv_client_type.len, hv_client_type.len, hv_client_type.arr));
*/

        EXEC SQL select :hv_client_prefix || to_char(NVL(max(substr(client_id, 3) ), 0) + 1, 'FM09999999')
		into :v_client_id:ind_client_id
                from clients
                where client_id like :hv_client_prefix || '%'
                and type = :hv_client_type
                and length(client_id) = 10;

	if (ind_client_id >= 0) {
		v_client_id.arr[v_client_id.len] = '\0';
                strcpy((char*)csClientID,(const char*)v_client_id.arr);

DEBUGLOG(("GenClientID client_id = [%s]\n", csClientID));
                return PD_OK;
        }

DEBUGLOG(("GenclientID NOT SUCC\n"));
        return PD_ERR;

gen_error:
DEBUGLOG(("gen_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_ERR;	

}

