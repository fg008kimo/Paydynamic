/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/06/12              Virginia Yun
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "ParDefMisc.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void ParDefMisc(char    cdebug)
{
        cDebug = cdebug;
}

int	ChkExist(const char *csCode, const char *csValue)
{
	int     iRet = PD_NOT_FOUND;

	EXEC SQL WHENEVER SQLERROR GOTO chkexist_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_code[PD_SP_CODE_LEN];
		varchar		hv_value[ PD_SP_VALUE_LEN];

                int             v_no_of_record;
                short           ind_no_of_record = -1;

        EXEC SQL END DECLARE SECTION;

	hv_code.len = strlen(csCode);
	memcpy(hv_code.arr, csCode, hv_code.len);
DEBUGLOG(("ChkExist code = [%.*s]\n",hv_code.len,hv_code.arr));

	hv_value.len = strlen(csValue);
	memcpy(hv_value.arr, csValue, hv_value.len);
DEBUGLOG(("ChkExist value = [%.*s]\n",hv_value.len,hv_value.arr));

        EXEC SQL
                SELECT count(1)
                   INTO :v_no_of_record:ind_no_of_record
                   FROM par_def_misc
                  WHERE pdm_code = :hv_code
		    and pdm_value = :hv_value
                    and rownum = 1;

        if (ind_no_of_record >= 0) {
                if (v_no_of_record > 0) {
DEBUGLOG(("ChkExist FOUND\n"));
                        iRet = PD_FOUND;
                }
        }

        if (iRet!= PD_FOUND) {
DEBUGLOG(("ChkExist NOT FOUND\n"));
        }

	return iRet;

chkexist_error:
DEBUGLOG(("ChkExist_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;

}

int GetValue(const char *csCode,
		char *csValue)
{
        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_code[PD_SP_CODE_LEN];

                varchar v_value[PD_SP_VALUE_LEN +1 ];
                short   ind_value = -1;

        EXEC SQL END DECLARE SECTION;

        hv_code.len = strlen((const char*)csCode);
        memcpy(hv_code.arr, csCode, hv_code.len);
DEBUGLOG(("GetValue: code = [%.*s]\n",hv_code.len,hv_code.arr));

        EXEC SQL SELECT pdm_value
                   INTO :v_value:ind_value
                FROM par_def_misc
                WHERE pdm_code = :hv_code;

        if (ind_value >= 0) {
DEBUGLOG(("Get Value OK \n"));
                v_value.arr[v_value.len] = '\0';
                strcpy((char*)csValue,(const char*)v_value.arr);
DEBUGLOG(("value = [%s]\n",csValue));
                return FOUND;
        }
DEBUGLOG(("Value NOT FOUND\n"));
        return NOT_FOUND;

find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}

