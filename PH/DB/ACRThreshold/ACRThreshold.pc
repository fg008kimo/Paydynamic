/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/12/17              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "ACRThreshold.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;
void ACRThreshold(char    cdebug)
{
        cDebug = cdebug;
}


int Add(const hash_t *hRls)
{
	char            *csTmp;
	double          dTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

	short           hv_return_value;

	varchar         hv_compare_with[PD_CODE_LEN];
	varchar         hv_bank_ccy[PD_CCY_ID_LEN];
	double          hv_tolerance;
	varchar         hv_add_user[PD_USER_LEN];

	short           ind_compare_with = -1;
	short           ind_bank_ccy = -1;
	short           ind_tolerance = -1;
	short           ind_add_user = -1;

	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

/* compare_with */
        if (GetField_CString(hRls,"compare_with",&csTmp)) {
                hv_compare_with.len = strlen(csTmp);
                memcpy(hv_compare_with.arr,csTmp,hv_compare_with.len);
                ind_compare_with = 0;
DEBUGLOG(("Add:compare_with = [%.*s]\n",hv_compare_with.len,hv_compare_with.arr));
        }

/* bank_ccy */
        if (GetField_CString(hRls,"bank_ccy",&csTmp)) {
                hv_bank_ccy.len = strlen(csTmp);
                memcpy(hv_bank_ccy.arr,csTmp,hv_bank_ccy.len);
                ind_bank_ccy = 0;
DEBUGLOG(("Add:bank_ccy = [%.*s]\n",hv_bank_ccy.len,hv_bank_ccy.arr));
        }

/* tolerance   */
        if (GetField_Double(hRls,"tolerance",&dTmp)) {
                hv_tolerance= dTmp;
                ind_tolerance = 0;
DEBUGLOG(("Add:tolerance = [%f]\%\n",hv_tolerance));
        }

/* user */
        if (GetField_CString(hRls,"add_user",&csTmp)) {
                hv_add_user.len = strlen(csTmp);
                memcpy(hv_add_user.arr,csTmp,hv_add_user.len);
                ind_add_user = 0;
DEBUGLOG(("Add:add_user = [%.*s]\n",hv_add_user.len,hv_add_user.arr));
        }

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_acr_tolerance_insert(
					:hv_compare_with:ind_compare_with,
					:hv_bank_ccy:ind_bank_ccy,
					:hv_tolerance:ind_tolerance,
					:hv_add_user:ind_add_user);
		END;
	END-EXEC;


DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK) {
DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("ACRThreshold_Add: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("ACRThreshold_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
                return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("ACRThreshold_Add: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_INTERNAL_ERR TxnAbort\n"));
        return PD_INTERNAL_ERR;
}



int FindTolerance(const char* csCompWith,const char* csBankCcy, double *dTol)
{

	int iRet = PD_NOT_FOUND;
	*dTol  = 0.0;
        EXEC SQL WHENEVER SQLERROR GOTO find_tol_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_compare_with[PD_CODE_LEN];
		varchar		hv_bank_ccy[PD_CCY_ID_LEN];

		double		v_tolerance;

		short		ind_tolerance= -1;

        EXEC SQL END DECLARE SECTION;

	hv_compare_with.len = strlen(csCompWith);
	memcpy(hv_compare_with.arr,csCompWith,hv_compare_with.len);
DEBUGLOG(("FindTolerance compare_with = [%.*s]\n",hv_compare_with.len,hv_compare_with.arr));

	hv_bank_ccy.len = strlen(csBankCcy);
	memcpy(hv_bank_ccy.arr,csBankCcy,hv_bank_ccy.len);
DEBUGLOG(("FindTolerance bank_ccy = [%.*s]\n",hv_bank_ccy.len,hv_bank_ccy.arr));


        EXEC SQL DECLARE c_cursor_find_tol CURSOR FOR
		select 
		       at_tolerance
  		  from acr_tolerance
                 where at_bank_ccy = :hv_bank_ccy
                   and at_compare_with = :hv_compare_with;


        EXEC SQL OPEN c_cursor_find_tol;
        do {
                EXEC SQL FETCH c_cursor_find_tol
                INTO
			:v_tolerance:ind_tolerance;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

/* tolerance */
                if (ind_tolerance >= 0) {
			*dTol = v_tolerance;
DEBUGLOG(("FindTolerance tolerance = [%f]\%\n",v_tolerance));
                }

		iRet = PD_FOUND;
	}
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_find_tol;

	if(iRet==PD_FOUND){
DEBUGLOG(("FindTolerance Normal Exit\n")); 
	}
	else{
DEBUGLOG(("FindTolerance Not found\n"));
	}

        return  iRet;

find_tol_error:
DEBUGLOG(("find_tol_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("ACRThreshold_Find: SP_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_find_tol;
        return PD_ERR;
}

int Update(const hash_t *hRls)
{
	char*   csBuf;
	char*   csCompWith;
	char*   csBankCcy;
	double	dTmp = 0.0;

        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar         hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));
	csBuf = (char*) malloc (128);
	strcpy((char*)hv_dynstmt.arr,"update acr_threshol set at_update_timestamp  = sysdate");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

/* compare_with */
/* bank_ccy */
        if (GetField_CString(hRls,"compare_with",&csCompWith) &&
	    GetField_CString(hRls,"bank_ccy",&csBankCcy)) {
DEBUGLOG(("Update:compare_with = [%s]\n",csCompWith));
DEBUGLOG(("Update:bank_ccy = [%s]\n",csBankCcy));


/* tolerance */
		if (GetField_Double(hRls,"tolerance",&dTmp)) {
DEBUGLOG(("Update:tolerance = [%f]\%\n",dTmp));
			sprintf(csBuf,"%f",dTmp);
			strcat((char*)hv_dynstmt.arr, ",at_tolerance = ");
			strcat((char*)hv_dynstmt.arr, csBuf);
			hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
		}

		strcat((char *)hv_dynstmt.arr, " WHERE at_compare_with = '");
		strcat((char *)hv_dynstmt.arr, csCompWith);
		strcat((char *)hv_dynstmt.arr, "'");
		strcat((char *)hv_dynstmt.arr, " AND at_bank_ccy = '");
		strcat((char *)hv_dynstmt.arr, csBankCcy);
		strcat((char *)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

		EXEC SQL PREPARE PS FROM :hv_dynstmt;
		EXEC SQL EXECUTE PS;

        }
	else{
DEBUGLOG(("Nothing update\n"));
	}

	FREE_ME(csBuf);

DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}
