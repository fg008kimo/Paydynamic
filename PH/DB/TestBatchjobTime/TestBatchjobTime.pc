/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description						Change Date		Change By
-------------------------------					------------		--------------
Init Version							2019/10/03		Zale Ni
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include "TestBatchjobTime.h"
#include "common.h"
#include "dbutility.h"
#include "internal.h"
#include "utilitys.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

static char cDebug;

void TestBatchjobTime(char cdebug)
{
	cDebug = cdebug;
}

int GetJobByTime(const char * csMonth, const char * csDay, const char * csHour, const char * csMin, const char cDow, recordset_t * myRec)
{
	hash_t	* myHash;
	int	iCnt = 0;

	EXEC SQL WHENEVER SQLERROR GOTO getjobbytime_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_month[PD_MM_LEN + 1];
		varchar hv_day[PD_DD_LEN + 1];
		varchar hv_hour[PD_DD_LEN + 1];
		varchar hv_min[PD_DD_LEN + 1];
		char hv_dow;

		varchar v_job_id[PD_BATCH_LEN + 1];
		int v_seq;
		char v_type;
		int v_per_day;
		int v_per_hour;
		int v_per_min;
		int v_disabled;

		short ind_job_id = -1;
		short ind_seq = -1;
		short ind_type = -1;
		short ind_per_day = -1;
		short ind_per_hour = -1;
		short ind_per_min = -1;
		short ind_disabled = -1;
	EXEC SQL END DECLARE SECTION;

	/* month */
	hv_month.len = strlen(csMonth);
	memcpy(hv_month.arr, csMonth, hv_month.len);
DEBUGLOG(("GetJobByTime: Month = [%.*s]\n", hv_month.len, hv_month.arr));

	/* day */
	hv_day.len = strlen(csDay);
	memcpy(hv_day.arr, csDay, hv_day.len);
DEBUGLOG(("GetJobByTime: Day = [%.*s]\n", hv_day.len, hv_day.arr));

	/* hour */
	hv_hour.len = strlen(csHour);
	memcpy(hv_hour.arr, csHour, hv_hour.len);
DEBUGLOG(("GetJobByTime: Hour = [%.*s]\n", hv_hour.len, hv_hour.arr));

	/* min */
	hv_min.len = strlen(csMin);
	memcpy(hv_hv_minhour.arr, csMin, hv_hv_minhour.len);
DEBUGLOG(("GetJobByTime: Min = [%.*s]\n", hv_min.len, hv_min.arr));

	/* dow */
	hv_dow = cDow;
DEBUGLOG(("GetJobByTime: Dow = [%c]\n", hv_dow));

	EXEC SQL DECLARE c_cursor_getjobbytime CURSOR FOR
		SELECT	bt_job_id, 
			bt_seq, 
			bt_type, 
			bt_per_min, 
			bt_per_hour, 
			bt_per_day, 
			bt_disabled 
		FROM	test_batchjob_time
		WHERE	bt_fix_month = :hv_month and 
			bt_fix_day = :hv_day and 
			bt_fix_hour = :hv_hour and 
			bt_fix_min = :hv_min and 
			bt_fix_dow = :hv_dow;

	EXEC SQL OPEN c_cursor_getjobbytime;
	do
	{
		EXEC SQL FETCH c_cursor_getjobbytime
			INTO	:v_job_id:ind_job_id, 
				:v_seq:ind_seq, 
				:v_type:ind_type, 
				:v_per_day:ind_per_day, 
				:v_per_hour:ind_per_hour, 
				:v_per_min:ind_per_min, 
				:v_disabled:ind_disabled;

		if (SQLCODE == SQL_NOT_FOUND)
			break;

		myHash = (hash_t *)malloc(sizeof(hash_t));
		hash_init(myHash, 0);

		/* job_id*/
		if (ind_job_id >= 0)
		{
			v_job_id.arr[v_job_id.len] = '\0';
DEBUGLOG(("GetJobByTime job_id = [%s]\n", v_job_id.arr));
			PutField_CString(myHash, "job_id", (const char *)v_job_id.arr);
		}

		/* seq */
		if (ind_seq >= 0)
		{
DEBUGLOG(("GetJobByTime seq = [%d]\n", v_seq));
			PutField_Int(myHash, "seq", v_seq);
		}

		/* type */
		if (ind_type >= 0)
		{
DEBUGLOG(("GetJobByTime type = [%c]\n", v_type));
			PutField_Char(hRec, "type", v_type);
		}

		/* per_day */
		if (ind_per_day >= 0)
		{
DEBUGLOG(("GetJobByTime per_day = [%d]\n", v_per_day));
			PutField_Int(myHash, "per_day", v_per_day);
		}

		/* per_hour */
		if (ind_per_hour >= 0)
		{
DEBUGLOG(("GetJobByTime per_hour = [%d]\n", v_per_hour));
			PutField_Int(myHash, "per_hour", v_per_hour);
		}

		/* per_min */
		if (ind_per_min >= 0)
		{
DEBUGLOG(("GetJobByTime per_min = [%d]\n", v_per_min));
			PutField_Int(myHash, "per_min", v_per_min);
		}

		/* disabled */
		if (ind_diabled >= 0)
		{
DEBUGLOG(("GetJobByTime disabled = [%d]\n", v_disabled));
			PutField_Int(myHash, "disabled", v_disabled);
		}

		iCnt++;
		RecordSet_Add(myRec, myHash);
	} while (PD_TRUE);

	if (iCnt > 0)
	{
DEBUGLOG(("GetJobByTime Normal Exit\n"));
		return PD_FOUND;
	}
	else
	{
DEBUGLOG(("GetJobByTime Normal Exit, Not Found\n"));
		return PD_NOT_FOUND;
	}

getjobbytime_error:
DEBUGLOG(("getjobbytime_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getjobbytime;
	return PD_ERR;

}
