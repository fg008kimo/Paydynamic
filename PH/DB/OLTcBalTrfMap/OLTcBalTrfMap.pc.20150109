/*
Partnerdelight (c)2014. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/01/03              Virginia Yun
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLTcBalTrfMap.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void OLTcBalTrfMap(char    cdebug)
{
        cDebug = cdebug;
}

int	GetBalTransferTxnCode(hash_t *hRls)
{
	int	iRet = PD_NOT_FOUND;

	char	*csTmp;
	int	iCnt = 0;

	EXEC SQL WHENEVER SQLERROR GOTO getbaltrftxncode_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_bal_trf_type[PD_BAL_TRF_TYPE_PLATF_LEN];
		varchar	hv_from_acct_type[PD_ACCT_TYPE_LEN];
		varchar	hv_to_acct_type[PD_ACCT_TYPE_LEN];
		varchar	hv_to_baid_category[PD_BAID_CATEGORY_TYPE_LEN];
		varchar	hv_bal_trf_txn_code_type[PD_BAL_TRF_TC_TYPE_LEN];

		short	ind_bal_trf_type = -1;
		short	ind_from_acct_type = -1;
		short	ind_to_acct_type = -1;
		short	ind_to_baid_category = -1;
		short	ind_bal_trf_txn_code_type = -1;


		varchar	v_map_txn_code[PD_TXN_CODE_LEN + 1];
		int	v_allow_fe_init;

		short	ind_map_txn_code = -1;
		short	ind_allow_fe_init = -1;

	EXEC SQL END DECLARE SECTION;

	if(GetField_CString(hRls, "bal_trf_type", &csTmp)) {
		hv_bal_trf_type.len = strlen(csTmp);
		strncpy((char *)hv_bal_trf_type.arr, csTmp, hv_bal_trf_type.len);
		ind_bal_trf_type = 0;
DEBUGLOG(("GetBalTransferTxnCode: bal_trf_type = [%.*s]\n", hv_bal_trf_type.len, hv_bal_trf_type.arr));
	} else {
DEBUGLOG(("GetBalTransferTxnCode: bal_trf_type NOT FOUND!!!\n"));
		return PD_ERR;
        }	

	if(GetField_CString(hRls, "from_acct_type", &csTmp)) {
		hv_from_acct_type.len = strlen(csTmp);
		strncpy((char *)hv_from_acct_type.arr, csTmp, hv_from_acct_type.len);
		ind_from_acct_type = 0;
DEBUGLOG(("GetBalTransferTxnCode: from_acct_type = [%.*s]\n", hv_from_acct_type.len, hv_from_acct_type.arr));
	} else {
DEBUGLOG(("GetBalTransferTxnCode: from_acct_type NOT FOUND!!!\n"));
		return PD_ERR;
        }	

	if(GetField_CString(hRls, "to_acct_type", &csTmp)) {
		hv_to_acct_type.len = strlen(csTmp);
		strncpy((char *)hv_to_acct_type.arr, csTmp, hv_to_acct_type.len);
		ind_to_acct_type = 0;
DEBUGLOG(("GetBalTransferTxnCode: to_acct_type = [%.*s]\n", hv_to_acct_type.len, hv_to_acct_type.arr));
	} else {
DEBUGLOG(("GetBalTransferTxnCode: to_acct_type NOT FOUND!!!\n"));
		return PD_ERR;
        }	

	if(GetField_CString(hRls, "to_baid_category", &csTmp)) {
		hv_to_baid_category.len = strlen(csTmp);
		strncpy((char *)hv_to_baid_category.arr, csTmp, hv_to_baid_category.len);
		ind_to_baid_category = 0;
DEBUGLOG(("GetBalTransferTxnCode: to_baid_category = [%.*s]\n", hv_to_baid_category.len, hv_to_baid_category.arr));
	} else {
DEBUGLOG(("GetBalTransferTxnCode: to_baid_category NOT FOUND!!!\n"));
		return PD_ERR;
        }	

	if(GetField_CString(hRls, "bal_trf_txn_code_type", &csTmp)) {
		hv_bal_trf_txn_code_type.len = strlen(csTmp);
		strncpy((char *)hv_bal_trf_txn_code_type.arr, csTmp, hv_bal_trf_txn_code_type.len);
		ind_bal_trf_txn_code_type = 0;
DEBUGLOG(("GetBalTransferTxnCode: bal_trf_txn_code_type = [%.*s]\n", hv_bal_trf_txn_code_type.len, hv_bal_trf_txn_code_type.arr));
	} else {
DEBUGLOG(("GetBalTransferTxnCode: bal_trf_txn_code_type NOT FOUND!!!\n"));
		return PD_ERR;
        }	


	EXEC SQL DECLARE c_cursor_getbaltrftxncode CURSOR FOR
		select	btm_txn_code, 
			btm_allow_fe_init
		from ol_tc_bal_trf_map, 
                     ol_tc_bal_trf_cat_map
		where btm_bal_trf_type = :hv_bal_trf_type:ind_bal_trf_type
		and btm_fr_acct_type = :hv_from_acct_type:ind_from_acct_type
		and btm_to_acct_type = :hv_to_acct_type:ind_to_acct_type
		and btm_to_baid_cat_id = btcm_map_id
		and btcm_baid_category = :hv_to_baid_category:ind_to_baid_category
		and btm_txn_code_type = :hv_bal_trf_txn_code_type:ind_bal_trf_txn_code_type;

        EXEC SQL OPEN c_cursor_getbaltrftxncode;
        do {
		EXEC SQL FETCH c_cursor_getbaltrftxncode
		INTO 
			:v_map_txn_code:ind_map_txn_code,
			:v_allow_fe_init:ind_allow_fe_init;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

		if (ind_map_txn_code >= 0) {
			v_map_txn_code.arr[v_map_txn_code.len] = '\0';
                        PutField_CString(hRls,"map_txn_code",(const char*)v_map_txn_code.arr);
DEBUGLOG(("GetBalTransferTxnCode map_txn_code = [%s]\n", v_map_txn_code.arr));
		}

		if (ind_allow_fe_init >= 0) {
                        PutField_Int(hRls,"allow_fe_init", v_allow_fe_init);
DEBUGLOG(("GetBalTransferTxnCode allow_fe_init = [%d]\n", v_allow_fe_init));
                }

		break;
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getbaltrftxncode;

	if (iCnt > 0) {
DEBUGLOG(("GetBalTransferTxnCode Normal Exit, Found\n"));
		iRet = PD_FOUND;
	} else {
DEBUGLOG(("GetBalTransferTxnCode Not Found\n"));
	}

	return iRet;

getbaltrftxncode_error:
DEBUGLOG(("getbaltrftxncode_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLTcBalTrfMap.GetBalTransferTxnCode:SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getbaltrftxncode;

        return PD_INTERNAL_ERR;
}


