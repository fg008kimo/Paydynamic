/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/10/08              Virginia Yun
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLRuleAMSchedulerHd.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;
void OLRuleAMSchedulerHd(char    cdebug)
{
        cDebug = cdebug;
}


int GetIdDetail(int iId, recordset_t* myRec)
{
	hash_t *myHash;
	int	iRet = PD_NOT_FOUND;
	EXEC SQL WHENEVER SQLERROR GOTO getiddetail_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;	

	EXEC SQL BEGIN DECLARE SECTION;
		int	hv_id;
		
		varchar	v_start_time[PD_TIME_LEN +1];
		varchar	v_end_time[PD_TIME_LEN +1];
		int	v_day;
		int	v_interval;
		varchar	v_effect_datetime[PD_DATETIME_LEN + 1];

		short	ind_start_time = -1;
		short	ind_end_time = -1;
		short	ind_day = -1;
		short	ind_interval = -1;
		short	ind_effect_datetime = -1;


	EXEC SQL END DECLARE SECTION;

	hv_id = iId;
DEBUGLOG(("GetIdDetail id = [%d]\n",iId));

	EXEC SQL DECLARE c_cursor_getiddetail CURSOR FOR
		select 	rat_start_time, 
			rat_end_time, 
			rat_day, 
			rat_interval,
			to_char(ras_effect_datetime, 'YYYYMMDDHH24MISS')
		from ol_rule_am_recur_type, ol_rule_am_scheduler_hd 
		where ras_disabled = 0
		and ras_effect_datetime <= sysdate
		and ras_scheduler_id = rat_id
		and rat_disabled = 0;

	EXEC SQL OPEN c_cursor_getiddetail;
        do {
		EXEC SQL FETCH c_cursor_getiddetail 
		INTO
			:v_start_time:ind_start_time,
			:v_end_time:ind_end_time,
			:v_day:ind_day,
			:v_interval:ind_interval,
			:v_effect_datetime:ind_effect_datetime;


		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		iRet = PD_FOUND;

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* start_time */
                if (ind_start_time >= 0) {
                        v_start_time.arr[v_start_time.len] = '\0';
DEBUGLOG(("GetIdDetail start_time = [%s]\n",v_start_time.arr));
                        PutField_CString(myHash,"start_time",(char*)v_start_time.arr);
                }
/* end_time */
                if (ind_end_time >= 0) {
                        v_end_time.arr[v_end_time.len] = '\0';
DEBUGLOG(("GetIdDetail end_time = [%s]\n",v_end_time.arr));
                        PutField_CString(myHash,"end_time",(char*)v_end_time.arr);
                }
/* day */
		if (ind_day >= 0) {
DEBUGLOG(("GetIdDetail day = [%d]\n",v_day));
			PutField_Int(myHash,"day",v_day);
		}

/* interval */
		if (ind_interval >= 0) {
DEBUGLOG(("GetIdDetail interval = [%d]\n",v_interval));
			PutField_Int(myHash,"interval",v_interval);
		}

/* effect_datetime */
		if (ind_effect_datetime >= 0) {
			v_effect_datetime.arr[v_effect_datetime.len] = '\0';
DEBUGLOG(("GetIdDetail effect_datetime = [%s]\n",v_effect_datetime.arr));
			PutField_CString(myHash,"effect_datetime",(char*)v_effect_datetime.arr);
		}		


		RecordSet_Add(myRec,myHash);

	} 
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getiddetail;
	return PD_FOUND;
getiddetail_error:
DEBUGLOG(("getiddetail code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getiddetail;
        return PD_NOT_FOUND;
}
