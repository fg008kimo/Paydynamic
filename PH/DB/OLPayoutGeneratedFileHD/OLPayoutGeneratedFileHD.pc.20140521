/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/01/16              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLPayoutGeneratedFileHD.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "internal.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void OLPayoutGeneratedFileHD(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hRec)
{
	char            *csTmp;
        int             iTmp;

        EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                unsigned long   hv_file_id;
                varchar         hv_file_date[PD_DATE_LEN];
                varchar         hv_pid[PD_PSP_ID_LEN];
                varchar         hv_bank_code[PD_BANK_CODE_LEN];
                int             hv_seq_num;
		varchar		hv_filename[PD_FILENAME_LEN];
		varchar		hv_add_user[PD_USER_LEN];
		varchar		hv_ccy_id[PD_CCY_ID_LEN];
                
                short           ind_file_id= -1;
                short           ind_file_date= -1;
                short           ind_pid= -1;
                short           ind_bank_code= -1;
                short           ind_seq_num= -1;
                short           ind_filename= -1;
                short           ind_add_user= -1;
                short           ind_ccy_id = -1;
                
                short           hv_return_value;
                EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

/*file_id*/
        if(GetField_CString(hRec,"file_id",&csTmp)){
                hv_file_id = ctol((const unsigned char*)csTmp,strlen(csTmp));
                ind_file_id= 0;
DEBUGLOG(("Add:file_id= [%ld]\n",hv_file_id));
        }

/*file_date*/
        if(GetField_CString(hRec,"file_date",&csTmp)){
                hv_file_date.len = strlen(csTmp);
                memcpy(hv_file_date.arr, csTmp, hv_file_date.len);
                ind_file_date= 0;
DEBUGLOG(("Add:file_date= [%.*s]\n",hv_file_date.len,hv_file_date.arr));
        }

/*file_pid*/
        if(GetField_CString(hRec,"file_pid",&csTmp)){
                hv_pid.len = strlen(csTmp);
                memcpy(hv_pid.arr, csTmp, hv_pid.len);
                ind_pid= 0;
DEBUGLOG(("Add:file_pid= [%.*s]\n",hv_pid.len,hv_pid.arr));
        }

/*seq_num*/
        if(GetField_Int(hRec,"seq_num",&iTmp)){
                hv_seq_num = iTmp;
                ind_seq_num= 0;
DEBUGLOG(("Add:seq_num= [%d]\n",hv_seq_num));
        }

/*filename*/
        if(GetField_CString(hRec,"filename",&csTmp)){
                hv_filename.len = strlen(csTmp);
                memcpy(hv_filename.arr, csTmp, hv_filename.len);
                ind_filename= 0;
DEBUGLOG(("Add:filename= [%.*s]\n",hv_filename.len,hv_filename.arr));
        }

/* bank_code */
        if(GetField_CString(hRec,"file_bank_code",&csTmp)){
                hv_bank_code.len = strlen(csTmp);
                memcpy(hv_bank_code.arr, csTmp, hv_bank_code.len);
                ind_bank_code= 0;
DEBUGLOG(("Add:bank_code= [%.*s]\n",hv_bank_code.len,hv_bank_code.arr));
        }

/*ccy_id*/
        if(GetField_CString(hRec,"ccy_id",&csTmp)){
                hv_ccy_id.len = strlen(csTmp);
                memcpy(hv_ccy_id.arr, csTmp, hv_ccy_id.len);
                ind_ccy_id= 0;
DEBUGLOG(("Add:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
        }


/*user*/
        if(GetField_CString(hRec,"add_user",&csTmp)){
                hv_add_user.len = strlen(csTmp);
                memcpy(hv_add_user.arr, csTmp, hv_add_user.len);
                ind_add_user= 0;
DEBUGLOG(("Add:add_user= [%.*s]\n",hv_add_user.len,hv_add_user.arr));
        }

	EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_ol_payout_gen_hd_insert(
                                        :hv_file_id:ind_file_id,
                                        :hv_file_date:ind_file_date,
                                        :hv_pid:ind_pid,
					:hv_bank_code:ind_bank_code,
                                        :hv_seq_num:ind_seq_num,
                                        :hv_filename:ind_filename,
					:hv_ccy_id:ind_ccy_id,
                                        :hv_add_user:ind_add_user);
                END;
        END-EXEC;
                
DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
DEBUGLOG(("Add:Normal Exit\n"));
                return PD_OK;
        }
                
        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("OLPayoutGeneratedFileHD_Add: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("OLPayoutGeneratedFileHD_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
                return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPayoutGeneratedFileHD_Add: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;

}

int GetHeader(const hash_t* hRec,recordset_t* myRec)
{
	hash_t *myHash;
	char*	csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO getheader_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		unsigned long	hv_file_id;

		varchar		v_filename[PD_FILENAME_LEN+1];
		varchar		v_file_date[PD_DATE_LEN+1];
		varchar         v_psp_id[PD_PSP_ID_LEN+1];
                varchar         v_payout_ccy[PD_CCY_ID_LEN+1];
                double          v_total_txn_amt;
		int		v_status;
		int		v_txn_count;
		varchar         v_bank_code[PD_BANK_CODE_LEN + 1];

		short		ind_filename = -1;
		short           ind_file_date= -1;
                short           ind_psp_id= -1;
                short           ind_payout_ccy= -1;
                short           ind_total_txn_amt= -1;
                short           ind_status= -1;
                short           ind_txn_count= -1;
		short		ind_bank_code = -1;


	EXEC SQL END DECLARE SECTION;

	if(GetField_CString(hRec,"file_id",&csTmp)){
		hv_file_id= (unsigned long)ctol((const unsigned char*)csTmp,strlen(csTmp));
DEBUGLOG(("GetHeader file_id = [%ld]\n",hv_file_id));
	}

	EXEC SQL DECLARE c_cursor_getheader CURSOR FOR
		select
			ofh_filename,
			ofh_file_date,
			ofh_file_pid,
                        ofh_status,
                        ofh_txn_count,
                        ofh_total_txn_amt,
                        ofh_ccy_id,
			ofh_file_bank_code
		from	ol_payout_generated_file_hd
		where	ofh_file_id =:hv_file_id;

	EXEC SQL OPEN  c_cursor_getheader;
	do{
		EXEC SQL FETCH c_cursor_getheader
		INTO
			:v_filename:ind_filename,
			:v_file_date:ind_file_date,
                        :v_psp_id:ind_psp_id,
                        :v_status:ind_status,
                        :v_txn_count:ind_txn_count,
                        :v_total_txn_amt:ind_total_txn_amt,
                        :v_payout_ccy:ind_payout_ccy,
			:v_bank_code:ind_bank_code;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

/*filename*/
		if(ind_filename>=0){
			v_filename.arr[v_filename.len]='\0';
			PutField_CString(myHash,"filename",(const char*)v_filename.arr);
DEBUGLOG(("GetHeader filename = [%s]\n",v_filename.arr));
		}

/*file_date*/
                if(ind_file_date>=0){
                        v_file_date.arr[v_file_date.len]='\0';
                        PutField_CString(myHash,"file_date",(const char*)v_file_date.arr);
DEBUGLOG(("GetHeader file_date = [%s]\n",v_file_date.arr));
                }

/*psp_id*/
                if(ind_psp_id>=0){
                        v_psp_id.arr[v_psp_id.len]='\0';
                        PutField_CString(myHash,"psp_id",(const char*)v_psp_id.arr);
DEBUGLOG(("GetHeader psp_id= [%s]\n",v_psp_id.arr));
                }

/*payout_currency*/
                if(ind_payout_ccy>=0){
                        v_payout_ccy.arr[v_payout_ccy.len]='\0';
                        PutField_CString(myHash,"payout_ccy",(const char*)v_payout_ccy.arr);
DEBUGLOG(("GetHeader payout_ccy= [%s]\n",v_payout_ccy.arr));
                }

/*total_txn_amt*/
                if(ind_total_txn_amt>=0){
                        PutField_Double(myHash,"total_txn_amt",v_total_txn_amt);
DEBUGLOG(("GetHeader total_txn_amt = [%lf]\n",v_total_txn_amt));
        	}

/*txn_count*/
                if(ind_txn_count>=0){
                        PutField_Int(myHash,"txn_count",v_txn_count);
DEBUGLOG(("GetHeader txn_count = [%d]\n",v_txn_count));
        	}

/*status*/
                if(ind_status>=0){
                        PutField_Int(myHash,"status",v_status);
DEBUGLOG(("GetHeader status = [%d]\n",v_status));
        	}

/*bank_code*/
		if(ind_bank_code >=0){
			v_bank_code.arr[v_bank_code.len]='\0';
			PutField_CString(myHash,"file_bank_code",(const char*)v_bank_code.arr);
DEBUGLOG(("GetHeader bank_code = [%s]\n",v_bank_code.arr));
		}

		RecordSet_Add(myRec,myHash);

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getheader;

DEBUGLOG(("GetHeader Normal Exit\n"));
	return  PD_OK;

getheader_error:
DEBUGLOG(("getheader_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPayoutGeneratedFileHD_Get: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getheader;
	return PD_ERR;

}

int GetNextFileId(unsigned long *lFileId)
{
	int iRet = PD_OK;
	*lFileId = 0l;

	EXEC SQL WHENEVER SQLERROR GOTO GetNextFileId_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		unsigned long	v_file_id;

                short           ind_file_id = -1;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL SELECT max(ofh_file_id)
                INTO    :v_file_id:ind_file_id
                FROM    ol_payout_generated_file_hd;

        if(ind_file_id>=0){
DEBUGLOG(("GetNextFileId Found\n"));
                *lFileId = v_file_id+1;
        }
        else {
DEBUGLOG(("GetNextFileId Start by 1\n"));
                *lFileId = 1;
        }

	return iRet;

GetNextFileId_error:
DEBUGLOG(("GetNextFileId_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}


int GetPreGenHeader(const int iStatus, recordset_t* myRec)
{
	hash_t *myHash;

	EXEC SQL WHENEVER SQLERROR GOTO getpreheader_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		int		hv_status;

		varchar		v_file_id[PD_TXN_SEQ_LEN+1];
		varchar		v_filename[PD_FILENAME_LEN+1];
		varchar		v_file_date[PD_DATE_LEN+1];
		varchar         v_psp_id[PD_PSP_ID_LEN+1];
		varchar         v_bank_code[PD_BANK_CODE_LEN+1];
                varchar         v_payout_ccy[PD_CCY_ID_LEN+1];
                double          v_total_txn_amt;
		int		v_txn_count;
		int		v_seq_num;

		short		ind_file_id = -1;
		short		ind_filename = -1;
		short           ind_file_date= -1;
                short           ind_psp_id= -1;
                short           ind_bank_code= -1;
                short           ind_payout_ccy= -1;
                short           ind_total_txn_amt= -1;
                short           ind_txn_count= -1;
                short           ind_seq_num= -1;


	EXEC SQL END DECLARE SECTION;

	//hv_status = PD_PAYOUTFILE_PRE_GENERATED;
	hv_status = iStatus;
	

	EXEC SQL DECLARE c_cursor_getpreheader CURSOR FOR
		select  ofh_file_id,
			ofh_seq_num,
			ofh_filename,
			ofh_file_date,
			ofh_file_pid,
			ofh_file_bank_code,
                        ofh_txn_count,
                        ofh_total_txn_amt,
			ofh_ccy_id
		from	ol_payout_generated_file_hd
		where	ofh_status=:hv_status
		for update;

	EXEC SQL OPEN  c_cursor_getpreheader;
	do{
		EXEC SQL FETCH c_cursor_getpreheader
		INTO	:v_file_id:ind_file_id,
			:v_seq_num:ind_seq_num,
			:v_filename:ind_filename,
			:v_file_date:ind_file_date,
                        :v_psp_id:ind_psp_id,
                        :v_bank_code:ind_bank_code,
                        :v_txn_count:ind_txn_count,
                        :v_total_txn_amt:ind_total_txn_amt,
                        :v_payout_ccy:ind_payout_ccy;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

/*file_id*/
		if(ind_file_id>=0){
			v_file_id.arr[v_file_id.len]='\0';
			PutField_CString(myHash,"file_id",(const char*)v_file_id.arr);
DEBUGLOG(("GetPreGenHeader file_id = [%s]\n",v_file_id.arr));
		}

/*seq_num*/
                if(ind_seq_num>=0){
                        PutField_Int(myHash,"seq_num",v_seq_num);
DEBUGLOG(("GetPreGenHeader seq_num = [%d]\n",v_seq_num));
        	}

/*filename*/
		if(ind_filename>=0){
			v_filename.arr[v_filename.len]='\0';
			PutField_CString(myHash,"filename",(const char*)v_filename.arr);
DEBUGLOG(("GetPreGenHeader filename = [%s]\n",v_filename.arr));
		}

/*file_date*/
                if(ind_file_date>=0){
                        v_file_date.arr[v_file_date.len]='\0';
                        PutField_CString(myHash,"file_date",(const char*)v_file_date.arr);
DEBUGLOG(("GetPreGenHeader file_date = [%s]\n",v_file_date.arr));
                }

/*psp_id*/
                if(ind_psp_id>=0){
                        v_psp_id.arr[v_psp_id.len]='\0';
                        PutField_CString(myHash,"psp_id",(const char*)v_psp_id.arr);
DEBUGLOG(("GetPreGenHeader psp_id= [%s]\n",v_psp_id.arr));
                }

/*bank_code*/
                if(ind_bank_code>=0){
                        v_bank_code.arr[v_bank_code.len]='\0';
                        PutField_CString(myHash,"file_bank_code",(const char*)v_bank_code.arr);
DEBUGLOG(("GetPreGenHeader bank_code= [%s]\n",v_bank_code.arr));
                }

/*payout_currency*/
                if(ind_payout_ccy>=0){
                        v_payout_ccy.arr[v_payout_ccy.len]='\0';
                        PutField_CString(myHash,"payout_ccy",(const char*)v_payout_ccy.arr);
DEBUGLOG(("GetPreGenHeader payout_ccy= [%s]\n",v_payout_ccy.arr));
                }

/*total_txn_amt*/
                if(ind_total_txn_amt>=0){
                        PutField_Double(myHash,"total_txn_amt",v_total_txn_amt);
DEBUGLOG(("GetPreGenHeader total_txn_amt = [%lf]\n",v_total_txn_amt));
        	}

/*txn_count*/
                if(ind_txn_count>=0){
                        PutField_Int(myHash,"txn_count",v_txn_count);
DEBUGLOG(("GetPreGenHeader txn_count = [%d]\n",v_txn_count));
        	}


		RecordSet_Add(myRec,myHash);

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getpreheader;

DEBUGLOG(("GetPreGenHeader Normal Exit\n"));
	return  PD_OK;

getpreheader_error:
DEBUGLOG(("getpreheader_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPayoutGeneratedFileHD_GetPreGen: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getpreheader;
	return PD_ERR;

}



int GetNextSeq(const char* csDate, const char* csPid, const char* csBankCode, int *iSeqNum)
{
	int iRet = PD_OK;
	*iSeqNum = 0;

	EXEC SQL WHENEVER SQLERROR GOTO GetNextSeq_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_file_date[PD_DATE_LEN];
		varchar		hv_file_pid[PD_PSP_ID_LEN];
		varchar		hv_bank_code[PD_BANK_CODE_LEN];
		int		v_seq_num;

                short		ind_seq_num = -1;

        EXEC SQL END DECLARE SECTION;


	hv_file_date.len = strlen(csDate);
	memcpy(hv_file_date.arr,csDate,hv_file_date.len);
DEBUGLOG(("GetNextSeq file_date = [%.*s]\n",hv_file_date.len,hv_file_date.arr));

	hv_file_pid.len = strlen(csPid);
	memcpy(hv_file_pid.arr,csPid,hv_file_pid.len);
DEBUGLOG(("GetNextSeq file_pid = [%.*s]\n",hv_file_pid.len,hv_file_pid.arr));

	hv_bank_code.len = strlen(csBankCode);
	memcpy(hv_bank_code.arr,csBankCode,hv_bank_code.len);
DEBUGLOG(("GetNextSeq bank_code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr));

        EXEC SQL SELECT max(ofh_seq_num)
                INTO    :v_seq_num:ind_seq_num
                FROM    ol_payout_generated_file_hd
		WHERE	ofh_file_date = :hv_file_date
		AND	ofh_file_pid = :hv_file_pid
		AND	ofh_file_bank_code = :hv_bank_code;

        if(ind_seq_num>=0){
DEBUGLOG(("GetNextSeq Found\n"));
                *iSeqNum = v_seq_num+1;
        }
        else {
DEBUGLOG(("GetNextSeq Start by 1\n"));
                *iSeqNum = 1;
        }

	return iRet;

GetNextSeq_error:
DEBUGLOG(("GetNextSeq_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}


int Update(const hash_t *hRec)
{
        char*   csBuf;
        char*   csFileId;
	int	iTmp;
	double	dTmp;

        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar         hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;


DEBUGLOG(("Update: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update ol_payout_generated_file_hd set ofh_update_timestamp = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

        if(GetField_CString(hRec,"file_id",&csFileId)){
DEBUGLOG(("Update:file_id = [%s]\n",csFileId));
	}
	else{
		FREE_ME(csBuf);
DEBUGLOG(("Update file_id not found\n"));
        	return INT_ERR;
	}

        if(GetField_Int(hRec,"status",&iTmp)){
DEBUGLOG(("Update: status = [%d]\n",iTmp));
                sprintf(csBuf,"%d",iTmp);
                strcat((char*)hv_dynstmt.arr, ",ofh_status = ");
                strcat((char*)hv_dynstmt.arr, csBuf);
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

        if(GetField_Int(hRec,"txn_cnt",&iTmp)){
DEBUGLOG(("Update: txn_cnt = [%d]\n",iTmp));
                sprintf(csBuf,"%d",iTmp);
                strcat((char*)hv_dynstmt.arr, ",ofh_txn_count = ");
                strcat((char*)hv_dynstmt.arr, csBuf);
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

        if(GetField_Double(hRec,"txn_amt",&dTmp)){
DEBUGLOG(("Update: total_txn_amt = [%lf]\n",dTmp));
                sprintf(csBuf,"%lf",dTmp);
                strcat((char*)hv_dynstmt.arr, ",ofh_total_txn_amt = ");
                strcat((char*)hv_dynstmt.arr, csBuf);
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

	if(GetField_CString(hRec,"ccy_id",&csBuf)){
DEBUGLOG(("Update: ccy_id = [%s]\n",csBuf));
                strcat((char*)hv_dynstmt.arr, ",ofh_ccy_id= '");
                strcat((char*)hv_dynstmt.arr, csBuf);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

	if(GetField_CString(hRec,"update_user",&csBuf)){
DEBUGLOG(("Update: update_user = [%s]\n",csBuf));
                strcat((char*)hv_dynstmt.arr, ",ofh_update_user = '");
                strcat((char*)hv_dynstmt.arr, csBuf);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

	if(GetField_CString(hRec,"file_bank_code",&csBuf)){
DEBUGLOG(("Update: file_bank_code = [%s]\n",csBuf));
		strcat((char*)hv_dynstmt.arr, ",ofh_file_bank_code = '");
		strcat((char*)hv_dynstmt.arr, csBuf);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

	strcat((char*)hv_dynstmt.arr, " WHERE ofh_file_id= ");
        strcat((char*)hv_dynstmt.arr, csFileId);
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));


        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);

DEBUGLOG(("UpdateStatus Normal Exit\n"));
        return PD_OK;

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPayoutGeneratedFileHD_Update: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_INTERNAL_ERR;
}


int Delete(const unsigned char* file_id)
{
        EXEC SQL WHENEVER SQLERROR GOTO delete_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_file_id[PD_TXN_SEQ_LEN];

                short   hv_return_value;
        EXEC SQL END DECLARE SECTION;

        hv_file_id.len = strlen((const char*)file_id);
        memcpy(hv_file_id.arr,file_id,hv_file_id.len);
DEBUGLOG(("Delete: file_id = [%.*s]\n",hv_file_id.len,hv_file_id.arr));

        EXEC SQL EXECUTE
            BEGIN

                :hv_return_value := sp_ol_payout_gen_hd_delete(
                                :hv_file_id);

            END;
        END-EXEC;


DEBUGLOG(("Delete:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
DEBUGLOG(("Delete:Normal Exit\n"));
                return PD_OK;
        }
	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("OLPayoutGeneratedFileHD_Delete: SP_OTHER_ERR\n");
DEBUGLOG(("Delete: SP_OTHER_ERR\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("OLPayoutGeneratedFileHD_Delete: SP_ERR\n");
DEBUGLOG(("Delete: SP_ERR\n"));
                return PD_ERR;
        }

delete_error:
DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPayoutGeneratedFileHD_Delete: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;

}
