/*
   Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
   of an authorized representative of Partnerdelight.

   Change Description                                 Change Date             Change By
   -------------------------------                    ------------            --------------
   Init Version                                       2012/03/05              Virginia Yun
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MmsStlBankDetail.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MmsStlBankDetail(char    cdebug)
{
	cDebug = cdebug;
}


int GetStlBankDetail(const char* csStlBankId,
		hash_t* hRec)
{

	EXEC SQL WHENEVER SQLERROR GOTO getstlbankdetail_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
	varchar         hv_stl_bank_id[PD_BANK_ID_LEN];
	int             hv_disabled;

	varchar         v_name[PD_NAME_LEN + 1];
	varchar         v_stl_bank_acct[PD_AC_NO_LEN + 1];

	short           ind_name = -1;
	short           ind_stl_bank_acct = -1;

	EXEC SQL END DECLARE SECTION;

	hv_stl_bank_id.len = strlen(csStlBankId);
	memcpy(hv_stl_bank_id.arr,csStlBankId,hv_stl_bank_id.len);
	DEBUGLOG(("GetStlBankDetail stl_bank_id = [%d][%.*s]\n",hv_stl_bank_id.len,hv_stl_bank_id.len,hv_stl_bank_id.arr));

	hv_disabled = 0;

	EXEC SQL DECLARE c_cursor_getstlbankdetail CURSOR FOR
		select sbd_stl_bank_name,
		       sbd_stl_bank_acct
		from   mms_stl_bank_detail
		where  sbd_stl_bank_id = :hv_stl_bank_id
		and    sbd_disabled = :hv_disabled;

	EXEC SQL OPEN c_cursor_getstlbankdetail;
	do {
		EXEC SQL FETCH c_cursor_getstlbankdetail
			INTO
			:v_name:ind_name,
			:v_stl_bank_acct:ind_stl_bank_acct;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}


DEBUGLOG(("GetStlBankDetail found record\n"));

		/* stl bank name */
		if (ind_name >= 0) {
			v_name.arr[v_name.len] = '\0';
			PutField_CString(hRec,"stl_bank_name",(const char*)v_name.arr);
			DEBUGLOG(("GetStlBankDetail name = [%s]\n",v_name.arr));
		}
		/* stl bank acct */
		if (ind_stl_bank_acct >= 0) {
			v_stl_bank_acct.arr[v_stl_bank_acct.len] = '\0';
			PutField_CString(hRec,"stl_bank_acct",(const char*)v_stl_bank_acct.arr);
			DEBUGLOG(("GetStlBankDetail stl_bank_acct = [%s]\n",v_stl_bank_acct.arr));
		}
	}
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getstlbankdetail;


	DEBUGLOG(("GetStlBankDetail Normal Exit\n"));
	return  PD_OK;

getstlbankdetail_error:
	DEBUGLOG(("getstlbankdetail_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	ERRLOG("BankDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getstlbankdetail;
	return PD_ERR;
}


int GetNextStlBankId(const char *csLastStlBankId,
                 char *csNextStlBankId)
{
        int iRet = PD_ERR;

        EXEC SQL WHENEVER SQLERROR GOTO getnextstlbankid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                int             hv_disabled;
                varchar         hv_last_stl_bank_id[PD_BANK_ID_LEN];

                varchar         v_stl_bank_id[PD_BANK_ID_LEN + 1];

                short           ind_stl_bank_id = -1;

        EXEC SQL END DECLARE SECTION;

        hv_last_stl_bank_id.len = strlen(csLastStlBankId);
        memcpy(hv_last_stl_bank_id.arr,csLastStlBankId,hv_last_stl_bank_id.len);
DEBUGLOG(("GetNextBankId last_stl_bank_id = [%d][%.*s]\n",hv_last_stl_bank_id.len,hv_last_stl_bank_id.len,hv_last_stl_bank_id.arr));

        hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getnextstlbankid CURSOR FOR
                select sbd_stl_bank_id
                from
                        (select sbd_stl_bank_id
                           from mms_stl_bank_detail
                          where sbd_stl_bank_id > :hv_last_stl_bank_id
                            and sbd_disabled = :hv_disabled
                        order by sbd_stl_bank_id
                        )b
                where rownum = 1;

        EXEC SQL OPEN c_cursor_getnextstlbankid;

        EXEC SQL FETCH c_cursor_getnextstlbankid
        INTO
		:v_stl_bank_id:ind_stl_bank_id;

	if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("GetNextStlBankId not found\n"));
		iRet = PD_NOT_FOUND;
	}

        if (ind_stl_bank_id >= 0) {
                v_stl_bank_id.arr[v_stl_bank_id.len] = '\0';
                strcpy(csNextStlBankId, (const char*) v_stl_bank_id.arr);
DEBUGLOG(("GetNextStlBankId stl_bank_id = [%s] [%s]\n",v_stl_bank_id.arr, csNextStlBankId));

                iRet = PD_OK;
DEBUGLOG(("GetNextStlBankId Normal Exit\n"));
        }
        else {
DEBUGLOG(("GetNextStlBankId Normal Exit, no record found\n"));
        }
        EXEC SQL CLOSE c_cursor_getnextstlbankid;

        return iRet;

getnextstlbankid_error:
DEBUGLOG(("getnextstlbankid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getnextstlbankid;
        return PD_ERR;

}

int     GetStlBankDetailbyRange(const hash_t *hRec, recordset_t *myRec)
{
	int iRet = PD_OK;
	int iCnt = 0;

	char *csTmp = NULL;
	int  iRowNum = 0;

        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getstlbankdetailbyrange_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
	short		hv_return_value;

        varchar         hv_st_stl_bank_id[PD_BANK_ID_LEN];
        int             hv_disabled;

        varchar         v_stl_bank_id[PD_BANK_ID_LEN + 1];
        varchar         v_name[PD_NAME_LEN + 1];
        varchar         v_stl_bank_acct[PD_AC_NO_LEN + 1];

	short		ind_st_stl_bank_id = -1;
	short		ind_disabled = -1;

        short           ind_stl_bank_id = -1;
        short           ind_name = -1;
        short           ind_stl_bank_acct = -1;

	SQL_CURSOR	c_cursor_id;

        EXEC SQL END DECLARE SECTION;

        hv_disabled = 0;
	ind_disabled = 0;
DEBUGLOG(("GetStlBankDetailbyRange hv_disabled = [%d]\n",hv_disabled));


	if (GetField_Int(hRec, "max_rtn", &iRowNum)) {
DEBUGLOG(("GetStlBankDetailbyRange max_rtn = [%d]\n", iRowNum));
	}
		

	if (GetField_CString(hRec, "start_stl_bank_id", &csTmp)) {
	        hv_st_stl_bank_id.len = strlen(csTmp);
		memcpy(hv_st_stl_bank_id.arr, csTmp, hv_st_stl_bank_id.len);
		ind_st_stl_bank_id = 0;
DEBUGLOG(("GetStlBankDetailbyRange st_stl_bank_id = [%d][%.*s]\n",hv_st_stl_bank_id.len,hv_st_stl_bank_id.len,hv_st_stl_bank_id.arr));
	}


	EXEC SQL ALLOCATE   :c_cursor_id;
	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_mms_stl_bank_detail_range(:hv_st_stl_bank_id:ind_st_stl_bank_id,
								     :hv_disabled:ind_disabled,
								     :c_cursor_id);	
		END;
	END-EXEC;
	
	if (hv_return_value == SP_OK) {

DEBUGLOG(("GetStlBankDetailbyRange found record\n"));
		for (;;) {
			myHash = (hash_t*) malloc(sizeof(hash_t));
			hash_init(myHash, 0);

			ind_stl_bank_id = -1;
			ind_name = -1;
			ind_stl_bank_acct = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_stl_bank_id:ind_stl_bank_id,
				:v_name:ind_name,
				:v_stl_bank_acct:ind_stl_bank_acct;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (iCnt < iRowNum + 1 || iRowNum == 0) { 

				if (ind_stl_bank_id >= 0) {
					v_stl_bank_id.arr[v_stl_bank_id.len] = '\0';
					PutField_CString(myHash,"stl_bank_id",(const char*)v_stl_bank_id.arr);
DEBUGLOG(("GetStlBankDetailbyRange [%05d] stl_bank_id = [%.*s]\n",iCnt, v_stl_bank_id.len, v_stl_bank_id.arr));
				}

				if (ind_name >= 0) {
					v_name.arr[v_name.len] = '\0';
					PutField_CString(myHash,"stl_bank_name",(const char*)v_name.arr);
DEBUGLOG(("GetStlBankDetailbyRange [%05d] name = [%.*s]\n",iCnt, v_name.len, v_name.arr));
				}

				if (ind_stl_bank_acct >= 0) {
                        		v_stl_bank_acct.arr[v_stl_bank_acct.len] = '\0';
		                        PutField_CString(myHash,"stl_bank_acct",(const char*)v_stl_bank_acct.arr);
DEBUGLOG(("GetStlBankDetailbyRange [%05d] stl_bank_acct = [%.*s]\n",iCnt, v_stl_bank_acct.len, v_stl_bank_acct.arr));
				}
		
				iCnt++;
				RecordSet_Add(myRec, myHash);
			}
		}
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetStlBankDetailbyRange Normal Exit\n"));
		return iRet;
	}
	else if (hv_return_value == SP_OTHER_ERR) {
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetStlBankDetailbyRange Exit with error\n"));
		return PD_ERR;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetStlBankDetailbyRange Normal Exit, no record found\n"));
		return PD_OK;
	}

        EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
        return iRet;


getstlbankdetailbyrange_error:
DEBUGLOG(("getstlbankdetailbyrange_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE :c_cursor_id; 
	EXEC SQL FREE :c_cursor_id;
        return PD_ERR;

}

