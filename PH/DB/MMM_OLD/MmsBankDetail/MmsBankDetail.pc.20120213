/*
   Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
   of an authorized representative of Partnerdelight.

   Change Description                                 Change Date             Change By
   -------------------------------                    ------------            --------------
   Init Version                                       2011/11/22              LokMan Chow 
   Add GetBankDetailbyRange, GetNextBankId            2011/12/21              Virginia Yun
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MmsBankDetail.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MmsBankDetail(char    cdebug)
{
	cDebug = cdebug;
}


int GetBankDetail(const char* csBankId,
		hash_t* hRec)
{

	EXEC SQL WHENEVER SQLERROR GOTO getbankdetail_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
	varchar         hv_bank_id[PD_BANK_ID_LEN];
	int             hv_disabled;

	varchar         v_name[PD_NAME_LEN + 1];
	varchar         v_bank_acct[PD_AC_NO_LEN + 1];

	short           ind_name = -1;
	short           ind_bank_acct = -1;

	EXEC SQL END DECLARE SECTION;

	hv_bank_id.len = strlen(csBankId);
	memcpy(hv_bank_id.arr,csBankId,hv_bank_id.len);
	DEBUGLOG(("GetBankDetail bank_id = [%d][%.*s]\n",hv_bank_id.len,hv_bank_id.len,hv_bank_id.arr));

	hv_disabled = 0;

	EXEC SQL DECLARE c_cursor_getbankdetail CURSOR FOR
		select bd_bank_name,
		       bd_bank_acct
			       from mms_bank_detail
			       where bd_bank_id = :hv_bank_id
			       and   bd_disabled = :hv_disabled;

	EXEC SQL OPEN c_cursor_getbankdetail;
	do {
		EXEC SQL FETCH c_cursor_getbankdetail
			INTO
			:v_name:ind_name,
			:v_bank_acct:ind_bank_acct;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}


		DEBUGLOG(("GetBankDetail found record\n"));

		/* bank name */
		if (ind_name >= 0) {
			v_name.arr[v_name.len] = '\0';
			PutField_CString(hRec,"bank_name",(const char*)v_name.arr);
			DEBUGLOG(("GetBankDetail name = [%s]\n",v_name.arr));
		}
		/* bank acct */
		if (ind_bank_acct >= 0) {
			v_bank_acct.arr[v_bank_acct.len] = '\0';
			PutField_CString(hRec,"bank_acct",(const char*)v_bank_acct.arr);
			DEBUGLOG(("GetBankDetail bank_acct = [%s]\n",v_bank_acct.arr));
		}
	}
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getbankdetail;


	DEBUGLOG(("GetBankDetail Normal Exit\n"));
	return  PD_OK;

getbankdetail_error:
	DEBUGLOG(("getbankdetail_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	ERRLOG("BankDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getbankdetail;
	return PD_ERR;
}


int	GetBankDetailbyRange(const char *csBankId, recordset_t *myRec)
{
	hash_t *myHash;
	EXEC SQL WHENEVER SQLERROR GOTO getbankdetailbyrange_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
	varchar		hv_st_bank_id[PD_BANK_ID_LEN];
	int             hv_disabled;

	varchar         v_bank_id[PD_BANK_ID_LEN + 1];
	varchar         v_name[PD_NAME_LEN + 1];
	varchar         v_bank_acct[PD_AC_NO_LEN + 1];

	short		ind_bank_id = -1;
	short           ind_name = -1;
	short           ind_bank_acct = -1;

	EXEC SQL END DECLARE SECTION;

        hv_disabled = 0;
DEBUGLOG(("GetBankDetailbyRange hv_disabled = [%d]\n",hv_disabled));

        hv_st_bank_id.len = strlen(csBankId);
        memcpy(hv_st_bank_id.arr,csBankId,hv_st_bank_id.len);
DEBUGLOG(("GetBankDetailbyRange st_bank_id = [%d][%.*s]\n",hv_st_bank_id.len,hv_st_bank_id.len,hv_st_bank_id.arr));

        EXEC SQL DECLARE c_cursor_getbankdetailbyrange CURSOR FOR
                select bd_bank_id,
		       bd_bank_name,
                       bd_bank_acct
                  from mms_bank_detail
                 where bd_disabled = :hv_disabled
		   and bd_bank_id >= decode(:hv_st_bank_id, '<NULL>', bd_bank_id, :hv_st_bank_id)
	      order by bd_bank_id;


        EXEC SQL OPEN c_cursor_getbankdetailbyrange;
        do {
                EXEC SQL FETCH c_cursor_getbankdetailbyrange
                INTO
			:v_bank_id:ind_bank_id,
                        :v_name:ind_name,
                        :v_bank_acct:ind_bank_acct;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
DEBUGLOG(("GetBankDetailbyRange found record\n"));


		myHash = (hash_t*) malloc(sizeof(hash_t));
		hash_init(myHash, 0);

/* bank id */
                if (ind_bank_id >= 0) {
                        v_bank_id.arr[v_bank_id.len] = '\0';
                        PutField_CString(myHash,"bank_id",(const char*)v_bank_id.arr);
DEBUGLOG(("GetBankDetailbyRange bank_id = [%s]\n",v_bank_id.arr));
		}

/* bank name */
                if (ind_name >= 0) {
                        v_name.arr[v_name.len] = '\0';
                        PutField_CString(myHash,"bank_name",(const char*)v_name.arr);
DEBUGLOG(("GetBankDetail name = [%s]\n",v_name.arr));
                }
/* bank acct */
                if (ind_bank_acct >= 0) {
                        v_bank_acct.arr[v_bank_acct.len] = '\0';
                        PutField_CString(myHash,"bank_acct",(const char*)v_bank_acct.arr);
DEBUGLOG(("GetBankDetail bank_acct = [%s]\n",v_bank_acct.arr));
                }

		RecordSet_Add(myRec, myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getbankdetailbyrange;

DEBUGLOG(("GetBankDetailbyRange Normal Exit\n"));
        return  PD_OK;

getbankdetailbyrange_error:
DEBUGLOG(("getbankdetailbyrange_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getbankdetailbyrange;
        return PD_ERR;


}

int GetNextBankId(const char *csLastBankId,
                 char *csNextBankId)
{
        int iRet = PD_ERR;

        EXEC SQL WHENEVER SQLERROR GOTO getnextbankid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                int             hv_disabled;
                varchar         hv_last_bank_id[PD_BANK_ID_LEN];

                varchar         v_bank_id[PD_BANK_ID_LEN + 1];

                short           ind_bank_id = -1;

        EXEC SQL END DECLARE SECTION;

        hv_last_bank_id.len = strlen(csLastBankId);
        memcpy(hv_last_bank_id.arr,csLastBankId,hv_last_bank_id.len);
DEBUGLOG(("GetNextBankId last_bank_id = [%d][%.*s]\n",hv_last_bank_id.len,hv_last_bank_id.len,hv_last_bank_id.arr));

        hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getnextbankid CURSOR FOR
                select b.bd_bank_id
                from
                        (select a.bd_bank_id
                           from mms_bank_detail a
                          where a.bd_bank_id > :hv_last_bank_id
                            and a.bd_disabled = :hv_disabled
                        order by a.bd_bank_id
                        )b
                where rownum = 1;

        EXEC SQL OPEN c_cursor_getnextbankid;

        EXEC SQL FETCH c_cursor_getnextbankid
        INTO
		:v_bank_id:ind_bank_id;

	if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("GetNextBankId not found\n"));
		iRet = PD_NOT_FOUND;
	}

        if (ind_bank_id >= 0) {
                v_bank_id.arr[v_bank_id.len] = '\0';
                strcpy(csNextBankId, (const char*) v_bank_id.arr);
DEBUGLOG(("GetNextBankId bank_id = [%s] [%s]\n",v_bank_id.arr, csNextBankId));

                iRet = PD_OK;
DEBUGLOG(("GetNextBankId Normal Exit\n"));
        }
        else {
DEBUGLOG(("GetNextBankId Normal Exit, no record found\n"));
        }
        EXEC SQL CLOSE c_cursor_getnextbankid;

        return iRet;

getnextbankid_error:
DEBUGLOG(("getnextbankid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getnextbankid;
        return PD_ERR;

}

