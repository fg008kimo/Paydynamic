/*
   Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
   of an authorized representative of Partnerdelight.

   Change Description                                 Change Date             Change By
   -------------------------------                    ------------            --------------
   Init Version                                       2011/11/22              LokMan Chow 
   Add GetBankDetailbyRange, GetNextBankId            2011/12/21              Virginia Yun
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MmsBankDetail.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MmsBankDetail(char    cdebug)
{
	cDebug = cdebug;
}


int GetBankDetail(const char* csBankId,
		hash_t* hRec)
{

	EXEC SQL WHENEVER SQLERROR GOTO getbankdetail_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
	varchar         hv_bank_id[PD_BANK_ID_LEN];
	int             hv_disabled;

	varchar         v_name[PD_NAME_LEN + 1];
	varchar         v_bank_acct[PD_AC_NO_LEN + 1];

	short           ind_name = -1;
	short           ind_bank_acct = -1;

	EXEC SQL END DECLARE SECTION;

	hv_bank_id.len = strlen(csBankId);
	memcpy(hv_bank_id.arr,csBankId,hv_bank_id.len);
	DEBUGLOG(("GetBankDetail bank_id = [%d][%.*s]\n",hv_bank_id.len,hv_bank_id.len,hv_bank_id.arr));

	hv_disabled = 0;

	EXEC SQL DECLARE c_cursor_getbankdetail CURSOR FOR
		select bd_bank_name,
		       bd_bank_acct
			       from mms_bank_detail
			       where bd_bank_id = :hv_bank_id
			       and   bd_disabled = :hv_disabled;

	EXEC SQL OPEN c_cursor_getbankdetail;
	do {
		EXEC SQL FETCH c_cursor_getbankdetail
			INTO
			:v_name:ind_name,
			:v_bank_acct:ind_bank_acct;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}


		DEBUGLOG(("GetBankDetail found record\n"));

		/* bank name */
		if (ind_name >= 0) {
			v_name.arr[v_name.len] = '\0';
			PutField_CString(hRec,"bank_name",(const char*)v_name.arr);
			DEBUGLOG(("GetBankDetail name = [%s]\n",v_name.arr));
		}
		/* bank acct */
		if (ind_bank_acct >= 0) {
			v_bank_acct.arr[v_bank_acct.len] = '\0';
			PutField_CString(hRec,"bank_acct",(const char*)v_bank_acct.arr);
			DEBUGLOG(("GetBankDetail bank_acct = [%s]\n",v_bank_acct.arr));
		}
	}
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getbankdetail;


	DEBUGLOG(("GetBankDetail Normal Exit\n"));
	return  PD_OK;

getbankdetail_error:
	DEBUGLOG(("getbankdetail_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	ERRLOG("BankDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getbankdetail;
	return PD_ERR;
}


int GetNextBankId(const char *csLastBankId,
                 char *csNextBankId)
{
        int iRet = PD_ERR;

        EXEC SQL WHENEVER SQLERROR GOTO getnextbankid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                int             hv_disabled;
                varchar         hv_last_bank_id[PD_BANK_ID_LEN];

                varchar         v_bank_id[PD_BANK_ID_LEN + 1];

                short           ind_bank_id = -1;

        EXEC SQL END DECLARE SECTION;

        hv_last_bank_id.len = strlen(csLastBankId);
        memcpy(hv_last_bank_id.arr,csLastBankId,hv_last_bank_id.len);
DEBUGLOG(("GetNextBankId last_bank_id = [%d][%.*s]\n",hv_last_bank_id.len,hv_last_bank_id.len,hv_last_bank_id.arr));

        hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getnextbankid CURSOR FOR
                select b.bd_bank_id
                from
                        (select a.bd_bank_id
                           from mms_bank_detail a
                          where a.bd_bank_id > :hv_last_bank_id
                            and a.bd_disabled = :hv_disabled
                        order by a.bd_bank_id
                        )b
                where rownum = 1;

        EXEC SQL OPEN c_cursor_getnextbankid;

        EXEC SQL FETCH c_cursor_getnextbankid
        INTO
		:v_bank_id:ind_bank_id;

	if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("GetNextBankId not found\n"));
		iRet = PD_NOT_FOUND;
	}

        if (ind_bank_id >= 0) {
                v_bank_id.arr[v_bank_id.len] = '\0';
                strcpy(csNextBankId, (const char*) v_bank_id.arr);
DEBUGLOG(("GetNextBankId bank_id = [%s] [%s]\n",v_bank_id.arr, csNextBankId));

                iRet = PD_OK;
DEBUGLOG(("GetNextBankId Normal Exit\n"));
        }
        else {
DEBUGLOG(("GetNextBankId Normal Exit, no record found\n"));
        }
        EXEC SQL CLOSE c_cursor_getnextbankid;

        return iRet;

getnextbankid_error:
DEBUGLOG(("getnextbankid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getnextbankid;
        return PD_ERR;

}

int     GetBankDetailbyRange(const hash_t *hRec, recordset_t *myRec)
{
	int iRet = PD_OK;
	int iCnt = 0;

	char *csTmp = NULL;
	int  iRowNum = 0;

        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getbankdetailbyrange_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
	short		hv_return_value;

        varchar         hv_st_bank_id[PD_BANK_ID_LEN];
        int             hv_disabled;

        varchar         v_bank_id[PD_BANK_ID_LEN + 1];
        varchar         v_name[PD_NAME_LEN + 1];
        varchar         v_bank_acct[PD_AC_NO_LEN + 1];

	short		ind_st_bank_id = -1;
	short		ind_disabled = -1;

        short           ind_bank_id = -1;
        short           ind_name = -1;
        short           ind_bank_acct = -1;

	SQL_CURSOR	c_cursor_id;

        EXEC SQL END DECLARE SECTION;

        hv_disabled = 0;
	ind_disabled = 0;
DEBUGLOG(("GetBankDetailbyRange hv_disabled = [%d]\n",hv_disabled));


	if (GetField_Int(hRec, "max_rtn", &iRowNum)) {
DEBUGLOG(("GetBankDetailbyRange max_rtn = [%d]\n", iRowNum));
	}
		

	if (GetField_CString(hRec, "start_bank_id", &csTmp)) {
	        hv_st_bank_id.len = strlen(csTmp);
		memcpy(hv_st_bank_id.arr, csTmp, hv_st_bank_id.len);
		ind_st_bank_id = 0;
DEBUGLOG(("GetBankDetailbyRange st_bank_id = [%d][%.*s]\n",hv_st_bank_id.len,hv_st_bank_id.len,hv_st_bank_id.arr));
	}


	EXEC SQL ALLOCATE   :c_cursor_id;
	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_mms_bank_detail_range(:hv_st_bank_id:ind_st_bank_id,
								     :hv_disabled:ind_disabled,
								     :c_cursor_id);	
		END;
	END-EXEC;
	
	if (hv_return_value == SP_OK) {

DEBUGLOG(("GetBankDetailbyRange found record\n"));
		for (;;) {
			myHash = (hash_t*) malloc(sizeof(hash_t));
			hash_init(myHash, 0);

			ind_bank_id = -1;
			ind_name = -1;
			ind_bank_acct = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_bank_id:ind_bank_id,
				:v_name:ind_name,
				:v_bank_acct:ind_bank_acct;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (iCnt < iRowNum + 1 || iRowNum == 0) { 

				if (ind_bank_id >= 0) {
					v_bank_id.arr[v_bank_id.len] = '\0';
					PutField_CString(myHash,"bank_id",(const char*)v_bank_id.arr);
DEBUGLOG(("GetBankDetailbyRange [%05d] bank_id = [%.*s]\n",iCnt, v_bank_id.len, v_bank_id.arr));
				}

				if (ind_name >= 0) {
					v_name.arr[v_name.len] = '\0';
					PutField_CString(myHash,"bank_name",(const char*)v_name.arr);
DEBUGLOG(("GetBankDetailbyRange [%05d] name = [%.*s]\n",iCnt, v_name.len, v_name.arr));
				}

				if (ind_bank_acct >= 0) {
                        		v_bank_acct.arr[v_bank_acct.len] = '\0';
		                        PutField_CString(myHash,"bank_acct",(const char*)v_bank_acct.arr);
DEBUGLOG(("GetBankDetailbyRange [%05d] bank_acct = [%.*s]\n",iCnt, v_bank_acct.len, v_bank_acct.arr));
				}
		
				iCnt++;
				RecordSet_Add(myRec, myHash);
			}
		}
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetBankDetailbyRange Normal Exit\n"));
		return iRet;
	}
	else if (hv_return_value == SP_OTHER_ERR) {
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetBankDetailbyRange Exit with error\n"));
		return PD_ERR;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetBankDetailbyRange Normal Exit, no record found\n"));
		return PD_OK;
	}

        EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
        return iRet;


getbankdetailbyrange_error:
DEBUGLOG(("getbankdetailbyrange_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("BankDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE :c_cursor_id; 
	EXEC SQL FREE :c_cursor_id;
        return PD_ERR;

}

