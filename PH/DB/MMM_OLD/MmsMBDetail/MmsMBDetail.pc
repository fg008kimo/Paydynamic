/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/11/22              LokMan Chow 
Add GetMBDetailbyRange, GetNextMBId		   2011/12/21	           Virginia Yun	
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MmsMBDetail.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MmsMBDetail(char    cdebug)
{
        cDebug = cdebug;
}


int GetMBDetail(const char* csMBId,
                hash_t* hRec)
{

        EXEC SQL WHENEVER SQLERROR GOTO getmbdetail_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_mb_id[PD_MB_ID_LEN];
                int             hv_disabled;

                varchar         v_name[PD_NAME_LEN + 1];

                short           ind_name = -1;

        EXEC SQL END DECLARE SECTION;

        hv_mb_id.len = strlen(csMBId);
        memcpy(hv_mb_id.arr,csMBId,hv_mb_id.len);
DEBUGLOG(("GetMBDetail mb_id = [%d][%.*s]\n",hv_mb_id.len,hv_mb_id.len,hv_mb_id.arr));

	hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getmbdetail CURSOR FOR
                select md_mb_name
                  from mms_mb_detail
                 where md_mb_id = :hv_mb_id
		 and   md_disabled = :hv_disabled;

        EXEC SQL OPEN c_cursor_getmbdetail;
        do {
                EXEC SQL FETCH c_cursor_getmbdetail
                INTO
                        :v_name:ind_name;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }


DEBUGLOG(("GetMBDetail found record\n"));

/* mb name */
                if (ind_name >= 0) {
                        v_name.arr[v_name.len] = '\0';
                        PutField_CString(hRec,"mb_name",(const char*)v_name.arr);
DEBUGLOG(("GetMBDetail mb_name = [%s]\n",v_name.arr));
                }
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getmbdetail;


DEBUGLOG(("GetMBDetail Normal Exit\n"));
        return  PD_OK;

getmbdetail_error:
DEBUGLOG(("getmbdetail_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MBDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getmbdetail;
        return PD_ERR;
}


int GetNextMBId(const char *csLastMBId,
                 char *csNextMBId)
{
        int iRet = PD_ERR;

        EXEC SQL WHENEVER SQLERROR GOTO getnextmbid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                int             hv_disabled;
                varchar         hv_last_mb_id[PD_MB_ID_LEN];

                varchar         v_mb_id[PD_MB_ID_LEN + 1];

                short           ind_mb_id = -1;

        EXEC SQL END DECLARE SECTION;

        hv_last_mb_id.len = strlen(csLastMBId);
        memcpy(hv_last_mb_id.arr,csLastMBId,hv_last_mb_id.len);
DEBUGLOG(("GetNextMBId last_mb_id = [%d][%.*s]\n",hv_last_mb_id.len,hv_last_mb_id.len,hv_last_mb_id.arr));

        hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getnextmbid CURSOR FOR
                select b.md_mb_id
                from
                        (select a.md_mb_id
                           from mms_mb_detail a
                          where a.md_mb_id > :hv_last_mb_id
                            and a.md_disabled = :hv_disabled
                        order by a.md_mb_id
                        )b
                where rownum = 1;

        EXEC SQL OPEN c_cursor_getnextmbid;

        EXEC SQL FETCH c_cursor_getnextmbid
        INTO
                :v_mb_id:ind_mb_id;

        if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("GetNextMBId not found\n"));
		iRet = PD_NOT_FOUND;
        }

        if (ind_mb_id >= 0) {
                v_mb_id.arr[v_mb_id.len] = '\0';
                strcpy(csNextMBId, (const char*) v_mb_id.arr);
DEBUGLOG(("GetNextMBId mb_id = [%s] [%s]\n",v_mb_id.arr, csNextMBId));

                iRet = PD_OK;
DEBUGLOG(("GetNextMBId Normal Exit\n"));
        }
        else {
DEBUGLOG(("GetNextMBId Normal Exit, no record found\n"));
        }
        EXEC SQL CLOSE c_cursor_getnextmbid;

        return iRet;

getnextmbid_error:
DEBUGLOG(("getnextmbid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getnextmbid;
        return PD_ERR;

}

int     GetMBDetailbyRange(const hash_t *hRec, recordset_t *myRec)
{
        int iRet = PD_OK;
        int iCnt = 0;

        char *csTmp = NULL;
        int  iRowNum = 0;

        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getmbdetailbyrange_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
        short           hv_return_value;

        varchar         hv_st_mb_id[PD_MB_ID_LEN];
        int             hv_disabled;

        varchar         v_mb_id[PD_MB_ID_LEN + 1];
        varchar         v_name[PD_NAME_LEN + 1];

        short           ind_st_mb_id = -1;
        short           ind_disabled = -1;

        short           ind_mb_id = -1;
        short           ind_name = -1;

        SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

        hv_disabled = 0;
        ind_disabled = 0;
DEBUGLOG(("GetMBDetailbyRange hv_disabled = [%d]\n",hv_disabled));


        if (GetField_Int(hRec, "max_rtn", &iRowNum)) {
DEBUGLOG(("GetMBDetailbyRange max_rtn = [%d]\n", iRowNum));
        }

        if (GetField_CString(hRec, "start_mb_id", &csTmp)) {
                hv_st_mb_id.len = strlen(csTmp);
                memcpy(hv_st_mb_id.arr, csTmp, hv_st_mb_id.len);
                ind_st_mb_id = 0;
DEBUGLOG(("GetMBDetailbyRange st_mb_id = [%d][%.*s]\n",hv_st_mb_id.len,hv_st_mb_id.len,hv_st_mb_id.arr));
        }

        EXEC SQL ALLOCATE   :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_mms_mb_detail_range(:hv_st_mb_id:ind_st_mb_id,
                                                                   :hv_disabled:ind_disabled,
                                                                   :c_cursor_id);
                END;
        END-EXEC;

        if (hv_return_value == SP_OK) {

DEBUGLOG(("GetMBDetailbyRange found record\n"));
                for (;;) {
                        myHash = (hash_t*) malloc(sizeof(hash_t));
                        hash_init(myHash, 0);

                        ind_mb_id = -1;
                        ind_name = -1;

                        EXEC SQL WHENEVER NOTFOUND DO break;
                        EXEC SQL FETCH :c_cursor_id
                        INTO    :v_mb_id:ind_mb_id,
                                :v_name:ind_name;

                        if (SQLCODE == SQL_NOT_FOUND) {
                                break;
                        }

                        if (iCnt < iRowNum + 1 || iRowNum == 0) {

                                if (ind_mb_id >= 0) {
                                        v_mb_id.arr[v_mb_id.len] = '\0';
                                        PutField_CString(myHash,"mb_id",(const char*)v_mb_id.arr);
DEBUGLOG(("GetMBDetailbyRange [%05d] mb_id = [%.*s]\n",iCnt, v_mb_id.len, v_mb_id.arr));
                                }

                                if (ind_name >= 0) {
                                        v_name.arr[v_name.len] = '\0';
                                        PutField_CString(myHash,"mb_name",(const char*)v_name.arr);
DEBUGLOG(("GetMBDetailbyRange [%05d] name = [%.*s]\n",iCnt, v_name.len, v_name.arr));
                                }


                                iCnt++;
                                RecordSet_Add(myRec, myHash);
                        }
                }
                EXEC SQL CLOSE :c_cursor_id;
                EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetMBDetailbyRange Normal Exit\n"));
                return iRet;
        }
        else if (hv_return_value == SP_OTHER_ERR) {
                EXEC SQL CLOSE :c_cursor_id;
                EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetMBDetailbyRange Exit with error\n"));
                return PD_ERR;
        }
        else {
                EXEC SQL CLOSE :c_cursor_id;
                EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetMBDetailbyRange Normal Exit, no record found\n"));
                return PD_OK;
        }
        EXEC SQL CLOSE :c_cursor_id;
        EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
        return iRet;


getmbdetailbyrange_error:
DEBUGLOG(("getmbdetailbyrange_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MBDetailByRange_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE :c_cursor_id;
        EXEC SQL FREE :c_cursor_id;
        return PD_ERR;

}
