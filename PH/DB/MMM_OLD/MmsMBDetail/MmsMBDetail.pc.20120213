/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/11/22              LokMan Chow 
Add GetMBDetailbyRange, GetNextMBId		   2011/12/21	           Virginia Yun	
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MmsMBDetail.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MmsMBDetail(char    cdebug)
{
        cDebug = cdebug;
}


int GetMBDetail(const char* csMBId,
                hash_t* hRec)
{

        EXEC SQL WHENEVER SQLERROR GOTO getmbdetail_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_mb_id[PD_MB_ID_LEN];
                int             hv_disabled;

                varchar         v_name[PD_NAME_LEN + 1];

                short           ind_name = -1;

        EXEC SQL END DECLARE SECTION;

        hv_mb_id.len = strlen(csMBId);
        memcpy(hv_mb_id.arr,csMBId,hv_mb_id.len);
DEBUGLOG(("GetMBDetail mb_id = [%d][%.*s]\n",hv_mb_id.len,hv_mb_id.len,hv_mb_id.arr));

	hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getmbdetail CURSOR FOR
                select md_mb_name
                  from mms_mb_detail
                 where md_mb_id = :hv_mb_id
		 and   md_disabled = :hv_disabled;

        EXEC SQL OPEN c_cursor_getmbdetail;
        do {
                EXEC SQL FETCH c_cursor_getmbdetail
                INTO
                        :v_name:ind_name;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }


DEBUGLOG(("GetMBDetail found record\n"));

/* bank name */
                if (ind_name >= 0) {
                        v_name.arr[v_name.len] = '\0';
                        PutField_CString(hRec,"mb_name",(const char*)v_name.arr);
DEBUGLOG(("GetMBDetail mb_name = [%s]\n",v_name.arr));
                }
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getmbdetail;


DEBUGLOG(("GetMBDetail Normal Exit\n"));
        return  PD_OK;

getmbdetail_error:
DEBUGLOG(("getmbdetail_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MBDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getmbdetail;
        return PD_ERR;
}


int     GetMBDetailbyRange(const char *csMBId, recordset_t *myRec)
{
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getmbdetailbyrange_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
        varchar         hv_st_mb_id[PD_MB_ID_LEN];
        int             hv_disabled;

        varchar         v_mb_id[PD_MB_ID_LEN + 1];
        varchar         v_name[PD_NAME_LEN + 1];

        short           ind_mb_id = -1;
        short           ind_name = -1;

        EXEC SQL END DECLARE SECTION;

        hv_disabled = 0;

        hv_st_mb_id.len = strlen(csMBId);
        memcpy(hv_st_mb_id.arr,csMBId,hv_st_mb_id.len);
DEBUGLOG(("GetMBDetailbyRange st_mb_id = [%d][%.*s]\n",hv_st_mb_id.len,hv_st_mb_id.len,hv_st_mb_id.arr));

        EXEC SQL DECLARE c_cursor_getmbdetailbyrange CURSOR FOR
                select md_mb_id,
                       md_mb_name
                  from mms_mb_detail
                 where md_disabled = :hv_disabled
                   and md_mb_id >= decode(:hv_st_mb_id, '<NULL>', md_mb_id, :hv_st_mb_id)
              order by md_mb_id;

        EXEC SQL OPEN c_cursor_getmbdetailbyrange;
        do {
                EXEC SQL FETCH c_cursor_getmbdetailbyrange
                INTO
                        :v_mb_id:ind_mb_id,
                        :v_name:ind_name;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
DEBUGLOG(("GetMBDetailbyRange found record\n"));


                myHash = (hash_t*) malloc(sizeof(hash_t));
                hash_init(myHash, 0);


/* mb id */
                if (ind_mb_id >= 0) {
                        v_mb_id.arr[v_mb_id.len] = '\0';
                        PutField_CString(myHash,"mb_id",(const char*)v_mb_id.arr);
DEBUGLOG(("GetMBDetailbyRange mb_id = [%s]\n",v_mb_id.arr));
                }

/* mb name */
                if (ind_name >= 0) {
                        v_name.arr[v_name.len] = '\0';
                        PutField_CString(myHash,"mb_name",(const char*)v_name.arr);
DEBUGLOG(("GetMBDetail name = [%s]\n",v_name.arr));
                }

                RecordSet_Add(myRec, myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getmbdetailbyrange;

DEBUGLOG(("GetMBDetailbyRange Normal Exit\n"));
        return  PD_OK;

getmbdetailbyrange_error:
DEBUGLOG(("getmbdetailbyrange_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MBDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getmbdetailbyrange;
        return PD_ERR;


}

int GetNextMBId(const char *csLastMBId,
                 char *csNextMBId)
{
        int iRet = PD_ERR;

        EXEC SQL WHENEVER SQLERROR GOTO getnextmbid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                int             hv_disabled;
                varchar         hv_last_mb_id[PD_MB_ID_LEN];

                varchar         v_mb_id[PD_MB_ID_LEN + 1];

                short           ind_mb_id = -1;

        EXEC SQL END DECLARE SECTION;

        hv_last_mb_id.len = strlen(csLastMBId);
        memcpy(hv_last_mb_id.arr,csLastMBId,hv_last_mb_id.len);
DEBUGLOG(("GetNextMBId last_mb_id = [%d][%.*s]\n",hv_last_mb_id.len,hv_last_mb_id.len,hv_last_mb_id.arr));

        hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getnextmbid CURSOR FOR
                select b.md_mb_id
                from
                        (select a.md_mb_id
                           from mms_mb_detail a
                          where a.md_mb_id > :hv_last_mb_id
                            and a.md_disabled = :hv_disabled
                        order by a.md_mb_id
                        )b
                where rownum = 1;

        EXEC SQL OPEN c_cursor_getnextmbid;

        EXEC SQL FETCH c_cursor_getnextmbid
        INTO
                :v_mb_id:ind_mb_id;

        if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("GetNextMBId not found\n"));
		iRet = PD_NOT_FOUND;
        }

        if (ind_mb_id >= 0) {
                v_mb_id.arr[v_mb_id.len] = '\0';
                strcpy(csNextMBId, (const char*) v_mb_id.arr);
DEBUGLOG(("GetNextMBId mb_id = [%s] [%s]\n",v_mb_id.arr, csNextMBId));

                iRet = PD_OK;
DEBUGLOG(("GetNextMBId Normal Exit\n"));
        }
        else {
DEBUGLOG(("GetNextMBId Normal Exit, no record found\n"));
        }
        EXEC SQL CLOSE c_cursor_getnextmbid;

        return iRet;

getnextmbid_error:
DEBUGLOG(("getnextmbid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getnextmbid;
        return PD_ERR;

}

