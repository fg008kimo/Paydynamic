/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/07/29              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "ServicePayMethod.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void ServicePayMethod(char    cdebug)
{
        cDebug = cdebug;
}

int IsServicePayMethodSupported(const char* csServiceCode,
                        const char* csPayMethod)
{
	
        EXEC SQL WHENEVER SQLERROR GOTO supp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];
		varchar	hv_pay_method[PD_PAY_METHOD_LEN];


		char    v_disabled;

                short   ind_disabled = -1;
        EXEC SQL END DECLARE SECTION;

	hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindServicePayMethod: service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len)); 

	hv_pay_method.len = strlen(csPayMethod);
        memcpy(hv_pay_method.arr,csPayMethod,hv_pay_method.len);
DEBUGLOG(("FindServicePayMethod: pay_method = [%.*s][%d]\n",hv_pay_method.len,hv_pay_method.arr,hv_pay_method.len)); 

	EXEC SQL select sp_disabled
                   into :v_disabled:ind_disabled
                   from service_pay_method
                  Where sp_service_code = :hv_service_code
                    And sp_pay_method = :hv_pay_method;

        if (ind_disabled >= 0) {
DEBUGLOG(("FindServicePayMethod: sp_disabled = %c\n",v_disabled));
                if (v_disabled != PD_DISABLED)
                        return PD_TRUE;
                else
                        return PD_FALSE;
        }
DEBUGLOG(("FindServicePayMethod: [%s][%s] Pay Method not supported\n",csServiceCode,csPayMethod));

        return PD_FALSE;
supp_error:
DEBUGLOG(("supp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_ERR;
}

int FindPayMethod(const char* csServiceCode,
                  recordset_t* myRec)
{
	hash_t *myHash;
	
        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];

		varchar	v_pay_method[PD_PAY_METHOD_LEN+1];

                short   ind_pay_method = -1;
        EXEC SQL END DECLARE SECTION;

	hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindPayMethod: service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len)); 

	EXEC SQL DECLARE c_cursor_find CURSOR FOR
		select	sp_pay_method
		from	service_pay_method
		Where	sp_service_code = :hv_service_code
		and	sp_disabled = '0';

	EXEC SQL OPEN c_cursor_find;
        do {
                EXEC SQL FETCH c_cursor_find
                INTO
			:v_pay_method:ind_pay_method;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

        	if (ind_pay_method >= 0) {
			v_pay_method.arr[v_pay_method.len] ='\0';
			PutField_CString(myHash,"pay_method",(const char*)v_pay_method.arr);
DEBUGLOG(("FindPayMethod: pay_method = [%s]\n",v_pay_method.arr));
        	}

		RecordSet_Add(myRec,myHash);

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_find;

DEBUGLOG(("FindPayMethod Normal Exit\n"));
        return PD_OK;

find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_find;
    return PD_ERR;
}

int GetPayMethodInfo(const char* csServiceCode,
			recordset_t* myRec)
{
	hash_t *myHash;
	
        EXEC SQL WHENEVER SQLERROR GOTO get_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];

		varchar	v_psp_id[PD_PSP_ID_LEN+1];

                short   ind_psp_id = -1;
        EXEC SQL END DECLARE SECTION;

	hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetPayMethodInfo: service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len)); 

	EXEC SQL DECLARE c_cursor_get CURSOR FOR
		select	pp_psp_id
		from	service_pay_method,
			psp_pay_method,
			psp_detail,
			psp_master
		Where	sp_service_code = :hv_service_code
		and	pp_pay_method = sp_pay_method
		and	psp_id = pp_psp_id
		and	pm_client_id = client_id
		and	disabled = 0
		and	status = 'O'
		and	pm_status = 'O'
		and	sp_disabled = 0
		and	pp_disabled = 0;

	EXEC SQL OPEN c_cursor_get;
        do {
                EXEC SQL FETCH c_cursor_get
                INTO
			:v_psp_id:ind_psp_id;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

        	if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len] ='\0';
			PutField_CString(myHash,"psp_id",(const char*)v_psp_id.arr);
DEBUGLOG(("GetPayMethodInfo: psp_id = [%s]\n",v_psp_id.arr));
        	}

		RecordSet_Add(myRec,myHash);

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_get;

DEBUGLOG(("GetPayMethodInfo Normal Exit\n"));
        return PD_OK;

get_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_get;
    return PD_ERR;
}
