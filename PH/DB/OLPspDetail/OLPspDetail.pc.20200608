/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/01/02              David Wong
Add GetPspIdByPspName				   2015/06/03		   Elvis Wong
Modify "Add", Add "GetNextPIDCode"		   2016/07/19		   Dirk Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLPspDetail.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char cDebug;


void OLPspDetail(char cdebug)
{
	cDebug = cdebug;
}


int Add(const hash_t *hPspDetail)
{
	char *csTmp;
	char cTmp;
	int  iTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_psp_id[PD_PSP_ID_LEN];
		varchar		hv_psp_name[PD_PSP_NAME_LEN];
		int		hv_disabled;
		varchar		hv_client_id[PD_CLIENT_ID_LEN];
		varchar		hv_bank_acct_type[PD_ACCT_TYPE_LEN];
		varchar		hv_ccy[PD_CCY_ID_LEN];
		varchar		hv_status[PD_ACCOUNT_STATUS_LEN];
		int		hv_payout_split_limit;
		char		hv_business_type;
		int		hv_code_in_num;
		varchar		hv_create_user[PD_USER_LEN];

		short		ind_psp_id = -1;
		short		ind_psp_name = -1;
		short		ind_disabled = -1;
		short		ind_client_id= -1;
		short		ind_bank_acct_type = -1;
		short		ind_ccy = -1;
		short		ind_status = -1;
		short		ind_payout_split_limit = -1;
		short		ind_business_type = -1;
		short		ind_code_in_num = -1;
		short		ind_create_user = -1;

		short		hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

	if (GetField_CString(hPspDetail, "psp_id", &csTmp))
	{
		hv_psp_id.len = strlen(csTmp);
		strncpy((char*)hv_psp_id.arr, csTmp, hv_psp_id.len);
		ind_psp_id = 0;
	}
DEBUGLOG(("Add: psp_id = [%.*s]\n", hv_psp_id.len, hv_psp_id.arr));

	if (GetField_CString(hPspDetail, "psp_name", &csTmp))
	{
		hv_psp_name.len = strlen(csTmp);
		strncpy((char*)hv_psp_name.arr, csTmp, hv_psp_name.len);
		ind_psp_name = 0;
	}
DEBUGLOG(("Add: psp_name = [%.*s]\n", hv_psp_name.len, hv_psp_name.arr));

	if (GetField_Int(hPspDetail, "disabled", &iTmp))
	{
		hv_disabled = iTmp;
		ind_disabled = 0;
	}
DEBUGLOG(("Add: disabled = [%d]\n", hv_disabled));

	if (GetField_CString(hPspDetail, "client_id", &csTmp))
	{
		hv_client_id.len = strlen(csTmp);
		strncpy((char*)hv_client_id.arr, csTmp, hv_client_id.len);
		ind_client_id = 0;
	}
DEBUGLOG(("Add: client_id = [%.*s]\n", hv_client_id.len, hv_client_id.arr));

	if (GetField_CString(hPspDetail, "bank_acct_type", &csTmp))
	{
		hv_bank_acct_type.len = strlen(csTmp);
		strncpy((char*)hv_bank_acct_type.arr, csTmp, hv_bank_acct_type.len);
		ind_bank_acct_type = 0;
	}
DEBUGLOG(("Add: bank_acct_type = [%.*s]\n", hv_bank_acct_type.len, hv_bank_acct_type.arr));

	if (GetField_CString(hPspDetail, "ccy", &csTmp))
	{
		hv_ccy.len = strlen(csTmp);
		strncpy((char*)hv_ccy.arr, csTmp, hv_ccy.len);
		ind_ccy = 0;
	}
DEBUGLOG(("Add: ccy = [%.*s]\n", hv_ccy.len, hv_ccy.arr));

	if (GetField_CString(hPspDetail, "status", &csTmp))
	{
		hv_status.len = strlen(csTmp);
		strncpy((char*)hv_status.arr, csTmp, hv_status.len);
		ind_status = 0;
	}
DEBUGLOG(("Add: status = [%.*s]\n", hv_status.len, hv_status.arr));

	if (GetField_Int(hPspDetail, "payout_split_limit", &iTmp))
	{
		hv_payout_split_limit = iTmp;
		ind_payout_split_limit = 0;
	}
DEBUGLOG(("Add: payout_split_limit = [%d]\n", iTmp));

	if (GetField_Char(hPspDetail, "business_type", &cTmp))
	{
		hv_business_type = cTmp;
		ind_business_type = 0;
	}
DEBUGLOG(("Add: business_type = [%c]\n", cTmp));

	if (GetField_Int(hPspDetail, "code_in_num", &iTmp))
	{
		hv_code_in_num = iTmp;
		ind_code_in_num = 0;
	}
DEBUGLOG(("Add: code_in_num = [%d]\n", iTmp));

	if (GetField_CString(hPspDetail, "create_user", &csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Add: create_user = [%.*s]\n", hv_create_user.len, hv_create_user.arr));

	FREE_ME(csTmp);

	EXEC SQL EXECUTE
	BEGIN
		:hv_return_value := sp_ol_psp_detail_insert(
				:hv_psp_id:ind_psp_id,
				:hv_psp_name:ind_psp_name,
				:hv_disabled:ind_disabled,
				:hv_client_id:ind_client_id,
				:hv_bank_acct_type:ind_bank_acct_type,
				:hv_ccy:ind_ccy,
				:hv_status:ind_status,
				:hv_payout_split_limit:ind_payout_split_limit,
				:hv_business_type:ind_business_type,
				:hv_code_in_num:ind_code_in_num,
				:hv_create_user:ind_create_user);
	END;
	END-EXEC;

	DEBUGLOG(("Add: Ret = [%d]\n", hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Add: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
		ERRLOG("OLPspDetail_Add: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
		ERRLOG("OLPspDetail_Add: SP_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPspDetail_Add: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int Delete(const char* csPspId, const char* csClientId)
{
	EXEC SQL WHENEVER SQLERROR GOTO delete_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_psp_id[PD_PSP_ID_LEN];
		varchar hv_client_id[PD_CLIENT_ID_LEN];

		short hv_return_value;
	EXEC SQL END DECLARE SECTION;

	hv_psp_id.len = strlen((const char*)csPspId);
	memcpy(hv_psp_id.arr, csPspId, hv_psp_id.len);
DEBUGLOG(("Delete: psp_id = [%.*s]\n", hv_psp_id.len, hv_psp_id.arr));

	hv_client_id.len = strlen((const char*)csClientId);
	memcpy(hv_client_id.arr, csClientId, hv_client_id.len);
DEBUGLOG(("Delete: client_id = [%.*s]\n", hv_client_id.len, hv_client_id.arr));

	EXEC SQL EXECUTE
	BEGIN
		:hv_return_value := sp_ol_psp_detail_delete(
				:hv_psp_id,
				:hv_client_id);
	END;
	END-EXEC;

	DEBUGLOG(("Delete: Ret = [%d]\n", hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Delete: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("OLPspDetail_Delete: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Delete: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("OLPspDetail_Delete: SP_ERR TxnAbort\n");
		DEBUGLOG(("Delete: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

delete_error:
DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPspDetail_Delete: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetPspDetail(const char* csPspId, hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getpspdetail_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_psp_id[PD_PSP_ID_LEN];
		int		hv_disabled;
		varchar		v_psp_name[PD_NAME_LEN + 1];
		varchar		v_client_id[PD_CLIENT_ID_LEN + 1];
		varchar		v_bank_acct_type[PD_ACCT_TYPE_LEN + 1];
		varchar		v_ccy[PD_CCY_ID_LEN + 1];
		varchar		v_status[PD_ACCOUNT_STATUS_LEN + 1];
		int		v_payout_format;

		short		ind_psp_name = -1;
		short		ind_client_id = -1;
		short		ind_bank_acct_type = -1;
		short		ind_ccy = -1;
		short		ind_status = -1;
		short           ind_payout_format = -1;
	EXEC SQL END DECLARE SECTION;

	hv_psp_id.len = strlen(csPspId);
	memcpy(hv_psp_id.arr, csPspId, hv_psp_id.len);
DEBUGLOG(("GetPspDetail psp_id = [%.*s]\n", hv_psp_id.len, hv_psp_id.arr));

	hv_disabled = 0;

	EXEC SQL DECLARE c_cursor_getpspdetail CURSOR FOR
		select opd_psp_name,
			opd_client_id,
			opd_bank_acct_type,
			opd_currency_id,
			opd_payout_format,
			opd_status
		from ol_psp_detail
		where opd_psp_id = :hv_psp_id
		and opd_disabled = :hv_disabled;

	EXEC SQL OPEN c_cursor_getpspdetail;
	do {
		EXEC SQL FETCH c_cursor_getpspdetail
		INTO
			:v_psp_name:ind_psp_name,
			:v_client_id:ind_client_id,
			:v_bank_acct_type:ind_bank_acct_type,
			:v_ccy:ind_ccy,
			:v_payout_format:ind_payout_format,
			:v_status:ind_status;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

DEBUGLOG(("GetPspDetail found record\n"));

/* psp name */
		if (ind_psp_name >= 0) {
			v_psp_name.arr[v_psp_name.len] = '\0';
			PutField_CString(hRec, "psp_name", (const char*)v_psp_name.arr);
DEBUGLOG(("GetPspDetail psp_name = [%s]\n", v_psp_name.arr));
		}

/* client_id*/
		if (ind_client_id >= 0) {
			v_client_id.arr[v_client_id.len] = '\0';
			PutField_CString(hRec, "client_id", (const char*)v_client_id.arr);
DEBUGLOG(("GetPspDetail client_id = [%s]\n", v_client_id.arr));
		}

/* payout_format */
                if (ind_payout_format>= 0) {
                        PutField_Int(hRec,"payout_format",v_payout_format);
DEBUGLOG(("GetPspDetail payout_format = [%d]\n",v_payout_format));
                }

/* bank_acct_type */
		if (ind_bank_acct_type >= 0) {
			v_bank_acct_type.arr[v_bank_acct_type.len] = '\0';
			PutField_CString(hRec, "bank_acct_type", (const char*)v_bank_acct_type.arr);
DEBUGLOG(("GetPspDetail bank_acct_type = [%s]\n", v_bank_acct_type.arr));
		}

/* ccy*/
		if (ind_ccy >= 0) {
			v_ccy.arr[v_ccy.len] = '\0';
			PutField_CString(hRec, "ccy", (const char*)v_ccy.arr);
DEBUGLOG(("GetPspDetail ccy = [%s]\n", v_ccy.arr));
		}

/* status */
		if (ind_status >= 0) {
			v_status.arr[v_status.len] = '\0';
			PutField_CString(hRec, "status", (const char*)v_status.arr);
DEBUGLOG(("GetPspDetail status = [%s]\n", v_status.arr));
		}
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getpspdetail;

DEBUGLOG(("GetPspDetail Normal Exit\n"));
	return PD_OK;

getpspdetail_error:
DEBUGLOG(("getpspdetail_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPspDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getpspdetail;
	return PD_ERR;
}


int Update(const hash_t *hRls)
{
	char* csTmp;
	char* csPspId;
	int   iTmp;

	EXEC SQL WHENEVER SQLERROR GOTO update_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_dynstmt[1024];
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));
	strcpy((char*)hv_dynstmt.arr, "update ol_psp_detail set opd_update_timestamp = sysdate");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

	GetField_CString(hRls, "psp_id", &csPspId);
DEBUGLOG(("Update: psp_id = [%s]\n", csPspId));

/* psp_name*/
	if (GetField_CString(hRls, "psp_name", &csTmp)) {
DEBUGLOG(("Update: psp_name = [%s]\n", csTmp));
		strcat((char*)hv_dynstmt.arr, ", opd_psp_name = '");
		strcat((char*)hv_dynstmt.arr, csTmp);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

/* bank_acct_type */
	if (GetField_CString(hRls, "bank_acct_type", &csTmp)) {
DEBUGLOG(("Update: bank_acct_type = [%s]\n", csTmp));
		strcat((char*)hv_dynstmt.arr, ", opd_bank_acct_type = '");
		strcat((char*)hv_dynstmt.arr, csTmp);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

/* status */
	if (GetField_CString(hRls, "status", &csTmp)) {
DEBUGLOG(("Update: status = [%s]\n", csTmp));
		strcat((char*)hv_dynstmt.arr, ", opd_status = '");
		strcat((char*)hv_dynstmt.arr, csTmp);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

/* psp_remark */
	if (GetField_CString(hRls, "psp_remark", &csTmp)) {
DEBUGLOG(("Update: psp_remark = [%s]\n", csTmp));
		strcat((char*)hv_dynstmt.arr, ", opd_psp_remark = '");
		strcat((char*)hv_dynstmt.arr, csTmp);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

/* processor_name */
	if (GetField_CString(hRls, "processor_name", &csTmp)) {
DEBUGLOG(("Update: processor_name = [%s]\n", csTmp));
		strcat((char*)hv_dynstmt.arr, ", opd_processor_name = '");
		strcat((char*)hv_dynstmt.arr, csTmp);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

/* payout_split_limit */
        if (GetField_Int(hRls, "payout_split_limit", &iTmp)) {
DEBUGLOG(("Update:payout_split_limit = [%d]\n",iTmp));
                sprintf(csTmp, "%d", iTmp);
                strcat((char*)hv_dynstmt.arr, ", opd_payout_split_limit = ");
                strcat((char*)hv_dynstmt.arr, csTmp);
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

/* update_user */
	if (GetField_CString(hRls, "update_user", &csTmp)) {
DEBUGLOG(("Update: update_user = [%s]\n", csTmp));
		strcat((char*)hv_dynstmt.arr, ", opd_update_user = '");
		strcat((char*)hv_dynstmt.arr, csTmp);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

	strcat((char *)hv_dynstmt.arr, " where opd_psp_id = '");
	strcat((char *)hv_dynstmt.arr, csPspId);
	strcat((char *)hv_dynstmt.arr, "'");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n", hv_dynstmt.len, hv_dynstmt.arr));

	EXEC SQL PREPARE PS FROM :hv_dynstmt;
	EXEC SQL EXECUTE PS;

DEBUGLOG(("Update Normal Exit\n"));
	return PD_OK;

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPspDetail_Update: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Update: SP_INTERNAL_ERR TxnAbort\n"));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	TxnAbort();
	return PD_INTERNAL_ERR;
}

int GetPspPayoutSplitAmt(const char* csPspId,
                hash_t* hRec)
{

        EXEC SQL WHENEVER SQLERROR GOTO getsplit_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_psp_id[PD_PSP_ID_LEN];
                int             hv_disabled;

                double          v_payout_split_limit;

                short           ind_payout_split_limit = -1;

        EXEC SQL END DECLARE SECTION;

        hv_psp_id.len = strlen(csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);
DEBUGLOG(("GetPspPayoutSplitAmt psp_id = [%d][%.*s]\n",hv_psp_id.len,hv_psp_id.len,hv_psp_id.arr));

        hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getsplit CURSOR FOR
                select
                       opd_payout_split_limit
                  from ol_psp_detail
                 where opd_psp_id = :hv_psp_id
                 and   opd_disabled = :hv_disabled
                 and   opd_status = 'O';

        EXEC SQL OPEN c_cursor_getsplit;
        do {
                EXEC SQL FETCH c_cursor_getsplit
                INTO
                        :v_payout_split_limit:ind_payout_split_limit;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }


DEBUGLOG(("GetPspPayoutSplitAmt found record\n"));

/* payout_split_limit */
                if (ind_payout_split_limit < 0)
                        v_payout_split_limit = 0.0;
                PutField_Double(hRec,"payout_split_limit",v_payout_split_limit);
DEBUGLOG(("GetPspPayoutSplitAmt payout_split_limit = [%lf]\n",v_payout_split_limit));


        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getsplit;


DEBUGLOG(("GetPspPayoutSplitAmt Normal Exit\n"));
        return  PD_OK;

getsplit_error:
DEBUGLOG(("getsplit_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("PspDetail_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getsplit;
        return PD_ERR;
}

int GetPayoutTmpAcct(const char* csPspId, hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getpotmp_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_psp_id[PD_PSP_ID_LEN];
		int		hv_disabled;

		varchar		v_baid[PD_BAID_LEN + 1];
		varchar		v_client_id[PD_CLIENT_ID_LEN + 1];
		varchar		v_ccy[PD_CCY_ID_LEN + 1];
		int		v_payout_format;
                double          v_payout_split_limit;

		short		ind_baid= -1;
		short		ind_client_id= -1;
		short		ind_ccy = -1;
		short           ind_payout_format = -1;
                short           ind_payout_split_limit = -1;
	EXEC SQL END DECLARE SECTION;

	hv_psp_id.len = strlen(csPspId);
	memcpy(hv_psp_id.arr, csPspId, hv_psp_id.len);
DEBUGLOG(("GetPayoutTmpAcct psp_id = [%.*s]\n", hv_psp_id.len, hv_psp_id.arr));

	hv_disabled = 0;

	EXEC SQL DECLARE c_cursor_getpotmp CURSOR FOR
		select	obai_baid,
			opd_client_id,
			opd_currency_id,
			opd_payout_format,
			opd_payout_split_limit
		from	ol_psp_detail,ol_bank_acct_id
		where	opd_psp_id = :hv_psp_id
		and	opd_disabled = :hv_disabled
		and	opd_psp_id = obai_psp_id
		and	obai_status = 'O'
		and	opd_status = 'O'
		and	opd_bank_acct_type = 'POA'
		and	obai_category = 'TEMP';

	EXEC SQL OPEN c_cursor_getpotmp;
	do {
		EXEC SQL FETCH c_cursor_getpotmp
		INTO
			:v_baid:ind_baid,
			:v_client_id:ind_client_id,
			:v_ccy:ind_ccy,
			:v_payout_format:ind_payout_format,
			:v_payout_split_limit:ind_payout_split_limit;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

DEBUGLOG(("GetPayoutTmpAcct found record\n"));

/* baid */
		if (ind_baid >= 0) {
			v_baid.arr[v_baid.len] = '\0';
			PutField_CString(hRec, "baid", (const char*)v_baid.arr);
DEBUGLOG(("GetPayoutTmpAcct baid = [%s]\n", v_baid.arr));
		}

/* client_id*/
		if (ind_client_id >= 0) {
			v_client_id.arr[v_client_id.len] = '\0';
			PutField_CString(hRec, "client_id", (const char*)v_client_id.arr);
DEBUGLOG(("GetPayoutTmpAcct client_id = [%s]\n", v_client_id.arr));
		}

/* payout_format */
                if (ind_payout_format>= 0) {
                        PutField_Int(hRec,"payout_format",v_payout_format);
DEBUGLOG(("GetPayoutTmpAcct payout_format = [%d]\n",v_payout_format));
                }

/* ccy*/
		if (ind_ccy >= 0) {
			v_ccy.arr[v_ccy.len] = '\0';
			PutField_CString(hRec, "ccy", (const char*)v_ccy.arr);
DEBUGLOG(("GetPayoutTmpAcct ccy = [%s]\n", v_ccy.arr));
		}

/* payout_split_limit */
                if (ind_payout_split_limit < 0)
                        v_payout_split_limit = 0.0;
                PutField_Double(hRec,"payout_split_limit",v_payout_split_limit);
DEBUGLOG(("GetPayoutTmpAcct payout_split_limit = [%lf]\n",v_payout_split_limit));


	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getpotmp;

DEBUGLOG(("GetPayoutTmpAcct Normal Exit\n"));
	return PD_OK;

getpotmp_error:
DEBUGLOG(("getpotmp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPspDetail_GetPayoutTmpAcct: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getpotmp;
	return PD_ERR;
}

int GetPspIdByPspName(const char* csPspName, char* csPspId)
{
	EXEC SQL WHENEVER SQLERROR GOTO getpspid_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_psp_name[PD_PSP_NAME_LEN];
		
		varchar		v_psp_id[PD_PSP_ID_LEN];

		short		ind_psp_id= -1;
	EXEC SQL END DECLARE SECTION;

	hv_psp_name.len = strlen(csPspName);
	memcpy(hv_psp_name.arr, csPspName, hv_psp_name.len);
DEBUGLOG(("GetPspIdByPspName psp_name = [%.*s]\n", hv_psp_name.len, hv_psp_name.arr));

	EXEC SQL DECLARE c_cursor_getpspid CURSOR FOR
		select	opd_psp_id
		from	ol_psp_detail
		where	opd_psp_name = :hv_psp_name;

	EXEC SQL OPEN c_cursor_getpspid;
	do {
		EXEC SQL FETCH c_cursor_getpspid
		INTO
			:v_psp_id:ind_psp_id;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

DEBUGLOG(("GetPspIdByPspName found record\n"));

/* psp_id */
		if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len] = '\0';
			strcpy(csPspId,(const char*)v_psp_id.arr);
DEBUGLOG(("GetPspIdByPspName psp_id = [%s]\n", v_psp_id.arr));
		}
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getpspid;

DEBUGLOG(("GetPspIdByPspName Normal Exit\n"));
	return PD_OK;

getpspid_error:
DEBUGLOG(("getpspid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLPspDetail_GetPspIdByPspName: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getpspid;
	return PD_ERR;
}

int GetNextPIDCode(int *iNextCodeInNum)
{
	int iRet = PD_OK;

	EXEC SQL WHENEVER SQLERROR GOTO getnextcode_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		int     v_code_in_num;

		short   ind_code_in_num = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE c_cursor_getnextcode CURSOR FOR
		select NVL(max(opd_code_in_num),0) + 1
		from ol_psp_detail;

        EXEC SQL OPEN c_cursor_getnextcode;

        EXEC SQL FETCH c_cursor_getnextcode
        INTO
                :v_code_in_num:ind_code_in_num;

        if (ind_code_in_num >=0) {
                *iNextCodeInNum = v_code_in_num;
DEBUGLOG(("GetNextClientIdCode code = [%d]\n",*iNextCodeInNum));
        }
        else {
DEBUGLOG(("GetNextClientCode not found\n"));
		iRet = PD_ERR;
        }

	EXEC SQL CLOSE c_cursor_getnextcode;

DEBUGLOG(("GetNextClientCode Normal Exit iRet =[%d]\n",iRet));
        return iRet;

getnextcode_error:
DEBUGLOG(("getnextcode_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getnextcode;
        return PD_ERR;


}
