/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/10/09              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLRuleUniqueNumber.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void OLRuleUniqueNumber(char    cdebug)
{
        cDebug = cdebug;
}


int GetOLRuleUniqueNumber(const char* csMerchantId,
			  hash_t* hTxn)
{
        EXEC SQL WHENEVER SQLERROR GOTO getrule_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		int             hv_disabled;

		char		v_direction;
		char		v_auto_extend;
		int             v_cnt;
		int             v_max_extend_count;
		int             v_check_interval;
		double          v_base_amt;
		double          v_range_start;
		double          v_range_end;
		double          v_step_size;

		short		ind_direction = -1;
		short		ind_auto_extend = -1;
		short		ind_cnt = -1;
		short           ind_max_extend_count = -1;
		short           ind_check_interval = -1;
		short           ind_base_amt = -1;
		short           ind_range_start = -1;
		short		ind_range_end = -1;
		short		ind_step_size = -1;

	EXEC SQL END DECLARE SECTION;

	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
DEBUGLOG(("GetOLRuleUniqueNumber merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_disabled = 0;

        EXEC SQL 
                select ru_auto_extend,
		       ru_max_extend_count,
		       ru_check_interval,
                       ru_base_amt,
                       ru_range_start,
		       ru_range_end,
		       ru_step_size,
		       ru_operate_direction,
		       count(1)
                INTO
			:v_auto_extend:ind_auto_extend,
			:v_max_extend_count:ind_max_extend_count,
			:v_check_interval:ind_check_interval,
                        :v_base_amt:ind_base_amt,
                        :v_range_start:ind_range_start,
			:v_range_end:ind_range_end,
			:v_step_size:ind_step_size,
			:v_direction:ind_direction,
			:v_cnt:ind_cnt
                  from 
		       ol_rule_unique_number
                 where ru_party_id = :hv_merchant_id
		 and   ru_disabled = :hv_disabled
		 group by ru_auto_extend,
			  ru_max_extend_count,
			  ru_check_interval,
			  ru_base_amt,
			  ru_range_start,
			  ru_range_end,
			  ru_step_size,
			  ru_operate_direction;

		if(ind_cnt<0)
			v_cnt = 0;

/* operate_direction */
                if (ind_direction>= 0) {
                        PutField_Char(hTxn,"direction",v_direction);
DEBUGLOG(("GetOLRuleUniqueNumber operate_direction = [%c]\n",v_direction));
                }

/* auto_extend */
                if (ind_auto_extend >= 0) {
                        PutField_Char(hTxn,"auto_extend",v_auto_extend);
DEBUGLOG(("GetOLRuleUniqueNumber auto_extend = [%c]\n",v_auto_extend));
                }

/* max_extend_count */
                if (ind_max_extend_count >= 0) {
                        PutField_Int(hTxn,"max_extend_count",v_max_extend_count);
DEBUGLOG(("GetOLRuleUniqueNumber max_extend_count = [%d]\n",v_max_extend_count));
                }

/* check_interval */
                if (ind_check_interval >= 0) {
                        PutField_Int(hTxn,"check_interval",v_check_interval);
DEBUGLOG(("GetOLRuleUniqueNumber check_interval = [%d]\n",v_check_interval));
                }

/* base_amt */
                if (ind_base_amt >= 0) {
                        PutField_Double(hTxn,"base_amt",v_base_amt);
DEBUGLOG(("GetOLRuleUniqueNumber base_amt = [%f]\n",v_base_amt));
                }
/* range_start */
                if (ind_range_start >= 0) {
                        PutField_Double(hTxn,"range_start",v_range_start);
DEBUGLOG(("GetOLRuleUniqueNumber range_start = [%f]\n",v_range_start));
                }

/* range_end */
                if (ind_range_end >= 0) {
                        PutField_Double(hTxn,"range_end",v_range_end);
DEBUGLOG(("GetOLRuleUniqueNumber range_end = [%f]\n",v_range_end));
                }

/* step_size */
                if (ind_step_size>= 0) {
                        PutField_Double(hTxn,"step_size",v_step_size);
DEBUGLOG(("GetOLRuleUniqueNumber step_size = [%f]\n",v_step_size));
                }

		if(v_cnt>0){
DEBUGLOG(("GetOLRuleUniqueNumber Rule Found\n"));
			return  PD_FOUND;
		}
		else{
DEBUGLOG(("GetOLRuleUniqueNumber Rule Not Found\n"));
			return  PD_NOT_FOUND;
		}

getrule_error:
DEBUGLOG(("getrule_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLRuleUniqueNumber_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}


int GetRuleUniqueNumber(const char* csTxnCode,
			  const char* csPartyType,
			  const char* csPartyId,
			  hash_t* hTxn)
{
        EXEC SQL WHENEVER SQLERROR GOTO getunirule_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar         hv_txn_code[PD_TXN_CODE_LEN];
		varchar         hv_party_id[PD_MERCHANT_ID_LEN];
		varchar		hv_party_type[PD_OFL_PARTY_LEN];
		int             hv_disabled;

		char		v_direction;
		char		v_auto_extend;
		int             v_cnt;
		int             v_max_extend_count;
		int             v_check_interval;
		double          v_base_amt;
		double          v_range_start;
		double          v_range_end;
		double          v_step_size;

		short		ind_txn_code = -1;
		short		ind_party_id = -1;
		short		ind_party_type = -1;
		short		ind_disabled = -1;
		short		ind_direction = -1;
		short		ind_auto_extend = -1;
		short		ind_cnt = -1;
		short           ind_max_extend_count = -1;
		short           ind_check_interval = -1;
		short           ind_base_amt = -1;
		short           ind_range_start = -1;
		short		ind_range_end = -1;
		short		ind_step_size = -1;

		SQL_CURSOR      c_cursor_id;
		short		hv_return_value;
	EXEC SQL END DECLARE SECTION;

	hv_txn_code.len = strlen(csTxnCode);
	memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
DEBUGLOG(("GetRuleUniqueNumber txn_code = [%.*s]\n",hv_txn_code.len,hv_txn_code.arr));
	ind_txn_code = 0;

	hv_party_id.len = strlen(csPartyId);
	memcpy(hv_party_id.arr,csPartyId,hv_party_id.len);
DEBUGLOG(("GetRuleUniqueNumber party_id = [%.*s]\n",hv_party_id.len,hv_party_id.arr));
	ind_party_id = 0;

	hv_party_type.len = strlen(csPartyType);
	memcpy(hv_party_type.arr,csPartyType,hv_party_type.len);
DEBUGLOG(("GetRuleUniqueNumber party_type = [%.*s]\n",hv_party_type.len,hv_party_type.arr));
	ind_party_type = 0;

	hv_disabled = 0;
	ind_disabled = 0;

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
			:hv_return_value := sp_get_rule_unique_num(:hv_txn_code:ind_txn_code,
							     :hv_party_id:ind_party_id,
                                                             :hv_party_type:ind_party_type,
							     :hv_disabled:ind_disabled,
							     :c_cursor_id);

                END;
        END-EXEC;

	if (hv_return_value > 0 ) {
DEBUGLOG(("GetRuleUniqueNumber: Found!\n"));
                for (;;) {

			EXEC SQL WHENEVER NOTFOUND DO break;
                        EXEC SQL FETCH :c_cursor_id
                        INTO
				:v_auto_extend:ind_auto_extend,
				:v_max_extend_count:ind_max_extend_count,
				:v_check_interval:ind_check_interval,
				:v_base_amt:ind_base_amt,
				:v_range_start:ind_range_start,
				:v_range_end:ind_range_end,
				:v_step_size:ind_step_size,
				:v_direction:ind_direction,
				:v_cnt:ind_cnt;


			if (SQLCODE == SQL_NOT_FOUND) {
				break;
                        }

			if(ind_cnt<0)
				v_cnt = 0;
/* operate_direction */
			if (ind_direction>= 0) {
				PutField_Char(hTxn,"direction",v_direction);
DEBUGLOG(("GetRuleUniqueNumber operate_direction = [%c]\n",v_direction));
			}

/* auto_extend */
			if (ind_auto_extend >= 0) {
				PutField_Char(hTxn,"auto_extend",v_auto_extend);
DEBUGLOG(("GetRuleUniqueNumber auto_extend = [%c]\n",v_auto_extend));
			}

/* max_extend_count */
			if (ind_max_extend_count >= 0) {
				PutField_Int(hTxn,"max_extend_count",v_max_extend_count);
DEBUGLOG(("GetRuleUniqueNumber max_extend_count = [%d]\n",v_max_extend_count));
			}

/* check_interval */
			if (ind_check_interval >= 0) {
				PutField_Int(hTxn,"check_interval",v_check_interval);
DEBUGLOG(("GetRuleUniqueNumber check_interval = [%d]\n",v_check_interval));
			}

/* base_amt */
			if (ind_base_amt >= 0) {
				PutField_Double(hTxn,"base_amt",v_base_amt);
DEBUGLOG(("GetRuleUniqueNumber base_amt = [%f]\n",v_base_amt));
			}
/* range_start */
			if (ind_range_start >= 0) {
				PutField_Double(hTxn,"range_start",v_range_start);
DEBUGLOG(("GetRuleUniqueNumber range_start = [%f]\n",v_range_start));
			}

/* range_end */
			if (ind_range_end >= 0) {
				PutField_Double(hTxn,"range_end",v_range_end);
DEBUGLOG(("GetRuleUniqueNumber range_end = [%f]\n",v_range_end));
			}

/* step_size */
			if (ind_step_size>= 0) {
				PutField_Double(hTxn,"step_size",v_step_size);
DEBUGLOG(("GetRuleUniqueNumber step_size = [%f]\n",v_step_size));
			}

		}
		EXEC SQL CLOSE :c_cursor_id;
                EXEC SQL FREE :c_cursor_id;
		if(v_cnt>0){
DEBUGLOG(("GetRuleUniqueNumber Rule Found\n"));
			return  PD_FOUND;
		}
		else{
DEBUGLOG(("GetRuleUniqueNumber Rule Not Found\n"));
			return  PD_NOT_FOUND;
		}
	}
        else {
                EXEC SQL CLOSE :c_cursor_id;
                EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetRuleUniqueNumber: exit with error\n"));
                return PD_NOT_FOUND;
        }

getunirule_error:
DEBUGLOG(("getunirule_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLRuleUniqueNumber_Get: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_id;
        EXEC SQL FREE :c_cursor_id;
        return PD_ERR;
}
