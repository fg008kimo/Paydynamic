/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/05/03              Cody Chan
Add FindCounterForWeb			   	   2012/01/11		   Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "TxnCounters.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;
void TxnCounters(char    cdebug)
{
        cDebug = cdebug;
}


int CounterCreate(const char* csTxnCode,
                const char* csCountry,
		const char* csChannelCode,
		const char* csServiceCode,
		const char* csPayMethod,
		const char  cPartyType,
                const char* csPartyId,
                const char* csCcy,
                double  dCounter,
                const char* csUser)

{

        EXEC SQL WHENEVER SQLERROR GOTO create_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

        short 		hv_return_value;

	varchar		hv_txn_code[PD_TXN_CODE_LEN];
	varchar		hv_country[PD_COUNTRY_LEN];
	varchar		hv_channel_code[PD_CHANNEL_CODE_LEN];
	varchar		hv_service_code[PD_SERVICE_CODE_LEN];
	varchar		hv_pay_method[PD_PAY_METHOD_LEN];
	char		hv_party_type;
	varchar		hv_party_id[PD_MERCHANT_ID_LEN];
	varchar		hv_currency_id[PD_CCY_ID_LEN];
	double		hv_counter;
	varchar		hv_create_user[PD_USER_LEN];	



	short		ind_txn_code = -1;
	short		ind_country = -1;
	short		ind_channel_code = -1;
	short		ind_service_code = -1;
	short		ind_pay_method = -1;
	short		ind_party_type = -1;
	short		ind_party_id = -1;
	short		ind_currency_id = -1;
	short		ind_counter = -1;
	short		ind_create_user = -1;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("TxnCountersCreate: Begin\n"));


        hv_txn_code.len = strlen(csTxnCode);
        memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
        ind_txn_code = 0;
DEBUGLOG(("TxnCountersCreate:txn_code = [%.*s]\n",hv_txn_code.len,hv_txn_code.arr));

        hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
        ind_country = 0;
DEBUGLOG(("TxnCountersCreate:country = [%.*s]\n",hv_country.len,hv_country.arr));

        hv_channel_code.len = strlen(csChannelCode);
        memcpy(hv_channel_code.arr,csChannelCode,hv_channel_code.len);
        ind_channel_code = 0;
DEBUGLOG(("TxnCountersCreate:channel_code = [%.*s]\n",hv_channel_code.len,hv_channel_code.arr));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
        ind_service_code = 0;
DEBUGLOG(("TxnCountersCreate:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	if(csPayMethod!=NULL){
        	hv_pay_method.len = strlen(csPayMethod);
        	memcpy(hv_pay_method.arr,csPayMethod,hv_pay_method.len);
        	ind_pay_method = 0;
DEBUGLOG(("TxnCountersCreate:pay_method = [%.*s]\n",hv_pay_method.len,hv_pay_method.arr));
	}	

        hv_currency_id.len = strlen(csCcy);
        memcpy(hv_currency_id.arr,csCcy,hv_currency_id.len);
        ind_currency_id = 0;
DEBUGLOG(("TxnCountersCreate:currency_id = [%.*s]\n",hv_currency_id.len,hv_currency_id.arr));

	hv_party_type = cPartyType;
	ind_party_type = 0;
DEBUGLOG(("TxnCountersCreate:party_type = [%c]\n",hv_party_type));

        hv_party_id.len = strlen(csPartyId);
        memcpy(hv_party_id.arr,csPartyId,hv_party_id.len);
        ind_party_id = 0;
DEBUGLOG(("TxnCountersCreate:party_id = [%.*s]\n",hv_party_id.len,hv_party_id.arr));


	/* counter  */
        hv_counter = dCounter;
        ind_counter = 0;
DEBUGLOG(("TxnCountersCreate:counter = [%f]\n",hv_counter));

        hv_create_user.len = strlen(csUser);
        memcpy(hv_create_user.arr,csUser,hv_create_user.len);
        ind_create_user = 0;
DEBUGLOG(("TxnCountersCreate:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));

	EXEC SQL EXECUTE
                BEGIN
			:hv_return_value := sp_txn_counters_insert(
					:hv_txn_code:ind_txn_code,
					:hv_country:ind_country,
					:hv_channel_code:ind_channel_code,
					:hv_service_code:ind_service_code,
					:hv_pay_method:ind_pay_method,
					:hv_party_type:ind_party_type,
					:hv_party_id:ind_party_id,
					:hv_currency_id:ind_currency_id,
					:hv_counter:ind_counter,
					:hv_create_user:ind_create_user);
	        END;
        END-EXEC;

DEBUGLOG(("TxnCountersCreate:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK) {
DEBUGLOG(("TxnCountersCreate:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("TxnCounters_Create: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("TxnCountersCreate: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("TxnCounters_Create: SP_ERR TxnAbort\n");
DEBUGLOG(("TxnCountersCreate: SP_ERR TxnAbort\n"));
		TxnAbort();
                return PD_ERR;
        }

create_error:
DEBUGLOG(("create_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("TxnCounters_Create: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("TxnCountersCreate: SP_INTERNAL_ERR TxnAbort\n"));
	TxnAbort();
        return PD_INTERNAL_ERR;
}


int FindCounters(const char* csTxnCode,
		const char* csCountryId,
		const char* csChannelCode,
		const char* csServiceCode,
		const char  cType,
		const char* csCategory,
		const char  cPartyType,
		const char* csPartyId,
		recordset_t* myRec)
{
	hash_t *myHash;
	int iRet = PD_NOT_FOUND;

DEBUGLOG(("FindCounters()\n"));
        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_txn_code[PD_TXN_CODE_LEN];
                varchar hv_country_id[PD_COUNTRY_LEN];
		varchar	hv_channel_code[PD_CHANNEL_CODE_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];
                varchar hv_party_id[PD_MERCHANT_ID_LEN];
                varchar hv_category[PD_CATEGORY_LEN];
		char	hv_type;
		char	hv_party_type;


		varchar	v_currency_id[PD_CURRENCY_ID_LEN +1];
                double  v_counter;
                double  v_total_counter;

		short	ind_currency_id = -1;
                short   ind_counter = -1;
                short   ind_total_counter = -1;
        EXEC SQL END DECLARE SECTION;


        hv_txn_code.len = strlen(csTxnCode);
        memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
DEBUGLOG(("FindCounters: txn_code = [%.*s][%d]\n",hv_txn_code.len,hv_txn_code.arr,hv_txn_code.len));

        hv_country_id.len = strlen(csCountryId);
        memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("FindCounters: country_id = [%.*s][%d]\n",hv_country_id.len,hv_country_id.arr,hv_country_id.len));

        hv_channel_code.len = strlen(csChannelCode);
        memcpy(hv_channel_code.arr,csChannelCode,hv_channel_code.len);
DEBUGLOG(("FindCounters: channel_code = [%.*s][%d]\n",hv_channel_code.len,hv_channel_code.arr,hv_channel_code.len));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindCounters: service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len));


	hv_type=cType;
DEBUGLOG(("FindCounters: type = [%c]\n",hv_type));

        hv_category.len = strlen(csCategory);
        memcpy(hv_category.arr,csCategory,hv_category.len);
DEBUGLOG(("FindCounters: category = [%.*s][%d]\n",hv_category.len,hv_category.arr,hv_category.len));
	
	hv_party_type=cPartyType;
DEBUGLOG(("FindCounters: party_type = [%c]\n",hv_party_type));

        hv_party_id.len = strlen(csPartyId);
        memcpy(hv_party_id.arr,csPartyId,hv_party_id.len);
DEBUGLOG(("FindCounters: party_id = [%.*s][%d]\n",hv_party_id.len,hv_party_id.arr,hv_party_id.len));


	EXEC SQL DECLARE c_cursor_findcounters CURSOR FOR
                 SELECT tc_currency_id,
         	        sum(tc_counter),
         		sum(tc_total_counter)
 	           FROM txn_counters
		  WHERE tc_country_id = :hv_country_id
                    and tc_channel_code = :hv_channel_code
                    and tc_txn_code = :hv_txn_code
                    and tc_service_code = :hv_service_code
                    and tc_type = :hv_type
                    and tc_category = :hv_category
                    and tc_party_type = :hv_party_type
                    and tc_party_id = :hv_party_id
                    group by tc_currency_id;

	
	
        EXEC SQL OPEN c_cursor_findcounters;
        do {
                EXEC SQL FETCH c_cursor_findcounters
		  INTO  :v_currency_id:ind_currency_id,
			:v_counter:ind_counter,
			:v_total_counter:ind_total_counter;

		
                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("FindCounters  found\n"));
		iRet = PD_FOUND;
		
                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

		if (ind_currency_id >= 0) {
                        v_currency_id.arr[v_currency_id.len] ='\0';
                        PutField_CString(myHash,"ccy",(const char*)v_currency_id.arr);
DEBUGLOG(("FindCounters currency_id = [%s]\n",v_currency_id.arr));
                }

		if (ind_counter < 0 ) {
			v_counter = 0.0;
		}

                PutField_Double(myHash,"counter",v_counter);
DEBUGLOG(("FindCounters counter = [%lf]\n",v_counter));

		if (ind_total_counter < 0 ) {
			v_total_counter = 0.0;
		}
                PutField_Double(myHash,"total_counter",v_total_counter);
DEBUGLOG(("FindCounters total counter = [%lf]\n",v_total_counter));
		RecordSet_Add(myRec,myHash);

	}
	while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_findcounters;

DEBUGLOG(("Txn Counter iRet = [%d]\n",iRet));
        return iRet;
find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_findcounters;
    return PD_NOT_FOUND;
}

int FindCounterForWeb(
		const char* csServiceCode,
		hash_t	*myHash)
{
	int iRet = PD_NOT_FOUND;

DEBUGLOG(("FindCounterForWeb()\n"));
        EXEC SQL WHENEVER SQLERROR GOTO findcounterforweb_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];


                double  v_counter;
                double  v_total_counter;
		varchar	hv_category[PD_CATEGORY_LEN];
		char	hv_type;
		char	hv_party_type;

                short   ind_counter = -1;
                short   ind_total_counter = -1;
        EXEC SQL END DECLARE SECTION;



        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindCounterForWeb: service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len));

	hv_type = PD_DAILY;
DEBUGLOG(("FindCounterForWeb: type = [%c]\n",hv_type));

        hv_category.len = strlen(PD_VALUE_TYPE_AMT);
        memcpy(hv_category.arr,PD_VALUE_TYPE_AMT,hv_category.len);
DEBUGLOG(("FindCounterForWeb: category = [%.*s][%d]\n",hv_category.len,hv_category.arr,hv_category.len));

	hv_party_type = PD_TYPE_PSP;
DEBUGLOG(("FindCounterForWeb: party_type = [%c]\n",hv_party_type));



	EXEC SQL DECLARE c_cursor_findcounterforweb CURSOR FOR
                 SELECT sum(tc_counter),
         		sum(tc_total_counter)
 	           FROM txn_counters
		  WHERE tc_channel_code in ('WEB','XPY')
                    and tc_txn_code in ('DSP','DSI')
                    and tc_service_code = :hv_service_code
                    and tc_type = :hv_type
                    and tc_category = :hv_category
                    and tc_party_type = :hv_party_type;

	
	
        EXEC SQL OPEN c_cursor_findcounterforweb;
        do {
                EXEC SQL FETCH c_cursor_findcounterforweb
		  INTO  
			:v_counter:ind_counter,
			:v_total_counter:ind_total_counter;

		
                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("FindCounterForWeb  found\n"));
		iRet = PD_FOUND;
		
		if (ind_counter < 0 ) {
			v_counter = 0.0;
		}

                PutField_Double(myHash,"counter",v_counter);
DEBUGLOG(("FindCounterForWeb counter = [%lf]\n",v_counter));

		if (ind_total_counter < 0 ) {
			v_total_counter = 0.0;
		}
                PutField_Double(myHash,"total_counter",v_total_counter);
DEBUGLOG(("FindCounterForWeb total counter = [%lf]\n",v_total_counter));

	}
	while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_findcounterforweb;

DEBUGLOG(("FindCounterForWeb Counter iRet = [%d]\n",iRet));
        return iRet;
findcounterforweb_error:
DEBUGLOG(("findcounterforweb_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_findcounterforweb;
    return PD_NOT_FOUND;
}

