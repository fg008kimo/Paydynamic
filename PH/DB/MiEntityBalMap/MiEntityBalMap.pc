/*
Partnerdelight (c)2015. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version (FindMapping)                         2015/11/03              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "internal.h"
#include "MiEntityBalMap.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void MiEntityBalMap(char    cdebug)
{
        cDebug = cdebug;
}


int FindMapping(const char* csEntityType,
                char cBalanceType)
{
        int     iRet = PD_NOT_FOUND;
DEBUGLOG(("FindMapping()\n"));

        EXEC SQL WHENEVER SQLERROR GOTO findmap_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_entity_type[PD_MMS_ENTITY_TYPE_LEN];
                char		hv_balance_type;

		int		v_cnt;
		short		ind_cnt = -1;

        EXEC SQL END DECLARE SECTION;

/* entity_type */
        hv_entity_type.len = strlen(csEntityType);
        memcpy(hv_entity_type.arr,csEntityType,hv_entity_type.len);
DEBUGLOG(("FindMapping entity_type = [%.*s]\n",hv_entity_type.len,hv_entity_type.arr));

/* balance_type */
	hv_balance_type = cBalanceType;
DEBUGLOG(("FindMapping balance_type = [%c]\n",hv_balance_type));

        EXEC SQL 
		SELECT count(1)
                INTO :v_cnt:ind_cnt
		FROM mi_entity_bal_map
		WHERE ebm_entity_type = :hv_entity_type
		AND   ebm_bal_type = :hv_balance_type
		AND   ebm_disabled = 0;

		if(ind_cnt<0)
			v_cnt = 0;

		if(v_cnt > 0)
                	iRet = PD_FOUND;

DEBUGLOG(("FindMapping() normal return iRet = [%d]\n",iRet));
        return iRet;

findmap_error:
DEBUGLOG(("pspentityid_error code %d\n", sqlca.sqlcode));
ERRLOG("DBMiEntityBalMap::findmap_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}


int isAllowBalNegative(const char* csEntityType,
                char cBalanceType)
{
        int     iRet = PD_FALSE;
DEBUGLOG(("isAllowBalNegative()\n"));

        EXEC SQL WHENEVER SQLERROR GOTO allow_negative_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_entity_type[PD_MMS_ENTITY_TYPE_LEN];
                char		hv_balance_type;

		int		v_ret;
		short		ind_ret = -1;

        EXEC SQL END DECLARE SECTION;

/* entity_type */
        hv_entity_type.len = strlen(csEntityType);
        memcpy(hv_entity_type.arr,csEntityType,hv_entity_type.len);
DEBUGLOG(("isAllowBalNegative entity_type = [%.*s]\n",hv_entity_type.len,hv_entity_type.arr));

/* balance_type */
	hv_balance_type = cBalanceType;
DEBUGLOG(("isAllowBalNegative balance_type = [%c]\n",hv_balance_type));

        EXEC SQL 
		SELECT ebm_allow_bal_negative
                INTO :v_ret:ind_ret
		FROM mi_entity_bal_map
		WHERE ebm_entity_type = :hv_entity_type
		AND   ebm_bal_type = :hv_balance_type
		AND   ebm_disabled = 0;

		if(ind_ret<0)
			v_ret = PD_FALSE;

                iRet = v_ret;
DEBUGLOG(("isAllowBalNegative() = [%d]\n",iRet));
        return iRet;

allow_negative_error:
DEBUGLOG(("pspentityid_error code %d\n", sqlca.sqlcode));
ERRLOG("DBMiEntityBalMap::allow_negative_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}
