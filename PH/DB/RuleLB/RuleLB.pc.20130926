/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/01/03              Cody Chan
Add customer_tag				   2013/01/29		   Cody Chan
GetAvalPspsByPool Check againest with hPsps        2013/03/04		   Cody Chan
Check psp limit before bank selection		   2013/03/20		   Stan Poon
get bank+psp by merchant and txnamt		   2013/07/04		   LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "RuleLB.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RuleLB(char    cdebug)
{
        cDebug = cdebug;
}


int MatchCriteria(const hash_t *hRec,
			recordset_t* myRec)
{

	int iRet = PD_NOT_FOUND;
	int	iCnt = 0;
	char	*csPtr;
	char	cPtr;
	int	iPtr;

	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO match_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_channel_code[PD_CHANNEL_CODE_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];
		varchar	hv_payment_method[PD_PAY_METHOD_LEN];
		varchar	hv_txn_country[PD_COUNTRY_LEN];
		varchar	hv_txn_ccy[PD_CCY_ID_LEN];
		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_client_id[PD_CLIENT_ID_LEN];
		char	hv_business_type;
		varchar	hv_customer_tag[PD_CUSTOMER_TAG_LEN];
		int	hv_restricted_ip;

		//int	v_txn_amount_tier;
		double  v_min_txn_amount;
		double  v_max_txn_amount;
		int	v_criteria_pool_id;
		int	v_scheduler_id;
		int	v_priority;
		
		short	ind_channel_code = -1;
		short	ind_service_code = -1;
		short	ind_payment_method = -1;
		short	ind_txn_country = -1;
		short	ind_txn_ccy = -1;
		short	ind_merchant_id = -1;
		short	ind_client_id = -1;
		short	ind_business_type = -1;
		short	ind_customer_tag = -1;
		short	ind_restricted_ip = -1;

		//short	ind_txn_amount_tier = -1;
		short	ind_min_txn_amount = -1;
		short	ind_max_txn_amount = -1;
		short	ind_pool_id = -1;
		short	ind_scheduler_id = -1;
		short	ind_priority = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

/* channel code */
	if (GetField_CString(hRec,"channel_code",&csPtr)) {
		hv_channel_code.len = strlen(csPtr);
		memcpy(hv_channel_code.arr,csPtr,hv_channel_code.len);
		ind_channel_code = 0;
DEBUGLOG(("MatchCriteria: channel_code = [%.*s]\n",hv_channel_code.len,hv_channel_code.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: channel_code is missing!!!\n"));
	}

/* service code */
	if (GetField_CString(hRec,"service_code",&csPtr)) {
		hv_service_code.len = strlen(csPtr);
		memcpy(hv_service_code.arr,csPtr,hv_service_code.len);
		ind_service_code = 0;
DEBUGLOG(("MatchCriteria: service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: service_code is missing!!!\n"));
	}

/*payment method */
	if (GetField_CString(hRec,"pay_method",&csPtr)) {
		hv_payment_method.len = strlen(csPtr);
		memcpy(hv_payment_method.arr,csPtr,hv_payment_method.len);
		ind_payment_method = 0;
DEBUGLOG(("MatchCriteria: payment_method = [%.*s]\n",hv_payment_method.len,hv_payment_method.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: pay_method is missing!!!\n"));
	}

/*txn_country */
	if (GetField_CString(hRec,"txn_country",&csPtr)) {
		hv_txn_country.len = strlen(csPtr);
		memcpy(hv_txn_country.arr,csPtr,hv_txn_country.len);
		ind_txn_country = 0;
DEBUGLOG(("MatchCriteria: txn_country = [%.*s]\n",hv_txn_country.len,hv_txn_country.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: txn_country is missing!!!\n"));
	}

/*txn_ccy */
	if (GetField_CString(hRec,"txn_ccy",&csPtr)) {
		hv_txn_ccy.len = strlen(csPtr);
		memcpy(hv_txn_ccy.arr,csPtr,hv_txn_ccy.len);
		ind_txn_ccy = 0;
DEBUGLOG(("MatchCriteria: txn_ccy = [%.*s]\n",hv_txn_ccy.len,hv_txn_ccy.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: txn_ccy is missing!!!\n"));
	}


/*merchant_id */
	if (GetField_CString(hRec,"merchant_id",&csPtr)) {
		hv_merchant_id.len = strlen(csPtr);
		memcpy(hv_merchant_id.arr,csPtr,hv_merchant_id.len);
		ind_merchant_id = 0;
DEBUGLOG(("MatchCriteria: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: merchant_id is missing!!!\n"));
	}

/*client_id */
	if (GetField_CString(hRec,"client_id",&csPtr)) {
		hv_client_id.len = strlen(csPtr);
		memcpy(hv_client_id.arr,csPtr,hv_client_id.len);
		ind_client_id = 0;
DEBUGLOG(("MatchCriteria: client_id = [%.*s]\n",hv_client_id.len,hv_client_id.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: client_id is missing!!!\n"));
	}


/*business_type */
	if (GetField_Char(hRec,"business_type",&cPtr)) {
		hv_business_type = cPtr;
		ind_business_type = 0;
DEBUGLOG(("MatchCriteria: business_type = [%c]\n",hv_business_type));
	}
	else {
DEBUGLOG(("MatchCriteria: business_type is missing!!!\n"));
	}

/*customer_tag */
	if (GetField_CString(hRec,"customer_tag",&csPtr)) {
		hv_customer_tag.len = strlen(csPtr);
		memcpy(hv_customer_tag.arr,csPtr,hv_customer_tag.len);
		ind_customer_tag = 0;
DEBUGLOG(("MatchCriteria: customer_tag = [%.*s]\n",hv_customer_tag.len,hv_customer_tag.arr));
	}

/*restricted_ip*/
	if (GetField_Int(hRec,"restricted_ip",&iPtr)) {
		hv_restricted_ip = iPtr;
		ind_restricted_ip = 0;
DEBUGLOG(("MatchCriteria: restricted_ip = [%d]\n",hv_restricted_ip));
	}
	else {
DEBUGLOG(("MatchCriteria: restricted_ip is missing!!!\n"));
	}

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_lb_match(:hv_channel_code:ind_channel_code,
								:hv_service_code:ind_service_code,
								:hv_payment_method:ind_payment_method,
								:hv_txn_country:ind_txn_country,
								:hv_txn_ccy:ind_txn_ccy,
								:hv_merchant_id:ind_merchant_id,
								:hv_client_id:ind_client_id,
								:hv_business_type:ind_business_type,
								:hv_customer_tag:ind_customer_tag,
								:hv_restricted_ip:ind_restricted_ip,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value > 0 ) {
DEBUGLOG(("MatchCriteria: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			//ind_txn_amount_tier = -1;
			ind_min_txn_amount = -1;
			ind_max_txn_amount = -1;
			ind_pool_id = -1;
			ind_scheduler_id = -1;
			ind_priority = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_min_txn_amount:ind_min_txn_amount,
				:v_max_txn_amount:ind_max_txn_amount,
				:v_criteria_pool_id:ind_pool_id,
				:v_scheduler_id:ind_scheduler_id,
				:v_priority:ind_priority;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			/*
			if (ind_txn_amount_tier >= 0) {
DEBUGLOG(("MatchCriteria: [%03d]txn_amount_tier = [%d]\n",iCnt,v_txn_amount_tier));
				PutField_Int(myHash,"amount_tier_id",v_txn_amount_tier);
			}
			*/

			if (ind_min_txn_amount >= 0) {
DEBUGLOG(("MatchCriteria: [%03d]min_txn_amount = [%lf]\n",iCnt,v_min_txn_amount));
				PutField_Double(myHash,"min_txn_amount",v_min_txn_amount);
			}
			if (ind_max_txn_amount >= 0) {
DEBUGLOG(("MatchCriteria: [%03d]max_txn_amount = [%lf]\n",iCnt,v_max_txn_amount));
				PutField_Double(myHash,"max_txn_amount",v_max_txn_amount);
			}
	
			if (ind_pool_id >= 0) {
DEBUGLOG(("MatchCriteria: [%03d]criteria_pool_id = [%d]\n",iCnt,v_criteria_pool_id));
				PutField_Int(myHash,"criteria_pool_id",v_criteria_pool_id);
			}
			if (ind_scheduler_id >= 0) {
DEBUGLOG(("MatchCriteria: [%03d]scheduler_id = [%d]\n",iCnt,v_scheduler_id));
				PutField_Int(myHash,"scheduler_id",v_scheduler_id);
			}

			if (ind_priority >= 0) {
DEBUGLOG(("MatchCriteria: [%03d]priority = [%d]\n",iCnt,v_priority));
				PutField_Int(myHash,"priority",v_priority);
			}

			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("MatchCriteria: exit with ok\n"));
		return PD_FOUND;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("MatchCriteria: exit with error\n"));
		return PD_NOT_FOUND;
	}


	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

match_error:
DEBUGLOG(("match_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    EXEC SQL FREE :c_cursor_id;
    return PD_NOT_FOUND;
}

int GetAvalPspsByPool(hash_t* hPsp,
			int iPoolId,
			recordset_t* myRec)
{

	int iRet = PD_OK;
	char*	csBuf;
	char	csTag[PD_TAG_LEN +1];
	char*	csPtr;
	int	iPtr;
	int 	i;

	hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getavalpspsbypool_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
	varchar         hv_dynstmt[PD_TMP_MSG_BUF_LEN];

	int	hv_pool_id;

	varchar	v_psp_id[PD_PSP_ID_LEN +1];
	int	v_ratio;
	int	v_priority;
	

	short	ind_psp_id = -1;
	short	ind_ratio = -1;
	short	ind_priority = -1;

        EXEC SQL END DECLARE SECTION;

	hv_pool_id = iPoolId;
DEBUGLOG(("GetAvalPspsByPool pool id = [%d]\n",hv_pool_id));

	csBuf = (char*) malloc (128);
	strcpy((char*)hv_dynstmt.arr,"SELECT rm_psp_id,");
	strcat((char*)hv_dynstmt.arr,"rm_ratio,");
	strcat((char*)hv_dynstmt.arr,"rm_priority");
	strcat((char*)hv_dynstmt.arr," FROM rule_psp_lb_mapping");
	strcat((char*)hv_dynstmt.arr," WHERE rm_pool_id  = ");
/* insert pool */
	sprintf(csBuf,"%d",iPoolId);
	strcat((char*)hv_dynstmt.arr, csBuf);
	strcat((char*)hv_dynstmt.arr," AND rm_psp_id in (");
/* insert psps */
	if (GetField_Int(hPsp,"psp_id_cnt",&iPtr)) {
DEBUGLOG(("GetAvalPspsByPool = [%d]\n",iPtr));
        }
	else 
		iPtr = 0;
	for (i= 0 ; i < iPtr; i++) {
		sprintf(csTag,"psp_id_%d",i);
		if (GetField_CString(hPsp,csTag,&csPtr)) {
DEBUGLOG(("GetAvalPspsByPool [%s] =  [%s]\n",csTag,csPtr));
			if (i != 0 ) 
				strcat((char*)hv_dynstmt.arr, ",");
			strcat((char*)hv_dynstmt.arr, "'");
			strcat((char*)hv_dynstmt.arr, csPtr);
			strcat((char*)hv_dynstmt.arr, "'");
		}
	}

	strcat((char*)hv_dynstmt.arr,")");
	strcat((char*)hv_dynstmt.arr," AND rm_disabled = 0");
	strcat((char*)hv_dynstmt.arr," order by rm_priority desc, rm_ratio desc");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

	FREE_ME(csBuf);

DEBUGLOG(("GetAvalPspsByPool:[%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));
	EXEC SQL PREPARE s1 FROM :hv_dynstmt;  
	EXEC SQL DECLARE c_cursor_getavalpspsbypool CURSOR FOR s1;
  	

	EXEC SQL OPEN c_cursor_getavalpspsbypool;
        do {
		EXEC SQL FETCH c_cursor_getavalpspsbypool
                INTO
			:v_psp_id:ind_psp_id,
			:v_ratio:ind_ratio,
			:v_priority:ind_priority;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }	

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);	

		if  (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len] = '\0';
DEBUGLOG(("GetAvalPspsByPool PSP ID = [%s]\n",v_psp_id.arr));
			PutField_CString(myHash,"psp_id",(char*)v_psp_id.arr);
		}

		if  (ind_ratio < 0) {
			v_ratio = 0;
		}
DEBUGLOG(("GetAvalPspsByPool ratio = [%d]\n",v_ratio));
		PutField_Int(myHash,"pool_psp_ratio",v_ratio);

		if  (ind_priority < 0) {
			v_priority = 0;
		}
DEBUGLOG(("GetAvalPspsByPool priority = [%d]\n",v_priority));
		PutField_Int(myHash,"pool_psp_priority",v_priority);


		RecordSet_Add(myRec,myHash);
	}while (PD_TRUE);	

	EXEC SQL CLOSE c_cursor_getavalpspsbypool;
	return iRet;

getavalpspsbypool_error:
DEBUGLOG(("getavalpspsbypool_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getavalpspsbypool;
    return PD_ERR;
}



int FindAvalPsp(int     iPoolId,
                const char* csServiceCode,
                const char* csTxnCountry,
                double dTxnAmt)
{
        int iRet = PD_ERR;

DEBUGLOG(("FindAvalPsp()\n"));
        EXEC SQL WHENEVER SQLERROR GOTO findavalpsp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                int     hv_pool_id;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
                varchar hv_txn_country[PD_COUNTRY_LEN];
                varchar hv_category[PD_CATEGORY_LEN];
                char    hv_type;
                char    hv_party_type;
                double  hv_txn_amt;

                int     v_counter;

                short   ind_counter = -1;

        EXEC SQL END DECLARE SECTION;

        hv_pool_id = iPoolId;
DEBUGLOG(("FindAvalPsp: pool id  = [%d]\n",iPoolId));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindAvalPsp: service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len));

        hv_txn_country.len = strlen(csTxnCountry);
        memcpy(hv_txn_country.arr,csTxnCountry,hv_txn_country.len);
DEBUGLOG(("FindAvalPsp: txn_country = [%.*s][%d]\n",hv_txn_country.len,hv_txn_country.arr,hv_txn_country.len));

        hv_type = PD_DAILY;
DEBUGLOG(("FindAvalPsp: type = [%c]\n",hv_type));


        hv_category.len = strlen(PD_VALUE_TYPE_AMT);
        memcpy(hv_category.arr,PD_VALUE_TYPE_AMT,hv_category.len);
DEBUGLOG(("FindAvalPsp: category = [%.*s][%d]\n",hv_category.len,hv_category.arr,hv_category.len));

        hv_party_type = PD_TYPE_PSP;
DEBUGLOG(("FindAvalPsp: party_type = [%c]\n",hv_party_type));

        hv_txn_amt = dTxnAmt;
DEBUGLOG(("FindAvalPsp: txn amt = [%f]\n",hv_txn_amt));


        EXEC SQL DECLARE c_cursor_findavalpsp CURSOR FOR
		SELECT count(*) as cnt
		  FROM (SELECT rm_psp_id,
         		       rpp_limit,
         		       nvl(tc_counter,0) as counter,
         		       nvl(tc_total_counter,0) as total_counter
   			  FROM (SELECT rm_psp_id,
                                       rpp_limit
                                  FROM rule_psp_lb_mapping,
                               	       psp_detail a,
                               	       psp_master b,
                               	       rule_psp_lb_psp
                         	 WHERE rm_pool_id = :hv_pool_id
                           	   AND rm_disabled = 0
                           	   AND rm_psp_id = a.psp_id
                           	   AND a.disabled = 0
                           	   AND a.online_mode = 'Y'
                           	   AND a.status = 'O'
                           	   AND a.client_id = b.pm_client_id
                           	   AND b.pm_status = 'O'
                           	   AND rm_psp_id = rpp_psp_id
                           	   AND rpp_disabled = 0) a
    		         LEFT JOIN txn_counters
    			   ON rm_psp_id = tc_party_id
    			  AND tc_txn_code in ('DSI','DSP')
                          AND tc_country_id = :hv_txn_country
                          AND tc_channel_code in ('WEB','XPY')
                          AND tc_service_code = :hv_service_code
                          AND TC_type = :hv_type
                          AND tc_category = :hv_category
                          AND Tc_party_type = :hv_party_type) 
    		  WHERE (rpp_limit >= (total_counter + :hv_txn_amt) or rpp_limit = 0);
              	



        EXEC SQL OPEN c_cursor_findavalpsp;
        do {
                EXEC SQL FETCH c_cursor_findavalpsp
                  INTO
                        :v_counter:ind_counter;


                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("FindAvalPsp  found\n"));
                if (ind_counter >= 0 ) {
DEBUGLOG(("FindAvalPsp  counter = [%d]\n",v_counter));
                        if (v_counter >0 )  {
                                iRet = PD_OK;
                        }
                }

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_findavalpsp;

DEBUGLOG(("FindAvalPsp Counter iRet = [%d]\n",iRet));
        return iRet;
findavalpsp_error:
DEBUGLOG(("findavalpsp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_findavalpsp;
    return PD_ERR;
}
int FindAvalPspForPool(int iPoolId,
			hash_t* hRec)
{
        int 	iRet = PD_ERR;
	int	iPspCnt;
	char*	csBuf;
	char*	csPtr;

DEBUGLOG(("FindAvalPspForPool()\n"));
        EXEC SQL WHENEVER SQLERROR GOTO findavalpspforpool_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
	int	v_cnt;
	varchar hv_dynstmt[1024];

	short	ind_cnt = -1;
        EXEC SQL END DECLARE SECTION;

	csBuf = (char*) malloc (128);

	strcpy((char*)hv_dynstmt.arr,"select count(*) as cnt ");
	strcat((char*)hv_dynstmt.arr,"from rule_psp_lb_mapping,rule_psp_lb_psp ");
	strcat((char*)hv_dynstmt.arr,"where rm_disabled = 0 ");

/* pool id */
	strcat((char*)hv_dynstmt.arr,"and rm_pool_id = ");
	sprintf(csBuf,"%d",iPoolId);
	strcat((char*)hv_dynstmt.arr,csBuf);
	strcat((char*)hv_dynstmt.arr," ");

	strcat((char*)hv_dynstmt.arr,"and rm_psp_id = rpp_psp_id ");
	strcat((char*)hv_dynstmt.arr,"and rpp_disabled = 0 ");
	strcat((char*)hv_dynstmt.arr,"and rpp_psp_id in (");
	
	if (GetField_Int(hRec,"psp_id_cnt",&iPspCnt)) {
DEBUGLOG(("FindAvalPspForPool: psp_id_cnt = [%d]\n",iPspCnt));
		int i = 0;
		char	csTag[PD_TAG_LEN +1];
		for (i = 0; i < iPspCnt; i++) {
			sprintf(csTag,"psp_id_%d",i);
			if (GetField_CString(hRec,csTag,&csPtr)) {
DEBUGLOG(("FindAvalPspForPool: [%s] = [%s]\n",csTag,csPtr));
				if (i == 0)
					sprintf(csBuf,"'%s'",csPtr);
				else 
					sprintf(csBuf,",'%s'",csPtr);
				strcat((char*)hv_dynstmt.arr,csBuf);
			}
		}
        }
	strcat((char*)hv_dynstmt.arr,")");

        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

	EXEC SQL PREPARE PS FROM :hv_dynstmt;
	EXEC SQL DECLARE c_cursor_getavalpsp CURSOR FOR PS;
	FREE_ME(csBuf);

	EXEC SQL OPEN c_cursor_getavalpsp;
        do {	
		EXEC SQL FETCH c_cursor_getavalpsp
                INTO
			:v_cnt:ind_cnt;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
		
		if (ind_cnt >= 0 ) {
			if (v_cnt > 0) {
DEBUGLOG(("FindAvalPspForPool: cnt = [%d]\n",v_cnt));
				iRet = PD_OK;
			}
		}
	}
	while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getavalpsp;
DEBUGLOG(("FindAvalPspForPool iRet = [%d]\n",iRet));
        return iRet;
findavalpspforpool_error:
DEBUGLOG(("findavalpspforpool_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getavalpsp;
    return PD_ERR;
}

int FindAvalPspSchudler(int iPoolId,
			hash_t* hRec)
{
        int 	iRet = PD_ERR;
	int	iPspCnt;
	char*	csBuf;
	char*	csPtr;

DEBUGLOG(("FindAvalPspSchudler()\n"));
        EXEC SQL WHENEVER SQLERROR GOTO findavalpspschudler_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
	int	v_cnt;
	varchar hv_dynstmt[1024];

	short	ind_cnt = -1;
        EXEC SQL END DECLARE SECTION;

	csBuf = (char*) malloc (128);

	strcpy((char*)hv_dynstmt.arr,"select count(*) as cnt ");
	strcat((char*)hv_dynstmt.arr,"from rule_psp_lb_mapping,rule_psp_lb_psp ");
	strcat((char*)hv_dynstmt.arr,"where rm_disabled = 0 ");

/* pool id */
	strcat((char*)hv_dynstmt.arr,"and rm_pool_id = ");
	sprintf(csBuf,"%d",iPoolId);
	strcat((char*)hv_dynstmt.arr,csBuf);
	strcat((char*)hv_dynstmt.arr," ");

	strcat((char*)hv_dynstmt.arr,"and rm_psp_id = rpp_psp_id ");
	strcat((char*)hv_dynstmt.arr,"and rpp_disabled = 0 ");
	strcat((char*)hv_dynstmt.arr,"and rpp_psp_id in (");
	
	if (GetField_Int(hRec,"psp_id_cnt",&iPspCnt)) {
DEBUGLOG(("FindAvalPspSchudler: psp_id_cnt = [%d]\n",iPspCnt));
		int i = 0;
		char	csTag[PD_TAG_LEN +1];
		for (i = 0; i < iPspCnt; i++) {
			sprintf(csTag,"psp_id_%d",i);
			if (GetField_CString(hRec,csTag,&csPtr)) {
DEBUGLOG(("FindAvalPspForPool: [%s] = [%s]\n",csTag,csPtr));
				if (i == 0)
					sprintf(csBuf,"'%s'",csPtr);
				else 
					sprintf(csBuf,",'%s'",csPtr);
				strcat((char*)hv_dynstmt.arr,csBuf);
			}
		}
        }
	strcat((char*)hv_dynstmt.arr,")");

        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

	EXEC SQL PREPARE PS FROM :hv_dynstmt;
	EXEC SQL DECLARE c_cursor_getavalpspschudler CURSOR FOR PS;
	FREE_ME(csBuf);

	EXEC SQL OPEN c_cursor_getavalpspschudler;
        do {	
		EXEC SQL FETCH c_cursor_getavalpspschudler
                INTO
			:v_cnt:ind_cnt;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
		
		if (ind_cnt >= 0 ) {
			if (v_cnt > 0) {
DEBUGLOG(("FindAvalPspSchudler: cnt = [%d]\n",v_cnt));
				iRet = PD_OK;
			}
		}
	}
	while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getavalpspschudler;
DEBUGLOG(("FindAvalPspSchudler iRet = [%d]\n",iRet));
        return iRet;
findavalpspschudler_error:
DEBUGLOG(("findavalpspschduler code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getavalpspschudler;
    return PD_ERR;
}

int GetAllPspByMerch(const char* csMerchantId,
			recordset_t* myRec)
{

	int iRet = PD_OK;
	int	iCnt = 0;

	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO get_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar	v_psp_name[PD_PSP_NAME_LEN];
		varchar	v_psp_id[PD_PSP_ID_LEN];
		varchar v_ccy[PD_CCY_ID_LEN];
		double v_limit;
		double v_remaining_limit;

		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];

		short	hv_return_value;

		short	ind_psp_name = -1;
		short	ind_psp_id = -1;
		short	ind_ccy = -1;
		short	ind_limit = -1;
		short	ind_remaining_limit = -1;

		short	ind_merchant_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

/* merchant_id */
	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("GetAllPspByMerch: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_lb_all_psp_get(:hv_merchant_id:ind_merchant_id,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value == 0 ) {
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_psp_name = -1;
			ind_psp_id = -1;
			ind_ccy = -1;
			ind_limit = -1;
			ind_remaining_limit = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_psp_name:ind_psp_name,
				:v_psp_id:ind_psp_id,
				:v_ccy:ind_ccy,
				:v_limit:ind_limit,
				:v_remaining_limit:ind_remaining_limit;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_psp_name >= 0) {
				v_psp_name.arr[v_psp_name.len] = '\0';
DEBUGLOG(("GetAllPspByMerch: [%03d]psp_name = [%s]\n",iCnt,v_psp_name.arr));
				PutField_CString(myHash,"psp_name",(const char*)v_psp_name.arr);
			}

			if (ind_psp_id >= 0) {
				v_psp_id.arr[v_psp_id.len] = '\0';
DEBUGLOG(("GetAllPspByMerch: [%03d]psp_id = [%s]\n",iCnt,v_psp_id.arr));
				PutField_CString(myHash,"psp_id",(const char*)v_psp_id.arr);
			}

			if (ind_ccy>= 0) {
				v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("GetAllPspByMerch: [%03d]ccy = [%s]\n",iCnt,v_ccy.arr));
				PutField_CString(myHash,"psp_ccy",(const char*)v_ccy.arr);
			}

			if (ind_limit >= 0) {
DEBUGLOG(("GetAllPspByMerch: [%03d]limit = [%lf]\n",iCnt,v_limit));
				PutField_Double(myHash,"psp_limit",v_limit);
			}

			if (ind_remaining_limit >= 0) {
DEBUGLOG(("GetAllPspByMerch: [%03d]remaining_limit = [%lf]\n",iCnt,v_remaining_limit));
				PutField_Double(myHash,"psp_remaining_limit",v_remaining_limit);
			}
	
			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
	}

	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAllPspByMerch: Finished\n"));

	return iRet;

get_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    EXEC SQL FREE :c_cursor_id;
    return PD_ERR;
}


int GetAllPspByMerchBank(const char* csMerchantId,
			const char* csBank,
			recordset_t* myRec)
{
	int iRet = PD_OK;
	int	iCnt = 0;

	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO mbget_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar	v_psp_name[PD_PSP_NAME_LEN];
		varchar	v_psp_id[PD_PSP_ID_LEN];
		varchar	v_client_id[PD_CLIENT_ID_LEN];
		varchar v_ccy[PD_CCY_ID_LEN];
		double v_limit;
		double v_remaining_limit;

		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_bank[PD_BANK_CODE_LEN];

		short	hv_return_value;

		short	ind_psp_name = -1;
		short	ind_psp_id = -1;
		short	ind_client_id = -1;
		short	ind_ccy = -1;
		short	ind_limit = -1;
		short	ind_remaining_limit = -1;

		short	ind_merchant_id = -1;
		short	ind_bank= -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

/* merchant_id */
	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("GetAllPspByMerchBank: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

/* bank_code */
	hv_bank.len = strlen(csBank);
	memcpy(hv_bank.arr,csBank,hv_bank.len);
	ind_bank= 0;
DEBUGLOG(("GetAllPspByMerchBank: bank_code = [%.*s]\n",hv_bank.len,hv_bank.arr));

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_lb_mbgetpsp(:hv_merchant_id:ind_merchant_id,
								:hv_bank:ind_bank,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value == 0 ) {
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_psp_name = -1;
			ind_psp_id = -1;
			ind_client_id = -1;
			ind_ccy = -1;
			ind_limit = -1;
			ind_remaining_limit = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_psp_name:ind_psp_name,
				:v_psp_id:ind_psp_id,
				:v_client_id:ind_client_id,
				:v_ccy:ind_ccy,
				:v_limit:ind_limit,
				:v_remaining_limit:ind_remaining_limit;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_psp_name >= 0) {
				v_psp_name.arr[v_psp_name.len] = '\0';
DEBUGLOG(("GetAllPspByMerchBank: [%03d]psp_name = [%s]\n",iCnt,v_psp_name.arr));
				PutField_CString(myHash,"psp_name",(const char*)v_psp_name.arr);
			}

			if (ind_psp_id >= 0) {
				v_psp_id.arr[v_psp_id.len] = '\0';
DEBUGLOG(("GetAllPspByMerchBank: [%03d]psp_id = [%s]\n",iCnt,v_psp_id.arr));
				PutField_CString(myHash,"psp_id",(const char*)v_psp_id.arr);
			}

			if (ind_client_id >= 0) {
				v_client_id.arr[v_client_id.len] = '\0';
DEBUGLOG(("GetAllPspByMerchBank: [%03d]client_id = [%s]\n",iCnt,v_client_id.arr));
				PutField_CString(myHash,"client_id",(const char*)v_client_id.arr);
			}

			if (ind_ccy>= 0) {
				v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("GetAllPspByMerchBank: [%03d]ccy = [%s]\n",iCnt,v_ccy.arr));
				PutField_CString(myHash,"psp_ccy",(const char*)v_ccy.arr);
			}

			if (ind_limit >= 0) {
DEBUGLOG(("GetAllPspByMerchBank: [%03d]limit = [%lf]\n",iCnt,v_limit));
				PutField_Double(myHash,"psp_limit",v_limit);
			}

			if (ind_remaining_limit >= 0) {
DEBUGLOG(("GetAllPspByMerchBank: [%03d]remaining_limit = [%lf]\n",iCnt,v_remaining_limit));
				PutField_Double(myHash,"psp_remaining_limit",v_remaining_limit);
			}
	
			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
	}

	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAllPspByMerchBank: Finished\n"));

	return iRet;

mbget_error:
DEBUGLOG(("mbget_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    EXEC SQL FREE :c_cursor_id;
    return PD_ERR;
}

int HaveDefineRuleByService(const char* csServiceCode)
{
        int iRet = PD_NOT_FOUND;

DEBUGLOG(("HaveDefineRuleByService()\n"));
        EXEC SQL WHENEVER SQLERROR GOTO byservice_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];

                int     v_count;

                short   ind_count= -1;

        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("HaveDefineRuleByService: service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len));

        EXEC SQL DECLARE c_cursor_byservice CURSOR FOR
		SELECT	count(*) 
              	FROM	rule_psp_lb_criteria
		where	rc_service_code = :hv_service_code
		and	rc_allow_special_region = 1
		and	rc_disabled = 0;

        EXEC SQL OPEN c_cursor_byservice;
        do {
                EXEC SQL FETCH c_cursor_byservice
                  INTO
                        :v_count:ind_count;


                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("HaveDefineRuleByService  found\n"));
                if (ind_count>= 0 ) {
DEBUGLOG(("HaveDefineRuleByService  count = [%d]\n",v_count));
                        if (v_count>0 )  {
                                iRet = PD_FOUND;
                        }
                }
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_byservice;

DEBUGLOG(("HaveDefineRuleByService iRet = [%d]\n",iRet));
        return iRet;
byservice_error:
DEBUGLOG(("byservice_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_byservice;
    return PD_ERR;
}


int GetBankPspByMerch(const char* csMerchantId,
			recordset_t* myRec)
{
	int iRet = PD_OK;
	int	iCnt = 0;

	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO maget_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar	v_psp_id[PD_PSP_ID_LEN];
		varchar	v_client_id[PD_CLIENT_ID_LEN];
		varchar v_ccy[PD_CCY_ID_LEN];
		varchar	v_bank[PD_BANK_CODE_LEN];
		double	v_remaining_limit;
		int	v_scheduler_id;
		int	v_note_id;

		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];

		short	hv_return_value;

		short	ind_psp_id = -1;
		short	ind_client_id = -1;
		short	ind_ccy = -1;
		short	ind_bank= -1;
		short	ind_remaining_limit = -1;
		short	ind_scheduler_id = -1;
		short	ind_note_id = -1;

		short	ind_merchant_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

/* merchant_id */
	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("GetBankPspByMerch: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));


	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_lb_merch_get_pspbank( :hv_merchant_id:ind_merchant_id,
									  :c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value == 0 ) {
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_psp_id = -1;
			ind_client_id = -1;
			ind_ccy = -1;
			ind_bank = -1;
			ind_remaining_limit = -1;
			ind_scheduler_id = -1;
			ind_note_id = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_bank:ind_bank,
				:v_client_id:ind_client_id,
				:v_psp_id:ind_psp_id,
				:v_ccy:ind_ccy,
				:v_remaining_limit:ind_remaining_limit,
				:v_scheduler_id:ind_scheduler_id,
				:v_note_id:ind_note_id;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_bank >= 0) {
				v_bank.arr[v_bank.len] = '\0';
DEBUGLOG(("GetBankPspByMerch: [%03d]bank = [%s]\n",iCnt,v_bank.arr));
				PutField_CString(myHash,"bank_code",(const char*)v_bank.arr);
			}

			if (ind_psp_id >= 0) {
				v_psp_id.arr[v_psp_id.len] = '\0';
DEBUGLOG(("GetBankPspByMerch: [%03d]psp_id = [%s]\n",iCnt,v_psp_id.arr));
				PutField_CString(myHash,"psp_id",(const char*)v_psp_id.arr);
			}

			if (ind_client_id >= 0) {
				v_client_id.arr[v_client_id.len] = '\0';
DEBUGLOG(("GetBankPspByMerch: [%03d]client_id = [%s]\n",iCnt,v_client_id.arr));
				PutField_CString(myHash,"client_id",(const char*)v_client_id.arr);
			}

			if (ind_ccy>= 0) {
				v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("GetBankPspByMerch: [%03d]ccy = [%s]\n",iCnt,v_ccy.arr));
				PutField_CString(myHash,"psp_ccy",(const char*)v_ccy.arr);
			}
	
			if (ind_remaining_limit>= 0) {
DEBUGLOG(("GetBankPspByMerch: [%03d]remaining_limit = [%lf]\n",iCnt,v_remaining_limit));
				PutField_Double(myHash,"remaining_limit",v_remaining_limit);
			}

			if (ind_scheduler_id>= 0) {
DEBUGLOG(("GetBankPspByMerch: [%03d]scheduler_id = [%d]\n",iCnt,v_scheduler_id));
				PutField_Int(myHash,"scheduler_id",v_scheduler_id);
			}

			if (ind_note_id>= 0) {
DEBUGLOG(("GetBankPspByMerch: [%03d]note_id = [%d]\n",iCnt,v_note_id));
				PutField_Int(myHash,"note_id",v_note_id);
			}

			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
	}

	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetBankPspByMerch: Finished\n"));

	return iRet;

maget_error:
DEBUGLOG(("maget_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    EXEC SQL FREE :c_cursor_id;
    return PD_ERR;
}

/*
int GetDstCcyWithLBRule(const char* csMerchantId,
			const char* csServiceCode,
			recordset_t* myRec)
{
	int iRet = PD_OK;
	int	iCnt = 0;

	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getccy_lb_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar v_ccy[PD_CCY_ID_LEN];

		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];

		short	hv_return_value;

		short	ind_ccy = -1;

		short	ind_merchant_id = -1;
		short	ind_service_code = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

// merchant_id 
	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("GetDstCcyWithLBRule: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

// service_code 
	hv_service_code.len = strlen(csServiceCode);
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("GetDstCcyWithLBRule: service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));


	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_lb_get_dstccy(:hv_merchant_id:ind_merchant_id,
								  :hv_service_code:ind_service_code,
								  :c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value == 0 ) {
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_ccy = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	
				:v_ccy:ind_ccy;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_ccy>= 0) {
				v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("GetDstCcyWithLBRule: [%03d]ccy = [%s]\n",iCnt,v_ccy.arr));
				PutField_CString(myHash,"psp_ccy",(const char*)v_ccy.arr);
			}
	
			RecordSet_Add(myRec,myHash);
			iCnt++;
			break; ////only one record
		}
	}

	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;

	if(iCnt==0)
		iRet = PD_ERR;

DEBUGLOG(("GetDstCcyWithLBRule: Finished iRet = [%d]\n",iRet));

	return iRet;

getccy_lb_error:
DEBUGLOG(("getccy_lb_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    EXEC SQL FREE :c_cursor_id;
    return PD_ERR;
}

int GetDstCcyWithoutLBRule(const char* csMerchantId,
			const char* csServiceCode,
			recordset_t* myRec)
{
	int iRet = PD_OK;
	int	iCnt = 0;

	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getccy_wolb_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar v_ccy[PD_CCY_ID_LEN];

		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];

		short	hv_return_value;

		short	ind_ccy = -1;

		short	ind_merchant_id = -1;
		short	ind_service_code = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

// merchant_id
	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("GetDstCcyWithoutLBRule: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

// service_code 
	hv_service_code.len = strlen(csServiceCode);
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("GetDstCcyWithoutLBRule: service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));


	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_no_lbrule_get_dstccy(:hv_merchant_id:ind_merchant_id,
								  :hv_service_code:ind_service_code,
								  :c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value == 0 ) {
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_ccy = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	
				:v_ccy:ind_ccy;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_ccy>= 0) {
				v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("GetDstCcyWithoutLBRule: [%03d]ccy = [%s]\n",iCnt,v_ccy.arr));
				PutField_CString(myHash,"psp_ccy",(const char*)v_ccy.arr);
			}
	
			RecordSet_Add(myRec,myHash);
			iCnt++;
			break; ////only one record
		}
	}

	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;

	if(iCnt==0)
		iRet = PD_ERR;

DEBUGLOG(("GetDstCcyWithoutLBRule: Finished iRet = [%d]\n",iRet));

	return iRet;

getccy_wolb_error:
DEBUGLOG(("getccy_wolb_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    EXEC SQL FREE :c_cursor_id;
    return PD_ERR;
}
*/

int GetDstCcyWithoutRule(const char* csMerchantId,
			const char* csServiceCode,
			hash_t * hTxn)
{
	int iRet = PD_OK;

        EXEC SQL WHENEVER SQLERROR GOTO getccy_wor_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar v_ccy[PD_CCY_ID_LEN];

		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];

		short	hv_return_value;

		short	ind_ccy = -1;

		short	ind_merchant_id = -1;
		short	ind_service_code = -1;


        EXEC SQL END DECLARE SECTION;

/* merchant_id */
	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("GetDstCcyWithoutRule: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

/* service_code */
	hv_service_code.len = strlen(csServiceCode);
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("GetDstCcyWithoutRule: service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));


        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_no_rule_get_dstccy(:hv_merchant_id:ind_merchant_id,
								  :hv_service_code:ind_service_code,
								  :v_ccy:ind_ccy);
                END;
        END-EXEC;

	if (hv_return_value == 0 ) {
		if (ind_ccy>= 0) {
			v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("GetDstCcyWithoutRule: ccy = [%s]\n",v_ccy.arr));
			PutField_CString(hTxn,"psp_ccy",(const char*)v_ccy.arr);
		}
	}
	else{
		iRet = PD_ERR;
DEBUGLOG(("GetDstCcyWithoutRule  Failed\n"));
	}


DEBUGLOG(("GetDstCcyWithoutRule: Finished iRet = [%d]\n",iRet));

	return iRet;

getccy_wor_error:
DEBUGLOG(("getccy_wor_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_ERR;
}

int GetCustomerGroup(const char* csMerchantId,
                     const char* csServiceCode,
                     const char* csCcy,
                     const char* csBankCode,
                     hash_t * hTxn)
{
	int iRet = PD_OK;
	int iCnt = 0;
	char csTag[PD_TAG_LEN+1];

        EXEC SQL WHENEVER SQLERROR GOTO getgrp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];
		varchar hv_ccy[PD_CCY_ID_LEN];
		varchar hv_bank_code[PD_BANK_CODE_LEN];

		varchar	v_group[PD_CUSTOMER_GROUP_CODE_LEN+1];

		short	hv_return_value;

		short	ind_merchant_id = -1;
		short	ind_service_code = -1;
		short	ind_ccy = -1;
		short	ind_bank_code  = -1;

		short	ind_group = -1;

		SQL_CURSOR      c_cursor_id;
        EXEC SQL END DECLARE SECTION;

/* merchant_id */
	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("GetCustomerGroup: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

/* service_code */
	hv_service_code.len = strlen(csServiceCode);
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("GetCustomerGroup: service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

/*ccy*/
	hv_ccy.len = strlen(csCcy);
	memcpy(hv_ccy.arr,csCcy,hv_ccy.len);
	ind_ccy = 0;
DEBUGLOG(("GetCustomerGroup: ccy = [%.*s]\n",hv_ccy.len,hv_ccy.arr));

/* bank_code */
	hv_bank_code.len = strlen(csBankCode);
	memcpy(hv_bank_code.arr,csBankCode,hv_bank_code.len);
	ind_bank_code = 0;
DEBUGLOG(("GetCustomerGroup: bank_code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr));


	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_lb_get_custgrp(:hv_merchant_id:ind_merchant_id,
								  :hv_service_code:ind_service_code,
								  :hv_ccy:ind_ccy,
								  :hv_bank_code:ind_bank_code,
								  :c_cursor_id);
                END;
        END-EXEC;

	PutField_Int(hTxn,"group_cnt",iCnt);
	if (hv_return_value == 0 ) {
		for (;;) {
			ind_group = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	
				:v_group:ind_group;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_group>= 0) {
				v_group.arr[v_group.len] = '\0';
DEBUGLOG(("GetCustomerGroup: [%03d]group = [%s]\n",iCnt,v_group.arr));
				sprintf(csTag,"customer_group_%d",iCnt);
				PutField_CString(hTxn,csTag,(const char*)v_group.arr);
			}
	
			iCnt++;
			PutField_Int(hTxn,"group_cnt",iCnt);
		}
	}
	else{
		iRet = PD_ERR;
DEBUGLOG(("GetCustomerGroup  Failed!!!\n"));
	}

DEBUGLOG(("GetCustomerGroup: Finished iRet = [%d]\n",iRet));
	return iRet;

getgrp_error:
DEBUGLOG(("getgrp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_ERR;
}
