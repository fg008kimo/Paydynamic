/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/01/03              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "RuleLB.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RuleLB(char    cdebug)
{
        cDebug = cdebug;
}


int MatchCriteria(const hash_t *hRec,
			recordset_t* myRec)
{

	int iRet = PD_NOT_FOUND;
	int	iCnt = 0;
	char	*csPtr;
	char	cPtr;

	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO match_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_channel_code[PD_CHANNEL_CODE_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];
		varchar	hv_payment_method[PD_PAY_METHOD_LEN];
		varchar	hv_txn_country[PD_COUNTRY_LEN];
		varchar	hv_txn_ccy[PD_CCY_ID_LEN];
		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_client_id[PD_CLIENT_ID_LEN];
		char	hv_business_type;

		int	v_txn_amount_tier;
		int	v_criteria_pool_id;
		int	v_scheduler_id;
		
		short	ind_channel_code = -1;
		short	ind_service_code = -1;
		short	ind_payment_method = -1;
		short	ind_txn_country = -1;
		short	ind_txn_ccy = -1;
		short	ind_merchant_id = -1;
		short	ind_client_id = -1;
		short	ind_business_type = 1;

		short	ind_txn_amount_tier = -1;
		short	ind_pool_id = -1;
		short	ind_scheduler_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

/* channel code */
	if (GetField_CString(hRec,"channel_code",&csPtr)) {
		hv_channel_code.len = strlen(csPtr);
		memcpy(hv_channel_code.arr,csPtr,hv_channel_code.len);
		ind_channel_code = 0;
DEBUGLOG(("MatchCriteria: channel_code = [%.*s]\n",hv_channel_code.len,hv_channel_code.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: channel_code is missing!!!\n"));
	}

/* service code */
	if (GetField_CString(hRec,"service_code",&csPtr)) {
		hv_service_code.len = strlen(csPtr);
		memcpy(hv_service_code.arr,csPtr,hv_service_code.len);
		ind_service_code = 0;
DEBUGLOG(("MatchCriteria: service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: service_code is missing!!!\n"));
	}

/*payment method */
	if (GetField_CString(hRec,"pay_method",&csPtr)) {
		hv_payment_method.len = strlen(csPtr);
		memcpy(hv_payment_method.arr,csPtr,hv_payment_method.len);
		ind_payment_method = 0;
DEBUGLOG(("MatchCriteria: payment_method = [%.*s]\n",hv_payment_method.len,hv_payment_method.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: pay_method is missing!!!\n"));
	}

/*txn_country */
	if (GetField_CString(hRec,"txn_country",&csPtr)) {
		hv_txn_country.len = strlen(csPtr);
		memcpy(hv_txn_country.arr,csPtr,hv_txn_country.len);
		ind_txn_country = 0;
DEBUGLOG(("MatchCriteria: txn_country = [%.*s]\n",hv_txn_country.len,hv_txn_country.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: txn_country is missing!!!\n"));
	}

/*txn_ccy */
	if (GetField_CString(hRec,"txn_ccy",&csPtr)) {
		hv_txn_ccy.len = strlen(csPtr);
		memcpy(hv_txn_ccy.arr,csPtr,hv_txn_ccy.len);
		ind_txn_ccy = 0;
DEBUGLOG(("MatchCriteria: txn_ccy = [%.*s]\n",hv_txn_ccy.len,hv_txn_ccy.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: txn_ccy is missing!!!\n"));
	}


/*merchant_id */
	if (GetField_CString(hRec,"merchant_id",&csPtr)) {
		hv_merchant_id.len = strlen(csPtr);
		memcpy(hv_merchant_id.arr,csPtr,hv_merchant_id.len);
		ind_merchant_id = 0;
DEBUGLOG(("MatchCriteria: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: merchant_id is missing!!!\n"));
	}

/*client_id */
	if (GetField_CString(hRec,"client_id",&csPtr)) {
		hv_client_id.len = strlen(csPtr);
		memcpy(hv_client_id.arr,csPtr,hv_client_id.len);
		ind_client_id = 0;
DEBUGLOG(("MatchCriteria: client_id = [%.*s]\n",hv_client_id.len,hv_client_id.arr));
	}
	else {
DEBUGLOG(("MatchCriteria: client_id is missing!!!\n"));
	}


/*business_type */
	if (GetField_Char(hRec,"business_type",&cPtr)) {
		hv_business_type = cPtr;
		ind_business_type = 0;
DEBUGLOG(("MatchCriteria: business_type = [%c]\n",hv_business_type));
	}
	else {
DEBUGLOG(("MatchCriteria: business_type is missing!!!\n"));
	}

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_lb_match(:hv_channel_code:ind_channel_code,
								:hv_service_code:ind_service_code,
								:hv_payment_method:ind_payment_method,
								:hv_txn_country:ind_txn_country,
								:hv_txn_ccy:ind_txn_ccy,
								:hv_merchant_id:ind_merchant_id,
								:hv_client_id:ind_client_id,
								:hv_business_type:ind_business_type,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value > 0 ) {
DEBUGLOG(("MatchCriteria: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_txn_amount_tier = -1;
			ind_pool_id = -1;
			ind_scheduler_id = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_txn_amount_tier:ind_txn_amount_tier,
				:v_criteria_pool_id:ind_pool_id,
				:v_scheduler_id:ind_scheduler_id;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_txn_amount_tier >= 0) {
DEBUGLOG(("MatchCriteria: [%03d]txn_amount_tier = [%d]\n",iCnt,v_txn_amount_tier));
				PutField_Int(myHash,"amount_tier_id",v_txn_amount_tier);
			}
			if (ind_pool_id >= 0) {
DEBUGLOG(("MatchCriteria: [%03d]criteria_pool_id = [%d]\n",iCnt,v_criteria_pool_id));
				PutField_Int(myHash,"criteria_pool_id",v_criteria_pool_id);
			}
			if (ind_scheduler_id >= 0) {
DEBUGLOG(("MatchCriteria: [%03d]scheduler_id = [%d]\n",iCnt,v_scheduler_id));
				PutField_Int(myHash,"scheduler_id",v_scheduler_id);
			}

			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("MatchCriteria: exit with ok\n"));
		return PD_FOUND;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("MatchCriteria: exit with error\n"));
		return PD_NOT_FOUND;
	}


	EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

match_error:
DEBUGLOG(("match_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    return PD_NOT_FOUND;
}

int GetAvalPspsByPool(int iPoolId,
			const char* csPayMethod,
			const char* csServiceCode,
			const char* csTxnCountry,
			recordset_t* myRec)
{

	int iRet = PD_OK;

	hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getavalpspsbypool_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

	int	hv_pool_id;
	varchar	hv_pay_method[PD_PAY_METHOD_LEN];
	varchar	hv_service_code[PD_SERVICE_CODE_LEN];
	varchar	hv_txn_country[PD_COUNTRY_LEN];
	char	hv_mode;

	varchar	v_psp_id[PD_PSP_ID_LEN +1];
	

	short	ind_psp_id = -1;

        EXEC SQL END DECLARE SECTION;

	hv_pool_id = iPoolId;
DEBUGLOG(("GetAvalPspsByPool pool id = [%d]\n",hv_pool_id));

	hv_pay_method.len = strlen(csPayMethod);
	memcpy(hv_pay_method.arr,csPayMethod,hv_pay_method.len);
DEBUGLOG(("GetAvalPspsByPool pool id = [%.*s]\n",hv_pay_method.len,hv_pay_method.arr));

	hv_service_code.len = strlen(csServiceCode);
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetAvalPspsByPool service code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_txn_country.len = strlen(csTxnCountry);
	memcpy(hv_txn_country.arr,csTxnCountry,hv_txn_country.len);
DEBUGLOG(("GetAvalPspsByPool txn country = [%.*s]\n",hv_txn_country.len,hv_txn_country.arr));


	hv_mode = PD_ONLINE_MODE;
DEBUGLOG(("GetAvalPspsByPool online mode = [%c]\n",hv_mode));

	EXEC SQL DECLARE c_cursor_getavalpspsbypool CURSOR FOR
		SELECT psp_id 
 		 FROM (SELECT rm_psp_id as psp_id
   			 FROM rule_psp_lb_mapping,
           		      rule_psp_lb_psp,
           		      psp_detail
		        WHERE rm_pool_id = :hv_pool_id
    			  AND rm_psp_id = rpp_psp_id
    		          AND rpp_disabled = 0
    			  AND rm_psp_id = psp_id
    			  AND disabled = 0
    			  AND online_mode = :hv_mode) a
 		WHERE a.psp_id in 
  		    (SELECT PP_PSP_ID
  		       FROM psp_pay_method
		      WHERE pp_disabled = 0
    			AND pp_country = :hv_txn_country
    			AND PP_PAY_METHOD in (
        			SELECT sp_pay_method
           			  FROM service_pay_method
           			 WHERE sp_service_code = :hv_service_code
               			   AND sp_disabled = 0
               			   AND sp_pay_method = :hv_pay_method));
  	

	EXEC SQL OPEN c_cursor_getavalpspsbypool;
        do {
		EXEC SQL FETCH c_cursor_getavalpspsbypool
                INTO
			:v_psp_id:ind_psp_id;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }	

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);	

		if  (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len] = '\0';
DEBUGLOG(("GetAvalPspsByPool PSP ID = [%s]\n",v_psp_id.arr));
			PutField_CString(myHash,"psp_id",(char*)v_psp_id.arr);
		}
		RecordSet_Add(myRec,myHash);
	}while (PD_TRUE);	

	EXEC SQL CLOSE c_cursor_getavalpspsbypool;
	return iRet;

getavalpspsbypool_error:
DEBUGLOG(("getavalpspsbypool_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getavalpspsbypool;
    return PD_ERR;
}



int FindAvalPsp(int     iPoolId,
                const char* csServiceCode,
                const char* csTxnCountry,
                double dTotal)
{
        int iRet = PD_ERR;

DEBUGLOG(("FindAvalPsp()\n"));
        EXEC SQL WHENEVER SQLERROR GOTO findavalpsp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                int     hv_pool_id;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
                varchar hv_txn_country[PD_COUNTRY_LEN];
                varchar hv_category[PD_CATEGORY_LEN];
                char    hv_type;
                char    hv_party_type;
                double  hv_total;

                int     v_counter;

                short   ind_counter = -1;

        EXEC SQL END DECLARE SECTION;

        hv_pool_id = iPoolId;
DEBUGLOG(("FindAvalPsp: pool id  = [%d]\n",iPoolId));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindAvalPsp: service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len));

        hv_txn_country.len = strlen(csTxnCountry);
        memcpy(hv_txn_country.arr,csTxnCountry,hv_txn_country.len);
DEBUGLOG(("FindAvalPsp: txn_country = [%.*s][%d]\n",hv_txn_country.len,hv_txn_country.arr,hv_txn_country.len));

        hv_type = PD_DAILY;
DEBUGLOG(("FindAvalPsp: type = [%c]\n",hv_type));


        hv_category.len = strlen(PD_VALUE_TYPE_AMT);
        memcpy(hv_category.arr,PD_VALUE_TYPE_AMT,hv_category.len);
DEBUGLOG(("FindAvalPsp: category = [%.*s][%d]\n",hv_category.len,hv_category.arr,hv_category.len));

        hv_party_type = PD_TYPE_PSP;
DEBUGLOG(("FindAvalPsp: party_type = [%c]\n",hv_party_type));

        hv_total = dTotal;
DEBUGLOG(("FindAvalPsp: total = [%f]\n",hv_total));


        EXEC SQL DECLARE c_cursor_findavalpsp CURSOR FOR
                select count(*) as cnt
                from (
                        select tc_party_id,
                        sum(tc_total_counter) as total_counter
                        from txn_counters
                 where tc_txn_code in ('DSI','DSP')
                   and tc_country_id = :hv_txn_country
                   and tc_channel_code in ('WEB','XPY')
                   and tc_service_code = :hv_service_code
                   and TC_type = :hv_type
                   and tc_category = :hv_category
                   and Tc_party_type = :hv_party_type
                   and tc_party_id in (
                        SELECT rm_psp_id
                          FROM rule_psp_lb_mapping,
                               psp_detail a,
                               clients b
                         WHERE rm_pool_id = :hv_pool_id
                           AND rm_disabled = 0
                           and rm_psp_id = a.psp_id
                           and a.disabled = 0
                           and a.online_mode = 'Y'
                           and a.status = 'O'
                           and a.client_id = b.client_id
                           and b.status = 'O'
                )
                group by tc_party_id) a
                where a.total_counter <= :hv_total;



        EXEC SQL OPEN c_cursor_findavalpsp;
        do {
                EXEC SQL FETCH c_cursor_findavalpsp
                  INTO
                        :v_counter:ind_counter;


                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

DEBUGLOG(("FindAvalPsp  found\n"));
                iRet = PD_FOUND;

                if (ind_counter >= 0 ) {
                        if (v_counter >0 )  {
                                iRet = PD_OK;
                        }
                }

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_findavalpsp;

DEBUGLOG(("FindAvalPsp Counter iRet = [%d]\n",iRet));
        return iRet;
findavalpsp_error:
DEBUGLOG(("findavalpsp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_findavalpsp;
    return PD_ERR;
}
int FindAvalPspForPool(int iPoolId,
			hash_t* hRec)
{
        int 	iRet = PD_ERR;
	int	iPspCnt;
	char*	csBuf;
	char*	csPtr;

DEBUGLOG(("FindAvalPspForPool()\n"));
        EXEC SQL WHENEVER SQLERROR GOTO findavalpspforpool_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
	int	v_cnt;
	varchar hv_dynstmt[1024];

	short	ind_cnt = -1;
        EXEC SQL END DECLARE SECTION;

	csBuf = (char*) malloc (128);

	strcpy((char*)hv_dynstmt.arr,"select count(*) as cnt ");
	strcat((char*)hv_dynstmt.arr,"from rule_psp_lb_mapping,rule_psp_lb_psp ");
	strcat((char*)hv_dynstmt.arr,"where rm_disabled = 0 ");

/* pool id */
	strcat((char*)hv_dynstmt.arr,"and rm_pool_id = ");
	sprintf(csBuf,"%d",iPoolId);
	strcat((char*)hv_dynstmt.arr,csBuf);
	strcat((char*)hv_dynstmt.arr," ");

	strcat((char*)hv_dynstmt.arr,"and rm_psp_id = rpp_psp_id ");
	strcat((char*)hv_dynstmt.arr,"and rpp_disabled = 0 ");
	strcat((char*)hv_dynstmt.arr,"and rpp_psp_id in (");
	
	if (GetField_Int(hRec,"psp_id_cnt",&iPspCnt)) {
DEBUGLOG(("FindAvalPspForPool: psp_id_cnt = [%d]\n",iPspCnt));
		int i = 0;
		char	csTag[PD_TAG_LEN +1];
		for (i = 0; i < iPspCnt; i++) {
			sprintf(csTag,"psp_id_%d",i);
			if (GetField_CString(hRec,csTag,&csPtr)) {
DEBUGLOG(("FindAvalPspForPool: [%s] = [%s]\n",csTag,csPtr));
				if (i == 0)
					sprintf(csBuf,"'%s'",csPtr);
				else 
					sprintf(csBuf,",'%s'",csPtr);
				strcat((char*)hv_dynstmt.arr,csBuf);
			}
		}
        }
	strcat((char*)hv_dynstmt.arr,")");

        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

	EXEC SQL PREPARE PS FROM :hv_dynstmt;
	EXEC SQL DECLARE c_cursor_getavalpsp CURSOR FOR PS;
	FREE_ME(csBuf);

	EXEC SQL OPEN c_cursor_getavalpsp;
        do {	
		EXEC SQL FETCH c_cursor_getavalpsp
                INTO
			:v_cnt:ind_cnt;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
		
		if (ind_cnt >= 0 ) {
			if (v_cnt > 0) {
DEBUGLOG(("FindAvalPspForPool: cnt = [%d]\n",v_cnt));
				iRet = PD_OK;
			}
		}
	}
	while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getavalpsp;
DEBUGLOG(("FindAvalPspForPool iRet = [%d]\n",iRet));
        return iRet;
findavalpspforpool_error:
DEBUGLOG(("findavalpspforpool_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getavalpsp;
    return PD_ERR;
}
