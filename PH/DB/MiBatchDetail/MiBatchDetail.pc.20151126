/*
Partnerdelight (c)2015. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/11/06              LokMan Chow
Add function GetAllDetailByTxnId                   2015/11/18              David Wong
Add function GetLastBatchIdByTxnId		   2015/11/25		   Dirk Wong
Add function GetAllDetailByBatchId                 2015/11/25              Elvis Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "internal.h"
#include "MiBatchDetail.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void MiBatchDetail(char    cdebug)
{
        cDebug = cdebug;
}



int Add(const hash_t *hRls)
{
	char            *csTmp;
	char          	cTmp;
	int          	iTmp;


	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

	short           hv_return_value;

	varchar         hv_batch_id[PD_MI_BATCH_ID_LEN];
	int         	hv_seq;
	varchar         hv_entity_id[PD_MMS_ENTITY_ID_LEN];
	varchar		hv_party_type[PD_MMS_PARTY_TYPE_LEN];
	varchar		hv_party_id[PD_MMS_PARTY_ID_LEN];
	varchar		hv_txn_id[PD_TXN_SEQ_LEN];
	char		hv_txn_oper_ind;
	varchar         hv_add_user[PD_USER_LEN];

	short           ind_batch_id = -1;
	short           ind_seq = -1;
	short           ind_entity_id = -1;
	short           ind_party_type = -1;
	short           ind_party_id = -1;
	short           ind_txn_id = -1;
	short           ind_txn_oper_ind = -1;
	short           ind_add_user = -1;

	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));


/* batch_id */
        if (GetField_CString(hRls,"batch_id",&csTmp)) {
                hv_batch_id.len = strlen(csTmp);
                memcpy(hv_batch_id.arr,csTmp,hv_batch_id.len);
                ind_batch_id = 0;
DEBUGLOG(("Add:batch_id = [%.*s]\n",hv_batch_id.len,hv_batch_id.arr));
        }

/* seq */
        if (GetField_Int(hRls,"seq",&iTmp)) {
                hv_seq = iTmp;
                ind_seq = 0;
DEBUGLOG(("Add:seq = [%d]\n",hv_seq));
        }

/* entity_id */
        if (GetField_CString(hRls,"entity_id",&csTmp)) {
                hv_entity_id.len = strlen(csTmp);
                memcpy(hv_entity_id.arr,csTmp,hv_entity_id.len);
                ind_entity_id = 0;
DEBUGLOG(("Add:entity_id = [%.*s]\n",hv_entity_id.len,hv_entity_id.arr));
        }

/* party_type */
        if (GetField_CString(hRls,"party_type",&csTmp)) {
                hv_party_type.len = strlen(csTmp);
                memcpy(hv_party_type.arr,csTmp,hv_party_type.len);
                ind_party_type = 0;
DEBUGLOG(("Add:party_type = [%.*s]\n",hv_party_type.len,hv_party_type.arr));
        }

/* party_id */
        if (GetField_CString(hRls,"party_id",&csTmp)) {
                hv_party_id.len = strlen(csTmp);
                memcpy(hv_party_id.arr,csTmp,hv_party_id.len);
                ind_party_id = 0;
DEBUGLOG(("Add:party_id = [%.*s]\n",hv_party_id.len,hv_party_id.arr));
        }

/* txn_id */
        if (GetField_CString(hRls,"txn_id",&csTmp)) {
                hv_txn_id.len = strlen(csTmp);
                memcpy(hv_txn_id.arr,csTmp,hv_txn_id.len);
                ind_txn_id = 0;
DEBUGLOG(("Add:txn_id = [%.*s]\n",hv_txn_id.len,hv_txn_id.arr));
        }

/* txn_oper_ind */
        if (GetField_Char(hRls,"txn_oper_ind",&cTmp)) {
                hv_txn_oper_ind= cTmp;
                ind_txn_oper_ind = 0;
DEBUGLOG(("Add:txn_oper_ind = [%c]\n",hv_txn_oper_ind));
        }

/* user */
        if (GetField_CString(hRls,"add_user",&csTmp)) {
                hv_add_user.len = strlen(csTmp);
                memcpy(hv_add_user.arr,csTmp,hv_add_user.len);
                ind_add_user = 0;
DEBUGLOG(("Add:add_user = [%.*s]\n",hv_add_user.len,hv_add_user.arr));
        }

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_mi_batch_detail_insert(
					:hv_batch_id:ind_batch_id,
					:hv_seq:ind_seq,
					:hv_entity_id:ind_entity_id,
					:hv_party_type:ind_party_type,
					:hv_party_id:ind_party_id,
					:hv_txn_id:ind_txn_id,
					:hv_txn_oper_ind:ind_txn_oper_ind,
					:hv_add_user:ind_add_user);
		END;
	END-EXEC;


DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK) {
DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MiBatchDetail_Add: SP_OTHER_ERR\n");
DEBUGLOG(("Add: SP_OTHER_ERR\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("MiBatchDetail_Add: SP_ERR\n");
DEBUGLOG(("Add: SP_ERR\n"));
                return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("MiBatchDetail_Add: SP_INTERNAL_ERR\n");
DEBUGLOG(("Add: SP_INTERNAL_ERR\n"));
        return PD_INTERNAL_ERR;
}


int GetOrgBatchIdByTxnId(const char* csTxnId, char cOperInd, hash_t* hDtl)
{
        int     iRet = PD_NOT_FOUND;
DEBUGLOG(("GetOrgBatchIdByTxnId()\n"));

        EXEC SQL WHENEVER SQLERROR GOTO getbatchid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_txn_id[PD_TXN_SEQ_LEN];
		char		hv_oper_ind;
		char		hv_status;

                varchar         v_batch_id[PD_TXN_SEQ_LEN+1];

		short		ind_batch_id = -1;

        EXEC SQL END DECLARE SECTION;

/* txn_id */
	hv_txn_id.len = strlen(csTxnId);
	memcpy(hv_txn_id.arr,csTxnId,hv_txn_id.len);
DEBUGLOG(("GetOrgBatchIdByTxnId txn_id = [%.*s]\n",hv_txn_id.len,hv_txn_id.arr));

       	hv_oper_ind = cOperInd;
DEBUGLOG(("GetOrgBatchIdByTxnId oper_ind = [%c]\n",hv_oper_ind));

	hv_status = 'N';

        EXEC SQL DECLARE c_cursor_getbatchid CURSOR FOR
		SELECT	unique bd_batch_id
	          FROM	mi_batch_header, mi_batch_detail
		WHERE	bh_batch_id = bd_batch_id
		AND	bh_status = :hv_status
		AND	bd_txn_id = :hv_txn_id
		AND	bd_txn_oper_ind = :hv_oper_ind;

        EXEC SQL OPEN c_cursor_getbatchid;
        do {
                EXEC SQL FETCH c_cursor_getbatchid
                INTO
			:v_batch_id:ind_batch_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                iRet = PD_FOUND;

/* batch_id */
                if (ind_batch_id >= 0 ) {
                        v_batch_id.arr[v_batch_id.len] ='\0';
DEBUGLOG(("GetOrgBatchIdByTxnId batch_id = [%s]\n",v_batch_id.arr));
			PutField_CString(hDtl,"batch_id",(const char*) v_batch_id.arr);
                }

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getbatchid;

DEBUGLOG(("GetOrgBatchIdByTxnId() normal return iRet = [%d]\n",iRet));
        return iRet;

getbatchid_error:
DEBUGLOG(("psppartyid_error code %d\n", sqlca.sqlcode));
ERRLOG("DBMiBatchDetail::getbatchid_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getbatchid;
        return PD_ERR;
}

/*
	myHash:
		txn_id(mandatory)
		oper_ind(optional)
*/
int GetAllDetailByTxnId(hash_t* myHash, recordset_t* myRec)
{
	int iRet = PD_NOT_FOUND;
	char cTmp;
	char* csTmp;

	hash_t *hTmp;

DEBUGLOG(("GetAllDetailByTxnId() start\n"));

	EXEC SQL WHENEVER SQLERROR GOTO getalldtbytxnid_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_txn_id[PD_TXN_SEQ_LEN];
		char hv_oper_ind;

		varchar v_batch_id[PD_TXN_SEQ_LEN + 1];
		int v_seq;
		varchar v_entity_id[PD_MMS_ENTITY_ID_LEN + 1];
		varchar v_party_type[PD_MMS_ENTITY_TYPE_LEN + 1];
		varchar v_party_id[PD_MMS_PARTY_ID_LEN + 1];
		varchar v_txn_id[PD_TXN_SEQ_LEN + 1];

		short ind_batch_id = -1;
		short ind_seq = -1;
		short ind_entity_id = -1;
		short ind_party_type = -1;
		short ind_party_id = -1;
		short ind_txn_id = -1;
	EXEC SQL END DECLARE SECTION;

/* txn_id */
	if (GetField_CString(myHash, "txn_id", &csTmp)) {
		hv_txn_id.len = strlen(csTmp);
		memcpy(hv_txn_id.arr, csTmp, hv_txn_id.len);
DEBUGLOG(("GetAllDetailByTxnId txn_id = [%.*s]\n", hv_txn_id.len, hv_txn_id.arr));
	}

/* oper_ind */
	if (GetField_Char(myHash, "oper_ind", &cTmp)) {
		hv_oper_ind = cTmp;
DEBUGLOG(("GetAllDetailByTxnId oper_ind = [%c]\n", hv_oper_ind));
	} else {
		hv_oper_ind = 'X';
DEBUGLOG(("GetAllDetailByTxnId oper_ind = [%c]\n", hv_oper_ind));
	}

	EXEC SQL DECLARE c_cursor_getalldtbytxnid CURSOR FOR
		SELECT	bd_batch_id,
			bd_seq,
			bd_entity_id,
			bd_party_type,
			bd_party_id,
			bd_txn_id
		FROM	mi_batch_detail
		WHERE	bd_batch_id in (
				SELECT	bd_batch_id
				FROM	mi_batch_detail
				WHERE	bd_txn_id = :hv_txn_id
				AND	bd_txn_oper_ind = decode(:hv_oper_ind, 'X', bd_txn_oper_ind, :hv_oper_ind)
			)
		ORDER BY bd_seq asc;

	EXEC SQL OPEN c_cursor_getalldtbytxnid;
	do {
		EXEC SQL FETCH c_cursor_getalldtbytxnid
		INTO
			:v_batch_id:ind_batch_id,
			:v_seq:ind_seq,
			:v_entity_id:ind_entity_id,
			:v_party_type:ind_party_type,
			:v_party_id:ind_party_id,
			:v_txn_id:ind_txn_id;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iRet = PD_FOUND;

		hTmp = (hash_t*) malloc (sizeof(hash_t));
		hash_init(hTmp, 0);

		// batch_id
		if (ind_batch_id >= 0) {
			v_batch_id.arr[v_batch_id.len] = '\0';
DEBUGLOG(("GetAllDetailByTxnId batch_id = [%s]\n", v_batch_id.arr));
			PutField_CString(hTmp, "batch_id", (const char*)v_batch_id.arr);
		}

		// seq
		if (ind_seq >= 0) {
DEBUGLOG(("GetAllDetailByTxnId seq = [%d]\n", v_seq));
			PutField_Int(hTmp, "seq", v_seq);
		}

		// entity_id
		if (ind_entity_id >= 0) {
			v_entity_id.arr[v_entity_id.len] = '\0';
DEBUGLOG(("GetAllDetailByTxnId entity_id = [%s]\n", v_entity_id.arr));
			PutField_CString(hTmp, "entity_id", (const char*)v_entity_id.arr);
		}

		// party_type
		if (ind_party_type >= 0) {
			v_party_type.arr[v_party_type.len] = '\0';
DEBUGLOG(("GetAllDetailByTxnId party_type = [%s]\n", v_party_type.arr));
			PutField_CString(hTmp, "party_type", (const char*)v_party_type.arr);
		}

		// party_id
		if (ind_party_id >= 0) {
			v_party_id.arr[v_party_id.len] = '\0';
DEBUGLOG(("GetAllDetailByTxnId party_id = [%s]\n", v_party_id.arr));
			PutField_CString(hTmp, "party_id", (const char*)v_party_id.arr);
		}

		// txn_id
		if (ind_txn_id >= 0) {
			v_txn_id.arr[v_txn_id.len] = '\0';
DEBUGLOG(("GetAllDetailByTxnId txn_id = [%s]\n", v_txn_id.arr));
			PutField_CString(hTmp, "txn_id", (const char*)v_txn_id.arr);
		}

		RecordSet_Add(myRec, hTmp);
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getalldtbytxnid;

DEBUGLOG(("GetAllDetailByTxnId() normal return iRet = [%d]\n", iRet));
	return iRet;

getalldtbytxnid_error:
DEBUGLOG(("getalldtbytxnid_error code %d\n", sqlca.sqlcode));
ERRLOG("DBMiBatchDetail::getalldtbytxnid_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getalldtbytxnid;
	return PD_ERR;
}

/*
	myHash:
		txn_id(mandatory)
		oper_ind(optional)
*/
int GetSingleDetailByTxnId(hash_t* myHash, recordset_t* myRec)
{
	int iRet = PD_NOT_FOUND;

	return iRet;
}


int GetLastBatchDtByTxnId(const char* csTxnId, hash_t* hDtl)
{
        int     iRet = PD_NOT_FOUND;
DEBUGLOG(("GetLastBatchDtByTxnId()\n"));

        EXEC SQL WHENEVER SQLERROR GOTO getlastbatchdt_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_txn_id[PD_TXN_SEQ_LEN];
		char		hv_status;

                varchar         v_batch_id[PD_TXN_SEQ_LEN+1];
		varchar		v_process_type[PD_MI_PROCESS_TYPE_LEN+1];

		short		ind_batch_id = -1;
		short		ind_process_type = -1;

        EXEC SQL END DECLARE SECTION;

/* txn_id */
	hv_txn_id.len = strlen(csTxnId);
	memcpy(hv_txn_id.arr,csTxnId,hv_txn_id.len);
DEBUGLOG(("GetOrgBatchIdByTxnId txn_id = [%.*s]\n",hv_txn_id.len,hv_txn_id.arr));

	hv_status = 'N';

        EXEC SQL DECLARE c_cursor_getlastbatchdt CURSOR FOR
		SELECT	unique bd_batch_id, bh_process_type
	        FROM	mi_batch_header, mi_batch_detail
		WHERE	bh_batch_id = bd_batch_id
		AND	bh_status = :hv_status
		AND	bd_txn_id = :hv_txn_id
		AND	bd_batch_id NOT IN (SELECT br_org_batch_id
					    FROM   mi_batch_relation
					    WHERE  br_batch_id = bd_batch_id)
		;

        EXEC SQL OPEN c_cursor_getlastbatchdt;
        do {
                EXEC SQL FETCH c_cursor_getlastbatchdt
                INTO
			:v_batch_id:ind_batch_id,
			:v_process_type:ind_process_type;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                iRet = PD_FOUND;

/* batch_id */
                if (ind_batch_id >= 0 ) {
                        v_batch_id.arr[v_batch_id.len] ='\0';
DEBUGLOG(("GetLastBatchDtByTxnId batch_id = [%s]\n",v_batch_id.arr));
			PutField_CString(hDtl,"batch_id",(const char*) v_batch_id.arr);
                }

/* process_type */
                if (ind_process_type >= 0 ) {
                        v_process_type.arr[v_process_type.len] ='\0';
DEBUGLOG(("GetLastBatchDtByTxnId process_type = [%s]\n",v_process_type.arr));
			PutField_CString(hDtl,"process_type",(const char*) v_process_type.arr);
                }

        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getlastbatchdt;

DEBUGLOG(("GetLastBatchDtByTxnId() normal return iRet = [%d]\n",iRet));
        return iRet;

getlastbatchdt_error:
DEBUGLOG(("getlastbatchdt_error code %d\n", sqlca.sqlcode));
ERRLOG("DBMiBatchDetail::getlastbatchdt_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getlastbatchdt;
        return PD_ERR;
}

int GetAllDetailByBatchId(const char* csBatchId, recordset_t* myRec)
{
	int iRet = PD_NOT_FOUND;

	hash_t *hTmp;

DEBUGLOG(("GetAllDetailByBatchId() start\n"));

	EXEC SQL WHENEVER SQLERROR GOTO getalldtbybatchid_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_batch_id[PD_TXN_SEQ_LEN];

		int v_seq;
		varchar v_entity_id[PD_MMS_ENTITY_ID_LEN + 1];
		varchar v_party_type[PD_MMS_ENTITY_TYPE_LEN + 1];
		varchar v_party_id[PD_MMS_PARTY_ID_LEN + 1];
		char v_oper_ind;
		varchar v_txn_id[PD_TXN_SEQ_LEN + 1];

		short ind_seq = -1;
		short ind_entity_id = -1;
		short ind_party_type = -1;
		short ind_party_id = -1;
		short ind_oper_ind = -1;
		short ind_txn_id = -1;
	EXEC SQL END DECLARE SECTION;

/* batch_id */
	hv_batch_id.len = strlen(csBatchId);
        memcpy(hv_batch_id.arr,csBatchId,hv_batch_id.len);
DEBUGLOG(("GetAllDetailByBatchId batch_id = [%d][%.*s]\n",hv_batch_id.len,hv_batch_id.len,hv_batch_id.arr));

	EXEC SQL DECLARE c_cursor_getalldtbybatchid CURSOR FOR
		SELECT	bd_seq,
			bd_entity_id,
			bd_party_type,
			bd_party_id,
			bd_txn_oper_ind,
			bd_txn_id
		FROM	mi_batch_detail
		WHERE	bd_batch_id = :hv_batch_id
		ORDER BY bd_seq ASC;

	EXEC SQL OPEN c_cursor_getalldtbybatchid;
	do {
		EXEC SQL FETCH c_cursor_getalldtbybatchid
		INTO
			:v_seq:ind_seq,
			:v_entity_id:ind_entity_id,
			:v_party_type:ind_party_type,
			:v_party_id:ind_party_id,
			:v_oper_ind:ind_oper_ind,
			:v_txn_id:ind_txn_id;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iRet = PD_FOUND;

		hTmp = (hash_t*) malloc (sizeof(hash_t));
                hash_init(hTmp, 0);

		// seq
		if (ind_seq >= 0) {
DEBUGLOG(("GetAllDetailByBatchId seq = [%d]\n", v_seq));
			PutField_Int(hTmp, "seq", v_seq);
		}

		// entity_id
		if (ind_entity_id >= 0) {
			v_entity_id.arr[v_entity_id.len] = '\0';
DEBUGLOG(("GetAllDetailByBatchId entity_id = [%s]\n", v_entity_id.arr));
			PutField_CString(hTmp, "entity_id", (const char*)v_entity_id.arr);
		}

		// party_type
		if (ind_party_type >= 0) {
			v_party_type.arr[v_party_type.len] = '\0';
DEBUGLOG(("GetAllDetailByBatchId party_type = [%s]\n", v_party_type.arr));
			PutField_CString(hTmp, "party_type", (const char*)v_party_type.arr);
		}

		// party_id
		if (ind_party_id >= 0) {
			v_party_id.arr[v_party_id.len] = '\0';
DEBUGLOG(("GetAllDetailByBatchId party_id = [%s]\n", v_party_id.arr));
			PutField_CString(hTmp, "party_id", (const char*)v_party_id.arr);
		}

		// oper_ind
                if (ind_oper_ind >= 0) {
                        PutField_Char(hTmp,"oper_ind",v_oper_ind);
DEBUGLOG(("GetAllDetailByBatchId oper_ind = [%c]\n",v_oper_ind));
                }

		// txn_id
		if (ind_txn_id >= 0) {
			v_txn_id.arr[v_txn_id.len] = '\0';
DEBUGLOG(("GetAllDetailByBatchId txn_id = [%s]\n", v_txn_id.arr));
			PutField_CString(hTmp, "txn_id", (const char*)v_txn_id.arr);
		}

		RecordSet_Add(myRec, hTmp);
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getalldtbybatchid;

DEBUGLOG(("GetAllDetailByBatchId() normal return iRet = [%d]\n", iRet));
	return iRet;

getalldtbybatchid_error:
DEBUGLOG(("getalldtbybatchid_error code %d\n", sqlca.sqlcode));
ERRLOG("DBMiBatchDetail::getalldtbybatchid_error code %d\n", sqlca.sqlcode);
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getalldtbybatchid;
	return PD_ERR;
}

