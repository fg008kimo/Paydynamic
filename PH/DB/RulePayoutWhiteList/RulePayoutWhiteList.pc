/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/09/29		   Dirk Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "RulePayoutWhiteList.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RulePayoutWhiteList(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hRls)
{
	char	*csTmp;
	int	iTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merch_id[PD_MERCHANT_ID_LEN];
		varchar		hv_acct_name[PD_ACCT_NAME_LEN];
		int		hv_disabled;
		varchar		hv_create_user[PD_USER_LEN];

		short		ind_merch_id = -1;
		short		ind_acct_name = -1;
		short		ind_disabled;
		short		ind_create_user = -1;

		short		hv_return_value;	
		
        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

        if(GetField_CString(hRls,"merch_id",&csTmp)) {
                hv_merch_id.len = strlen(csTmp);
                strncpy((char*)hv_merch_id.arr, csTmp, hv_merch_id.len);
                ind_merch_id = 0;
        }
DEBUGLOG(("Add:merch_id = [%.*s]\n",hv_merch_id.len, hv_merch_id.arr));

        if(GetField_CString(hRls,"acct_name",&csTmp)) {
                hv_acct_name.len = strlen(csTmp);
                strncpy((char*)hv_acct_name.arr, csTmp, hv_acct_name.len);
                ind_acct_name= 0;
DEBUGLOG(("Add:acct_name = [%.*s]\n",hv_acct_name.len, hv_acct_name.arr));
        }

        if(GetField_Int(hRls, "disabled", &iTmp)) {
                hv_disabled = iTmp;
                ind_disabled = 0;
DEBUGLOG(("Add:disabled = [%d]\n",hv_disabled));
        }

        if(GetField_CString(hRls,"create_user",&csTmp)) {
                hv_create_user.len = strlen(csTmp);
                strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
                ind_create_user = 0;
        } else if(GetField_CString(hRls,"update_user",&csTmp)) {
                hv_create_user.len = strlen(csTmp);
                strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
                ind_create_user = 0;
        }
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_rpwl_insert(
						:hv_merch_id:ind_merch_id,
						:hv_acct_name:ind_acct_name,
						:hv_disabled:ind_disabled,
						:hv_create_user:ind_create_user); 
		END;
	END-EXEC;

DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
DEBUGLOG(("Add:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("RulePayoutWhiteList_Add: SP_OTHER_ERR\n");
DEBUGLOG(("Add: SP_OTHER_ERR\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("RulePayoutWhiteList_Add: SP_ERR\n");
DEBUGLOG(("Add: SP_ERR\n"));
                return PD_ERR;
        }


add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("RulePayoutWhiteList_Add: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}


int Delete(const char *csMerchName, const char *csAcctName, const char *csUser)
{
	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merch_id[PD_MERCHANT_ID_LEN];
		varchar		hv_acct_name[PD_ACCT_NAME_LEN];
		varchar		hv_user[PD_USER_LEN];

		short		ind_merch_id = -1;
		short		ind_acct_name = -1;
		short		ind_user = -1;

		short		hv_return_value;	
		
        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Delete: Begin\n"));

	hv_merch_id.len = strlen(csMerchName);
	strncpy((char*)hv_merch_id.arr, csMerchName, hv_merch_id.len);
	ind_merch_id = 0;
DEBUGLOG(("Delete:merch_id = [%.*s]\n",hv_merch_id.len, hv_merch_id.arr));

        hv_acct_name.len = strlen(csAcctName);
        strncpy((char*)hv_acct_name.arr, csAcctName, hv_acct_name.len);
        ind_acct_name= 0;
DEBUGLOG(("Delete:acct_name = [%.*s]\n",hv_acct_name.len, hv_acct_name.arr));


        hv_user.len = strlen(csUser);
        strncpy((char*)hv_user.arr, csUser, hv_user.len);
        ind_user = 0;
DEBUGLOG(("Delete:user = [%.*s]\n",hv_user.len,hv_user.arr));

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_rpwl_delete(
						:hv_merch_id:ind_merch_id,
						:hv_acct_name:ind_acct_name,
						:hv_user:ind_user); 
		END;
	END-EXEC;

DEBUGLOG(("Delete:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
DEBUGLOG(("Delete:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("RulePayoutWhiteList_Delete: SP_OTHER_ERR\n");
DEBUGLOG(("Add: SP_OTHER_ERR\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("RulePayoutWhiteList_Delete: SP_ERR\n");
DEBUGLOG(("Add: SP_ERR\n"));
                return PD_ERR;
        }


add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("RulePayoutWhiteList_Delete: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int InWhiteList(const char *csMerchId, const char *csAcctName) {
	int iRet = PD_FALSE;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_merch_id[PD_MERCHANT_ID_LEN];
		varchar hv_acct_name[PD_ACCT_NAME_LEN];

		int	v_count;
		short	ind_count;
	EXEC SQL END DECLARE SECTION;

	hv_merch_id.len = strlen(csMerchId);
	memcpy(hv_merch_id.arr, csMerchId, hv_merch_id.len);
DEBUGLOG(("InWhiteList merch_id = [%.*s]\n", hv_merch_id.len, hv_merch_id.arr));

	hv_acct_name.len = strlen(csAcctName);
	memcpy(hv_acct_name.arr, csAcctName, hv_acct_name.len);
DEBUGLOG(("InWhiteList acct_name = [%.*s]\n", hv_acct_name.len, hv_acct_name.arr));

	EXEC SQL	select	count(*)
			into	v_count:ind_count
			from	rule_payout_white_list
			where	rpwl_merch_id = :hv_merch_id
			and	rpwl_acct_name = :hv_acct_name
			and	rpwl_disabled = 0;

	if (ind_count >= 0) {
		if (v_count > 0) {
			iRet = PD_TRUE;
DEBUGLOG(("InWhiteList found, count = [%d]\n", v_count));
		} else {
			iRet = PD_FALSE;
DEBUGLOG(("InWhiteList not found, count = [%d]\n", v_count));
		}
	}

DEBUGLOG(("InWhiteList Normal Exit\n"));
	return iRet;

sql_error:
DEBUGLOG(("getinwhitelist_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("RulePayoutWhiteList_Get: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

