/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2010/08/27              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "Currency.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void Currency(char    cdebug)
{
        cDebug = cdebug;
}


int FindCurrency(const char* currency_id)
{
	EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_currency_id[PD_CCY_ID_LEN];

                char	v_disabled;
                short   ind_disabled = -1;

        EXEC SQL END DECLARE SECTION;

        hv_currency_id.len = strlen((const char*)currency_id);
        memcpy(hv_currency_id.arr,currency_id,hv_currency_id.len);
DEBUGLOG(("FindCode: currency_id = [%.*s]\n",hv_currency_id.len,hv_currency_id.arr));

        EXEC SQL SELECT disabled
                   INTO :v_disabled:ind_disabled
                FROM currency
                WHERE currency_id = :hv_currency_id;

        if (ind_disabled >= 0) {
		if(v_disabled=='0'){
DEBUGLOG(("disabled= [%c]\n",v_disabled));
                	return FOUND;
		}
		else{
DEBUGLOG(("disabled= [%c]\n",v_disabled));
                	return NOT_FOUND;
		}
        }
DEBUGLOG(("Code NOT FOUND\n"));
        return NOT_FOUND;
find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}


int GetCcyIdByNum(const char* currency_num, char * currency_id)
{
	EXEC SQL WHENEVER SQLERROR GOTO get_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_currency_num[PD_CCY_ID_LEN];

                varchar	v_currency_id[PD_CCY_ID_LEN+1];
                short   ind_currency_id = -1;

        EXEC SQL END DECLARE SECTION;

        hv_currency_num.len = strlen((const char*)currency_num);
        memcpy(hv_currency_num.arr,currency_num,hv_currency_num.len);
DEBUGLOG(("FindCode: currency_num = [%.*s]\n",hv_currency_num.len,hv_currency_num.arr));

        EXEC SQL SELECT currency_id
                   INTO :v_currency_id:ind_currency_id
                FROM currency
                WHERE currency_num = :hv_currency_num;

        if (ind_currency_id >= 0) {
DEBUGLOG(("Find Currency Code\n"));
                v_currency_id.arr[v_currency_id.len] = '\0';
                strcpy((char*)currency_id,(const char*)v_currency_id.arr);
DEBUGLOG(("Currency Code = [%s]\n",currency_id));
                return FOUND;
        }
DEBUGLOG(("Code NOT FOUND\n"));
        return NOT_FOUND;
get_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}


int FindBundledCurrency(const char* currency_id, char* bundled_ccy)
{
	int iRet = PD_OK;

	EXEC SQL WHENEVER SQLERROR GOTO findb_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_currency_id[PD_CCY_ID_LEN];

		varchar	v_bundled_ccy[PD_CCY_ID_LEN+1];
		char	v_restricted;

                short   ind_bundled_ccy= -1;
                short   ind_restricted= -1;

        EXEC SQL END DECLARE SECTION;

        hv_currency_id.len = strlen((const char*)currency_id);
        memcpy(hv_currency_id.arr,currency_id,hv_currency_id.len);
DEBUGLOG(("FindCode: currency_id = [%.*s]\n",hv_currency_id.len,hv_currency_id.arr));

        EXEC SQL SELECT bundled_ccy,
			restricted
                   INTO :v_bundled_ccy:ind_bundled_ccy,
			:v_restricted:ind_restricted
                FROM currency
                WHERE currency_id = :hv_currency_id
		AND   disabled = '0';

        if (ind_restricted >= 0) {
		if(v_restricted=='Y'){
			if(ind_bundled_ccy>=0){
				v_bundled_ccy.arr[v_bundled_ccy.len] = '\0';
                		strcpy((char*)bundled_ccy,(const char*)v_bundled_ccy.arr);
DEBUGLOG(("restricted= [%c], use bundled currency[%s]\n",v_restricted,bundled_ccy));
			}
			else{
DEBUGLOG(("bundled currency not found!!\n"));
				iRet = PD_ERR;
			}
		}
		else{
			strcpy((char*)bundled_ccy,(const char*)currency_id);
			bundled_ccy[PD_CCY_ID_LEN]='\0';
DEBUGLOG(("restricted= [%c], use the same currency[%s]\n",v_restricted,bundled_ccy));
		}
        }

        return iRet;

findb_error:
DEBUGLOG(("findb_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_ERR;
}


int IsRestricted(const char* currency_id)
{
	int iRet = PD_FALSE;

	EXEC SQL WHENEVER SQLERROR GOTO isret_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_currency_id[PD_CCY_ID_LEN];

		char	v_restricted;

                short   ind_restricted= -1;

        EXEC SQL END DECLARE SECTION;

        hv_currency_id.len = strlen((const char*)currency_id);
        memcpy(hv_currency_id.arr,currency_id,hv_currency_id.len);
DEBUGLOG(("FindCode: currency_id = [%.*s]\n",hv_currency_id.len,hv_currency_id.arr));

        EXEC SQL SELECT restricted
                   INTO :v_restricted:ind_restricted
                FROM currency
                WHERE currency_id = :hv_currency_id
		AND   disabled = '0';

        if (ind_restricted >= 0) {
		if(v_restricted=='Y'){
DEBUGLOG(("currency id restricted[%s]\n",currency_id));
			iRet = PD_TRUE;
		}
		else{
DEBUGLOG(("currency id not restricted[%s]\n",currency_id));
		}
        }
	else{
DEBUGLOG(("currency id  not found!!\n"));
		iRet = PD_ERR;
	}

        return iRet;

isret_error:
DEBUGLOG(("isret_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_ERR;
}

int IsSupportDecimal(const char* currency_id)
{
	int iRet = PD_TRUE;

	EXEC SQL WHENEVER SQLERROR GOTO support_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_currency_id[PD_CCY_ID_LEN];

                int	v_support_decimal;
                short   ind_support_decimal = -1;

        EXEC SQL END DECLARE SECTION;

        hv_currency_id.len = strlen((const char*)currency_id);
        memcpy(hv_currency_id.arr,currency_id,hv_currency_id.len);
DEBUGLOG(("IsSupportDeciaml: currency_id = [%.*s]\n",hv_currency_id.len,hv_currency_id.arr));

        EXEC SQL SELECT support_decimal
                   INTO :v_support_decimal:ind_support_decimal
                FROM currency
                WHERE currency_id = :hv_currency_id;

        if (ind_support_decimal >= 0) {
		if(v_support_decimal==1){
DEBUGLOG(("support_decimal = [%d]\n",v_support_decimal));
		}
		else{
DEBUGLOG(("support_decimal = [%d]\n",v_support_decimal));
                	iRet = PD_FALSE;
		}
        }
	else{
DEBUGLOG(("support_decimal (default) = [1]\n"));
	}

        return iRet;

support_error:
DEBUGLOG(("support_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_FALSE;
}




int FindAllCurrency(recordset_t* myRec)
{
	int iRet = PD_OK;
        hash_t *myHash;
        int iCnt=0;

	EXEC SQL WHENEVER SQLERROR GOTO getccy_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar v_ccy[PD_CCY_ID_LEN];

                short   ind_ccy= -1;

        EXEC SQL END DECLARE SECTION;


        EXEC SQL DECLARE c_cursor_getccy CURSOR FOR
                select  currency_id
		from	currency
		where	disabled='0';

	EXEC SQL OPEN c_cursor_getccy;
        do {
                EXEC SQL FETCH c_cursor_getccy
                INTO
                        :v_ccy:ind_ccy;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                iCnt ++;

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);


                if (ind_ccy >= 0) {
                        v_ccy.arr[v_ccy.len] ='\0';
                        PutField_CString(myHash,"to_ccy",(const char*)v_ccy.arr);
DEBUGLOG(("FindAllCurrency ccy = [%s]\n",v_ccy.arr));
                }

		RecordSet_Add(myRec,myHash);

        }while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getccy;

DEBUGLOG(("FindAllCurrency Normal Exit iRet[%d]\n",iRet));
        return iRet;

getccy_error:
DEBUGLOG(("getccy_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getccy;
        return PD_ERR;

        return iRet;
}
