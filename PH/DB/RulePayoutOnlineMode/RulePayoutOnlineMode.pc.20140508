/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/05/21              LokManChow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "RulePayoutOnlineMode.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RulePayoutOnlineMode(char    cdebug)
{
        cDebug = cdebug;
}


int ChkRuleExists(const unsigned char* csMerchantId,
                 const unsigned char* csServiceCode)
{
        int     iRet = PD_NOT_FOUND;

	EXEC SQL WHENEVER SQLERROR GOTO chkruleexists_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];
                int             hv_disabled;

                int             v_no_of_record;
                short           ind_no_of_record = -1;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("ChkRuleExists: Begin\n"));

	hv_merchant_id.len = strlen((const char *)csMerchantId);
	strncpy((char*)hv_merchant_id.arr, (const char *)csMerchantId, hv_merchant_id.len);
DEBUGLOG(("ChkRuleExists:merchant_id = [%.*s]\n",hv_merchant_id.len, hv_merchant_id.arr));

	hv_service_code.len = strlen((const char *)csServiceCode);
	strncpy((char*)hv_service_code.arr, (const char *)csServiceCode, hv_service_code.len);
DEBUGLOG(("ChkRuleExists:service_code = [%.*s]\n",hv_service_code.len, hv_service_code.arr));

	hv_disabled = 0;
DEBUGLOG(("ChkRuleExists:disabled = [%d]\n",hv_disabled));

	        EXEC SQL
                	SELECT count(1)
			INTO :v_no_of_record:ind_no_of_record
			FROM rule_payout_online_mode
			WHERE rp_merchant_id = :hv_merchant_id
			AND   rp_service_code = :hv_service_code
			AND   rp_disabled = :hv_disabled
			and rownum = 1;


        if (ind_no_of_record >= 0) {
                if (v_no_of_record > 0) {
DEBUGLOG(("ChkRuleExists FOUND\n"));
                        iRet = PD_FOUND;
                }
        }

        if (iRet!= PD_FOUND) {
DEBUGLOG(("ChkRuleExists NOT FOUND\n"));
        }


        return iRet;

chkruleexists_error:
DEBUGLOG(("ChkRuleExists_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}


int FindPsp(const unsigned char* csMerchantId,
	    const unsigned char* csServiceCode,
            unsigned char* csPspId)
{
        int iRet = PD_NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar hv_service_code[PD_SERVICE_CODE_LEN];
                varchar hv_merchant_id[PD_MERCHANT_ID_LEN];
                int     hv_disabled;

                varchar v_psp_id[PD_PSP_ID_LEN+1];

                short   ind_psp_id = -1;
        EXEC SQL END DECLARE SECTION;

        hv_merchant_id.len = strlen((const char*)csMerchantId);
        memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
DEBUGLOG(("FindPsp: merchant_id= [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

        hv_service_code.len = strlen((const char*)csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindPsp: ServiceCode = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_disabled=0;

	EXEC SQL
		SELECT rp_psp_id
		INTO :v_psp_id:ind_psp_id
		FROM rule_payout_online_mode
		WHERE rp_merchant_id = :hv_merchant_id
		AND   rp_service_code = :hv_service_code
		AND   rp_disabled = :hv_disabled;

	if(ind_psp_id>=0){
		v_psp_id.arr[v_psp_id.len] = '\0';
                strcpy((char*)csPspId,(const char*)v_psp_id.arr);
DEBUGLOG(("psp_id = [%s]\n",csPspId));
                iRet = PD_FOUND;
	}

DEBUGLOG(("iRet = [%d]\n",iRet));
	return iRet;

find_error:
DEBUGLOG(("FindPsp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int ChkRuleExistsByMerchant(const unsigned char* csMerchantId)
{
        int     iRet = PD_NOT_FOUND;

	EXEC SQL WHENEVER SQLERROR GOTO chkruleexistsm_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
                int             hv_disabled;

                int             v_no_of_record;
                short           ind_no_of_record = -1;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("ChkRuleExistsByMerchant: Begin\n"));

	hv_merchant_id.len = strlen((const char *)csMerchantId);
	strncpy((char*)hv_merchant_id.arr, (const char *)csMerchantId, hv_merchant_id.len);
DEBUGLOG(("ChkRuleExistsByMerchant:merchant_id = [%.*s]\n",hv_merchant_id.len, hv_merchant_id.arr));

	hv_disabled = 0;
DEBUGLOG(("ChkRuleExistsByMerchant:disabled = [%d]\n",hv_disabled));

	        EXEC SQL
                	SELECT count(1)
			INTO :v_no_of_record:ind_no_of_record
			FROM rule_payout_online_mode
			WHERE rp_merchant_id = :hv_merchant_id
			AND   rp_disabled = :hv_disabled
			and rownum = 1;


        if (ind_no_of_record >= 0) {
                if (v_no_of_record > 0) {
DEBUGLOG(("ChkRuleExistsByMerchant FOUND\n"));
                        iRet = PD_FOUND;
                }
        }

        if (iRet!= PD_FOUND) {
DEBUGLOG(("ChkRuleExistsByMerchant NOT FOUND\n"));
        }


        return iRet;

chkruleexistsm_error:
DEBUGLOG(("ChkRuleExistsByMerchant_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}
