/*
Partnerdelight (c)2015. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/03/30              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "CrrJnlType.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;
void CrrJnl(char    cdebug)
{
	cDebug = cdebug;
}

int GetJnlTxn(const char* csFunctionName,
                recordset_t* myRec)
{
	hash_t *myHash;

	EXEC SQL WHENEVER SQLERROR GOTO getjnltxn_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar         hv_function_name[PD_TMP_BUF_LEN];

		varchar		v_txn_id[PD_TXN_ID_LEN +1];

		short		ind_txn_id = -1;

		SQL_CURSOR    c_cursor_crrjnl;
	
	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_crrjnl;

	hv_function_name.len = strlen(csFunctionName);
        memcpy(hv_function_name.arr,csFunctionName,hv_function_name.len);
DEBUGLOG(("GetJnlTxn function_name = [%.*s]\n",hv_function_name.len,hv_function_name.arr));

	EXEC SQL EXECUTE
        	BEGIN
			CRRJNL_PKG.open_cur_CRRJNL(:hv_function_name,
						:c_cursor_crrjnl);
		END;
	END-EXEC;

	for (;;) {
                EXEC SQL WHENEVER NOTFOUND DO break;
                EXEC SQL FETCH :c_cursor_crrjnl
		INTO
			:v_txn_id:ind_txn_id;
		
		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* txn id*/
                if (ind_txn_id>=  0) {
                        v_txn_id.arr[v_txn_id.len] = '\0';
                        PutField_CString(myHash,"txn_seq",(const char*)v_txn_id.arr);
DEBUGLOG(("GetJnlTxn txn_id = [%s]\n",v_txn_id.arr));
                }

		RecordSet_Add(myRec,myHash);
	}

	EXEC SQL CLOSE :c_cursor_crrjnl;

        return PD_OK;

getjnltxn_error:
DEBUGLOG(("getjnltxn_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_crrjnl;
        return PD_ERR;
}
