/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/03/19              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "PayoutQueueHd.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void PayoutQueueHd(char    cdebug)
{
        cDebug = cdebug;
}

int Add(hash_t *hRls)
{
	char	*csTmp;
	char	cTmp;
	int	iTmp;
	char	csQueueId[PD_TXN_SEQ_LEN+1];

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		unsigned long	v_queue_id;
		varchar		hv_txn_date[PD_DATE_LEN];
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_service_code[PD_SERVICE_CODE_LEN];
		varchar		hv_psp_id[PD_PSP_ID_LEN];
		char		hv_status;

		int		hv_num_of_record;

		short           ind_queue_id = -1;
		short		ind_txn_date = -1;
		short		ind_merchant_id = -1;
		short		ind_service_code = -1;
		short		ind_psp_id= -1;
		short		ind_status = -1;
		short		ind_num_of_record = -1;

		short           hv_return_value;
		EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));


/*txn_date*/
	if(GetField_CString(hRls,"txn_date",&csTmp)){
		//hv_txn_date.len = strlen(csTmp);
		hv_txn_date.len = PD_DATE_LEN;
		memcpy(hv_txn_date.arr, csTmp, PD_DATE_LEN);
		ind_txn_date = 0;
DEBUGLOG(("Add:txn_date = [%.*s]\n",hv_txn_date.len,hv_txn_date.arr));
	}

/*status*/
	if(GetField_Char(hRls,"status",&cTmp)){
		hv_status = cTmp;
		ind_status = 0;
DEBUGLOG(("Add:status = [%c]\n",hv_status));
	}

/*merchant_id*/
	if(GetField_CString(hRls,"merchant_id",&csTmp)){
		hv_merchant_id.len = strlen(csTmp);
		memcpy(hv_merchant_id.arr, csTmp, hv_merchant_id.len);
		ind_merchant_id = 0;
DEBUGLOG(("Add:merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
	}

/*service_code*/
	if(GetField_CString(hRls,"service_code",&csTmp)){
		hv_service_code.len = strlen(csTmp);
		memcpy(hv_service_code.arr, csTmp, hv_service_code.len);
		ind_service_code= 0;
DEBUGLOG(("Add:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
	}

/*psp_id*/
	if(GetField_CString(hRls,"psp_id",&csTmp)){
		hv_psp_id.len = strlen(csTmp);
		memcpy(hv_psp_id.arr, csTmp, hv_psp_id.len);
		ind_psp_id= 0;
DEBUGLOG(("Add:psp_id = [%.*s]\n",hv_psp_id.len,hv_psp_id.arr));
	}

/*num_of_record*/
	if (GetField_Int(hRls,"num_of_record",&iTmp)) {
		hv_num_of_record = iTmp;
		ind_num_of_record = 0;
DEBUGLOG(("Add:num_of_record = [%d]\n",hv_num_of_record));
	}


	
	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_payout_queue_hd_insert(
					:v_queue_id:ind_queue_id,
					:hv_txn_date:ind_txn_date,
					:hv_merchant_id:ind_merchant_id,
					:hv_service_code:ind_service_code,
					:hv_psp_id:ind_psp_id,
					:hv_num_of_record:ind_num_of_record,
					:hv_status:ind_status);
		END;
	END-EXEC;

DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
		if(ind_queue_id>=0){
			sprintf(csQueueId,"%ld",v_queue_id);
			PutField_CString(hRls,"queue_id",csQueueId);
		}
		else{
ERRLOG("PayoutQueueHd_Add: Cannot find QueueId\n");
DEBUGLOG(("Add: Cannot find QueueId\n"));
			return PD_ERR; 
		}

DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("PayoutQueueHd_Add: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
ERRLOG("PayoutQueueHd_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR; 
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("PayoutQueueHd_Add: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;

}





int UpdateStatus(const hash_t *hRls)
{
	char*   csBuf;
	char*	csQueueId;
	char	cStatus;

	EXEC SQL WHENEVER SQLERROR GOTO updatestatus_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar		hv_dynstmt[1024];

	EXEC SQL END DECLARE SECTION;


DEBUGLOG(("Update: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update payout_queue_hd set pq_update_timestamp=sysdate,");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);


	GetField_CString(hRls,"queue_id",&csQueueId);
DEBUGLOG(("Update:queue_id = [%s]\n",csQueueId));


        if(GetField_Char(hRls,"status",&cStatus)){
DEBUGLOG(("Update: status = [%c]\n",cStatus));
		sprintf(csBuf,"%c",cStatus);
		strcat((char*)hv_dynstmt.arr, "pq_status = '");
		strcat((char*)hv_dynstmt.arr, csBuf);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}


	strcat((char*)hv_dynstmt.arr, " WHERE pq_queue_id = '");
	strcat((char*)hv_dynstmt.arr, csQueueId);
	strcat((char*)hv_dynstmt.arr, "'");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));


	EXEC SQL PREPARE PS FROM :hv_dynstmt;
	EXEC SQL EXECUTE PS;

	FREE_ME(csBuf);

DEBUGLOG(("UpdateStatus Normal Exit\n"));
        return PD_OK;

updatestatus_error:
DEBUGLOG(("updatestatus_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("PayoutQueueHd_Update: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_INTERNAL_ERR;
}



int GetPayoutQueueHd(const char cStatus, recordset_t* myRec)
{
	hash_t *myHash;
	EXEC SQL WHENEVER SQLERROR GOTO getpayout_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		char		hv_status;

		varchar		v_merchant_id[PD_MERCHANT_ID_LEN+1];
		varchar		v_service_code[PD_SERVICE_CODE_LEN+1];
		varchar		v_psp_id[PD_PSP_ID_LEN+1];
		varchar		v_txn_date[PD_DATE_LEN+1];
		varchar         v_queue_id[PD_SEQ_NUM_LEN+1];
		int		v_num_of_record;

		short           ind_merchant_id= -1;
		short           ind_service_code= -1;
		short           ind_psp_id= -1;
		short           ind_queue_id = -1;
		short		ind_txn_date= -1;
		short		ind_num_of_record = -1;

	EXEC SQL END DECLARE SECTION;

	hv_status= cStatus;
DEBUGLOG(("GetTxnHeader status = [%c]\n",hv_status));


	EXEC SQL DECLARE c_cursor_getpayout CURSOR FOR
		select	pq_queue_id,
			pq_merchant_id,
			pq_service_code,
			pq_psp_id,
			pq_txn_date,
			pq_num_of_record
		from	payout_queue_hd
		where	pq_status=:hv_status;

	EXEC SQL OPEN  c_cursor_getpayout;
	do{
		EXEC SQL FETCH c_cursor_getpayout
		INTO
			:v_queue_id:ind_queue_id,
			:v_merchant_id:ind_merchant_id,
			:v_service_code:ind_service_code,
			:v_psp_id:ind_psp_id,
			:v_txn_date:ind_txn_date,
			:v_num_of_record:ind_num_of_record;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

/*queue_id*/
		if(ind_queue_id>=0){
			v_queue_id.arr[v_queue_id.len]='\0';
			PutField_CString(myHash,"queue_id",(const char*)v_queue_id.arr);
DEBUGLOG(("GetPayoutQueueHd queue_id=[%s]\n",v_queue_id.arr));
		}

/*merchant_id*/
		if(ind_merchant_id>=0){
			v_merchant_id.arr[v_merchant_id.len]='\0';
			PutField_CString(myHash,"merchant_id",(const char*)v_merchant_id.arr);
DEBUGLOG(("GetPayoutQueueHd merchant_id=[%s]\n",v_merchant_id.arr));
		}

/*service_code*/
		if(ind_service_code>=0){
			v_service_code.arr[v_service_code.len]='\0';
			PutField_CString(myHash,"service_code",(const char*)v_service_code.arr);
DEBUGLOG(("GetPayoutQueueHd service_code=[%s]\n",v_service_code.arr));
		}

/*psp_id*/
		if(ind_psp_id>=0){
			v_psp_id.arr[v_psp_id.len]='\0';
			PutField_CString(myHash,"psp_id",(const char*)v_psp_id.arr);
DEBUGLOG(("GetPayoutQueueHd psp_id=[%s]\n",v_psp_id.arr));
		}

/*num_of_record*/
		if(ind_num_of_record>=0){
			PutField_Int(myHash,"num_of_record",v_num_of_record);
DEBUGLOG(("GetPayoutQueueHd num_of_record = [%d]\n",v_num_of_record));
		}

		RecordSet_Add(myRec,myHash);

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getpayout;

DEBUGLOG(("GetPayoutQueueHd Normal Exit\n"));
	return  PD_OK;

getpayout_error:
DEBUGLOG(("getpayout_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("PayoutQueueHd_Get: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getpayout;
	return PD_ERR;

}

