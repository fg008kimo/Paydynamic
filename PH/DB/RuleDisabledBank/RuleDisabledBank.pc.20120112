/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/01/10              LokManChow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "RuleDisabledBank.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RuleDisabledBank(char    cdebug)
{
        cDebug = cdebug;
}


int GetDisabledBank(const unsigned char* csChannel,
		    const unsigned char* csTxnCountry,
                    const char cPartyType,
                    recordset_t* myRec)
{

DEBUGLOG(("GetDisabledBank()\n"));
	int iRet = PD_OK;
	int	iCnt = 0;
	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO dis_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_txn_country[PD_COUNTRY_LEN];
		varchar	hv_channel[PD_CHANNEL_CODE_LEN];
		char	hv_party_type;

		varchar	v_bank_code[PD_BANK_CODE_LEN+1];
		varchar	v_channel_code[PD_CHANNEL_CODE_LEN+1];
		varchar	v_party_id[PD_CLIENT_ID_LEN+1];
		int	v_scheduler_id;
		
		short	ind_channel = -1;
		short	ind_txn_country = -1;
		short	ind_party_type = 1;

		short	ind_channel_code = -1;
		short	ind_bank_code= -1;
		short	ind_party_id = -1;
		short	ind_scheduler_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("GetDisabledBank: channel_code = [%s]\n",csChannel));
DEBUGLOG(("GetDisabledBank: txn_country = [%s]\n",csTxnCountry));

/*channel*/
	hv_channel.len = strlen((const char*)csChannel);
	memcpy(hv_channel.arr,csChannel,hv_channel.len);
	ind_channel= 0;
DEBUGLOG(("GetDisabledBank: channel_code = [%.*s]\n",hv_channel.len,hv_channel.arr));

/*txn_country */
	hv_txn_country.len = strlen((const char*)csTxnCountry);
	memcpy(hv_txn_country.arr,csTxnCountry,hv_txn_country.len);
	ind_txn_country = 0;
DEBUGLOG(("GetDisabledBank: txn_country = [%.*s]\n",hv_txn_country.len,hv_txn_country.arr));


/*party_type */
	hv_party_type = cPartyType;
	ind_party_type = 0;
DEBUGLOG(("GetDisabledBank: party_type = [%c]\n",hv_party_type));

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_disabled_bank_get(:hv_channel:ind_channel,
								:hv_txn_country:ind_txn_country,
								:hv_party_type:ind_party_type,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value > 0 ) {
DEBUGLOG(("GetDisabledBank: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_bank_code = -1;
			ind_channel_code = -1;
			ind_party_id = -1;
			ind_scheduler_id = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_bank_code:ind_bank_code,
				:v_channel_code:ind_channel_code,
				:v_party_id:ind_party_id,
				:v_scheduler_id:ind_scheduler_id;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_bank_code >= 0) {
DEBUGLOG(("GetDisabledBank: [%03d]bank_code = [%.*s]\n",iCnt,v_bank_code.len,v_bank_code.arr));
				PutField_CString(myHash,"bank_code",(const char *)v_bank_code.arr);
			}
			if (ind_channel_code >= 0) {
DEBUGLOG(("GetDisabledBank: [%03d]channel_code = [%.*s]\n",iCnt,v_channel_code.len,v_channel_code.arr));
				PutField_CString(myHash,"channel_code",(const char *)v_channel_code.arr);
			}
			if (ind_party_id >= 0) {
DEBUGLOG(("GetDisabledBank: [%03d]party_id = [%.*s]\n",iCnt,v_party_id.len,v_party_id.arr));
				PutField_CString(myHash,"party_id",(const char *)v_party_id.arr);
			}
			if (ind_scheduler_id >= 0) {
DEBUGLOG(("GetDisabledBank: [%03d]scheduler_id = [%d]\n",iCnt,v_scheduler_id));
				PutField_Int(myHash,"scheduler_id",v_scheduler_id);
			}

			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("GetDisabledBank: exit with ok\n"));
		return iRet;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("GetDisabledBank: exit with error\n"));
		return PD_ERR;
	}


	EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

dis_error:
DEBUGLOG(("dis_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    return PD_ERR;
}


int GetAllBankByCountry(const unsigned char* csTxnCountry,
			recordset_t* myRec)
{
	int iRet = PD_OK;
	int	iCnt = 0;
	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getall_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_txn_country[PD_COUNTRY_LEN];

		varchar	v_bank_code[PD_BANK_CODE_LEN+1];
		
		short	ind_txn_country = -1;
		short	ind_bank_code= -1;

		SQL_CURSOR      c_cursor_id;
        EXEC SQL END DECLARE SECTION;


/*txn_country */
	hv_txn_country.len = strlen((const char*)csTxnCountry);
	memcpy(hv_txn_country.arr,csTxnCountry,hv_txn_country.len);
	ind_txn_country = 0;
DEBUGLOG(("GetAllBankByCountry: txn_country = [%.*s]\n",hv_txn_country.len,hv_txn_country.arr));

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_def_bank_get(:hv_txn_country:ind_txn_country,
							    :c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value > 0 ) {
DEBUGLOG(("GetAllBankByCountry: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_bank_code = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_bank_code:ind_bank_code;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_bank_code >= 0) {
DEBUGLOG(("GetAllBankByCountry: [%03d]bank_code = [%.*s]\n",iCnt,v_bank_code.len,v_bank_code.arr));
				PutField_CString(myHash,"bank_code",(const char *)v_bank_code.arr);
			}
			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("GetAllBankByCountry: exit with ok\n"));
		return iRet;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("GetAllBankByCountry: exit with error\n"));
		return PD_ERR;
	}


	EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

getall_error:
DEBUGLOG(("getall_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    return PD_ERR;
}

int DisabledBankInfo(const unsigned char* csBank,
                    const char cPartyType,
                    recordset_t* myRec)
{

DEBUGLOG(("DisabledBankInfo()\n"));
	int iRet = PD_OK;
	int	iCnt = 0;
	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO info_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_bank_code[PD_BANK_CODE_LEN];
		char	hv_party_type;
		char	v_party_type;

		varchar	v_channel_code[PD_CHANNEL_CODE_LEN+1];
		varchar	v_party_id[PD_CLIENT_ID_LEN+1];
		int	v_scheduler_id;
		
		short	ind_party_type = 1;
		short	ind_channel_code = -1;
		short	ind_bank_code= -1;
		short	ind_party_id = -1;
		short	ind_scheduler_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

/*bank_code*/
	hv_bank_code.len = strlen((const char*)csBank);
	memcpy(hv_bank_code.arr,csBank,hv_bank_code.len);
	ind_bank_code= 0;
DEBUGLOG(("DisabledBankInfo: bank_code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr));

/*party_type */
	hv_party_type = cPartyType;
	ind_party_type = 0;
DEBUGLOG(("GetDisabledBank: party_type = [%c]\n",hv_party_type));


	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_disabled_bank_info(:hv_bank_code:ind_bank_code,
								:hv_party_type:ind_party_type,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value > 0 ) {
DEBUGLOG(("DisabledBankInfo: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_channel_code = -1;
			ind_party_type = -1;
			ind_party_id = -1;
			ind_scheduler_id = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_channel_code:ind_channel_code,
				:v_party_type:ind_party_type,
				:v_party_id:ind_party_id,
				:v_scheduler_id:ind_scheduler_id;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_channel_code >= 0) {
DEBUGLOG(("DisabledBankInfo: [%03d]channel_code = [%.*s]\n",iCnt,v_channel_code.len,v_channel_code.arr));
				PutField_CString(myHash,"channel_code",(const char *)v_channel_code.arr);
			}
			if (ind_party_type >= 0) {
DEBUGLOG(("DisabledBankInfo: [%03d]party_type = [%c]\n",iCnt,v_party_type));
				PutField_Char(myHash,"party_type",v_party_type);
			}
			if (ind_party_id >= 0) {
DEBUGLOG(("DisabledBankInfo: [%03d]party_id = [%.*s]\n",iCnt,v_party_id.len,v_party_id.arr));
				PutField_CString(myHash,"party_id",(const char *)v_party_id.arr);
			}
			if (ind_scheduler_id >= 0) {
DEBUGLOG(("DisabledBankInfo: [%03d]scheduler_id = [%d]\n",iCnt,v_scheduler_id));
				PutField_Int(myHash,"scheduler_id",v_scheduler_id);
			}

			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("DisabledBankInfo: exit with ok\n"));
		return iRet;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("DisabledBankInfo: exit with error\n"));
		return PD_ERR;
	}


	EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

info_error:
DEBUGLOG(("info_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    return PD_ERR;
}


int GetAllBankSupported(const unsigned char* csTxnCountry,
			const unsigned char* csPayMethod,
			recordset_t* myRec)
{
	int iRet = PD_OK;
	int	iCnt = 0;
	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getsupp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_txn_country[PD_COUNTRY_LEN];
		varchar	hv_pay_method[PD_PAY_METHOD_LEN];

		varchar	v_bank_code[PD_BANK_CODE_LEN+1];
		
		short	ind_txn_country = -1;
		short	ind_pay_method = -1;
		short	ind_bank_code= -1;

		SQL_CURSOR      c_cursor_id;
        EXEC SQL END DECLARE SECTION;


/*txn_country */
	hv_txn_country.len = strlen((const char*)csTxnCountry);
	memcpy(hv_txn_country.arr,csTxnCountry,hv_txn_country.len);
	ind_txn_country = 0;
DEBUGLOG(("GetAllBankByCountry: txn_country = [%.*s]\n",hv_txn_country.len,hv_txn_country.arr));

/*pay_method*/
	hv_pay_method.len = strlen((const char*)csPayMethod);
	memcpy(hv_pay_method.arr,csPayMethod,hv_pay_method.len);
	ind_pay_method = 0;
DEBUGLOG(("GetAllBankByCountry: pay_method = [%.*s]\n",hv_pay_method.len,hv_pay_method.arr));

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_def_bank_support(:hv_txn_country:ind_txn_country,
							    :hv_pay_method:ind_pay_method,
							    :c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value > 0 ) {
DEBUGLOG(("GetAllBankByCountry: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_bank_code = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_bank_code:ind_bank_code;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_bank_code >= 0) {
DEBUGLOG(("GetAllBankByCountry: [%03d]bank_code = [%.*s]\n",iCnt,v_bank_code.len,v_bank_code.arr));
				PutField_CString(myHash,"bank_code",(const char *)v_bank_code.arr);
			}
			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("GetAllBankByCountry: exit with ok\n"));
		return iRet;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("GetAllBankByCountry: exit with error\n"));
		return PD_ERR;
	}


	EXEC SQL CLOSE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

getsupp_error:
DEBUGLOG(("getsupp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    return PD_ERR;
}
