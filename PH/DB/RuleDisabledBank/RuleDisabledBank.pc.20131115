/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/01/10              LokManChow
Add function Add, Delete			   2012/01/12		   Virginia Yun 	
Add function ChkRuleExists, Update		   2012/01/13		   Virginia Yun 	
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "RuleDisabledBank.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RuleDisabledBank(char    cdebug)
{
        cDebug = cdebug;
}


int GetDisabledBank(const unsigned char* csChannel,
		    const unsigned char* csTxnCountry,
                    const char cPartyType,
                    recordset_t* myRec)
{

DEBUGLOG(("GetDisabledBank()\n"));
	int iRet = PD_OK;
	int	iCnt = 0;
	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO dis_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_txn_country[PD_COUNTRY_LEN];
		varchar	hv_channel[PD_CHANNEL_CODE_LEN];
		char	hv_party_type;

		varchar	v_bank_code[PD_BANK_CODE_LEN+1];
		varchar	v_channel_code[PD_CHANNEL_CODE_LEN+1];
		varchar	v_party_id[PD_CLIENT_ID_LEN+1];
		int	v_scheduler_id;
		int	v_note_id;
		
		short	ind_channel = -1;
		short	ind_txn_country = -1;
		short	ind_party_type = 1;

		short	ind_channel_code = -1;
		short	ind_bank_code= -1;
		short	ind_party_id = -1;
		short	ind_scheduler_id = -1;
		short	ind_note_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("GetDisabledBank: channel_code = [%s]\n",csChannel));
DEBUGLOG(("GetDisabledBank: txn_country = [%s]\n",csTxnCountry));

/*channel*/
	hv_channel.len = strlen((const char*)csChannel);
	memcpy(hv_channel.arr,csChannel,hv_channel.len);
	ind_channel= 0;
DEBUGLOG(("GetDisabledBank: channel_code = [%.*s]\n",hv_channel.len,hv_channel.arr));

/*txn_country */
	hv_txn_country.len = strlen((const char*)csTxnCountry);
	memcpy(hv_txn_country.arr,csTxnCountry,hv_txn_country.len);
	ind_txn_country = 0;
DEBUGLOG(("GetDisabledBank: txn_country = [%.*s]\n",hv_txn_country.len,hv_txn_country.arr));


/*party_type */
	hv_party_type = cPartyType;
	ind_party_type = 0;
DEBUGLOG(("GetDisabledBank: party_type = [%c]\n",hv_party_type));

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_disabled_bank_get(:hv_channel:ind_channel,
								:hv_txn_country:ind_txn_country,
								:hv_party_type:ind_party_type,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value == 1 ) {
DEBUGLOG(("GetDisabledBank: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_bank_code = -1;
			ind_channel_code = -1;
			ind_party_id = -1;
			ind_scheduler_id = -1;
			ind_note_id = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_bank_code:ind_bank_code,
				:v_channel_code:ind_channel_code,
				:v_party_id:ind_party_id,
				:v_scheduler_id:ind_scheduler_id,
				:v_note_id:ind_note_id;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_bank_code >= 0) {
				v_bank_code.arr[v_bank_code.len]='\0';
DEBUGLOG(("GetDisabledBank: [%03d]bank_code = [%.*s]\n",iCnt,v_bank_code.len,v_bank_code.arr));
				PutField_CString(myHash,"bank_code",(const char *)v_bank_code.arr);
			}
			if (ind_channel_code >= 0) {
				v_channel_code.arr[v_channel_code.len]='\0';
DEBUGLOG(("GetDisabledBank: [%03d]channel_code = [%.*s]\n",iCnt,v_channel_code.len,v_channel_code.arr));
				PutField_CString(myHash,"channel_code",(const char *)v_channel_code.arr);
			}
			if (ind_party_id >= 0) {
				v_party_id.arr[v_party_id.len]='\0';
DEBUGLOG(("GetDisabledBank: [%03d]party_id = [%.*s]\n",iCnt,v_party_id.len,v_party_id.arr));
				PutField_CString(myHash,"party_id",(const char *)v_party_id.arr);
			}
			if (ind_scheduler_id >= 0) {
DEBUGLOG(("GetDisabledBank: [%03d]scheduler_id = [%d]\n",iCnt,v_scheduler_id));
				PutField_Int(myHash,"scheduler_id",v_scheduler_id);
			}
			if (ind_note_id >= 0) {
DEBUGLOG(("GetDisabledBank: [%03d]note_id = [%d]\n",iCnt,v_note_id));
				PutField_Int(myHash,"note_id",v_note_id);
			}

			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetDisabledBank: exit with ok\n"));
		return iRet;
	}
	else if(hv_return_value == 9){
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetDisabledBank: exit with error\n"));
		return PD_ERR;
	}
	else{
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetDisabledBank: exit with ok, no record\n"));
		return PD_OK;
	}


	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

dis_error:
DEBUGLOG(("dis_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    	EXEC SQL WHENEVER SQLERROR CONTINUE;
    	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
    return PD_ERR;
}


int GetAllBankByCountry(const unsigned char* csTxnCountry,
			recordset_t* myRec)
{
	int iRet = PD_OK;
	int	iCnt = 0;
	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getall_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_txn_country[PD_COUNTRY_LEN];

		varchar	v_bank_code[PD_BANK_CODE_LEN+1];
		
		short	ind_txn_country = -1;
		short	ind_bank_code= -1;

		SQL_CURSOR      c_cursor_id;
        EXEC SQL END DECLARE SECTION;


/*txn_country */
	hv_txn_country.len = strlen((const char*)csTxnCountry);
	memcpy(hv_txn_country.arr,csTxnCountry,hv_txn_country.len);
	ind_txn_country = 0;
DEBUGLOG(("GetAllBankByCountry: txn_country = [%.*s]\n",hv_txn_country.len,hv_txn_country.arr));

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_def_bank_get(:hv_txn_country:ind_txn_country,
							    :c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value > 0 ) {
DEBUGLOG(("GetAllBankByCountry: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_bank_code = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_bank_code:ind_bank_code;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_bank_code >= 0) {
				v_bank_code.arr[v_bank_code.len]='\0';
DEBUGLOG(("GetAllBankByCountry: [%03d]bank_code = [%.*s]\n",iCnt,v_bank_code.len,v_bank_code.arr));
				PutField_CString(myHash,"bank_code",(const char *)v_bank_code.arr);
			}
			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAllBankByCountry: exit with ok\n"));
		return iRet;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAllBankByCountry: exit with error\n"));
		return PD_ERR;
	}


	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

getall_error:
DEBUGLOG(("getall_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    	EXEC SQL WHENEVER SQLERROR CONTINUE;
    	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
    	return PD_ERR;
}

int DisabledBankInfo(const unsigned char* csBank,
                    const char cPartyType,
                    recordset_t* myRec)
{

DEBUGLOG(("DisabledBankInfo()\n"));
	int iRet = PD_OK;
	int	iCnt = 0;
	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO info_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_bank_code[PD_BANK_CODE_LEN];
		char	hv_party_type;
		char	v_party_type;

		varchar	v_channel_code[PD_CHANNEL_CODE_LEN+1];
		varchar	v_party_id[PD_CLIENT_ID_LEN+1];
		int	v_scheduler_id;
		
		short	ind_party_type = 1;
		short	ind_channel_code = -1;
		short	ind_bank_code= -1;
		short	ind_party_id = -1;
		short	ind_scheduler_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

/*bank_code*/
	hv_bank_code.len = strlen((const char*)csBank);
	memcpy(hv_bank_code.arr,csBank,hv_bank_code.len);
	ind_bank_code= 0;
DEBUGLOG(("DisabledBankInfo: bank_code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr));

/*party_type */
	hv_party_type = cPartyType;
	ind_party_type = 0;
DEBUGLOG(("GetDisabledBank: party_type = [%c]\n",hv_party_type));


	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_disabled_bank_info(:hv_bank_code:ind_bank_code,
								:hv_party_type:ind_party_type,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value ==1 ) {
DEBUGLOG(("DisabledBankInfo: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_channel_code = -1;
			ind_party_type = -1;
			ind_party_id = -1;
			ind_scheduler_id = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_channel_code:ind_channel_code,
				:v_party_type:ind_party_type,
				:v_party_id:ind_party_id,
				:v_scheduler_id:ind_scheduler_id;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_channel_code >= 0) {
DEBUGLOG(("DisabledBankInfo: [%03d]channel_code = [%.*s]\n",iCnt,v_channel_code.len,v_channel_code.arr));
				PutField_CString(myHash,"channel_code",(const char *)v_channel_code.arr);
			}
			if (ind_party_type >= 0) {
DEBUGLOG(("DisabledBankInfo: [%03d]party_type = [%c]\n",iCnt,v_party_type));
				PutField_Char(myHash,"party_type",v_party_type);
			}
			if (ind_party_id >= 0) {
DEBUGLOG(("DisabledBankInfo: [%03d]party_id = [%.*s]\n",iCnt,v_party_id.len,v_party_id.arr));
				PutField_CString(myHash,"party_id",(const char *)v_party_id.arr);
			}
			if (ind_scheduler_id >= 0) {
DEBUGLOG(("DisabledBankInfo: [%03d]scheduler_id = [%d]\n",iCnt,v_scheduler_id));
				PutField_Int(myHash,"scheduler_id",v_scheduler_id);
			}

			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("DisabledBankInfo: exit with ok\n"));
		return iRet;
	}
	else if(hv_return_value == 9){
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("DisabledBankInfo: exit with error\n"));
		return PD_ERR;
	}
	else{
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("DisabledBankInfo: exit with ok, no record\n"));
		return PD_OK;
	}


	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

info_error:
DEBUGLOG(("info_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    EXEC SQL FREE :c_cursor_id;
    return PD_ERR;
}


int GetAllBankSupported(const unsigned char* csTxnCountry,
			const unsigned char* csServiceCode,
			recordset_t* myRec)
{
	int iRet = PD_OK;
	int	iCnt = 0;
	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getsupp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_txn_country[PD_COUNTRY_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];

		varchar	v_bank_code[PD_BANK_CODE_LEN+1];
		
		short	ind_txn_country = -1;
		short	ind_service_code = -1;
		short	ind_bank_code= -1;

		SQL_CURSOR      c_cursor_id;
        EXEC SQL END DECLARE SECTION;


/*txn_country */
	hv_txn_country.len = strlen((const char*)csTxnCountry);
	memcpy(hv_txn_country.arr,csTxnCountry,hv_txn_country.len);
	ind_txn_country = 0;
DEBUGLOG(("GetAllBankSupported: txn_country = [%.*s]\n",hv_txn_country.len,hv_txn_country.arr));

/*service_code*/
	hv_service_code.len = strlen((const char*)csServiceCode);
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("GetAllBankSupported: service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_def_bank_support(:hv_txn_country:ind_txn_country,
								:hv_service_code:ind_service_code,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value > 0 ) {
DEBUGLOG(("GetAllBankSupported: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_bank_code = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	:v_bank_code:ind_bank_code;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_bank_code >= 0) {
				v_bank_code.arr[v_bank_code.len]='\0';
DEBUGLOG(("GetAllBankSupported: [%03d]bank_code = [%.*s]\n",iCnt,v_bank_code.len,v_bank_code.arr));
				PutField_CString(myHash,"bank_code",(const char *)v_bank_code.arr);
			}
			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAllBankSupported: exit with ok\n"));
		return iRet;
	}
	else {
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetAllBankSupported: exit with error\n"));
		return PD_ERR;
	}


	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

getsupp_error:
DEBUGLOG(("getsupp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_id;
    EXEC SQL FREE :c_cursor_id;
    return PD_ERR;
}

int Add(hash_t *hRls)
{
        char  *csTmp;
        int   iTmp;
	char  cTmp;

        EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_bank_code[PD_BANK_CODE_LEN];
                char		hv_party_type;
                varchar         hv_channel_code[PD_CHANNEL_CODE_LEN];
                varchar         hv_party_id[PD_CLIENT_ID_LEN];
                int             hv_scheduler_id;
                int             hv_disabled;
                varchar         hv_create_user[PD_USER_LEN];
		int		hv_note_id;

                short           ind_bank_code = -1;
                short           ind_party_type = -1;
                short           ind_channel_code = -1;
                short           ind_party_id = -1;
                short           ind_scheduler_id = -1;
                short           ind_disabled = -1;
                short           ind_create_user = -1;
		short		ind_note_id = -1;

                short           hv_return_value;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

        if (GetField_CString(hRls, "bank_code", &csTmp)) {
                hv_bank_code.len = strlen(csTmp);
                strncpy((char*)hv_bank_code.arr, csTmp, hv_bank_code.len);
                ind_bank_code = 0;
DEBUGLOG(("Add:bank_code = [%.*s]\n",hv_bank_code.len, hv_bank_code.arr));
        }

        if (GetField_Char(hRls, "party_type", &cTmp)) {
		hv_party_type = cTmp;
		ind_party_type = 0;
DEBUGLOG(("Add:party_type = [%c]\n", hv_party_type));
        }

        if (GetField_CString(hRls, "ch_code", &csTmp)) {
                hv_channel_code.len = strlen(csTmp);
                strncpy((char*)hv_channel_code.arr, csTmp, hv_channel_code.len);
                ind_channel_code = 0;
DEBUGLOG(("Add:channel_code = [%.*s]\n",hv_channel_code.len, hv_channel_code.arr));
        }

        if (GetField_CString(hRls, "party_id", &csTmp)) {
                hv_party_id.len = strlen(csTmp);
                strncpy((char*)hv_party_id.arr, csTmp, hv_party_id.len);
                ind_party_id= 0;
DEBUGLOG(("Add:party_id = [%.*s]\n",hv_party_id.len, hv_party_id.arr));
        }

        if(GetField_Int(hRls, "scheduler_id", &iTmp)) {
                hv_scheduler_id = iTmp;
                ind_scheduler_id = 0;
DEBUGLOG(("Add:scheduler_id = [%d]\n",hv_scheduler_id));
        }

        if(GetField_Int(hRls, "note_id", &iTmp)) {
                hv_note_id= iTmp;
                ind_note_id = 0;
DEBUGLOG(("Add:note_id = [%d]\n",hv_note_id));
        }

        if(GetField_Int(hRls, "disabled", &iTmp)) {
                hv_disabled = iTmp;
                ind_disabled = 0;
        }
        else {
                hv_disabled = 0;
                ind_disabled = 0;
        }
DEBUGLOG(("Add:disabled = [%d]\n",hv_disabled));


        if(GetField_CString(hRls,"create_user",&csTmp))
        {
                hv_create_user.len = strlen(csTmp);
                strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
                ind_create_user = 0;
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));
        }

        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_disabled_bank_insert(
                                                :hv_bank_code:ind_bank_code,
                                                :hv_party_type:ind_party_type,
                                                :hv_channel_code:ind_channel_code,
                                                :hv_party_id:ind_party_id,
                                                :hv_scheduler_id:ind_scheduler_id,
						:hv_note_id:ind_note_id,
                                                :hv_disabled:ind_disabled,
                                                :hv_create_user:ind_create_user);
                END;
        END-EXEC;

        DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
                DEBUGLOG(("Add:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
                ERRLOG("RuleDisabledBank_Add: SP_OTHER_ERR TxnAbort\n");
                DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
                ERRLOG("RuleDisabledBank_Add: SP_ERR TxnAbort\n");
                DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
                return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("RuleDisabledBank_Add: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;


}

int Delete (hash_t *hRls)
{
        char  *csTmp;
	char  cTmp;
	int   iTmp;

        EXEC SQL WHENEVER SQLERROR GOTO delete_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_bank_code[PD_BANK_CODE_LEN];
                char		hv_party_type;
                varchar         hv_channel_code[PD_CHANNEL_CODE_LEN];
                varchar         hv_party_id[PD_CLIENT_ID_LEN];
                int             hv_scheduler_id;
                int             hv_disabled;

                short           ind_bank_code = -1;
                short           ind_party_type = -1;
                short           ind_channel_code = -1;
                short           ind_party_id = -1;
                short           ind_scheduler_id = -1;
		short		ind_disabled = -1;

                short           hv_return_value;

        EXEC SQL END DECLARE SECTION;


DEBUGLOG(("Delete: Begin\n"));

        if (GetField_CString(hRls, "bank_code", &csTmp)) {
                hv_bank_code.len = strlen(csTmp);
                strncpy((char*)hv_bank_code.arr, csTmp, hv_bank_code.len);
                ind_bank_code = 0;
DEBUGLOG(("Delete:bank_code = [%.*s]\n",hv_bank_code.len, hv_bank_code.arr));
        }

        if (GetField_Char(hRls, "party_type", &cTmp)) {
                hv_party_type = cTmp;
                ind_party_type = 0;
DEBUGLOG(("Delete:party_type = [%c]\n",hv_party_type));
        }

        if (GetField_CString(hRls, "ch_code", &csTmp)) {
                hv_channel_code.len = strlen(csTmp);
                strncpy((char*)hv_channel_code.arr, csTmp, hv_channel_code.len);
                ind_channel_code = 0;
DEBUGLOG(("Delete:channel_code = [%.*s]\n",hv_channel_code.len, hv_channel_code.arr));
        }

        if (GetField_CString(hRls, "party_id", &csTmp)) {
                hv_party_id.len = strlen(csTmp);
                strncpy((char*)hv_party_id.arr, csTmp, hv_party_id.len);
                ind_party_id= 0;
DEBUGLOG(("Delete:party_id = [%.*s]\n",hv_party_id.len, hv_party_id.arr));
        }

        if(GetField_Int(hRls, "scheduler_id", &iTmp)) {
                hv_scheduler_id = iTmp;
                ind_scheduler_id = 0;
DEBUGLOG(("Delete:scheduler_id = [%d]\n",hv_scheduler_id));
        }

        if(GetField_Int(hRls, "disabled", &iTmp)) {
                hv_disabled = iTmp;
                ind_disabled = 0;
        }
        else {
                hv_disabled = 0;
                ind_disabled = 0;
        }
DEBUGLOG(("Deletd:disabled = [%d]\n",hv_disabled));


        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_disabled_bank_delete(
                                                :hv_bank_code:ind_bank_code,
                                                :hv_party_type:ind_party_type,
                                                :hv_channel_code:ind_channel_code,
                                                :hv_party_id:ind_party_id,
                                                :hv_scheduler_id:ind_scheduler_id,
						:hv_disabled:ind_disabled);
                END;
        END-EXEC;

        DEBUGLOG(("Delete:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
                DEBUGLOG(("Delete:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
                ERRLOG("RuleDisabledBank_delete: SP_OTHER_ERR TxnAbort\n");
                DEBUGLOG(("Delete: SP_OTHER_ERR TxnAbort\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
                ERRLOG("RuleDisabledBank_Delete: SP_ERR TxnAbort\n");
                DEBUGLOG(("Delete: SP_ERR TxnAbort\n"));
                return PD_ERR;
        }

delete_error:
DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("RuleDisabledBank_Delete: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;


}

int ChkRuleExists(hash_t *hRls)
{
        int     iRet = PD_NOT_FOUND;
	char    *csTmp;
	char	cTmp;
	int	iTmp;

	EXEC SQL WHENEVER SQLERROR GOTO chkruleexists_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_bank_code[PD_BANK_CODE_LEN];
                char            hv_party_type;
                varchar         hv_channel_code[PD_CHANNEL_CODE_LEN];
                varchar         hv_party_id[PD_CLIENT_ID_LEN];
                int             hv_scheduler_id;
                int             hv_disabled;

                int             v_no_of_record;
                short           ind_no_of_record = -1;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("ChkRuleExists: Begin\n"));

        if (GetField_CString(hRls, "bank_code", &csTmp)) {
                hv_bank_code.len = strlen(csTmp);
                strncpy((char*)hv_bank_code.arr, csTmp, hv_bank_code.len);
DEBUGLOG(("ChkRuleExists:bank_code = [%.*s]\n",hv_bank_code.len, hv_bank_code.arr));
        }

        if (GetField_Char(hRls, "party_type", &cTmp)) {
                hv_party_type = cTmp;
DEBUGLOG(("ChkRuleExists:party_type = [%c]\n",hv_party_type));
        }

        if (GetField_CString(hRls, "ch_code", &csTmp)) {
                hv_channel_code.len = strlen(csTmp);
                strncpy((char*)hv_channel_code.arr, csTmp, hv_channel_code.len);
DEBUGLOG(("ChkRuleExists:channel_code = [%.*s]\n",hv_channel_code.len, hv_channel_code.arr));
        }

        if (GetField_CString(hRls, "party_id", &csTmp)) {
                hv_party_id.len = strlen(csTmp);
                strncpy((char*)hv_party_id.arr, csTmp, hv_party_id.len);
DEBUGLOG(("ChkRuleExists:party_id = [%.*s]\n",hv_party_id.len, hv_party_id.arr));
        }

        if(GetField_Int(hRls, "scheduler_id", &iTmp)) {
                hv_scheduler_id = iTmp;
DEBUGLOG(("ChkRuleExists:scheduler_id = [%d]\n",hv_scheduler_id));
        }

        if(GetField_Int(hRls, "disabled", &iTmp)) {
                hv_disabled = iTmp;
        }
        else {
                hv_disabled = 0;
        }
DEBUGLOG(("ChkRuleExists:disabled = [%d]\n",hv_disabled));

	if (hv_party_type == PD_TYPE_GLOBAL) {
	        EXEC SQL
                	SELECT count(1)
			INTO :v_no_of_record:ind_no_of_record
			FROM rule_disabled_bank
			WHERE rb_bank_code = :hv_bank_code
			AND   rb_type = :hv_party_type
			AND   rb_channel_code = :hv_channel_code
			AND   rb_scheduler_id = :hv_scheduler_id
			/*AND   rb_disabled = :hv_disabled*/
			and rownum = 1;
	}
	else {
		EXEC SQL
                        SELECT count(1)
                        INTO :v_no_of_record:ind_no_of_record
                        FROM rule_disabled_bank
                        WHERE rb_bank_code = :hv_bank_code
                        AND   rb_type = :hv_party_type
                        AND   rb_party_id = :hv_party_id
                        AND   rb_scheduler_id = :hv_scheduler_id
                        /*AND   rb_disabled = :hv_disabled*/
                        and rownum = 1;
	}


        if (ind_no_of_record >= 0) {
                if (v_no_of_record > 0) {
DEBUGLOG(("ChkRuleExists FOUND\n"));
                        iRet = PD_FOUND;
                }
        }

        if (iRet!= PD_FOUND) {
DEBUGLOG(("ChkRuleExists NOT FOUND\n"));
        }


        return iRet;

chkruleexists_error:
DEBUGLOG(("ChkRuleExists_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;

}

int Update(hash_t *hRls)
{
	char	*csBuf;

        char    cPartyType;
        char    *csTmp;
        int     iTmp;

        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar         hv_dynstmt[1024];
        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));

        csBuf = (char*) malloc (128);

        strcpy((char*)hv_dynstmt.arr,"update rule_disabled_bank set rb_update_timestamp  = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

/* note_id */
        if (GetField_Int(hRls,"note_id", &iTmp)) {
DEBUGLOG(("Update:note_id = [%d]\n",iTmp));
		if (iTmp == 0) {
			strcat((char*)hv_dynstmt.arr, ",rb_note_id = null");
                	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
		} else {
                	sprintf(csBuf, "%d", iTmp);

	                strcat((char*)hv_dynstmt.arr, ",rb_note_id = '");
			strcat((char*)hv_dynstmt.arr, csBuf);
			strcat((char*)hv_dynstmt.arr, "'");
			hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
		}
        }


/* disabled */
        if (GetField_Int(hRls,"disabled", &iTmp)) {
DEBUGLOG(("Update:disabled = [%d]\n",iTmp));
		sprintf(csBuf, "%d", iTmp);

                strcat((char*)hv_dynstmt.arr, ",rb_disabled = '");
                strcat((char*)hv_dynstmt.arr, csBuf);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

/* update user */
        if (GetField_CString(hRls,"update_user",&csTmp)) {
DEBUGLOG(("Update:update_user = [%s]\n",csTmp));
                strcat((char*)hv_dynstmt.arr, ",rb_update_user = '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }


        GetField_CString(hRls, "bank_code", &csTmp);
DEBUGLOG(("Update:bank_code= [%s]\n",csTmp));
        strcat((char *)hv_dynstmt.arr, " WHERE rb_bank_code = '");
        strcat((char *)hv_dynstmt.arr, csTmp);
        strcat((char *)hv_dynstmt.arr, "'");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

        GetField_Char(hRls, "party_type", &cPartyType);
DEBUGLOG(("Update:party_type = [%c]\n",cPartyType));
	sprintf(csBuf, "%c", cPartyType); 
        strcat((char *)hv_dynstmt.arr, " AND rb_type = '");
        strcat((char *)hv_dynstmt.arr, csBuf);
        strcat((char *)hv_dynstmt.arr, "'");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

	if (cPartyType == PD_TYPE_GLOBAL) {
		GetField_CString(hRls, "ch_code", &csTmp);
DEBUGLOG(("Update:channel_code = [%s]\n",csTmp));
		strcat((char *)hv_dynstmt.arr, " AND rb_channel_code = '");
		strcat((char *)hv_dynstmt.arr, csTmp);
		strcat((char *)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}
	else {
		GetField_CString(hRls, "party_id", &csTmp);
DEBUGLOG(("Update:party_id = [%s]\n",csTmp));
		strcat((char *)hv_dynstmt.arr, " AND rb_party_id = '");
		strcat((char *)hv_dynstmt.arr, csTmp);
		strcat((char *)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

	GetField_Int(hRls, "scheduler_id", &iTmp);
DEBUGLOG(("Update:scheduler_id = [%d]\n",iTmp));
	sprintf(csBuf, "%d", iTmp);
        strcat((char *)hv_dynstmt.arr, " AND rb_scheduler_id = '");
        strcat((char *)hv_dynstmt.arr, csBuf);
        strcat((char *)hv_dynstmt.arr, "'");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;


	FREE_ME(csBuf);

DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;


update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("RuleDisabledBank_Update: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Update: SP_INTERNAL_ERR TxnAbort\n"));
        TxnAbort();
        return PD_INTERNAL_ERR;
}

int DisableBankSchedulerId(const unsigned char* csBank,
                             const char cPartyType,
                             const unsigned char* csPartyId)
{

DEBUGLOG(("DisableBankSchedulerId()\n"));

	int iSchedulerId = PD_NOT_FOUND;
	
	EXEC SQL WHENEVER SQLERROR GOTO sid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_bank_code[PD_BANK_CODE_LEN];
		char    hv_party_type;
		varchar hv_party_id[PD_CLIENT_ID_LEN+1];

		int     v_scheduler_id;

		short   ind_scheduler_id = -1;

        EXEC SQL END DECLARE SECTION;


/*bank_code*/
	hv_bank_code.len = strlen((const char*)csBank);
	memcpy(hv_bank_code.arr,csBank,hv_bank_code.len);
DEBUGLOG(("DisableBankSchedulerId: bank_code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr));

/*party_type */
	hv_party_type = cPartyType;
DEBUGLOG(("DisableBankSchedulerId: party_type = [%c]\n",hv_party_type));

/*party_id*/
	hv_party_id.len = strlen((const char*)csPartyId);
	memcpy(hv_party_id.arr,csPartyId,hv_party_id.len);
DEBUGLOG(("DisableBankSchedulerId: party_id = [%.*s]\n",hv_party_id.len,hv_party_id.arr));

	EXEC SQL
		SELECT	rb_scheduler_id
		INTO	:v_scheduler_id:ind_scheduler_id
		FROM	rule_disabled_bank
		WHERE	rb_bank_code = :hv_bank_code
		AND	rb_type = :hv_party_type
		AND	rb_party_id= :hv_party_id
		and	rb_disabled = 0;

	if(ind_scheduler_id>=0){
		iSchedulerId = v_scheduler_id;
DEBUGLOG(("DisableBankSchedulerId Found = [%d]\n",iSchedulerId));
	}

	if(iSchedulerId==PD_NOT_FOUND){
DEBUGLOG(("DisableBankSchedulerId Not Found\n"));
	}

	return iSchedulerId;

sid_error:
DEBUGLOG(("DisableBankSchedulerId_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int GetDisableSchedule(const unsigned char* csChannel,
                    const char cPartyType,
		    const unsigned char* csPartyId,
		    const unsigned char* csBankCode,
                    recordset_t* myRec)
{

DEBUGLOG(("GetDisableSchedule()\n"));
	int iRet = PD_OK;
	int	iCnt = 0;
	hash_t	*myHash;

        EXEC SQL WHENEVER SQLERROR GOTO dissch_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		short	hv_return_value;
		varchar	hv_channel[PD_CHANNEL_CODE_LEN];
		char	hv_party_type;
		varchar	hv_bank_code[PD_BANK_CODE_LEN];
		varchar	hv_party_id[PD_CLIENT_ID_LEN];

		int	v_scheduler_id;
		int	v_note_id;
		
		short	ind_channel = -1;
		short	ind_party_type = 1;
		short	ind_bank_code= -1;
		short	ind_party_id = -1;

		short	ind_scheduler_id = -1;
		short	ind_note_id = -1;

		SQL_CURSOR      c_cursor_id;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("GetDisableSchedule: channel_code = [%s]\n",csChannel));
DEBUGLOG(("GetDisableSchedule: party_type = [%c]\n",cPartyType));
DEBUGLOG(("GetDisableSchedule: party_id = [%s]\n",csPartyId));
DEBUGLOG(("GetDisableSchedule: bank_code = [%s]\n",csBankCode));

/*channel*/
	hv_channel.len = strlen((const char*)csChannel);
	memcpy(hv_channel.arr,csChannel,hv_channel.len);
	ind_channel= 0;
DEBUGLOG(("GetDisableSchedule: channel_code = [%.*s]\n",hv_channel.len,hv_channel.arr));

/*party_type */
	hv_party_type = cPartyType;
	ind_party_type = 0;
DEBUGLOG(("GetDisableSchedule: party_type = [%c]\n",hv_party_type));

/*party_id*/
	hv_party_id.len = strlen((const char*)csPartyId);
	memcpy(hv_party_id.arr,csPartyId,hv_party_id.len);
	ind_party_id= 0;
DEBUGLOG(("GetDisableSchedule: party_id = [%.*s]\n",hv_party_id.len,hv_party_id.arr));

/*bank_code*/
	hv_bank_code.len = strlen((const char*)csBankCode);
	memcpy(hv_bank_code.arr,csBankCode,hv_bank_code.len);
	ind_bank_code= 0;
DEBUGLOG(("GetDisableSchedule: bank_code = [%.*s]\n",hv_bank_code.len,hv_bank_code.arr));

	EXEC SQL ALLOCATE       :c_cursor_id;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_disable_schedule(:hv_channel:ind_channel,
								:hv_party_type:ind_party_type,
								:hv_party_id:ind_party_id,
								:hv_bank_code:ind_bank_code,
								:c_cursor_id);
                END;
        END-EXEC;

	if (hv_return_value == 1 ) {
DEBUGLOG(("GetDisableSchedule: Found!\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);	

			ind_scheduler_id = -1;
			ind_note_id = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_id
			INTO	
				:v_scheduler_id:ind_scheduler_id,
				:v_note_id:ind_note_id;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			if (ind_scheduler_id >= 0) {
DEBUGLOG(("GetDisableSchedule: [%03d]scheduler_id = [%d]\n",iCnt,v_scheduler_id));
				PutField_Int(myHash,"scheduler_id",v_scheduler_id);
			}
			if (ind_note_id >= 0) {
DEBUGLOG(("GetDisableSchedule: [%03d]note_id = [%d]\n",iCnt,v_note_id));
				PutField_Int(myHash,"note_id",v_note_id);
			}

			RecordSet_Add(myRec,myHash);
			iCnt++;
		}
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetDisableSchedule: exit with ok\n"));
		return iRet;
	}
	else if(hv_return_value == 9){
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetDisableSchedule: exit with error\n"));
		return PD_ERR;
	}
	else{
		EXEC SQL CLOSE :c_cursor_id;
		EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("GetDisableSchedule: exit with ok, no record\n"));
		return PD_OK;
	}


	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

dissch_error:
DEBUGLOG(("dissch_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    	EXEC SQL WHENEVER SQLERROR CONTINUE;
    	EXEC SQL CLOSE :c_cursor_id;
	EXEC SQL FREE :c_cursor_id;
    return PD_ERR;
}
