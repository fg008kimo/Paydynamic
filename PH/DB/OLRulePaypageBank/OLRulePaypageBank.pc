/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/08/27              Virginia Yun
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLRulePaypageBank.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void OLRulePaypageBank(char    cdebug)
{
	cDebug = cdebug;
}


int GetBankList(const char* csMerchantId,
		const char* csClientId,
		recordset_t* myRec)
{
	int iRet = PD_ERR;

	hash_t *myHash;
	EXEC SQL WHENEVER SQLERROR GOTO getbanklist_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		short           hv_return_value;

		varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar         hv_client_id[PD_CLIENT_ID_LEN];

		short		ind_merchant_id = -1;
		short		ind_client_id = -1;

		varchar         v_int_bank_code[PD_BANK_CODE_LEN + 1]; 
		int		v_display_order;

		short		ind_int_bank_code = -1;
		short		ind_display_order = -1;

		SQL_CURSOR      c_cursor_banklist;

	EXEC SQL END DECLARE SECTION;

	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
DEBUGLOG(("GetBankList merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
	ind_merchant_id = 0;

	hv_client_id.len = strlen(csClientId);
	memcpy(hv_client_id.arr,csClientId,hv_client_id.len);
DEBUGLOG(("GetBankList client_id = [%.*s]\n",hv_client_id.len,hv_client_id.arr));
	ind_client_id = 0;


	EXEC SQL ALLOCATE       :c_cursor_banklist;
	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_ol_get_paypage_bank( :hv_merchant_id:ind_merchant_id,
									:hv_client_id:ind_client_id,
									:c_cursor_banklist);
		END;
	END-EXEC;

///////////////////////////////
	if (hv_return_value > 0)  {
DEBUGLOG(("GetBankList Found\n"));
		for (;;) {
			myHash = (hash_t*) malloc (sizeof(hash_t));
			hash_init(myHash,0);

			ind_int_bank_code = -1;
			ind_display_order = -1;

			EXEC SQL WHENEVER NOTFOUND DO break;
			EXEC SQL FETCH :c_cursor_banklist
			INTO    
				:v_int_bank_code:ind_int_bank_code,
				:v_display_order:ind_display_order;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			iRet = PD_OK;

// int_bank_code
			if (ind_int_bank_code >= 0) {
				v_int_bank_code.arr[v_int_bank_code.len] = '\0';
				PutField_CString(myHash,"int_bank_code",(const char*)v_int_bank_code.arr);
DEBUGLOG(("GetBankList int_bank_code = [%s]\n",v_int_bank_code.arr));

			} 
// display_order	
			if (ind_display_order >= 0) {
				PutField_Int(myHash, "display_order", v_display_order);
DEBUGLOG(("GetBankList display_order = [%d]\n", v_display_order));
			}
		
			RecordSet_Add(myRec,myHash);
		}
		EXEC SQL CLOSE :c_cursor_banklist;
		EXEC SQL FREE :c_cursor_banklist;
	}
	else {
		EXEC SQL CLOSE :c_cursor_banklist;
		EXEC SQL FREE :c_cursor_banklist;
DEBUGLOG(("GetBankList Not Found\n"));
	}

DEBUGLOG(("GetBank List Return [%d]\n", iRet));

	return iRet;

///////////////////////////////

getbanklist_error:
DEBUGLOG(("getbanklist_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_banklist;
	EXEC SQL FREE :c_cursor_banklist;
	return PD_ERR;
}

