/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/01/09              Dirk Wong
Add GetOrgBatchIdByBatchId
and GetBatchIdByOrgBatchId 			   2015/04/28		   Elvis Wong
Add batch_sub_type				   2015/05/15		   Elvis Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLBatchRelation.h"
#include "common.h"
#include "internal.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void OLBatchRelation(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hRls)
{
	char	cTmp;

	char*	csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_org_batch_id[PD_TXN_SEQ_LEN];
		varchar		hv_batch_id[PD_TXN_SEQ_LEN];
	 	char            hv_batch_sub_type;
		varchar         hv_create_user[PD_USER_LEN];

		short		ind_org_batch_id = -1;
		short		ind_batch_id = -1;
		short           ind_batch_sub_type = -1;
		short		ind_create_user = -1;

		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;
DEBUGLOG(("Add: Begin\n"));

	if (GetField_CString(hRls,"org_batch_id",&csTmp)) {
		hv_org_batch_id.len = strlen(csTmp);
		strncpy((char*)hv_org_batch_id.arr, csTmp, hv_org_batch_id.len);
		ind_org_batch_id = 0;
DEBUGLOG(("Add: org_batch_id = [%s]\n",(char*)hv_org_batch_id.arr));
	}

	if (GetField_CString(hRls,"batch_id",&csTmp)) {
		hv_batch_id.len = strlen(csTmp);
		strncpy((char*)hv_batch_id.arr, csTmp, hv_batch_id.len);
		ind_batch_id = 0;
DEBUGLOG(("Add: batch_id = [%s]\n",(char*)hv_batch_id.arr));
	}

	if (GetField_Char(hRls,"batch_sub_type",&cTmp)) {
                hv_batch_sub_type = cTmp;
                ind_batch_sub_type = 0;
DEBUGLOG(("Add: batch_sub_type = [%c]\n",hv_batch_sub_type));
        } else {
                hv_batch_sub_type = 'R';
                ind_batch_sub_type = 0;
DEBUGLOG(("Add: batch_sub_type = [%c]\n",hv_batch_sub_type));
        }

	if(GetField_CString(hRls,"create_user",&csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Add: create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_ol_batch_relation_insert(
						:hv_org_batch_id:ind_org_batch_id,
						:hv_batch_id:ind_batch_id,
						:hv_batch_sub_type:ind_batch_sub_type,
                                                :hv_create_user:ind_create_user);
		END;
	END-EXEC;

	DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("OLBatchRelation_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	} 

	if (hv_return_value == SP_ERR)  {
ERRLOG("OLBatchRelation_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchRelation_Add: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int GetOrgBatchIdByBatchId(const char* csBatchId, recordset_t* rRecordSet)
{
	int iRet = PD_OK;

        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getorgbatchid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_batch_id[PD_TXN_SEQ_LEN];

                varchar v_org_batch_id[PD_TXN_SEQ_LEN + 1];
                short ind_org_batch_id = -1;
        EXEC SQL END DECLARE SECTION;

        hv_batch_id.len = strlen(csBatchId);
        strncpy((char*)hv_batch_id.arr, csBatchId, hv_batch_id.len);
DEBUGLOG(("GetOrgBatchIdByBatchId batch_id = [%s]\n",(char*)hv_batch_id.arr));

	EXEC SQL DECLARE c_cursor_getorgbatchid CURSOR FOR
                select obr_org_batch_id
                from ol_batch_relation
                where obr_batch_id = :hv_batch_id
		order by obr_relation_timestamp DESC;
        EXEC SQL OPEN c_cursor_getorgbatchid;	

	for (;;) {
                EXEC SQL FETCH c_cursor_getorgbatchid
                into :v_org_batch_id:ind_org_batch_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash, 0);

        	if (ind_org_batch_id >= 0) {
                	v_org_batch_id.arr[v_org_batch_id.len] = '\0';
                        PutField_CString(myHash, "org_batch_id", (const char*)v_org_batch_id.arr);
DEBUGLOG(("org_batch_id = [%s]\n", (const char*)v_org_batch_id.arr));
        	}

		RecordSet_Add(rRecordSet, myHash);
	}
	
	EXEC SQL CLOSE c_cursor_getorgbatchid;

DEBUGLOG(("GetOrgBatchIdByBatchId: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

getorgbatchid_error:
DEBUGLOG(("getorgbatchid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchRelation getorgbatchid_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_getorgbatchid;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int GetBatchIdByOrgBatchId(const char* csOrgBatchId, recordset_t* rRecordSet)
{
	int iRet = PD_OK;

	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getbatchid_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_org_batch_id[PD_TXN_SEQ_LEN];

                varchar v_batch_id[PD_TXN_SEQ_LEN + 1];
                short ind_batch_id = -1;
        EXEC SQL END DECLARE SECTION;

	hv_org_batch_id.len = strlen(csOrgBatchId);
        strncpy((char*)hv_org_batch_id.arr, csOrgBatchId, hv_org_batch_id.len);
DEBUGLOG(("GetBatchIdByOrgBatchId org_batch_id = [%s]\n",(char*)hv_org_batch_id.arr));

	EXEC SQL DECLARE c_cursor_getbatchid CURSOR FOR
                select obr_batch_id
                from ol_batch_relation
                where obr_org_batch_id = :hv_org_batch_id
		order by obr_relation_timestamp DESC;
	EXEC SQL OPEN c_cursor_getbatchid;

	for (;;) {
		EXEC SQL FETCH c_cursor_getbatchid
                into :v_batch_id:ind_batch_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash, 0);

        	if (ind_batch_id >= 0) {
                	v_batch_id.arr[v_batch_id.len] = '\0';
                        PutField_CString(myHash, "batch_id", (const char*)v_batch_id.arr);
DEBUGLOG(("batch_id = [%s]\n", (const char*)v_batch_id.arr));
		}
	
		RecordSet_Add(rRecordSet, myHash);
        }

	EXEC SQL CLOSE c_cursor_getbatchid;

DEBUGLOG(("GetBatchIdByOrgBatchId: Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

getbatchid_error:
DEBUGLOG(("getbatchid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBatchRelation getbatchid_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE c_cursor_getbatchid;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}
