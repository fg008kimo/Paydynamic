/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/07/17              Stan Poon
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "OLStmtFormat.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define PD_FMT_COL_FORMAT_ID "format_id"
#define PD_FMT_TYPE_DELIMITER "delimiter"
#define PD_FMT_TYPE_HOLD "hold"

#define PD_FMT_TYPE_CONTENT "content"

#define PD_FMT_COL_NEXT_LEVEL "nextlevel"
#define PD_FMT_COL_DESC "desc"
#define PD_FMT_COL_TEMPLATE "template"

char cDebug;

void OLStmtFormat(char cdebug)
{
	cDebug = cdebug;
}


int GetFormat(const char* csIntBankCode, recordset_t* myRec)
{
	int iRet = PD_OK;
	int iCnt = 0;
	int isFormatContent = 0;
	int isFormatDelimiter = 0;
	int isFormatHold = 0;

	char csFormatId[PD_FORMAT_ID_LEN + 1];
	char csCurrFormatId[PD_FORMAT_ID_LEN + 1];

	char csFormatType[PD_FORMAT_TYPE_LEN + 1];
	char csFormatValue[PD_FORMAT_VALUE_LEN + 1];

	char *csTmp;
	char *csTag = (char*) malloc (64);

	hash_t *myHash;
	myHash = (hash_t*) malloc (sizeof(hash_t));
	hash_init(myHash, 0);

	EXEC SQL WHENEVER SQLERROR GOTO getformat_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_int_bank_code[PD_BANK_CODE_LEN + 1];
		varchar v_id[PD_FORMAT_ID_LEN + 1];
		varchar v_type[PD_FORMAT_TYPE_LEN + 1];
		varchar v_value[PD_FORMAT_VALUE_LEN + 1];
		varchar v_desc[PD_FORMAT_DESC_LEN + 1];
		varchar v_template[PD_FORMAT_TEMPLATE_LEN + 1];
		int v_next_level;

		short ind_int_bank_code = -1;
		short ind_id = -1;
		short ind_type = -1;
		short ind_value = -1;
		short ind_desc = -1;
		short ind_template = -1;
		short ind_next_level = -1;
	EXEC SQL END DECLARE SECTION;

	hv_int_bank_code.len = strlen(csIntBankCode);
	strncpy((char*)hv_int_bank_code.arr, csIntBankCode, hv_int_bank_code.len);
	ind_int_bank_code = 0;
DEBUGLOG(("GetFormat int_bank_code = [%.*s]\n", hv_int_bank_code.len, hv_int_bank_code.arr));

	EXEC SQL DECLARE getformatcursor CURSOR FOR
		SELECT	OLFT_FORMAT_ID,
			lower(OLFT_FORMAT_TYPE),
			OLFT_FORMAT_VALUE,
			OLFT_FORMAT_DESC,
			OLFT_FORMAT_TEMPLATE,
			OLFT_NEXT_LEVEL
		FROM	OL_STMT_FORMAT_TEMPLATE,
			OL_STMT_FORMAT
		WHERE	OLSF_INT_BANK_CODE = :hv_int_bank_code:ind_int_bank_code
		AND	(OLSF_FORMAT_ID = OLFT_FORMAT_ID OR OLFT_FORMAT_ID LIKE OLSF_FORMAT_ID || '.%')
		AND	(OLFT_NEXT_LEVEL = 0 OR (OLFT_NEXT_LEVEL = 1 AND OLFT_FORMAT_DESC > OLFT_FORMAT_ID))
		AND	OLSF_DISABLED = 0
		AND	OLSF_EFFECT_TIMESTAMP <= sysdate
		ORDER BY OLFT_FORMAT_ID ASC, OLFT_FORMAT_TYPE ASC, OLFT_FORMAT_VALUE ASC;

	EXEC SQL OPEN getformatcursor;
	for (;;) {
		EXEC SQL FETCH getformatcursor
		INTO	:v_id:ind_id,
			:v_type:ind_type,
			:v_value:ind_value,
			:v_desc:ind_desc,
			:v_template:ind_template,
			:v_next_level:ind_next_level;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

/* id */
		if (ind_id >= 0) {
			v_id.arr[v_id.len] = '\0';
			strcpy(csCurrFormatId, (const char*)v_id.arr);
			if (iCnt == 1) {
				strcpy(csFormatId, (const char*)v_id.arr);
				PutField_CString(myHash, PD_FMT_COL_FORMAT_ID, csFormatId); //
DEBUGLOG(("GetFormat read (%s) = [%s]\n", PD_FMT_COL_FORMAT_ID, csFormatId));
			} else {
				csTmp = mystrtok(csCurrFormatId, ".");
				if (csTmp != NULL && strcmp(csTmp, csFormatId)) {
					RecordSet_Add(myRec, myHash);
DEBUGLOG(("GetFormat hash added - (%s) = [%s]\n", PD_FMT_COL_FORMAT_ID, csFormatId));
					myHash = (hash_t*) malloc (sizeof(hash_t));
					hash_init(myHash, 0);
					strcpy(csFormatId, (const char*)v_id.arr);
					PutField_CString(myHash, PD_FMT_COL_FORMAT_ID, csFormatId); //
DEBUGLOG(("GetFormat read (%s) = [%s]\n", PD_FMT_COL_FORMAT_ID, csFormatId));
				}
				strcpy(csCurrFormatId, (const char*)v_id.arr);
			}
		}

		isFormatContent = 0;
		isFormatDelimiter = 0;
		isFormatHold = 0;

/* type */
		if (ind_type >= 0) {
			v_type.arr[v_type.len] = '\0';
			strcpy(csFormatType, (const char*)v_type.arr);
			if (!strcmp(csFormatType, PD_FMT_TYPE_CONTENT))
				isFormatContent = 1;
			else if (!strcmp(csFormatType, PD_FMT_TYPE_DELIMITER))
				isFormatDelimiter = 1;
			else if (!strcmp(csFormatType, PD_FMT_TYPE_HOLD))
				isFormatHold = 1;
		}

/* value */
		if (ind_value >= 0) {
			v_value.arr[v_value.len] = '\0';
			strcpy(csFormatValue, (const char*)v_value.arr);
			if (isFormatDelimiter == 1) {
				sprintf(csTag, "%s_%s", csFormatType, csCurrFormatId);
				PutField_CString(myHash, csTag, csFormatValue); //
DEBUGLOG(("GetFormat (%s) = [%s]\n", csTag, csFormatValue));
			} else if (isFormatContent == 0 && isFormatHold != 1) {
				PutField_CString(myHash, csFormatType, csFormatValue); //
DEBUGLOG(("GetFormat (%s) = [%s]\n", csFormatType, csFormatValue));
			}
		}

/* desc */
		if (ind_desc >= 0 && isFormatContent == 1) {
			v_desc.arr[v_desc.len] = '\0';
			sprintf(csTag, "%s_%s_%s", PD_FMT_COL_DESC, csCurrFormatId, csFormatValue);
			PutField_CString(myHash, csTag, (const char *)v_desc.arr); //
DEBUGLOG(("GetFormat (%s) = [%s]\n", csTag, v_desc.arr));
		} else if (ind_desc >= 0 && isFormatHold == 1) {
			v_desc.arr[v_desc.len] = '\0';
			sprintf(csTag, "%s_%s", PD_FMT_TYPE_HOLD, csFormatValue);
			PutField_CString(myHash, csTag, (const char *)v_desc.arr); //
DEBUGLOG(("GetFormat (%s) = [%s]\n", csTag, v_desc.arr));
		}

/* template */
		if (ind_template >= 0 && isFormatContent == 1) {
			v_template.arr[v_template.len] = '\0';
			sprintf(csTag, "%s_%s_%s", PD_FMT_COL_TEMPLATE, csCurrFormatId, csFormatValue);
			PutField_CString(myHash, csTag, (const char *)v_template.arr); //
DEBUGLOG(("GetFormat (%s) = [%s]\n", csTag, v_template.arr));
		}

/* next_level */
		if (ind_next_level >= 0 && isFormatContent == 1) {
			sprintf(csTag, "%s_%s_%s", PD_FMT_COL_NEXT_LEVEL, csCurrFormatId, csFormatValue);
			PutField_Int(myHash, csTag, v_next_level); //
			if (v_next_level == 1)
DEBUGLOG(("GetFormat (%s) = [%d]\n", csTag, v_next_level));
		}
	}
	EXEC SQL CLOSE getformatcursor;

	if (iCnt > 0 ) {
		RecordSet_Add(myRec, myHash);
DEBUGLOG(("GetFormat hash added - (%s) = [%s]\n", PD_FMT_COL_FORMAT_ID, csFormatId));
		iRet = PD_OK;
	} else {
DEBUGLOG(("GetFormat NOT FOUND!!!\n"));
ERRLOG("OLStmtFormat::GetFormat NOT FOUND!!!\n");
		iRet = PD_ERR;
	}

	free(csTag);

DEBUGLOG(("GetFormat Normal Exit! iRet = [%d]\n", iRet));
	// hash_destroy(myHash);
	// FREE_ME(myHash);
	return iRet;

getformat_error:
DEBUGLOG(("getformat_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLStmtFormat getformat_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE getformatcursor;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	// hash_destroy(myHash);
	// FREE_ME(myHash);
	return PD_ERR;
}
