/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2010/10/19              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "PayoutHeader.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void PayoutHeader(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hPayoutHeader)
{
	char		*csTmp;
	int		iTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar         hv_batch_id[PD_TXN_SEQ_LEN];
		varchar		hv_txn_date[PD_DATE_LEN];
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_checksum[PD_CHECKSUM_LEN];

		int		hv_num_of_record;

		short           ind_batch_id = -1;
		short		ind_txn_date = -1;
		short		ind_merchant_id = -1;
		short		ind_checksum = -1;
		short		ind_num_of_record = -1;

		short           hv_return_value;
		EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

/*batch_id*/
	if(GetField_CString(hPayoutHeader,"batch_id",&csTmp)){
		hv_batch_id.len = strlen(csTmp);
		memcpy(hv_batch_id.arr, csTmp, hv_batch_id.len);
		ind_batch_id= 0;
DEBUGLOG(("Add:batch_id= [%.*s]\n",hv_batch_id.len,hv_batch_id.arr));
	}

/*txn_date*/
	if(GetField_CString(hPayoutHeader,"txn_date",&csTmp)){
		//hv_txn_date.len = strlen(csTmp);
		hv_txn_date.len = PD_DATE_LEN;
		memcpy(hv_txn_date.arr, csTmp, PD_DATE_LEN);
		ind_txn_date = 0;
DEBUGLOG(("Add:txn_date = [%.*s]\n",hv_txn_date.len,hv_txn_date.arr));
	}

/*checksum*/
	if(GetField_CString(hPayoutHeader,"checksum",&csTmp)){
		hv_checksum.len = strlen(csTmp);
		memcpy(hv_checksum.arr, csTmp, hv_checksum.len);
		ind_checksum = 0;
DEBUGLOG(("Add:checksum = [%.*s]\n",hv_checksum.len,hv_checksum.arr));
	}

/*merchant_id*/
	if(GetField_CString(hPayoutHeader,"merchant_id",&csTmp)){
		hv_merchant_id.len = strlen(csTmp);
		memcpy(hv_merchant_id.arr, csTmp, hv_merchant_id.len);
		ind_merchant_id = 0;
DEBUGLOG(("Add:merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
	}

/*num_of_record*/
	if (GetField_Int(hPayoutHeader,"num_of_record",&iTmp)) {
		hv_num_of_record = iTmp;
		ind_num_of_record = 0;
DEBUGLOG(("Add:num_of_record = [%d]\n",hv_num_of_record));
	}


	
	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_payout_header_insert(
					:hv_batch_id:ind_batch_id,
					:hv_txn_date:ind_txn_date,
					:hv_merchant_id:ind_merchant_id,
					:hv_num_of_record:ind_num_of_record,
					:hv_checksum:ind_checksum);
		END;
	END-EXEC;

DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("PayoutHeader_Add: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("PayoutHeader_Add: SP_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR; 
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("PayoutHeader_Add: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;

}





int UpdateStatus(const hash_t *hRls)
{
	char*   csBuf;
	char*	csTxnDate;
	char*	csBatchId;
	char*	csRespCode;
	char	cStatus;

	EXEC SQL WHENEVER SQLERROR GOTO updatestatus_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar		hv_dynstmt[1024];

	EXEC SQL END DECLARE SECTION;


DEBUGLOG(("Update: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update payout_header set ");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

	GetField_CString(hRls,"txn_date",&csTxnDate);
DEBUGLOG(("Update:txn_date = [%s]\n",csTxnDate));

	GetField_CString(hRls,"batch_id",&csBatchId);
DEBUGLOG(("Update:batch_id = [%s]\n",csBatchId));


        if(GetField_Char(hRls,"status",&cStatus)){
DEBUGLOG(("Update: status = [%c]\n",cStatus));
		sprintf(csBuf,"%c",cStatus);
		strcat((char*)hv_dynstmt.arr, "status = '");
		strcat((char*)hv_dynstmt.arr, csBuf);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}


	if(GetField_Char(hRls,"resp_code",&csRespCode)){
		strcat((char*)hv_dynstmt.arr, ",response_code = '");
		strcat((char*)hv_dynstmt.arr, csRespCode);
		strcat((char*)hv_dynstmt.arr, "'");
		hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

	
	
	strcat((char*)hv_dynstmt.arr, " WHERE txn_date = '");
	strcat((char*)hv_dynstmt.arr, csTxnDate);
	strcat((char*)hv_dynstmt.arr, "' AND batch_id = '");
	strcat((char*)hv_dynstmt.arr, csBatchId);
	strcat((char*)hv_dynstmt.arr, "'");
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));


	EXEC SQL PREPARE PS FROM :hv_dynstmt;
	EXEC SQL EXECUTE PS;

	FREE_ME(csBuf);

DEBUGLOG(("UpdateStatus Normal Exit\n"));
        return PD_OK;

updatestatus_error:
DEBUGLOG(("updatestatus_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("PayoutHeader_Update: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_INTERNAL_ERR;
}



int GetPayoutHeader(const char* csMerchId, const char *csTxnDate, recordset_t* myRec)
{
	hash_t *myHash;
	EXEC SQL WHENEVER SQLERROR GOTO getpayout_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_txn_date[PD_DATE_LEN];
	
		varchar         v_batch_id[PD_SEQ_NUM_LEN+1];
		varchar		v_checksum[PD_CHECKSUM_LEN+1];
		char		v_status;
		int		v_num_of_record;

		short           ind_batch_id = -1;
		short		ind_status = -1;
		short		ind_checksum = -1;
		short		ind_num_of_record = -1;

	EXEC SQL END DECLARE SECTION;

	hv_txn_date.len = strlen(csTxnDate);
	memcpy(hv_txn_date.arr,csTxnDate,hv_txn_date.len);
DEBUGLOG(("GetTxnHeader txn_date = [%.*s]\n",hv_txn_date.len,hv_txn_date.arr));

	hv_merchant_id.len = strlen(csMerchId);
	memcpy(hv_merchant_id.arr,csMerchId,hv_merchant_id.len);
DEBUGLOG(("GetTxnHeader merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	EXEC SQL DECLARE c_cursor_getpayout CURSOR FOR
		select	batch_id,
			checksum,
			status,
			num_of_record
		from	payout_header
		where	merchant_id =:hv_merchant_id
		AND	txn_date =:hv_txn_date;

	EXEC SQL OPEN  c_cursor_getpayout;
	do{
		EXEC SQL FETCH c_cursor_getpayout
		INTO
			:v_batch_id:ind_batch_id,
			:v_checksum:ind_checksum,
			:v_status:ind_status,
			:v_num_of_record:ind_num_of_record;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash,0);

/*batch_id*/
	if(ind_batch_id>=0){
		PutField_CString(myHash,"batch_id",(const char*)v_batch_id.arr);
DEBUGLOG(("GetPayoutHeader batch_id=[%s]\n",v_batch_id.arr));
	}

/*checksum*/
	if(ind_checksum>=0){
		PutField_CString(myHash,"checksum",(const char*)v_checksum.arr);
DEBUGLOG(("GetPayoutHeader checksum = [%s]\n",v_checksum.arr));
	}

/*status*/
	if(ind_status>=0){
		PutField_Char(myHash,"status",v_status);
DEBUGLOG(("GetPayoutHeader status= [%c]\n",v_status));
	}

/*num_of_record*/
	if(ind_num_of_record>=0){
		PutField_Int(myHash,"num_of_record",v_num_of_record);
DEBUGLOG(("GetPayoutHeader num_of_record = [%d]\n",v_num_of_record));
	}

		RecordSet_Add(myRec,myHash);

	}while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getpayout;

DEBUGLOG(("GetPayoutHeader Normal Exit\n"));
	return  PD_OK;

getpayout_error:
DEBUGLOG(("getpayout_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("PayoutHeader_Get: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getpayout;
	return PD_ERR;

}

