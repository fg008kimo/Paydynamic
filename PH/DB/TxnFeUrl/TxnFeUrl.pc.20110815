/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2010/02/21              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "TxnFeUrl.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void TxnFeUrl(char    cdebug)
{
        cDebug = cdebug;
}


int GetFeUrl(const char* csTxnCode,
                const char* csServiceCode,
                const char* csTxnCountry,
                const char* csLanguage,
                char cDirection ,recordset_t* myRec)
{
	int iRet = PD_ERR;
	char csURL[PD_TMP_BUF_LEN + 1];
                
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO geturl_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_txn_code[PD_TXN_CODE_LEN];
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];
		varchar         hv_country[PD_COUNTRY_LEN];
		varchar         hv_language[PD_LANGUAGE_LEN];
                char        	hv_direction;
		char		hv_disabled;
                
                varchar         v_method[PD_METHOD_LEN + 1];
                varchar         v_path[PD_VALUE_LEN + 1];
                varchar         v_url[PD_VALUE_LEN + 1];

                short           ind_method = -1;
                short           ind_path = -1;
                short           ind_url = -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_txn_code.len = strlen(csTxnCode);
        memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
DEBUGLOG(("GetFeUrl txn_code = [%.*s]\n",hv_txn_code.len,hv_txn_code.arr));
        
        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("GetFeUrl service_code= [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_country.len = strlen(csTxnCountry);
        memcpy(hv_country.arr,csTxnCountry,hv_country.len);
DEBUGLOG(("GetFeUrl country = [%.*s]\n",hv_country.len,hv_country.arr));

	hv_language.len = strlen(csLanguage);
        memcpy(hv_language.arr,csLanguage,hv_language.len);
DEBUGLOG(("GetFeUrl language = [%.*s]\n",hv_language.len,hv_language.arr));

	hv_direction = cDirection;
DEBUGLOG(("GetFeUrl direction= [%c]\n",hv_direction));

	hv_disabled='0';

        EXEC SQL DECLARE c_cursor_geturl CURSOR FOR
                select	a.method,
			a.path,
			b.url
		from	txn_fe_url a,
			service b
		where	a.txn_code = :hv_txn_code
		and	a.service_code = :hv_service_code
		and	a.service_code = b.code
		and     b.txn_country=:hv_country
		and     a.language=:hv_language
		and	a.direction = :hv_direction
		and	a.disabled = :hv_disabled
		and	b.disabled = :hv_disabled
		AND   	b.effect_date  =
                        (SELECT max(effect_date)
                           FROM service
                          WHERE code=:hv_service_code
			  and   txn_country=:hv_country
                            AND disabled=:hv_disabled
                            AND effect_date <= sysdate)
                AND   	a.effect_date  =
                        (SELECT max(effect_date)
                           FROM txn_fe_url
                          WHERE txn_code=:hv_txn_code
                            AND service_code=:hv_service_code
			    AND direction = :hv_direction
                            AND disabled=:hv_disabled
			    AND language=:hv_language
                            AND effect_date <= sysdate);


        EXEC SQL OPEN c_cursor_geturl;
        do {
                EXEC SQL FETCH c_cursor_geturl
                INTO
                        :v_method:ind_method,
			:v_path:ind_path,
			:v_url:ind_url;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);
/* method */
                if (ind_method >= 0) {
                        v_method.arr[v_method.len] = '\0';
                        PutField_CString(myHash,"method",v_method.arr);
DEBUGLOG(("GetFeUrl method = [%s]\n",v_method.arr));
                }

		if (ind_url >= 0) {
                        v_url.arr[v_url.len] = '\0';
                        strcpy(csURL,v_url.arr);
DEBUGLOG(("URL = [%s]\n",csURL));
                        if (ind_path >= 0) {
                                v_path.arr[v_path.len] = '\0';
DEBUGLOG(("PATH = [%.*s]\n",v_path.len,v_path.arr));
                                strcat((char*)csURL,v_path.arr);
DEBUGLOG(("URL+PATH = [%s]\n",csURL));

				PutField_CString(myHash,"fe_url",csURL);
DEBUGLOG(("GetFeUrl fe_url = [%s]\n",csURL));
				iRet = PD_OK;
			}
			else
DEBUGLOG(("PATH NOT FOUND\n"));
                }
		else
DEBUGLOG(("URL NOT FOUND\n"));


                RecordSet_Add(myRec,myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_geturl;
	
	
DEBUGLOG(("GetFeUrl Normal Exit [%d]\n",iRet));

	return iRet;

geturl_error:
DEBUGLOG(("geturl_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_geturl;
        return PD_ERR;
}


