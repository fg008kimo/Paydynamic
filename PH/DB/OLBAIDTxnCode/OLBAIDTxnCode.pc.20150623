/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/02/19              Stan Poon
Add CheckDefaultBaidTxnCode                        2015/01/27              Elvis Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "OLBAIDTxnCode.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char cDebug;

void OLBAIDTxnCode(char cdebug)
{
	cDebug = cdebug;
}


int GetDetail(const char* csTxnCode, const char* csBankAcctType, hash_t* myHash)
{
	int iRet = PD_FOUND;
	int iCnt = 0;

	EXEC SQL WHENEVER SQLERROR GOTO getkeywords_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_txn_code[PD_TXN_CODE_LEN];
		varchar	hv_bank_acct_type[PD_ACCT_TYPE_LEN];
		int	v_voidable;
		varchar	v_amt_type[PD_AMT_TYPE_LEN + 1];
		int	v_full_match;
		int	v_hold_credit_side;
		int	v_real_time_post;
		int	v_update_bal;
		varchar	v_void_code[PD_TXN_CODE_LEN + 1];

		short ind_txn_code = -1;
		short ind_bank_acct_type = -1;
		short ind_voidable = -1;
		short ind_amt_type = -1;
		short ind_full_match = -1;
		short ind_hold_credit_side = -1;
		short ind_real_time_post = -1;
		short ind_update_bal = -1;
		short ind_void_code = -1;
	EXEC SQL END DECLARE SECTION;

	hv_txn_code.len = strlen(csTxnCode);
	strncpy((char*)hv_txn_code.arr, csTxnCode, hv_txn_code.len);
	ind_txn_code = 0;
DEBUGLOG(("GetDetail format_txn_code = [%.*s]\n", hv_txn_code.len, hv_txn_code.arr));

	hv_bank_acct_type.len = strlen(csBankAcctType);
	strncpy((char*)hv_bank_acct_type.arr, csBankAcctType, hv_bank_acct_type.len);
	ind_bank_acct_type = 0;
DEBUGLOG(("GetDetail format_bank_acct_type = [%.*s]\n", hv_bank_acct_type.len, hv_bank_acct_type.arr));

	EXEC SQL DECLARE getdetailcursor CURSOR FOR
		SELECT	OBTC_VOIDABLE,
			OBTC_AMT_TYPE,
			OBTC_VOID_CODE,
			OBTM_FULL_MATCH,
			OBTM_HOLD_CREDIT_SIDE,
			OBTM_REAL_TIME_POST,
			OBTM_UPDATE_BAL
		FROM	OL_BAID_TXN_CODE,
			OL_BAID_TXN_CODE_MAPPING
		WHERE	OBTC_CODE = :hv_txn_code:ind_txn_code
		AND	OBTC_CODE = OBTM_CODE
		AND	OBTM_BANK_ACCT_TYPE = :hv_bank_acct_type:ind_bank_acct_type;

	EXEC SQL OPEN getdetailcursor;
	for (;;) {
		EXEC SQL FETCH getdetailcursor
		INTO	:v_voidable:ind_voidable,
			:v_amt_type:ind_amt_type,
			:v_void_code:ind_void_code,
			:v_full_match:ind_full_match,
			:v_hold_credit_side:ind_hold_credit_side,
			:v_real_time_post:ind_real_time_post,
			:v_update_bal:ind_update_bal;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

/* voidable */
		if (ind_voidable >= 0) {
			PutField_Int(myHash, "voidable", v_voidable);
DEBUGLOG(("GetDetail voidable = [%d]\n",v_voidable));
		}
/* amt_type */
		if (ind_amt_type >= 0) {
			v_amt_type.arr[v_amt_type.len] = '\0';
			PutField_CString(myHash, "amt_type", (char*)v_amt_type.arr);
DEBUGLOG(("GetDetail amt_type = [%s]\n",v_amt_type.arr));
		}
/* void_code */
		if (ind_void_code >= 0) {
			v_void_code.arr[v_void_code.len] = '\0';
			PutField_CString(myHash, "void_code", (char*)v_void_code.arr);
DEBUGLOG(("GetDetail void_code = [%s]\n",v_void_code.arr));
		}
/* full_match */
		if (ind_full_match >= 0) {
			PutField_Int(myHash, "full_match", v_full_match);
DEBUGLOG(("GetDetail full_match = [%d]\n",v_full_match));
		}
/* hold_credit_side */
		if (ind_hold_credit_side >= 0) {
			PutField_Int(myHash, "hold_credit_side", v_hold_credit_side);
DEBUGLOG(("GetDetail hold_credit_side = [%d]\n",v_hold_credit_side));
		}
/* real_time_post */
		if (ind_real_time_post >= 0) {
			PutField_Int(myHash, "real_time_post", v_real_time_post);
DEBUGLOG(("GetDetail real_time_post = [%d]\n",v_real_time_post));
		}
/* update_bal */
		if (ind_update_bal >= 0) {
			PutField_Int(myHash, "update_bal", v_update_bal);
DEBUGLOG(("GetDetail update_bal = [%d]\n", v_update_bal));
		}

		break;

	}
	EXEC SQL CLOSE getdetailcursor;

	if (iCnt > 0) {
		iRet = PD_FOUND;
DEBUGLOG(("GetDetail FOUND\n"));
	} else {
		iRet = PD_NOT_FOUND;
DEBUGLOG(("GetDetail NOT FOUND!!!\n"));
	}

DEBUGLOG(("GetDetail Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getkeywords_error:
DEBUGLOG(("getkeywords_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBAIDTxnCode getkeywords_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE getdetailcursor;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int IsVoidable(const unsigned char* csTxnCode)
{
	int iRet = PD_FALSE;

	EXEC SQL WHENEVER SQLERROR GOTO is_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_txn_code[PD_TXN_CODE_LEN];

		int v_voidable;

		short ind_voidable = -1;
	EXEC SQL END DECLARE SECTION;

	hv_txn_code.len = strlen((const char*)csTxnCode);
	memcpy(hv_txn_code.arr, csTxnCode, hv_txn_code.len);
DEBUGLOG(("IsVoidable: csTxnCode = [%.*s]\n", hv_txn_code.len, hv_txn_code.arr));

	EXEC SQL SELECT obtc_voidable
			INTO :v_voidable:ind_voidable
			FROM ol_baid_txn_code
			WHERE obtc_code = :hv_txn_code
			AND ROWNUM <= 1;

	if (ind_voidable >= 0) {
DEBUGLOG(("Voidable = [%d]\n", v_voidable));
		if (v_voidable == PD_TRUE) {
			iRet = PD_TRUE;
		}
	} else{
DEBUGLOG(("Record Not Found [%s]\n", csTxnCode));
	}

DEBUGLOG(("IsVoidable iRet = [%d]\n", iRet));
	return iRet;

is_error:
DEBUGLOG(("is_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int GetBAIDTxnCodeDtl(const char* csTxnCode, hash_t* myHash)
{
	int iRet = PD_FOUND;
	int iCnt = 0;

	EXEC SQL WHENEVER SQLERROR GOTO gettxncodedtl_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_txn_code[PD_TXN_CODE_LEN];
		short	ind_txn_code = -1;

		int     v_voidable;
		varchar v_amt_type[PD_AMT_TYPE_LEN + 1];
		varchar v_void_code[PD_TXN_CODE_LEN + 1];

		short ind_voidable = -1;
		short ind_amt_type = -1;
		short ind_void_code = -1;
	EXEC SQL END DECLARE SECTION;

	hv_txn_code.len = strlen(csTxnCode);
	strncpy((char*)hv_txn_code.arr, csTxnCode, hv_txn_code.len);
        ind_txn_code = 0;
DEBUGLOG(("GetBAIDTxnCodeDtl txn_code = [%.*s]\n", hv_txn_code.len, hv_txn_code.arr));

       EXEC SQL DECLARE getBAIDTxnCodeDtlcursor CURSOR FOR
                SELECT  OBTC_VOIDABLE,
                        OBTC_AMT_TYPE,
                        OBTC_VOID_CODE
                FROM    OL_BAID_TXN_CODE
                WHERE   OBTC_CODE = :hv_txn_code:ind_txn_code;


	EXEC SQL OPEN getBAIDTxnCodeDtlcursor;
        for (;;) {
		EXEC SQL FETCH getBAIDTxnCodeDtlcursor
		INTO	:v_voidable:ind_voidable,
			:v_amt_type:ind_amt_type,
			:v_void_code:ind_void_code;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		iCnt++;

/* voidable */
                if (ind_voidable >= 0) {
                        PutField_Int(myHash, "voidable", v_voidable);
DEBUGLOG(("GetBAIDTxnCodeDtl voidable = [%d]\n",v_voidable));
                }

/* amt_type */
                if (ind_amt_type >= 0) {
                        v_amt_type.arr[v_amt_type.len] = '\0';
                        PutField_CString(myHash, "amt_type", (char*)v_amt_type.arr);
DEBUGLOG(("GetBAIDTxnCodeDtl amt_type = [%s]\n",v_amt_type.arr));
		}

/* void_code */
                if (ind_void_code >= 0) {
                        v_void_code.arr[v_void_code.len] = '\0';
                        PutField_CString(myHash, "void_code", (char*)v_void_code.arr);
DEBUGLOG(("GetBAIDTxnCodeDtl void_code = [%s]\n",v_void_code.arr));
                }

		break;
	}
	EXEC SQL CLOSE getBAIDTxnCodeDtlcursor;

	if (iCnt > 0) {
		iRet = PD_FOUND;
DEBUGLOG(("GetBAIDTxnCodeDtl FOUND\n"));
	} else {
		iRet = PD_NOT_FOUND;
DEBUGLOG(("GetBAIDTxnCodeDtl NOT FOUND!!!\n"));
	}

DEBUGLOG(("GetBAIDTxnCodeDtl Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

gettxncodedtl_error:
DEBUGLOG(("gettxncodedtl_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBAIDTxnCode gettxncodedtl_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL CLOSE getBAIDTxnCodeDtlcursor;
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;

}
		
int CheckDefaultBaidTxnCode(hash_t* hRls)
{
        int iRet = PD_OK;

        int iCnt = 0;

        char *csTmp;

        EXEC SQL WHENEVER SQLERROR GOTO checkdefaultbaidtxncode_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_txn_id[PD_TXN_SEQ_LEN];

                varchar v_default_code[PD_TXN_CODE_LEN + 1];
                varchar v_amt_type[PD_AMT_TYPE_LEN + 1];

                short ind_default_code = -1;
                short ind_amt_type = -1;
        EXEC SQL END DECLARE SECTION;

/* txn_id */
        if (GetField_CString(hRls, "txn_id", &csTmp)) {
                hv_txn_id.len = strlen(csTmp);
                strncpy((char*)hv_txn_id.arr, csTmp, sizeof(hv_txn_id.arr));
DEBUGLOG(("CheckDefaultBaidTxnCode txn_id = [%.*s]\n", sizeof(hv_txn_id.arr), (const char*)hv_txn_id.arr));
        } else {
DEBUGLOG(("CheckDefaultBaidTxnCode txn_id not found!\n"));
                iRet = PD_ERR;
        }

	EXEC SQL DECLARE c_checkdefaultbaidtxncode CURSOR FOR
                SELECT  OBTC.OBTC_DEFAULT_CODE,
                        OBTC.OBTC_AMT_TYPE
                FROM    OL_BAID_TXN OBT,
                        OL_BAID_TXN_CODE OBTC,
                        OL_PSP_DETAIL OPD
                WHERE   OBT.OBT_TXN_ID = :hv_txn_id
			//AND   OBT.OBT_STATUS = 'C'
                	//AND   OBT.OBT_AR_IND = 'A'
                AND     OBTC.OBTC_CODE = OBT.OBT_TXN_CODE
                AND     OPD.OPD_PSP_ID = OBT.OBT_PID
                AND     OPD.OPD_DISABLED = 0;

	if (iRet == PD_OK) {
                EXEC SQL OPEN c_checkdefaultbaidtxncode;

                for (;;) {
                        EXEC SQL FETCH c_checkdefaultbaidtxncode
                        INTO    :v_default_code:ind_default_code,
                                :v_amt_type:ind_amt_type;

                        if (SQLCODE == SQL_NOT_FOUND) {
                                break;
                        }

                        iCnt++;
	
// default_code
		if (ind_default_code >= 0) {
                                v_default_code.arr[v_default_code.len] = '\0';
                                PutField_CString(hRls, "default_code", (const char*)v_default_code.arr);
DEBUGLOG(("CheckDefaultBaidTxnCode default_code = [%s]\n", (const char*)v_default_code.arr));
                        }

// amt_type
                        if (ind_amt_type >= 0) {
                                v_amt_type.arr[v_amt_type.len] = '\0';
                                PutField_CString(hRls, "amt_type", (const char*)v_amt_type.arr);
DEBUGLOG(("CheckDefaultBaidTxnCode amt_type = [%s]\n", (const char*)v_amt_type.arr));
                        }

                        break;
                }

                EXEC SQL CLOSE c_checkdefaultbaidtxncode;
        }

        if (iCnt > 0) {
                iRet = PD_OK;
        } else {
                iRet = PD_ERR;
        }

DEBUGLOG(("CheckDefaultBaidTxnCode Normal Exit! iRet = [%d]\n", iRet));
        return iRet;

checkdefaultbaidtxncode_error:
DEBUGLOG(("checkdefaultbaidtxncode_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLStmtMatchEngine checkdefaultbaidtxncode_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_checkdefaultbaidtxncode;
        return PD_ERR;
}

