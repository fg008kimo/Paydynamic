/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/01/04              LokMan Chow
Get ID Detail					   2012/01/09		   Cody Chan
FindMostUpdatedSchedule
	by 1. max effective datetime
	   2. max update timestamp		   2016/10/19		   LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "RuleSchedulerHeader.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;
void RuleSchedulerHeader(char    cdebug)
{
        cDebug = cdebug;
}


int GetIdDetail(int iId, recordset_t* myRec)
{
	hash_t *myHash;
	int	iRet = PD_NOT_FOUND;
	EXEC SQL WHENEVER SQLERROR GOTO getiddetail_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;	

	EXEC SQL BEGIN DECLARE SECTION;
		int	hv_id;
		
		char	v_schedule_mode;
		varchar	v_start_datetime[PD_DATETIME_LEN + 1];
		varchar	v_end_datetime[PD_DATETIME_LEN + 1];
		varchar	v_start_time[PD_TIME_LEN +1];
		varchar	v_end_time[PD_TIME_LEN +1];
		int	v_day;
		varchar	v_effect_datetime[PD_DATETIME_LEN + 1];

		short	ind_schedule_mode = -1;
		short	ind_start_datetime = -1;
		short	ind_end_datetime = -1;
		short	ind_start_time = -1;
		short	ind_end_time = -1;
		short	ind_day = -1;
		short	ind_effect_datetime = -1;

		

	EXEC SQL END DECLARE SECTION;

	hv_id = iId;
DEBUGLOG(("GetIdDetail id = [%d]\n",iId));

	EXEC SQL DECLARE c_cursor_getiddetail CURSOR FOR
		 SELECT rs_schedule_mode,
                        ro_start_datetime,
                        ro_end_datetime,
                        rt_start_time,
                        rt_end_time,
                        rt_day,
			to_char(rs_effect_datetime,'YYYYMMDDHH24MISS')
 		  FROM (SELECT *
           		  FROM  rule_scheduler_header 
          		 WHERE rowid = 
           			(SELECT rowid
                    		   FROM rule_scheduler_header
                          	  WHERE rs_disabled = 0
                            	    AND rs_scheduler_id = :hv_id
                          	    AND rs_effect_datetime  <= sysdate) )
                  LEFT join rule_schedule_once
                     ON rs_scheduler_id = ro_scheduler_id
                    AND ro_disabled = 0
                  LEFT join rule_schedule_recur
                     ON rs_scheduler_id = rr_scheduler_id
                    AND rr_disabled = 0
                  LEFT join rule_recur_type
                     ON rr_recurring_id = rt_id
                    AND rt_disabled = 0;

	EXEC SQL OPEN c_cursor_getiddetail;
        do {
		EXEC SQL FETCH c_cursor_getiddetail 
		INTO
			:v_schedule_mode:ind_schedule_mode,
			:v_start_datetime:ind_start_datetime,
			:v_end_datetime:ind_end_datetime,
			:v_start_time:ind_start_time,
			:v_end_time:ind_end_time,
			:v_day:ind_day,
			:v_effect_datetime:ind_effect_datetime;


		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		iRet = PD_FOUND;

		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* schedule_mode */
		if (ind_schedule_mode >= 0) {
DEBUGLOG(("GetIdDetail schedule_mode = [%c]\n",v_schedule_mode));
			PutField_Char(myHash,"schedule_mode",v_schedule_mode);
		}		

/* start_datetime */
		if (ind_start_datetime >= 0) {
			v_start_datetime.arr[v_start_datetime.len] = '\0';
DEBUGLOG(("GetIdDetail start_datetime = [%s]\n",v_start_datetime.arr));
			PutField_CString(myHash,"start_datetime",(char*)v_start_datetime.arr);
		}		
/* end_datetime */
		if (ind_end_datetime >= 0) {
			v_end_datetime.arr[v_end_datetime.len] = '\0';
DEBUGLOG(("GetIdDetail end_datetime = [%s]\n",v_end_datetime.arr));
			PutField_CString(myHash,"end_datetime",(char*)v_end_datetime.arr);
		}		

/* start_time */
                if (ind_start_time >= 0) {
                        v_start_time.arr[v_start_time.len] = '\0';
DEBUGLOG(("GetIdDetail start_time = [%s]\n",v_start_time.arr));
                        PutField_CString(myHash,"start_time",(char*)v_start_time.arr);
                }
/* end_time */
                if (ind_end_time >= 0) {
                        v_end_time.arr[v_end_time.len] = '\0';
DEBUGLOG(("GetIdDetail end_time = [%s]\n",v_end_time.arr));
                        PutField_CString(myHash,"end_time",(char*)v_end_time.arr);
                }
/* day */
		if (ind_day >= 0) {
DEBUGLOG(("GetIdDetail day = [%d]\n",v_day));
			PutField_Int(myHash,"day",v_day);
		}

/* effect_datetime */
		if (ind_effect_datetime >= 0) {
			v_effect_datetime.arr[v_effect_datetime.len] = '\0';
DEBUGLOG(("GetIdDetail effect_datetime = [%s]\n",v_effect_datetime.arr));
			PutField_CString(myHash,"effect_datetime",(char*)v_effect_datetime.arr);
		}		


		RecordSet_Add(myRec,myHash);

	} 
	while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getiddetail;
	return PD_FOUND;
getiddetail_error:
DEBUGLOG(("getiddetail code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getiddetail;
        return PD_NOT_FOUND;
}





int FindMostUpdatedSchedule(hash_t* hRls)
{
	int	iRet = PD_NOT_FOUND;
	char*   csBuf;
        char*   csIdList;
	int	iCnt = 0;
	int	iTmp= 0;

	EXEC SQL WHENEVER SQLERROR GOTO mostupdsch_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;	

	EXEC SQL BEGIN DECLARE SECTION;
	
		varchar hv_dynstmt[1024*4];	
		int	v_result_id;

		short	ind_result_id= -1;

	EXEC SQL END DECLARE SECTION;

	csBuf = (char*) malloc (128);
	csIdList = (char*) malloc (1024);
	csBuf[0] = '\0';
	csIdList[0] = '\0';


        if (GetField_Int(hRls,"id_cnt",&iCnt)) {
DEBUGLOG(("FindMostUpdatedSchedule: id_cnt = [%d]\n",iCnt));
                int i = 0;
                char    csTag[PD_TAG_LEN +1];
                for (i = 1; i <= iCnt; i++) {
                        sprintf(csTag,"id_%d",i);
                        if (GetField_Int(hRls,csTag,&iTmp)) {
DEBUGLOG(("FindMostUpdatedSchedule: [%s] = [%d]\n",csTag,iTmp));
                                if (i == 1)
                                        sprintf(csBuf,"%d",iTmp);
                                else
                                        sprintf(csBuf,",%d",iTmp);
                                strcat(csIdList,csBuf);
                        }
                }
        }
	
/*
select rs_scheduler_id
from(select rs_scheduler_id
     from rule_scheduler_header
     where rs_scheduler_id in (id_1, id_2, ..., id_n)
     and rs_disabled =0
     and rs_effect_datetime = (
			select max(rs_effect_datetime)
			from rule_scheduler_header
			where rs_scheduler_id in (id_1, id_2, ..., id_n)
			and rs_disabled =0)
     order by rs_update_timestamp desc)
where rownum =1;
*/

        strcpy((char*)hv_dynstmt.arr,"select rs_scheduler_id from ( ");
        strcat((char*)hv_dynstmt.arr,"select rs_scheduler_id from rule_scheduler_header ");
	strcat((char*)hv_dynstmt.arr,"where rs_disabled = 0 ");
        strcat((char*)hv_dynstmt.arr,"and rs_scheduler_id in ( ");
        strcat((char*)hv_dynstmt.arr,csIdList);
        strcat((char*)hv_dynstmt.arr," ) ");
        strcat((char*)hv_dynstmt.arr,"and rs_effect_datetime = ( ");
        strcat((char*)hv_dynstmt.arr,"select max(rs_effect_datetime) from rule_scheduler_header ");
	strcat((char*)hv_dynstmt.arr,"where rs_disabled = 0 ");
        strcat((char*)hv_dynstmt.arr,"and rs_scheduler_id in ( ");
        strcat((char*)hv_dynstmt.arr,csIdList);
        strcat((char*)hv_dynstmt.arr," )");
        strcat((char*)hv_dynstmt.arr,")");
        strcat((char*)hv_dynstmt.arr," order by rs_update_timestamp desc) where rownum = 1");

        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL DECLARE c_cursor_mostupdsch CURSOR FOR PS;
        FREE_ME(csBuf);
        FREE_ME(csIdList);

        EXEC SQL OPEN c_cursor_mostupdsch;
        do {
                EXEC SQL FETCH c_cursor_mostupdsch
                INTO
                        :v_result_id:ind_result_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if(ind_result_id >= 0){
			PutField_Int(hRls,"result_id",v_result_id);
DEBUGLOG(("The Most updated Schedule = [%d]\n",v_result_id));
			iRet = PD_FOUND;
		}
        }
        while (PD_TRUE);

        EXEC SQL CLOSE c_cursor_mostupdsch;
DEBUGLOG(("FindMostUpdatedSchedule iRet = [%d]\n",iRet));
        return iRet;

mostupdsch_error:
DEBUGLOG(("mostupdsch code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_mostupdsch;
        return PD_ERR;
}
