/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2018/07/10              Elvis Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "internal.h"
#include "OLAutoUploadJobTmp.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

static char    cDebug;


void OLAutoUploadJobTmp(char    cdebug)
{
        cDebug = cdebug;
}

int Add(int iJobSeq)
{
        EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
                int     	hv_seq;
                char    	hv_status;
		varchar         hv_create_user[PD_USER_LEN];	
	
		short           ind_seq = -1;
		short           ind_status = -1;
		short           ind_create_user = -1;

		short           hv_return_value;
        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

	hv_seq = iJobSeq;
	ind_seq = 0;
DEBUGLOG(("Add hv_seq [%d]\n",iJobSeq));

        hv_status = PD_AUTO_UPL_JOB_STATUS_PENDING;
	ind_status = 0;
DEBUGLOG(("Add hv_status [%c]\n",hv_status));
	
	hv_create_user.len = strlen(PD_UPDATE_USER);
       	strncpy((char *)hv_create_user.arr, PD_UPDATE_USER, hv_create_user.len);
       	ind_create_user = 0;
DEBUGLOG(("Add hv_create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));

	EXEC SQL EXECUTE
                BEGIN

                :hv_return_value := sp_ol_auto_upl_job_tmp_ins(
                                        :hv_seq:ind_seq,
                                        :hv_status:ind_status,
                                        :hv_create_user:ind_create_user);

                 END;
        END-EXEC;

	DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
                DEBUGLOG(("Add:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
                ERRLOG("OLAutoUploadJobStatus_Add: SP_OTHER_ERR TxnAbort\n");
                DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
                ERRLOG("OLAutoUploadJobStatus_Add: SP_ERR TxnAbort\n");
                DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
                return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLAutoUploadJobStatus_Add: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int Delete(int iJobSeq)
{
        EXEC SQL WHENEVER SQLERROR GOTO delete_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		int     hv_seq;

                short   hv_return_value;
        EXEC SQL END DECLARE SECTION;

	hv_seq = iJobSeq;
DEBUGLOG(("Delete hv_seq [%d]\n",iJobSeq));

        EXEC SQL EXECUTE
            BEGIN

                :hv_return_value := sp_ol_auto_upl_job_tmp_del(
                                :hv_seq);

            END;
        END-EXEC;

DEBUGLOG(("Delete:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
DEBUGLOG(("Delete:Normal Exit\n"));
                return PD_OK;
        }
        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("OLAutoUploadJobTmp_Delete: SP_OTHER_ERR\n");
DEBUGLOG(("Delete: SP_OTHER_ERR\n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("OLAutoUploadJobTmp_Delete: SP_ERR\n");
DEBUGLOG(("Delete: SP_ERR\n"));
                return PD_ERR;
        }
delete_error:
DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("POLAutoUploadJobTmp_Delete: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int LockJobTmpStatus(int iJobSeq)
{
        int iRet = PD_ERR;

        EXEC SQL WHENEVER SQLERROR GOTO lockjobtmpstatus_err;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                int     hv_seq;
                char    v_status;
                short   ind_status = -1;
        EXEC SQL END DECLARE SECTION;

        hv_seq = iJobSeq;
DEBUGLOG(("LockJobTmpStatus hv_seq [%d]\n",iJobSeq));

        EXEC SQL SELECT OAUJT_STATUS
                   INTO :v_status:ind_status
                 FROM OL_AUTO_UPLOAD_JOB_TMP
                 WHERE OAUJT_JOB_SEQ = :hv_seq
                 FOR UPDATE;

        if (ind_status >= 0) {
                if (v_status == PD_AUTO_UPL_JOB_STATUS_PENDING) {
                        iRet = PD_OK;
                }
        }

        if (iRet == PD_OK) {
DEBUGLOG(("LockJobTmpStatus SUCCESS\n"));
        } else {
DEBUGLOG(("LockJobTmpStatus FAILURE\n"));
        }

        return iRet;

lockjobtmpstatus_err:
DEBUGLOG(("lockjobtmpstatus_err code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_ERR;
}
