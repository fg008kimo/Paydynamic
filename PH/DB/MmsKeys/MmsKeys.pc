/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/10/11              Virginia Yun
Change to/as merchant key struct		   2015/06/03		   Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MmsKeys.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MmsKeys(char    cdebug)
{
        cDebug = cdebug;
}

int GetMmsKey(const unsigned char *csNodeId,
		const unsigned char* csKeyName,
              hash_t *myHash)
{

        int iRet = PD_FOUND;


        EXEC SQL WHENEVER SQLERROR GOTO getmmskey_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar         hv_node_id[PD_MMS_NODE_ID_LEN];
                varchar         hv_key_name[PD_KEY_NAME_LEN];
                int             hv_disabled;

                varchar         v_mms_key[PD_MD5_KEY_LEN + 1];
                short           ind_mms_key = -1;

        EXEC SQL END DECLARE SECTION;

        hv_node_id.len = strlen((const char*)csNodeId);
        memcpy(hv_node_id.arr, csNodeId, hv_node_id.len);
DEBUGLOG(("GetMmsKey node_id = [%d][%.*s]\n",hv_node_id.len,hv_node_id.len,hv_node_id.arr));

        hv_key_name.len = strlen((const char*)csKeyName);
        memcpy(hv_key_name.arr, csKeyName, hv_key_name.len);
DEBUGLOG(("GetMmsKey key_name = [%d][%.*s]\n",hv_key_name.len,hv_key_name.len,hv_key_name.arr));

        hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getmmskey CURSOR FOR
                SELECT mk_key_value
                  FROM mms_keys
                 WHERE mk_node_id = :hv_node_id
		   AND mk_key = :hv_key_name
                   AND mk_disabled = :hv_disabled
                   AND mk_effect_date = 
                           (SELECT max(mk_effect_date)
                              FROM mms_keys
                             WHERE mk_node_id = :hv_node_id
			       AND mk_key = :hv_key_name
                               AND mk_disabled = :hv_disabled
                               AND mk_effect_date <= sysdate);


        EXEC SQL OPEN c_cursor_getmmskey;
        do{
                EXEC SQL FETCH c_cursor_getmmskey
                INTO
                        :v_mms_key:ind_mms_key; 

                if (SQLCODE == SQL_NOT_FOUND) {
                        iRet = PD_NOT_FOUND; //expected as at least 1 record
                        break;
                } 

                
                // MMS Key 
                if (ind_mms_key >= 0) {
                        v_mms_key.arr[v_mms_key.len] = '\0';
                        PutField_CString(myHash, "mms_key", (const char*)v_mms_key.arr); 
DEBUGLOG(("GetMmsKey mms_key = [%s]\n", v_mms_key.arr));
                } 
               
                break; //*************** only one now

        }while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getmmskey;

DEBUGLOG(("GetMmsKey Normal Exit iRet = [%d]\n",iRet));
     
        return iRet;


getmmskey_error:
DEBUGLOG(("getmmskey_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));

        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getmmskey;

        return PD_ERR;

}

