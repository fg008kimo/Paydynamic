/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/10/11              Virginia Yun
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MmsKeys.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MmsKeys(char    cdebug)
{
        cDebug = cdebug;
}

int GetMmsKey(const unsigned char *csNodeId,
              recordset_t *myRec)
{

        int iRet = PD_OK;

        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getmmskey_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar         hv_node_id[PD_MMS_NODE_ID_LEN];
                int             hv_disabled;

                varchar         v_mms_key[PD_MMS_KEY_LEN + 1];
                short           ind_mms_key = -1;

        EXEC SQL END DECLARE SECTION;

        hv_node_id.len = strlen(csNodeId);
        memcpy(hv_node_id.arr, csNodeId, hv_node_id.len);

DEBUGLOG(("GetMmsKey node_id = [%d][%.*s]\n",hv_node_id.len,hv_node_id.len,hv_node_id.arr));

        hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getmmskey CURSOR FOR
                SELECT mk_key
                  FROM mms_keys
                 WHERE mk_node_id = :hv_node_id
                   AND mk_disabled = :hv_disabled
                   AND mk_effect_date = 
                           (SELECT max(mk_effect_date)
                              FROM mms_keys
                             WHERE mk_node_id = :hv_node_id
                               AND mk_disabled = :hv_disabled
                               AND mk_effect_date <= sysdate);


        EXEC SQL OPEN c_cursor_getmmskey;
        do{
                EXEC SQL FETCH c_cursor_getmmskey
                INTO
                        :v_mms_key:ind_mms_key; 

                if (SQLCODE == SQL_NOT_FOUND) {
                        iRet = SQL_NOT_FOUND; //expected as at least 1 record
                        break;
                } 

                myHash = (hash_t *)malloc (sizeof(hash_t)); 
                hash_init(myHash, 0);
                
                // MMS Key 
                if (ind_mms_key >= 0) {
                        v_mms_key.arr[v_mms_key.len] = '\0';
                        PutField_CString(myHash, "mms_key", v_mms_key.arr); 
DEBUGLOG(("GetMmsKey mms_key = [%s]\n", v_mms_key.arr));
                } 
               
                RecordSet_Add(myRec, myHash);
                break; //*************** only one now

        }while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getmmskey;

DEBUGLOG(("GetMmsKey Normal Exit\n"));
     
        return iRet;


getmmskey_error:
DEBUGLOG(("getmmskey_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));

        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getmmskey;

        return PD_ERR;

}


int GetMmsAllClientKey(recordset_t *myRec)
{

        int iRet = PD_OK;

        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getmmsclientkey_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                int             hv_disabled;
                char            hv_node_type;

                varchar         v_node_id[PD_MMS_NODE_ID_LEN + 1];
                varchar         v_mms_key[PD_MMS_KEY_LEN + 1];

                short           ind_node_id = -1;
                short           ind_mms_key = -1;

        EXEC SQL END DECLARE SECTION;


        hv_node_type = PD_MMS_CLIENT;
        hv_disabled = 0;

        EXEC SQL DECLARE c_cursor_getmmsclientkey CURSOR FOR
               SELECT mk_node_id, mk_key 
                  FROM mms_keys, mmx_nodes
                 WHERE mn_node_type = :hv_node_type
                   AND mn_node_id = mk_node_id
                   AND mk_disabled =:hv_disabled 
                   AND mk_effect_date =
                           (SELECT max(mk_effect_date)
                              FROM mms_keys
                             WHERE mk_node_id = mn_node_id
                               AND mk_disabled = :hv_disabled 
                               AND mk_effect_date <= sysdate);


        EXEC SQL OPEN c_cursor_getmmsclientkey;
        do{
                EXEC SQL FETCH c_cursor_getmmsclientkey
                INTO
                        :v_node_id:ind_node_id,
                        :v_mms_key:ind_mms_key;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t *)malloc (sizeof(hash_t));
                hash_init(myHash, 0);

                // MMS Node Id 
                if (ind_node_id >= 0) {
                        v_node_id.arr[v_node_id.len] = '\0';
                        PutField_CString(myHash, "node_id", v_node_id.arr);
DEBUGLOG(("GetMmsClientKey node_id = [%s]\n", v_node_id.arr));
                }

                // MMS Key
                if (ind_mms_key >= 0) {
                        v_mms_key.arr[v_mms_key.len] = '\0';
                        PutField_CString(myHash, "mms_key", v_mms_key.arr);
DEBUGLOG(("GetMmsClientKey mms_key = [%s]\n", v_mms_key.arr));
                }

                RecordSet_Add(myRec, myHash);

        }while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getmmsclientkey;

DEBUGLOG(("GetMmsClientKey Normal Exit\n"));

        return iRet;


getmmsclientkey_error:
DEBUGLOG(("getmmsclientkey_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));

        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getmmskey;

        return PD_ERR;

}



