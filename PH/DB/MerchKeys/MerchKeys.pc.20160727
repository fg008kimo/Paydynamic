/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/01/07              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MerchKeys.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MerchKeys(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hMerchKeys)
{
	char            *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_key_value[PD_MD5_KEY_LEN];
		varchar		hv_key[PD_KEY_NAME_LEN];
		varchar 	hv_create_user[PD_USER_LEN];
		varchar 	hv_effect_date[PD_DATE_LEN];


		short		ind_merchant_id = -1;
		short		ind_key_value = -1;
		short		ind_key = -1;
		short		ind_create_user = -1;
		short		ind_effect_date = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Add: Begin\n"));


	if(GetField_CString(hMerchKeys,"merchant_id",&csTmp))
	{
		hv_merchant_id.len = strlen(csTmp);
		strncpy((char*)hv_merchant_id.arr, csTmp, hv_merchant_id.len);
		ind_merchant_id = 0;
	}
DEBUGLOG(("Add:merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));


	if(GetField_CString(hMerchKeys,"key_value",&csTmp))
	{
		hv_key_value.len = strlen(csTmp);
		strncpy((char*)hv_key_value.arr, csTmp, hv_key_value.len);
		ind_key_value = 0;
	}
DEBUGLOG(("Add:key_value = [%.*s]\n",hv_key_value.len,hv_key_value.arr));

	if(GetField_CString(hMerchKeys,"key",&csTmp))
	{
		hv_key.len = strlen(csTmp);
		strncpy((char*)hv_key.arr, csTmp, hv_key.len);
		ind_key = 0;
	}
DEBUGLOG(("Add:key = [%.*s]\n",hv_key.len,hv_key.arr));



	if(GetField_CString(hMerchKeys,"create_user",&csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));

	if(GetField_CString(hMerchKeys,"effect_date",&csTmp))
	{
		hv_effect_date.len = strlen(csTmp);
		strncpy((char*)hv_effect_date.arr, csTmp, hv_effect_date.len);
		ind_effect_date= 0;
	}
DEBUGLOG(("Add:effect_date = [%.*s]\n",hv_effect_date.len,hv_effect_date.arr));



	FREE_ME(csTmp);


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merch_keys_insert(
				:hv_merchant_id:ind_merchant_id,
				:hv_key:ind_key,
				:hv_key_value:ind_key_value,
				:hv_create_user:ind_create_user,
				:hv_effect_date:ind_effect_date);

	    END;
	END-EXEC;


	DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("MerchKeys_Add: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("MerchKeys_Add: SP_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

add_error:
	DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;


}




int Delete(const char* merchant_id, const char* key)
{
	EXEC SQL WHENEVER SQLERROR GOTO delete_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
	        varchar	hv_key[PD_KEY_NAME_LEN];
		varchar hv_merchant_id[PD_MERCHANT_ID_LEN];

		short	hv_return_value;
	EXEC SQL END DECLARE SECTION;


	hv_key.len = strlen((const char*)key);
	memcpy(hv_key.arr,key,hv_key.len);
DEBUGLOG(("Delete: key = [%.*s]\n",hv_key.len,hv_key.arr));

	hv_merchant_id.len = strlen((const char*)merchant_id);
	memcpy(hv_merchant_id.arr,merchant_id,hv_merchant_id.len);
DEBUGLOG(("Delete: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	EXEC SQL EXECUTE
	    BEGIN
		
		:hv_return_value := sp_merch_keys_delete(
				:hv_merchant_id,
				:hv_key);

	    END;
	END-EXEC;


	DEBUGLOG(("Delete:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("Delete:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("MerchKeys_Delete: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Delete: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("MerchKeys_Delete: SP_ERR TxnAbort\n");
DEBUGLOG(("Delete: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

delete_error:
	DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;

}


int GetMerchantKey(const char* csMerchantID,const char* csKey,
                recordset_t* myRec)
{
	int iRet = 0;
                
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getmerchantkey_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_key[PD_KEY_NAME_LEN + 1];
                
		varchar		v_key_value[PD_MD5_KEY_LEN + 1];

		short		ind_key_value = -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetMerchantKey merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_key.len = strlen(csKey);
        memcpy(hv_key.arr,csKey,hv_key.len);
DEBUGLOG(("GetMerchantKey key = [%.*s]\n",hv_key.len,hv_key.arr));
        
        EXEC SQL DECLARE c_cursor_getmerchantkey CURSOR FOR
                select
		       key_value
                  from merch_keys
		 where merchant_id = :hv_merchant_id
		 and   key = :hv_key
		 AND   effect_date  =
                        (SELECT max(effect_date)
                           FROM merch_keys
                          WHERE merchant_id = :hv_merchant_id
                            AND key = :hv_key
                            AND effect_date <= to_char(sysdate,'yyyymmdd'));


        EXEC SQL OPEN c_cursor_getmerchantkey;
        do {
                EXEC SQL FETCH c_cursor_getmerchantkey
                INTO
			:v_key_value:ind_key_value;

                if (SQLCODE == SQL_NOT_FOUND) {
			iRet = SQL_NOT_FOUND;
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);


/* key */
                if (ind_key_value >= 0) {
                        v_key_value.arr[v_key_value.len] = '\0';
                        PutField_CString(myHash,"key_value",(const char*)v_key_value.arr);
DEBUGLOG(("GetMerchantKey key_value = [%s]\n",v_key_value.arr));
                }

                RecordSet_Add(myRec,myHash);
		break; //**************** only one now
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getmerchantkey;

	

DEBUGLOG(("GetMerchantKey Normal Exit\n"));
        if(iRet==0) return  PD_OK;
	else	return iRet;

getmerchantkey_error:
DEBUGLOG(("getmerchantkey_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getmerchantkey;
        return PD_ERR;
}


