/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/01/07              LokMan Chow
Add CheckAvailableForGenSTK, UpdateKey		   2016/07/27		   Dirk Wong
Modify GetMerchantKey				   2016/08/08		   Dirk Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MerchKeys.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;

void MerchKeys(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hMerchKeys)
{
	char            *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_key_value[PD_MD5_KEY_LEN];
		varchar		hv_key[PD_KEY_NAME_LEN];
		varchar 	hv_create_user[PD_USER_LEN];
		varchar 	hv_effect_date[PD_DATE_LEN];


		short		ind_merchant_id = -1;
		short		ind_key_value = -1;
		short		ind_key = -1;
		short		ind_create_user = -1;
		short		ind_effect_date = -1;
		
		short           hv_return_value;
	EXEC SQL END DECLARE SECTION;


	DEBUGLOG(("Add: Begin\n"));


	if(GetField_CString(hMerchKeys,"merchant_id",&csTmp))
	{
		hv_merchant_id.len = strlen(csTmp);
		strncpy((char*)hv_merchant_id.arr, csTmp, hv_merchant_id.len);
		ind_merchant_id = 0;
	}
DEBUGLOG(("Add:merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));


	if(GetField_CString(hMerchKeys,"key_value",&csTmp))
	{
		hv_key_value.len = strlen(csTmp);
		strncpy((char*)hv_key_value.arr, csTmp, hv_key_value.len);
		ind_key_value = 0;
	}
DEBUGLOG(("Add:key_value = [%.*s]\n",hv_key_value.len,hv_key_value.arr));

	if(GetField_CString(hMerchKeys,"key",&csTmp))
	{
		hv_key.len = strlen(csTmp);
		strncpy((char*)hv_key.arr, csTmp, hv_key.len);
		ind_key = 0;
	}
DEBUGLOG(("Add:key = [%.*s]\n",hv_key.len,hv_key.arr));



	if(GetField_CString(hMerchKeys,"create_user",&csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Add:create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));

	if(GetField_CString(hMerchKeys,"effect_date",&csTmp))
	{
		hv_effect_date.len = strlen(csTmp);
		strncpy((char*)hv_effect_date.arr, csTmp, hv_effect_date.len);
		ind_effect_date= 0;
	}
DEBUGLOG(("Add:effect_date = [%.*s]\n",hv_effect_date.len,hv_effect_date.arr));



	FREE_ME(csTmp);


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_merch_keys_insert(
				:hv_merchant_id:ind_merchant_id,
				:hv_key:ind_key,
				:hv_key_value:ind_key_value,
				:hv_create_user:ind_create_user,
				:hv_effect_date:ind_effect_date);

	    END;
	END-EXEC;


	DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Add:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("MerchKeys_Add: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("MerchKeys_Add: SP_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

add_error:
	DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;


}




int Delete(const char* merchant_id, const char* key)
{
	EXEC SQL WHENEVER SQLERROR GOTO delete_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
	        varchar	hv_key[PD_KEY_NAME_LEN];
		varchar hv_merchant_id[PD_MERCHANT_ID_LEN];

		short	hv_return_value;
	EXEC SQL END DECLARE SECTION;


	hv_key.len = strlen((const char*)key);
	memcpy(hv_key.arr,key,hv_key.len);
DEBUGLOG(("Delete: key = [%.*s]\n",hv_key.len,hv_key.arr));

	hv_merchant_id.len = strlen((const char*)merchant_id);
	memcpy(hv_merchant_id.arr,merchant_id,hv_merchant_id.len);
DEBUGLOG(("Delete: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	EXEC SQL EXECUTE
	    BEGIN
		
		:hv_return_value := sp_merch_keys_delete(
				:hv_merchant_id,
				:hv_key);

	    END;
	END-EXEC;


	DEBUGLOG(("Delete:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
DEBUGLOG(("Delete:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("MerchKeys_Delete: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Delete: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("MerchKeys_Delete: SP_ERR TxnAbort\n");
DEBUGLOG(("Delete: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

delete_error:
	DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
	DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;

}


int GetMerchantKey(const char* csMerchantID,const char* csKey,
                recordset_t* myRec)
{
	int iRet = 0;
                
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getmerchantkey_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar		hv_key[PD_KEY_NAME_LEN + 1];
                
		varchar		v_key_value[PD_MD5_KEY_LEN + 1];
		varchar		v_effect_date[PD_DATE_LEN + 1];

		short		ind_key_value = -1;
		short		ind_effect_date = -1;
        
        
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("GetMerchantKey merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        hv_key.len = strlen(csKey);
        memcpy(hv_key.arr,csKey,hv_key.len);
DEBUGLOG(("GetMerchantKey key = [%.*s]\n",hv_key.len,hv_key.arr));
        
        EXEC SQL DECLARE c_cursor_getmerchantkey CURSOR FOR
                select
		       key_value,
		       effect_date
                  from merch_keys
		 where merchant_id = :hv_merchant_id
		 and   key = :hv_key
		 AND   effect_date  =
                        (SELECT max(effect_date)
                           FROM merch_keys
                          WHERE merchant_id = :hv_merchant_id
                            AND key = :hv_key
                            AND effect_date <= to_char(sysdate,'yyyymmdd'));


        EXEC SQL OPEN c_cursor_getmerchantkey;
        do {
                EXEC SQL FETCH c_cursor_getmerchantkey
                INTO
			:v_key_value:ind_key_value,
			:v_effect_date:ind_effect_date;

                if (SQLCODE == SQL_NOT_FOUND) {
			iRet = SQL_NOT_FOUND;
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);


/* key */
                if (ind_key_value >= 0) {
                        v_key_value.arr[v_key_value.len] = '\0';
                        PutField_CString(myHash,"key_value",(const char*)v_key_value.arr);
DEBUGLOG(("GetMerchantKey key_value = [%s]\n",v_key_value.arr));
                }

/* effect_date */
                if (ind_effect_date >= 0) {
                        v_effect_date.arr[v_effect_date.len] = '\0';
                        PutField_CString(myHash,"effect_date",(const char*)v_effect_date.arr);
DEBUGLOG(("GetMerchantKey effect_date = [%s]\n",v_effect_date.arr));
                }

                RecordSet_Add(myRec,myHash);
		break; //**************** only one now
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getmerchantkey;

	

DEBUGLOG(("GetMerchantKey Normal Exit\n"));
        if(iRet==0) return  PD_OK;
	else	return iRet;

getmerchantkey_error:
DEBUGLOG(("getmerchantkey_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getmerchantkey;
        return PD_ERR;
}


int CheckAvailableForGenSTK(const char* csMerchantID)
{
	int iRet = PD_NOT_FOUND;
                
        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO checkavail_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
                        
        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merchant_id[PD_MERCHANT_ID_LEN];
                
		int		v_count;
		short		ind_count = -1;
        EXEC SQL END DECLARE SECTION;
        
        hv_merchant_id.len = strlen(csMerchantID);
        memcpy(hv_merchant_id.arr,csMerchantID,hv_merchant_id.len);
DEBUGLOG(("CheckAvailableForGenSTK merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
        
        
        EXEC SQL DECLARE c_cursor_checkavail CURSOR FOR
		SELECT	count(*)
		  FROM	merch_keys t1
		 WHERE	merchant_id = :hv_merchant_id
		   AND	key = 'PTK'
		   AND	NOT EXISTS (SELECT null
				      FROM merch_keys t2
				     WHERE key = 'STK'
				       AND t1.merchant_id = t2.merchant_id)
		GROUP BY
			merchant_id HAVING count(*)=1;

        EXEC SQL OPEN c_cursor_checkavail;
    //    do {
                EXEC SQL FETCH c_cursor_checkavail
                INTO
			:v_count:ind_count;

                if (SQLCODE == SQL_NOT_FOUND) {
			iRet = SQL_NOT_FOUND;
    //                    break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* count */
                if (ind_count >= 0) {
			if (v_count == 1) {
				iRet = PD_OK;
DEBUGLOG(("CheckAvailableForGenSTK return OK!\n"));
			}
                }
//        }
  //      while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_checkavail;

	

DEBUGLOG(("CheckAvailableForGenSTK Normal Exit\n"));
        return  iRet;

checkavail_error:
DEBUGLOG(("checkavail_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_checkavail;
        return PD_ERR;

}


int UpdateKey(const hash_t *hMerchKeys)
{
	char *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO updatekey_err;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_key[PD_KEY_NAME_LEN];
		varchar	hv_key_value[PD_ITT_MD5_KEN_LEN];
		varchar	hv_update_user[PD_USER_LEN];
		varchar	hv_effect_date[PD_DATE_LEN];

		short	ind_merchant_id = -1;
		short	ind_key = -1;
		short	ind_key_value = -1;
		short	ind_update_user = -1;
		short	ind_effect_date = -1;

		short	hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateKey: Begin\n"));

//merchant_id
	if (GetField_CString(hMerchKeys,"merchant_id",&csTmp)) {
		hv_merchant_id.len = strlen(csTmp);
		strncpy((char*)hv_merchant_id.arr, csTmp, hv_merchant_id.len);
		ind_merchant_id = 0;
DEBUGLOG(("UpdateKey merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
	}

//key
	if (GetField_CString(hMerchKeys,"key",&csTmp)) {
		hv_key.len = strlen(csTmp);
		strncpy((char*)hv_key.arr, csTmp, hv_key.len);
		ind_key = 0;
DEBUGLOG(("UpdateKey key = [%.*s]\n",hv_key.len,hv_key.arr));
	}

//key_value
	if (GetField_CString(hMerchKeys,"key_value",&csTmp)) {
		hv_key_value.len = strlen(csTmp);
		strncpy((char*)hv_key_value.arr, csTmp, hv_key_value.len);
		ind_key_value = 0;
DEBUGLOG(("UpdateKey key_value = [%.*s]\n",hv_key_value.len,hv_key_value.arr));
	}

//update_user
	if (GetField_CString(hMerchKeys,"update_user",&csTmp)) {
		hv_update_user.len = strlen(csTmp);
		strncpy((char*)hv_update_user.arr, csTmp, hv_update_user.len);
		ind_update_user = 0;
DEBUGLOG(("UpdateKey update_user = [%.*s]\n",hv_update_user.len,hv_update_user.arr));
	}

//effect_date
	if (GetField_CString(hMerchKeys,"effect_date",&csTmp)) {
		hv_effect_date.len = strlen(csTmp);
		strncpy((char*)hv_effect_date.arr, csTmp, hv_effect_date.len);
		ind_effect_date = 0;
DEBUGLOG(("UpdateKey effect_date [%.*s]\n",hv_effect_date.len,hv_effect_date.arr));
	}


	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_merch_keys_update(
								:hv_merchant_id:ind_merchant_id,
								:hv_key:ind_key,
								:hv_key_value:ind_key_value,
								:hv_update_user:ind_update_user,
								:hv_effect_date:ind_effect_date);
		END;
	END-EXEC;

DEBUGLOG(("UpdateKey Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK) {
DEBUGLOG(("UpdateKey Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
ERRLOG("UpdateKey: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("UpdateKey: SP_OTHER_ERR TxnAbort\n"));	
                return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
ERRLOG("UpdateKey: SP_ERR TxnAbort\n");
DEBUGLOG(("UpdateKey: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

updatekey_err:
DEBUGLOG(("updatekey_err code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("UpdateKey: SP_ERR TxnAbort\n");
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_ERR;
}

