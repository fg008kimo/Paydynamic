/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/20              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "RuleMerchantTxnCap.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RuleMerchantTxnCap(char    cdebug)
{
        cDebug = cdebug;
}


int Find(const char* csCountryId,
                const char* csChannelCode,
		const char* csTxnCode,
                const char* csServiceCode,
                const char* csMerchantId,
                const char* csClientId,
                 recordset_t* myRec)
{

	int iRet = PD_NOT_FOUND;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_country_id[PD_COUNTRY_CODE_LEN];
		varchar	hv_channel_code[PD_CHANNEL_CODE_LEN];
		varchar	hv_txn_code[PD_TXN_CODE_LEN];
		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_client_id[PD_CLIENT_ID_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];
		

		char	v_counter_type;
		varchar	v_counter_category[PD_CATEGORY_LEN +1];
		double	v_value;


		short	ind_counter_type = -1;
		short	ind_counter_category = -1;
		short	ind_value = -1;
		short	ind_country_id= -1;
		short	ind_channel_code= -1;
		short	ind_txn_code= -1;
		short	ind_merchant_id= -1;
		short	ind_client_id= -1;
		short	ind_service_code = -1;

		SQL_CURSOR      c_cursor_counter;
		short           hv_return_value;

        EXEC SQL END DECLARE SECTION;

	hv_country_id.len = strlen(csCountryId);	
	memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
	ind_country_id = 0;
DEBUGLOG(("Find: country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_channel_code.len = strlen(csChannelCode);	
	memcpy(hv_channel_code.arr,csChannelCode,hv_channel_code.len);
	ind_channel_code = 0;
DEBUGLOG(("Find: channel_code = [%.*s]\n",hv_channel_code.len,hv_channel_code.arr));

	hv_txn_code.len = strlen(csTxnCode);	
	memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
	ind_txn_code = 0;
DEBUGLOG(("Find: txn_code = [%.*s]\n",hv_txn_code.len,hv_txn_code.arr));

	hv_merchant_id.len = strlen(csMerchantId);	
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("Find: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_client_id.len = strlen(csClientId);
	memcpy(hv_client_id.arr,csClientId,hv_client_id.len);
	ind_client_id= 0;
DEBUGLOG(("Find: client_id = [%.*s]\n",hv_client_id.len,hv_client_id.arr));

	hv_service_code.len = strlen(csServiceCode);	
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
	ind_service_code = 0;
DEBUGLOG(("Find: service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	EXEC SQL ALLOCATE       :c_cursor_counter;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_rule_txn_cap_find(:hv_country_id:ind_country_id,
								 :hv_channel_code:ind_channel_code,
								 :hv_service_code:ind_service_code,
								 :hv_txn_code:ind_txn_code,
								 :hv_merchant_id:ind_merchant_id,
								 :hv_client_id:ind_client_id,
								 :c_cursor_counter);
                END;
        END-EXEC;

	if (hv_return_value > 0)  {
DEBUGLOG(("Find Found\n"));
                for (;;) {
                        myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);

                        ind_counter_type= -1;
                        ind_counter_category= -1;
                        ind_value= -1;

                        EXEC SQL WHENEVER NOTFOUND DO break;
                        EXEC SQL FETCH :c_cursor_counter
                	INTO
				:v_counter_type:ind_counter_type,
				:v_counter_category:ind_counter_category,
				:v_value:ind_value;

			if (SQLCODE == SQL_NOT_FOUND) {
                	        break;
                	}
		
			iRet = PD_FOUND;

			if (ind_counter_type >= 0 ) {
DEBUGLOG(("Find counter_type = [%c]\n",v_counter_type));
				PutField_Char(myHash,"type",v_counter_type);
			}

			if (ind_counter_category >= 0 ) {
				v_counter_category.arr[v_counter_category.len] ='\0';
                        	PutField_CString(myHash,"category",(const char*)v_counter_category.arr);
DEBUGLOG(("Find counter_category = [%s]\n",v_counter_category.arr));
			}

			if (ind_value >= 0 ) {
DEBUGLOG(("Find value = [%lf]\n",v_value));
				PutField_Double(myHash,"value",v_value);
			}

	 		RecordSet_Add(myRec,myHash);

        	}
		EXEC SQL CLOSE :c_cursor_counter;
		EXEC SQL FREE :c_cursor_counter;
	}
	else {
DEBUGLOG(("Find Not Found\n"));
                EXEC SQL CLOSE :c_cursor_counter;
		EXEC SQL FREE :c_cursor_counter;
        }



DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_counter;
    EXEC SQL FREE :c_cursor_counter;
    return PD_NOT_FOUND;
}

