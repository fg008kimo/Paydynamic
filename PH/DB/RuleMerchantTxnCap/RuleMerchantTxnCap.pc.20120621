/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/20              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "RuleMerchantTxnCap.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void RuleMerchantTxnCap(char    cdebug)
{
        cDebug = cdebug;
}


int Find(const char* csCountryId,
                const char* csChannelCode,
		const char* csTxnCode,
                const char* csServiceCode,
                const char* csMerchantId,
                 recordset_t* myRec)
{

	int iRet = PD_NOT_FOUND;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_country_id[PD_COUNTRY_CODE_LEN];
		varchar	hv_channel_code[PD_CHANNEL_CODE_LEN];
		varchar	hv_txn_code[PD_TXN_CODE_LEN];
		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN];
		varchar	hv_service_code[PD_SERVICE_CODE_LEN];
		

		char	v_counter_type;
		varchar	v_counter_category[PD_CATEGORY_LEN +1];
		double	v_value;


		short	ind_counter_type = -1;
		short	ind_counter_category = -1;
		short	ind_value = -1;

        EXEC SQL END DECLARE SECTION;

	hv_country_id.len = strlen(csCountryId);	
	memcpy(hv_country_id.arr,csCountryId,hv_country_id.len);
DEBUGLOG(("Find: country_id = [%.*s]\n",hv_country_id.len,hv_country_id.arr));

	hv_channel_code.len = strlen(csChannelCode);	
	memcpy(hv_channel_code.arr,csChannelCode,hv_channel_code.len);
DEBUGLOG(("Find: channel_code = [%.*s]\n",hv_channel_code.len,hv_channel_code.arr));

	hv_txn_code.len = strlen(csTxnCode);	
	memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
DEBUGLOG(("Find: txn_code = [%.*s]\n",hv_txn_code.len,hv_txn_code.arr));

	hv_merchant_id.len = strlen(csMerchantId);	
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
DEBUGLOG(("Find: merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_service_code.len = strlen(csServiceCode);	
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("Find: service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));


	EXEC SQL DECLARE c_cursor_getvalue CURSOR FOR
		SELECT 	rm_counter_type,
         		rm_counter_category,
         		rm_value
  		  FROM  rule_merchant_txn_cap
		 WHERE  rm_country = :hv_country_id
   		   and  rm_channel_code = :hv_channel_code
		   and  rm_txn_code = :hv_txn_code
   		   and  rm_service_code = :hv_service_code
   		   and  rm_merchant_id = :hv_merchant_id
   		   and  rm_disabled = 0;


	EXEC SQL OPEN c_cursor_getvalue;
	do{	
		EXEC SQL FETCH c_cursor_getvalue
                INTO
			:v_counter_type:ind_counter_type,
			:v_counter_category:ind_counter_category,
			:v_value:ind_value;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
		myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);
		
		iRet = PD_FOUND;

		if (ind_counter_type >= 0 ) {
DEBUGLOG(("Find counter_type = [%c]\n",v_counter_type));
			PutField_Char(myHash,"type",v_counter_type);
		}

		if (ind_counter_category >= 0 ) {
			v_counter_category.arr[v_counter_category.len] ='\0';
                        PutField_CString(myHash,"category",(const char*)v_counter_category.arr);
DEBUGLOG(("Find counter_category = [%s]\n",v_counter_category.arr));
		}

		if (ind_value >= 0 ) {
DEBUGLOG(("Find value = [%lf]\n",v_value));
			PutField_Double(myHash,"value",v_value);
		}

	 	RecordSet_Add(myRec,myHash);

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getvalue;

DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return PD_NOT_FOUND;
}

