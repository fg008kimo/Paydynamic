/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/07/22              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "OLTmpApi.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char cDebug;

void OLTmpApi(char cdebug)
{
	cDebug = cdebug;
}

int GetEditInfo(const char *csBatchId,
	hash_t *hRec)
{
	int iRet = PD_OK;
	int iDBCnt = 0;
	int iDetailCnt = 0;
	int iOrderCnt = 0;
	char csTag[PD_TAG_LEN + 1];

	EXEC SQL WHENEVER SQLERROR GOTO geteditinfo_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_batch_id[PD_BSE_BATCH_ID_LEN];

		varchar	v_tag_name[PD_BSE_TAG_NAME_LEN + 1];

		int v_seq;
		varchar	v_tag_value[PD_BSE_TAG_VALUE_LEN + 1];

		short ind_tag_name = -1;
		short ind_seq = -1;
		short ind_tag_value = -1;
	EXEC SQL END DECLARE SECTION;

	hv_batch_id.len = strlen(csBatchId);
	memcpy(hv_batch_id.arr, csBatchId, hv_batch_id.len);
DEBUGLOG(("GetEditInfo:: batch_id = [%.*s]\n", hv_batch_id.len, hv_batch_id.arr));

	EXEC SQL DECLARE c_cursor_geteditinfo CURSOR FOR
		select ota_tag_name, ota_seq,
			LISTAGG(ota_tag_value)
			WITHIN GROUP
			(ORDER BY ota_seq, ota_sub_seq)
		from ol_tmp_api
		where ota_batch_id = :hv_batch_id
		group by ota_tag_name, ota_seq
		order by ota_tag_name, ota_seq;

	EXEC SQL OPEN c_cursor_geteditinfo;
	do {
		EXEC SQL FETCH c_cursor_geteditinfo
		INTO	:v_tag_name:ind_tag_name,
			:v_seq:ind_seq,
			:v_tag_value:ind_tag_value;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		/* tag_name */
		if (ind_tag_name >= 0) {
			v_tag_name.arr[v_tag_name.len] = '\0';
DEBUGLOG(("GetEditInfo:: tag_name = [%s]\n", v_tag_name.arr));
		} else {
			continue;
		}

		/* tag seq */
		if (ind_seq >=0 ) {
DEBUGLOG(("GetEditInfo:: seq = [%d]\n", v_seq));
		} else {
			continue;
		}

		/* tag_values */
		if (ind_tag_value >= 0) {
			v_tag_value.arr[v_tag_value.len] = '\0';
DEBUGLOG(("GetEditInfo:: tag_value = [%s]\n", v_tag_value.arr));
		} else {
			continue;
		}

		if (!strcmp((const char *)v_tag_name.arr, PD_BSE_DETAIL)) {
			iDetailCnt++;
			sprintf(csTag, "dt_i_%d", v_seq);
			PutField_CString(hRec, csTag, (const char *)v_tag_value.arr);
		} else if (!strcmp((const char *)v_tag_name.arr, PD_BSE_CNT)) {
			iDBCnt = atoi((const char *)v_tag_value.arr);
			PutField_CString(hRec, PD_BSE_CNT, (const char *)v_tag_value.arr);
		} else if (!strcmp((const char *)v_tag_name.arr, PD_BSE_ORDER)) {
			iOrderCnt++;
			PutField_CString(hRec, PD_BSE_ORDER, (const char *)v_tag_value.arr);
		}
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_geteditinfo;

	if ((iDBCnt == 0) || (iDetailCnt != iDBCnt)) {
DEBUGLOG(("GetEditInfo:: detail count mismatch\n"));
		iRet = PD_ERR;
	} else if (iOrderCnt > 1) {
DEBUGLOG(("GetEditInfo:: too many order field\n"));
		iRet = PD_ERR;
	}

DEBUGLOG(("GetEditInfo:: Normal Exit [%d]\n", iRet));
	return iRet;

geteditinfo_error:
DEBUGLOG(("geteditinfo_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLTmpApi_GetEditInfo: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_geteditinfo;
	return PD_ERR;
}

