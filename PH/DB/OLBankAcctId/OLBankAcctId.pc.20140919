/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/01/02              David Wong
Add new GetNextBAIDCode                            2014/05/05              Virginia Yun
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLBankAcctId.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char cDebug;


void OLBankAcctId(char cdebug)
{
	cDebug = cdebug;
}


int Add(const hash_t *hRec)
{
	char *csTmp;
	double dTmp;
	int	iTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_baid[PD_BAID_LEN];
 		varchar		hv_baid_name[PD_BAID_NAME_LEN];
		varchar		hv_int_bank_code[PD_BANK_CODE_LEN];
		varchar		hv_bank_acct_num[PD_BANK_ACCT_NUM_LEN];
		varchar		hv_psp_id[PD_PSP_ID_LEN];
		varchar		hv_status[PD_ACCOUNT_STATUS_LEN];
		double		hv_init_bal;
		int		hv_code_in_num;
		varchar		hv_create_user[PD_USER_LEN];

		short		ind_baid = -1;
		short		ind_baid_name = -1;
		short		ind_int_bank_code = -1;
		short		ind_bank_acct_num = -1;
		short		ind_psp_id = -1;
		short		ind_status = -1;
		short		ind_init_bal = -1;
		short		ind_code_in_num = -1;
		short		ind_create_user = -1;

		short		hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

	if (GetField_CString(hRec, "baid", &csTmp))
	{
		hv_baid.len = strlen(csTmp);
		strncpy((char*)hv_baid.arr, csTmp, hv_baid.len);
		ind_baid = 0;
	}
DEBUGLOG(("Add: baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	if (GetField_CString(hRec, "baid_name", &csTmp))
	{
		hv_baid_name.len = strlen(csTmp);
		strncpy((char*)hv_baid_name.arr, csTmp, hv_baid_name.len);
		ind_baid_name = 0;
	}
DEBUGLOG(("Add: baid_name = [%.*s]\n", hv_baid_name.len, hv_baid_name.arr));

	if (GetField_CString(hRec, "int_bank_code", &csTmp))
	{
		hv_int_bank_code.len = strlen(csTmp);
		strncpy((char*)hv_int_bank_code.arr, csTmp, hv_int_bank_code.len);
		ind_int_bank_code = 0;
DEBUGLOG(("Add: int_bank_code = [%.*s]\n", hv_int_bank_code.len, hv_int_bank_code.arr));
	}

	if (GetField_CString(hRec, "bank_acct_num", &csTmp))
	{
		hv_bank_acct_num.len = strlen(csTmp);
		strncpy((char*)hv_bank_acct_num.arr, csTmp, hv_bank_acct_num.len);
		ind_bank_acct_num = 0;
DEBUGLOG(("Add: bank_acct_num = [%.*s]\n", hv_bank_acct_num.len, hv_bank_acct_num.arr));
	}

	if (GetField_CString(hRec, "psp_id", &csTmp))
	{
		hv_psp_id.len = strlen(csTmp);
		strncpy((char*)hv_psp_id.arr, csTmp, hv_psp_id.len);
		ind_psp_id = 0;
	}
DEBUGLOG(("Add: psp_id = [%.*s]\n", hv_psp_id.len, hv_psp_id.arr));

	if (GetField_CString(hRec, "status", &csTmp))
	{
		hv_status.len = strlen(csTmp);
		strncpy((char*)hv_status.arr, csTmp, hv_status.len);
		ind_status = 0;
	}
DEBUGLOG(("Add: status = [%.*s]\n", hv_status.len, hv_status.arr));

	if (GetField_Double(hRec, "init_bal", &dTmp)) 
	{
		hv_init_bal = dTmp;
		ind_init_bal = 0;
DEBUGLOG(("Add: init_bal = [%lf]\n", hv_init_bal)); 
	}

	if (GetField_Int(hRec, "code_in_num", &iTmp)) {
		hv_code_in_num = iTmp;
                ind_code_in_num= 0;
DEBUGLOG(("Add: code_in_num = [%d]\n", hv_code_in_num));
	}


	if (GetField_CString(hRec, "create_user", &csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Add: create_user = [%.*s]\n", hv_create_user.len, hv_create_user.arr));

	FREE_ME(csTmp);

	EXEC SQL EXECUTE
	BEGIN
		:hv_return_value := sp_ol_bank_acct_id_insert(
				:hv_baid:ind_baid,
				:hv_baid_name:ind_baid_name,
				:hv_int_bank_code:ind_int_bank_code,
				:hv_bank_acct_num:ind_bank_acct_num,
				:hv_psp_id:ind_psp_id,
				:hv_status:ind_status,
				:hv_init_bal:ind_init_bal,
				:hv_code_in_num:ind_code_in_num,
				:hv_create_user:ind_create_user);
	END;
	END-EXEC;

	DEBUGLOG(("Add: Ret = [%d]\n", hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Add: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
		ERRLOG("OLBankAcctId_Add: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
		ERRLOG("OLBankAcctId_Add: SP_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Add: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int Delete(const char* csBaid)
{
	EXEC SQL WHENEVER SQLERROR GOTO delete_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_baid[PD_BAID_LEN];

		short hv_return_value;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen((const char*)csBaid);
	memcpy(hv_baid.arr, csBaid, hv_baid.len);
DEBUGLOG(("Delete: baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	EXEC SQL EXECUTE
	BEGIN
		:hv_return_value := sp_ol_bank_acct_id_delete(:hv_baid);
	END;
	END-EXEC;

	DEBUGLOG(("Delete: Ret = [%d]\n", hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Delete: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("OLBankAcctId_Delete: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Delete: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("OLBankAcctId_Delete: SP_ERR TxnAbort\n");
		DEBUGLOG(("Delete: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

delete_error:
DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Delete: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetBankAcctIdDtl(const char* csBaid, hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getbankacctiddtl_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_baid[PD_BAID_LEN];

		varchar		v_org_baid[PD_BAID_LEN + 1];
		varchar		v_baid_name[PD_BAID_NAME_LEN + 1];
		varchar		v_int_bank_code[PD_BANK_CODE_LEN + 1];
		varchar		v_bank_acct_num[PD_BANK_ACCT_NUM_LEN + 1];
		varchar		v_psp_id[PD_PSP_ID_LEN + 1];
		varchar		v_status[PD_ACCOUNT_STATUS_LEN + 1];

		short		ind_org_baid = -1;
		short		ind_baid_name = -1;
		short		ind_int_bank_code = -1;
		short		ind_bank_acct_num = -1;
		short		ind_psp_id = -1;
		short		ind_status = -1;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen(csBaid);
	memcpy(hv_baid.arr, csBaid, hv_baid.len);
DEBUGLOG(("GetBankAcctIdDtl baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	EXEC SQL DECLARE c_cursor_getbankacctiddtl CURSOR FOR
		select 	obai_baid,
			obai_baid_name,
			obai_int_bank_code,
			obai_bank_acct_num,
			obai_psp_id,
			obai_status
		from ol_bank_acct_id
		where obai_baid = :hv_baid;

	EXEC SQL OPEN c_cursor_getbankacctiddtl;
	do {
		EXEC SQL FETCH c_cursor_getbankacctiddtl
		INTO
			:v_org_baid:ind_org_baid,
			:v_baid_name:ind_baid_name,
			:v_int_bank_code:ind_int_bank_code,
			:v_bank_acct_num:ind_bank_acct_num,
			:v_psp_id:ind_psp_id,
			:v_status:ind_status;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

DEBUGLOG(("GetBankAcctIdDtl found record\n"));

// baid
		if (ind_org_baid >= 0) {
			v_org_baid.arr[v_org_baid.len] = '\0';
			PutField_CString(hRec, "org_baid", (const char*)v_org_baid.arr);
DEBUGLOG(("GetBankAcctIdDtl org_baid = [%s]\n", v_org_baid.arr));
		}

// baid_name
		if (ind_baid_name >= 0) {
			v_baid_name.arr[v_baid_name.len] = '\0';
			PutField_CString(hRec, "baid_name", (const char*)v_baid_name.arr);
DEBUGLOG(("GetBankAcctIdDtl baid_name = [%s]\n", v_baid_name.arr));
		}

// int_bank_code
		if (ind_int_bank_code >= 0) {
			v_int_bank_code.arr[v_int_bank_code.len] = '\0';
			PutField_CString(hRec, "int_bank_code", (const char*)v_int_bank_code.arr);
DEBUGLOG(("GetBankAcctIdDtl int_bank_code = [%s]\n", v_int_bank_code.arr));
		}

// bank_acct_num
		if (ind_bank_acct_num >= 0) {
			v_bank_acct_num.arr[v_bank_acct_num.len] = '\0';
			PutField_CString(hRec, "bank_acct_num", (const char*)v_bank_acct_num.arr);
DEBUGLOG(("GetBankAcctIdDtl bank_acct_num = [%s]\n", v_bank_acct_num.arr));
		}

// psp_id
		if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len] = '\0';
			PutField_CString(hRec, "psp_id", (const char*)v_psp_id.arr);
DEBUGLOG(("GetBankAcctIdDtl psp_id = [%s]\n", v_psp_id.arr));
		}

// status
		if (ind_status >= 0) {
			v_status.arr[v_status.len] = '\0';
			PutField_CString(hRec, "status", (const char*)v_status.arr);
DEBUGLOG(("GetBankAcctIdDtl status = [%s]\n", v_status.arr));
		}
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getbankacctiddtl;

DEBUGLOG(("GetBankAcctIdDtl Normal Exit\n"));
	return PD_OK;

getbankacctiddtl_error:
DEBUGLOG(("getbankacctiddtl_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getbankacctiddtl;
	return PD_ERR;
}


int GetBaidByBankAcct(const char* csIntBankCode, const char* csBankAcctNum,
						const char* csBankAcctType, hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getbaidbybankacct_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_int_bank_code[PD_BANK_CODE_LEN];
		varchar		hv_bank_acct_num[PD_BANK_ACCT_NUM_LEN];
		varchar		hv_bank_acct_type[PD_ACCT_TYPE_LEN];
		varchar		v_baid[PD_BAID_LEN + 1];
		varchar		v_psp_id[PD_PSP_ID_LEN + 1];

		short		ind_baid = -1;
		short		ind_psp_id = -1;
	EXEC SQL END DECLARE SECTION;

// input int_bank_code
	hv_int_bank_code.len = strlen(csIntBankCode);
	memcpy(hv_int_bank_code.arr, csIntBankCode, hv_int_bank_code.len);
DEBUGLOG(("GetBaidByBankAcct int_bank_code = [%.*s]\n", hv_int_bank_code.len, hv_int_bank_code.arr));

// input bank_acct_num
	hv_bank_acct_num.len = strlen(csBankAcctNum);
	memcpy(hv_bank_acct_num.arr, csBankAcctNum, hv_bank_acct_num.len);
DEBUGLOG(("GetBaidByBankAcct bank_acct_num = [%.*s]\n", hv_bank_acct_num.len, hv_bank_acct_num.arr));

// input bank_acct_type
	hv_bank_acct_type.len = strlen(csBankAcctType);
	memcpy(hv_bank_acct_type.arr, csBankAcctType, hv_bank_acct_type.len);
DEBUGLOG(("GetBaidByBankAcct bank_acct_type = [%.*s]\n", hv_bank_acct_type.len, hv_bank_acct_type.arr));

	EXEC SQL select obai_baid, obai_psp_id
			into :v_baid:ind_baid, :v_psp_id:ind_psp_id
			from ol_bank_acct_id, ol_psp_detail
			where obai_int_bank_code = :hv_int_bank_code
			and ((obai_bank_acct_num = :hv_bank_acct_num) or
				(obai_bank_acct_num like '%' || substr(:hv_bank_acct_num, -4, 4)))
			and obai_status = 'O'
			and obai_psp_id = opd_psp_id
			and opd_bank_acct_type = :hv_bank_acct_type;

	if ((ind_baid >= 0) && (ind_psp_id >= 0)) {
		v_baid.arr[v_baid.len] = '\0';
		PutField_CString(hRec, "baid", (const char*)v_baid.arr);
DEBUGLOG(("GetBaidByBankAcct baid = [%s]\n", v_baid.arr));

		v_psp_id.arr[v_psp_id.len] = '\0';
		PutField_CString(hRec, "psp_id", (const char*)v_psp_id.arr);
DEBUGLOG(("GetBaidByBankAcct psp_id = [%s]\n", v_psp_id.arr));

		return PD_OK;
	}

DEBUGLOG(("GetBaidByBankAcct baid not found\n"));
	return PD_ERR;

getbaidbybankacct_error:
DEBUGLOG(("getbaidbybankacct_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetDtlByBankAcct(const char* csIntBankCode, const char* csBankAcctNum,
						hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getbaidbybankacct_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_int_bank_code[PD_BANK_CODE_LEN];
		varchar		hv_bank_acct_num[PD_BANK_ACCT_NUM_LEN];
		varchar		v_baid[PD_BAID_LEN + 1];
		varchar		v_psp_id[PD_PSP_ID_LEN + 1];

		short		ind_baid = -1;
		short		ind_psp_id = -1;
	EXEC SQL END DECLARE SECTION;

	hv_int_bank_code.len = strlen(csIntBankCode);
	memcpy(hv_int_bank_code.arr, csIntBankCode, hv_int_bank_code.len);
DEBUGLOG(("GetDtlByBankAcct int_bank_code = [%.*s]\n", hv_int_bank_code.len, hv_int_bank_code.arr));

	hv_bank_acct_num.len = strlen(csBankAcctNum);
	memcpy(hv_bank_acct_num.arr, csBankAcctNum, hv_bank_acct_num.len);
DEBUGLOG(("GetDtlByBankAcct bank_acct_num = [%.*s]\n", hv_bank_acct_num.len, hv_bank_acct_num.arr));

	EXEC SQL	select	obai_baid,
				obai_psp_id
			into 	:v_baid:ind_baid,
				:v_psp_id:ind_psp_id
			from	ol_bank_acct_id
			where	obai_int_bank_code = :hv_int_bank_code
			and	obai_bank_acct_num = :hv_bank_acct_num
			and	obai_status = 'O';

	if ((ind_baid >= 0) && (ind_psp_id >= 0)) {
		v_baid.arr[v_baid.len] = '\0';
		PutField_CString(hRec, "baid", (const char*)v_baid.arr);
DEBUGLOG(("GetDtlByBankAcct baid = [%s]\n", v_baid.arr));

		v_psp_id.arr[v_psp_id.len] = '\0';
		PutField_CString(hRec, "psp_id", (const char*)v_psp_id.arr);
DEBUGLOG(("GetDtlByBankAcct psp_id = [%s]\n", v_psp_id.arr));

		return PD_OK;
	}

DEBUGLOG(("GetDtlByBankAcct baid not found\n"));
	return PD_ERR;

getbaidbybankacct_error:
DEBUGLOG(("getbaidbybankacct_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetUnknownCrDrBaid(const char* csBaid, hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getunknowncrdrbaid_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_baid[PD_BAID_LEN];
		varchar		v_bank_acct_type[PD_ACCT_TYPE_LEN + 1];
		varchar		v_unknown_baid[PD_BAID_LEN + 1];

		short		ind_bank_acct_type = -1;
		short		ind_unknown_baid = -1;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen(csBaid);
	memcpy(hv_baid.arr, csBaid, hv_baid.len);
DEBUGLOG(("GetUnknownCrDrBaid baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	EXEC SQL DECLARE c_cursor_getunknowncrdrbaid CURSOR FOR
		select	opd_bank_acct_type, obai_baid
		from	ol_bank_acct_id obai,
			ol_psp_detail opd,
			(select	obai_int_bank_code, obai_bank_acct_num from ol_bank_acct_id where obai_baid = :hv_baid) obai2
		where	obai.obai_int_bank_code = obai2.obai_int_bank_code
		and	obai.obai_bank_acct_num = obai2.obai_bank_acct_num
		and	obai_psp_id = opd_psp_id
		and	opd_bank_acct_type in ('UBC', 'UBD');

	EXEC SQL OPEN c_cursor_getunknowncrdrbaid;
	do {
		EXEC SQL FETCH c_cursor_getunknowncrdrbaid
		INTO
			:v_bank_acct_type:ind_bank_acct_type,
			:v_unknown_baid:ind_unknown_baid;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

DEBUGLOG(("GetUnknownCrDrBaid found record\n"));

// bank_acct_type
		if (ind_bank_acct_type >= 0) {
			v_bank_acct_type.arr[v_bank_acct_type.len] = '\0';
DEBUGLOG(("GetUnknownCrDrBaid bank_acct_type = [%s]\n", v_bank_acct_type.arr));
		}

// unknown_baid
		if (ind_unknown_baid >= 0) {
			v_unknown_baid.arr[v_unknown_baid.len] = '\0';
			if (!strcmp((const char*)v_bank_acct_type.arr, "UKC")) {
				PutField_CString(hRec, "unknown_cr_baid", (const char*)v_unknown_baid.arr);
			} else {
				PutField_CString(hRec, "unknown_dr_baid", (const char*)v_unknown_baid.arr);
			}
DEBUGLOG(("GetUnknownCrDrBaid unknown_cr_baid = [%s]\n", v_unknown_baid.arr));
		}
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getunknowncrdrbaid;

DEBUGLOG(("GetUnknownCrDrBaid Normal Exit\n"));
	return PD_OK;

getunknowncrdrbaid_error:
DEBUGLOG(("getunknowncrdrbaid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getunknowncrdrbaid;
	return PD_ERR;
}

int Update(const hash_t *hRls)
{
	char*	csBAID;
        char*   csBuf;
        char*   csTmp;

        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar        hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));

        csBuf = (char*) malloc (512);

        strcpy((char*)hv_dynstmt.arr,"update ol_bank_acct_id set obai_update_timestamp  = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

	GetField_CString(hRls,"baid",&csBAID);
DEBUGLOG(("Update: baid = [%s]\n", csBAID));
	
/* baid_name */
	if (GetField_CString(hRls, "baid_name", &csTmp)) {
DEBUGLOG(("Update: baid_name = [%s]\n",csTmp));
		strcat((char*)hv_dynstmt.arr, ", obai_baid_name= '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
	}

/*status */
        if (GetField_CString(hRls,"status",&csTmp)) {
DEBUGLOG(("Update:status = [%s]\n",csTmp));
                strcat((char*)hv_dynstmt.arr, ", obai_status = '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

/*update_user*/
        if(GetField_CString(hRls,"update_user",&csTmp)){
DEBUGLOG(("Update:update_user = [%s]\n",csTmp));
                strcat((char*)hv_dynstmt.arr, ",obai_update_user= '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

	strcat((char *)hv_dynstmt.arr, " WHERE obai_baid = '");
        strcat((char *)hv_dynstmt.arr, csBAID);
        strcat((char *)hv_dynstmt.arr, "'");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));


        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);

DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("OLBankAcctId_Update: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Update: SP_INTERNAL_ERR TxnAbort\n"));
        TxnAbort();
        return PD_INTERNAL_ERR;

}

int GetNextBAIDCode(int  *iNextCodeInNum)
{
	int iRet = PD_OK;

	EXEC SQL WHENEVER SQLERROR GOTO getnextcode_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		int     v_code_in_num;

		short   ind_code_in_num = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE c_cursor_getnextcode CURSOR FOR
		select NVL(max(obai_code_in_num),0) + 1
		from ol_bank_acct_id;

        EXEC SQL OPEN c_cursor_getnextcode;

        EXEC SQL FETCH c_cursor_getnextcode
        INTO
                :v_code_in_num:ind_code_in_num;

        if (ind_code_in_num >=0) {
                *iNextCodeInNum = v_code_in_num;
DEBUGLOG(("GetNextBAIDCode code = [%d]\n",iNextCodeInNum));
        }
        else {
DEBUGLOG(("GetNextBAIDCode not found\n"));
		iRet = PD_ERR;
        }

	EXEC SQL CLOSE c_cursor_getnextcode;

DEBUGLOG(("GetNextBAIDCode Normal Exit iRet =[%d]\n",iRet));
        return iRet;

getnextcode_error:
DEBUGLOG(("getnextcode_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getnextcode;
        return PD_ERR;

}


int GetBankAcctIdCountry(const unsigned char* csBaid, unsigned char* csCountry)
{
	int iRet = NOT_FOUND;

	EXEC SQL WHENEVER SQLERROR GOTO getbaidcty_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_baid[PD_BAID_LEN];

		varchar	v_country[PD_COUNTRY_LEN + 1];

		short ind_country = -1;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen((const char*)csBaid);
	memcpy(hv_baid.arr, csBaid, hv_baid.len);
DEBUGLOG(("GetBankAcctIdCountry baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	EXEC SQL
		select distinct country
		into :v_country:ind_country
		from ol_bank_acct_id, bank_desc
		where obai_baid = :hv_baid
		and obai_int_bank_code = internal_bank_code;

	if (ind_country >= 0) {
		v_country.arr[v_country.len] = '\0';
		strcpy((char*)csCountry, (const char*)v_country.arr);
DEBUGLOG(("country = [%s]\n", csCountry));
		iRet = FOUND;
	}

	if (iRet == FOUND) {
DEBUGLOG(("GetBankAcctIdCountry success [%d]\n", iRet));
	} else {
DEBUGLOG(("GetBankAcctIdCountry failed [%d]\n", iRet));
	}

	return iRet;

getbaidcty_error:
DEBUGLOG(("getbaidcty_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Get: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return NOT_FOUND;
}

