/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/01/02              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "OLBankAcctId.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char cDebug;


void OLBankAcctId(char cdebug)
{
	cDebug = cdebug;
}


int Add(const hash_t *hRec)
{
	char *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_baid[PD_BAID_LEN];
		varchar		hv_int_bank_code[PD_BANK_CODE_LEN];
		varchar		hv_bank_acct_num[PD_BANK_ACCT_NUM_LEN];
		varchar		hv_psp_id[PD_PSP_ID_LEN];
		varchar		hv_status[PD_ACCOUNT_STATUS_LEN];
		varchar		hv_create_user[PD_USER_LEN];

		short		ind_baid = -1;
		short		ind_int_bank_code = -1;
		short		ind_bank_acct_num = -1;
		short		ind_psp_id = -1;
		short		ind_status = -1;
		short		ind_create_user = -1;

		short		hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

	if (GetField_CString(hRec, "baid", &csTmp))
	{
		hv_baid.len = strlen(csTmp);
		strncpy((char*)hv_baid.arr, csTmp, hv_baid.len);
		ind_baid = 0;
	}
DEBUGLOG(("Add: baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	if (GetField_CString(hRec, "int_bank_code", &csTmp))
	{
		hv_int_bank_code.len = strlen(csTmp);
		strncpy((char*)hv_int_bank_code.arr, csTmp, hv_int_bank_code.len);
		ind_int_bank_code = 0;
	}
DEBUGLOG(("Add: int_bank_code = [%.*s]\n", hv_int_bank_code.len, hv_int_bank_code.arr));

	if (GetField_CString(hRec, "bank_acct_num", &csTmp))
	{
		hv_bank_acct_num.len = strlen(csTmp);
		strncpy((char*)hv_bank_acct_num.arr, csTmp, hv_bank_acct_num.len);
		ind_bank_acct_num = 0;
	}
DEBUGLOG(("Add: bank_acct_num = [%.*s]\n", hv_bank_acct_num.len, hv_bank_acct_num.arr));

	if (GetField_CString(hRec, "psp_id", &csTmp))
	{
		hv_psp_id.len = strlen(csTmp);
		strncpy((char*)hv_psp_id.arr, csTmp, hv_psp_id.len);
		ind_psp_id = 0;
	}
DEBUGLOG(("Add: psp_id = [%.*s]\n", hv_psp_id.len, hv_psp_id.arr));

	if (GetField_CString(hRec, "status", &csTmp))
	{
		hv_status.len = strlen(csTmp);
		strncpy((char*)hv_status.arr, csTmp, hv_status.len);
		ind_status = 0;
	}
DEBUGLOG(("Add: status = [%.*s]\n", hv_status.len, hv_status.arr));

	if (GetField_CString(hRec, "create_user", &csTmp))
	{
		hv_create_user.len = strlen(csTmp);
		strncpy((char*)hv_create_user.arr, csTmp, hv_create_user.len);
		ind_create_user = 0;
	}
DEBUGLOG(("Add: create_user = [%.*s]\n", hv_create_user.len, hv_create_user.arr));

	FREE_ME(csTmp);

	EXEC SQL EXECUTE
	BEGIN
		:hv_return_value := sp_ol_bank_acct_id_insert(
				:hv_baid:ind_baid,
				:hv_int_bank_code:ind_int_bank_code,
				:hv_bank_acct_num:ind_bank_acct_num,
				:hv_psp_id:ind_psp_id,
				:hv_status:ind_status,
				:hv_create_user:ind_create_user);
	END;
	END-EXEC;

	DEBUGLOG(("Add: Ret = [%d]\n", hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Add: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
		ERRLOG("OLBankAcctId_Add: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
		ERRLOG("OLBankAcctId_Add: SP_ERR TxnAbort\n");
		DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Add: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int Delete(const char* csBaid)
{
	EXEC SQL WHENEVER SQLERROR GOTO delete_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_baid[PD_BAID_LEN];

		short hv_return_value;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen((const char*)csBaid);
	memcpy(hv_baid.arr, csBaid, hv_baid.len);
DEBUGLOG(("Delete: baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	EXEC SQL EXECUTE
	BEGIN
		:hv_return_value := sp_ol_bank_acct_id_delete(:hv_baid);
	END;
	END-EXEC;

	DEBUGLOG(("Delete: Ret = [%d]\n", hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Delete: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("OLBankAcctId_Delete: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Delete: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("OLBankAcctId_Delete: SP_ERR TxnAbort\n");
		DEBUGLOG(("Delete: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

delete_error:
DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Delete: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetBankAcctIdDtl(const char* csBaid, hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getbankacctiddtl_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_baid[PD_BAID_LEN];
		varchar		v_int_bank_code[PD_BANK_CODE_LEN + 1];
		varchar		v_bank_acct_num[PD_BANK_ACCT_NUM_LEN + 1];
		varchar		v_psp_id[PD_PSP_ID_LEN + 1];
		varchar		v_status[PD_ACCOUNT_STATUS_LEN + 1];

		short		ind_int_bank_code = -1;
		short		ind_bank_acct_num = -1;
		short		ind_psp_id = -1;
		short		ind_status = -1;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen(csBaid);
	memcpy(hv_baid.arr, csBaid, hv_baid.len);
DEBUGLOG(("GetBankAcctIdDtl baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	EXEC SQL DECLARE c_cursor_getbankacctiddtl CURSOR FOR
		select obai_int_bank_code,
			obai_bank_acct_num,
			obai_psp_id,
			obai_status
		from ol_bank_acct_id
		where obai_baid = :hv_baid;

	EXEC SQL OPEN c_cursor_getbankacctiddtl;
	do {
		EXEC SQL FETCH c_cursor_getbankacctiddtl
		INTO
			:v_int_bank_code:ind_int_bank_code,
			:v_bank_acct_num:ind_bank_acct_num,
			:v_psp_id:ind_psp_id,
			:v_status:ind_status;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

DEBUGLOG(("GetBankAcctIdDtl found record\n"));

// int_bank_code
		if (ind_int_bank_code >= 0) {
			v_int_bank_code.arr[v_int_bank_code.len] = '\0';
			PutField_CString(hRec, "int_bank_code", (const char*)v_int_bank_code.arr);
DEBUGLOG(("GetBankAcctIdDtl int_bank_code = [%s]\n", v_int_bank_code.arr));
		}

// bank_acct_num
		if (ind_bank_acct_num >= 0) {
			v_bank_acct_num.arr[v_bank_acct_num.len] = '\0';
			PutField_CString(hRec, "bank_acct_num", (const char*)v_bank_acct_num.arr);
DEBUGLOG(("GetBankAcctIdDtl bank_acct_num = [%s]\n", v_bank_acct_num.arr));
		}

// psp_id
		if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len] = '\0';
			PutField_CString(hRec, "psp_id", (const char*)v_psp_id.arr);
DEBUGLOG(("GetBankAcctIdDtl psp_id = [%s]\n", v_psp_id.arr));
		}

// status
		if (ind_status >= 0) {
			v_status.arr[v_status.len] = '\0';
			PutField_CString(hRec, "status", (const char*)v_status.arr);
DEBUGLOG(("GetBankAcctIdDtl status = [%s]\n", v_status.arr));
		}
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getbankacctiddtl;

DEBUGLOG(("GetBankAcctIdDtl Normal Exit\n"));
	return PD_OK;

getbankacctiddtl_error:
DEBUGLOG(("getbankacctiddtl_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getbankacctiddtl;
	return PD_ERR;
}


int GetBaidByBankAcct(const char* csIntBankCode, const char* csBankAcctNum,
						const char* csBankAcctType, hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getbaidbybankacct_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_int_bank_code[PD_BANK_CODE_LEN];
		varchar		hv_bank_acct_num[PD_BANK_ACCT_NUM_LEN];
		varchar		hv_bank_acct_type[PD_ACCT_TYPE_LEN];
		varchar		v_baid[PD_BAID_LEN + 1];
		varchar		v_psp_id[PD_PSP_ID_LEN + 1];

		short		ind_baid = -1;
		short		ind_psp_id = -1;
	EXEC SQL END DECLARE SECTION;

// input int_bank_code
	hv_int_bank_code.len = strlen(csIntBankCode);
	memcpy(hv_int_bank_code.arr, csIntBankCode, hv_int_bank_code.len);
DEBUGLOG(("GetBaidByBankAcct int_bank_code = [%.*s]\n", hv_int_bank_code.len, hv_int_bank_code.arr));

// input bank_acct_num
	hv_bank_acct_num.len = strlen(csBankAcctNum);
	memcpy(hv_bank_acct_num.arr, csBankAcctNum, hv_bank_acct_num.len);
DEBUGLOG(("GetBaidByBankAcct bank_acct_num = [%.*s]\n", hv_bank_acct_num.len, hv_bank_acct_num.arr));

// input bank_acct_type
	hv_bank_acct_type.len = strlen(csBankAcctType);
	memcpy(hv_bank_acct_type.arr, csBankAcctType, hv_bank_acct_type.len);
DEBUGLOG(("GetBaidByBankAcct bank_acct_type = [%.*s]\n", hv_bank_acct_type.len, hv_bank_acct_type.arr));

	EXEC SQL select obai_baid, obai_psp_id
			into :v_baid:ind_baid, :v_psp_id:ind_psp_id
			from ol_bank_acct_id, ol_psp_detail
			where obai_int_bank_code = :hv_int_bank_code
			and ((obai_bank_acct_num = :hv_bank_acct_num) or
				(obai_bank_acct_num like '%' || substr(:hv_bank_acct_num, -4, 4)))
			and obai_status = 'O'
			and obai_psp_id = opd_psp_id
			and opd_bank_acct_type = :hv_bank_acct_type;

	if ((ind_baid >= 0) && (ind_psp_id >= 0)) {
		v_baid.arr[v_baid.len] = '\0';
		PutField_CString(hRec, "baid", (const char*)v_baid.arr);
DEBUGLOG(("GetBaidByBankAcct baid = [%s]\n", v_baid.arr));

		v_psp_id.arr[v_psp_id.len] = '\0';
		PutField_CString(hRec, "psp_id", (const char*)v_psp_id.arr);
DEBUGLOG(("GetBaidByBankAcct psp_id = [%s]\n", v_psp_id.arr));

		return PD_OK;
	}

DEBUGLOG(("GetBaidByBankAcct baid not found\n"));
	return PD_ERR;

getbaidbybankacct_error:
DEBUGLOG(("getbaidbybankacct_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetDtlByBankAcct(const char* csIntBankCode, const char* csBankAcctNum,
						hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getbaidbybankacct_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_int_bank_code[PD_BANK_CODE_LEN];
		varchar		hv_bank_acct_num[PD_BANK_ACCT_NUM_LEN];
		varchar		v_baid[PD_BAID_LEN + 1];
		varchar		v_psp_id[PD_PSP_ID_LEN + 1];

		short		ind_baid = -1;
		short		ind_psp_id = -1;
	EXEC SQL END DECLARE SECTION;

	hv_int_bank_code.len = strlen(csIntBankCode);
	memcpy(hv_int_bank_code.arr, csIntBankCode, hv_int_bank_code.len);
DEBUGLOG(("GetDtlByBankAcct int_bank_code = [%.*s]\n", hv_int_bank_code.len, hv_int_bank_code.arr));

	hv_bank_acct_num.len = strlen(csBankAcctNum);
	memcpy(hv_bank_acct_num.arr, csBankAcctNum, hv_bank_acct_num.len);
DEBUGLOG(("GetDtlByBankAcct bank_acct_num = [%.*s]\n", hv_bank_acct_num.len, hv_bank_acct_num.arr));

	EXEC SQL	select	obai_baid,
				obai_psp_id
			into 	:v_baid:ind_baid,
				:v_psp_id:ind_psp_id
			from	ol_bank_acct_id
			where	obai_int_bank_code = :hv_int_bank_code
			and	obai_bank_acct_num = :hv_bank_acct_num
			and	obai_status = 'O';

	if ((ind_baid >= 0) && (ind_psp_id >= 0)) {
		v_baid.arr[v_baid.len] = '\0';
		PutField_CString(hRec, "baid", (const char*)v_baid.arr);
DEBUGLOG(("GetDtlByBankAcct baid = [%s]\n", v_baid.arr));

		v_psp_id.arr[v_psp_id.len] = '\0';
		PutField_CString(hRec, "psp_id", (const char*)v_psp_id.arr);
DEBUGLOG(("GetDtlByBankAcct psp_id = [%s]\n", v_psp_id.arr));

		return PD_OK;
	}

DEBUGLOG(("GetDtlByBankAcct baid not found\n"));
	return PD_ERR;

getbaidbybankacct_error:
DEBUGLOG(("getbaidbybankacct_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetUnknownCrDrBaid(const char* csBaid, hash_t* hRec)
{
	EXEC SQL WHENEVER SQLERROR GOTO getunknowncrdrbaid_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_baid[PD_BAID_LEN];
		varchar		v_bank_acct_type[PD_ACCT_TYPE_LEN + 1];
		varchar		v_unknown_baid[PD_BAID_LEN + 1];

		short		ind_bank_acct_type = -1;
		short		ind_unknown_baid = -1;
	EXEC SQL END DECLARE SECTION;

	hv_baid.len = strlen(csBaid);
	memcpy(hv_baid.arr, csBaid, hv_baid.len);
DEBUGLOG(("GetUnknownCrDrBaid baid = [%.*s]\n", hv_baid.len, hv_baid.arr));

	EXEC SQL DECLARE c_cursor_getunknowncrdrbaid CURSOR FOR
		select	opd_bank_acct_type, obai_baid
		from	ol_bank_acct_id obai,
			ol_psp_detail opd,
			(select	obai_int_bank_code, obai_bank_acct_num from ol_bank_acct_id where obai_baid = :hv_baid) obai2
		where	obai.obai_int_bank_code = obai2.obai_int_bank_code
		and	obai.obai_bank_acct_num = obai2.obai_bank_acct_num
		and	obai_psp_id = opd_psp_id
		and	opd_bank_acct_type in ('UBC', 'UBD');

	EXEC SQL OPEN c_cursor_getunknowncrdrbaid;
	do {
		EXEC SQL FETCH c_cursor_getunknowncrdrbaid
		INTO
			:v_bank_acct_type:ind_bank_acct_type,
			:v_unknown_baid:ind_unknown_baid;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

DEBUGLOG(("GetUnknownCrDrBaid found record\n"));

// bank_acct_type
		if (ind_bank_acct_type >= 0) {
			v_bank_acct_type.arr[v_bank_acct_type.len] = '\0';
DEBUGLOG(("GetUnknownCrDrBaid bank_acct_type = [%s]\n", v_bank_acct_type.arr));
		}

// unknown_baid
		if (ind_unknown_baid >= 0) {
			v_unknown_baid.arr[v_unknown_baid.len] = '\0';
			if (!strcmp((const char*)v_bank_acct_type.arr, "UKC")) {
				PutField_CString(hRec, "unknown_cr_baid", (const char*)v_unknown_baid.arr);
			} else {
				PutField_CString(hRec, "unknown_dr_baid", (const char*)v_unknown_baid.arr);
			}
DEBUGLOG(("GetUnknownCrDrBaid unknown_cr_baid = [%s]\n", v_unknown_baid.arr));
		}
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_getunknowncrdrbaid;

DEBUGLOG(("GetUnknownCrDrBaid Normal Exit\n"));
	return PD_OK;

getunknowncrdrbaid_error:
DEBUGLOG(("getunknowncrdrbaid_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLBankAcctId_Get: SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getunknowncrdrbaid;
	return PD_ERR;
}
