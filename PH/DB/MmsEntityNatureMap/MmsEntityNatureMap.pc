/*
Partnerdelight (c)2015. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/06/09              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "internal.h"
#include "MmsEntityNatureMap.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


#define	PREFIX	'A'

char    cDebug;

void MmsEntityNatureMap(char    cdebug)
{
        cDebug = cdebug;
}


int Add(const recordset_t* rRecordSet)
{
	int	iRet = PD_OK;
	char	*csPtr;
	hash_t*	hRec;
	EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

        short           hv_return_value;

	varchar		hv_nature_id[PD_NATURE_ID_LEN];
	varchar		hv_nature_grp[PD_NATURE_GROUP_LEN];
	varchar		hv_nature_grp_val[PD_NATURE_GROUP_VAL_LEN];
	varchar		hv_add_user[PD_USER_LEN];


	EXEC SQL END DECLARE SECTION;	
DEBUGLOG(("Add: Begin\n"));
		hRec = RecordSet_GetFirst((recordset_t*) rRecordSet);
                while ((hRec) && (iRet == PD_OK)) {
/* nature_id */
        		if (GetField_CString(hRec,"nature_id",&csPtr)) {
                		hv_nature_id.len = strlen(csPtr);
                		memcpy(hv_nature_id.arr,csPtr,hv_nature_id.len);
DEBUGLOG(("Add:nature_id = [%.*s]\n",hv_nature_id.len,hv_nature_id.arr));
        		}

/* nature_grp */
        		if (GetField_CString(hRec,"nature_grp",&csPtr)) {
                		hv_nature_grp.len = strlen(csPtr);
                		memcpy(hv_nature_grp.arr,csPtr,hv_nature_grp.len);
DEBUGLOG(("Add:nature_grp = [%.*s]\n",hv_nature_grp.len,hv_nature_grp.arr));
        		}

/* nature_grp_val */
        		if (GetField_CString(hRec,"nature_grp_val",&csPtr)) {
                		hv_nature_grp_val.len = strlen(csPtr);
                		memcpy(hv_nature_grp_val.arr,csPtr,hv_nature_grp_val.len);
DEBUGLOG(("Add:nature_grp_val = [%.*s]\n",hv_nature_grp_val.len,hv_nature_grp_val.arr));
        		}

/* add_user */
        		if (GetField_CString(hRec,"add_user",&csPtr)) {
                		hv_add_user.len = strlen(csPtr);
                		memcpy(hv_add_user.arr,csPtr,hv_add_user.len);
DEBUGLOG(("Add:add_user = [%.*s]\n",hv_add_user.len,hv_add_user.arr));
        		}

			EXEC SQL EXECUTE
                	BEGIN
                        	:hv_return_value := sp_mms_entity_nmap_insert(
					:hv_nature_id,
					:hv_nature_grp,
					:hv_nature_grp_val,
                                        :hv_add_user);
                	END;
        		END-EXEC;

			if (hv_return_value == SP_OK) 
				iRet = PD_OK;

        		if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MmsEntityNatureMap_Add: SP_OTHER_ERR\n");
DEBUGLOG(("Add: SP_OTHER_ERR\n"));
                		iRet = PD_OTHER_ERR;
        		}

        		if (hv_return_value == SP_ERR)  {
ERRLOG("MmsEntityNatureMap_Add: SP_ERR\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
                		iRet = PD_ERR;
        		}
			hRec = RecordSet_GetNext((recordset_t*)rRecordSet);
		}

DEBUGLOG(("MmsEntityNatureMap::Add Normal exit iRet = [%d]\n",iRet));
	return iRet;
add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("MmsEntityNatureMap::Add() SP_INTERNAL_ERR\n");
DEBUGLOG(("MmsEntityNatureMap::Add() SP_INTERNAL_ERR\n"));
        return PD_INTERNAL_ERR;
}

int Find(const recordset_t* rRecordSet,char *csNatureId)
{
	int	iRet = NOT_FOUND;
	int	iRecCnt = 0;
	char	*csBuf;
	char	*csGrpPtr;
	char	*csGrpValPtr;
	hash_t* hRec;
	
	
	EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

        varchar         hv_dynstmt[PD_TMP_MSG_BUF_LEN];

	varchar		v_nature_id[PD_NATURE_ID_LEN +1];

	short		ind_nature_id = -1;

        EXEC SQL END DECLARE SECTION;	

DEBUGLOG(("Find\n"));
	csBuf = (char*) malloc (PD_TMP_BUF_LEN + 1);

	hRec = RecordSet_GetFirst((recordset_t*) rRecordSet);
        while (hRec) {
DEBUGLOG(("Find record [%d]\n",iRecCnt));
		GetField_CString(hRec,"group",&csGrpPtr);
		GetField_CString(hRec,"group_val",&csGrpValPtr);
		if (iRecCnt == 0 ) {
			sprintf(csBuf,"select %c0.m_nature_id from ",PREFIX);
			strcpy((char*)hv_dynstmt.arr, csBuf);

			strcat((char*)hv_dynstmt.arr, "(select m_nature_id from MMS_ENTITY_NATURE_MAP WHERE ");

			sprintf(csBuf, "m_nature_grp = '%s' and m_nature_grp_val = '%s') %c0 ", csGrpPtr,csGrpValPtr,PREFIX);
			strcat((char*)hv_dynstmt.arr, csBuf);
		}
		else {
			strcat((char*)hv_dynstmt.arr, "INNER JOIN ");
			sprintf(csBuf, "(select m_nature_id from ");
			strcat((char*)hv_dynstmt.arr, csBuf);

			strcat((char*)hv_dynstmt.arr, "(select m_nature_id from MMS_ENTITY_NATURE_MAP WHERE ");
			sprintf(csBuf, "m_nature_grp = '%s' and m_nature_grp_val = '%s')) %c%d ",csGrpPtr,csGrpValPtr,PREFIX,iRecCnt);
			strcat((char*)hv_dynstmt.arr, csBuf);

			sprintf(csBuf, "on %c0.m_nature_id = %c%d.m_nature_id ",PREFIX,PREFIX,iRecCnt);
			strcat((char*)hv_dynstmt.arr, csBuf);
		}

		iRecCnt++;
		hRec = RecordSet_GetNext((recordset_t*)rRecordSet);
	}
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("Find SQL =[%s]\n",hv_dynstmt.arr))

	EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL DECLARE C CURSOR FOR  PS;	

	EXEC SQL OPEN C;
        do {
                EXEC SQL FETCH C
                INTO
                        :v_nature_id:ind_nature_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if (ind_nature_id >= 0 ) {
		 	v_nature_id.arr[v_nature_id.len] ='\0';
			strcpy(csNatureId,(const char*)v_nature_id.arr);
DEBUGLOG(("Find: Nature ID = [%s]\n",csNatureId));
			iRet = FOUND;
		}
        }
        while(PD_TRUE);

	EXEC SQL CLOSE C;
	FREE_ME(csBuf);
	
DEBUGLOG(("Find: Noraml return iRet = [%d]\n",iRet));
	return iRet;
find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE C;
ERRLOG("MmsEntityNatureMap::Find SP_INTERNAL_ERR\n");
DEBUGLOG(("MmsEntityNatureMap::Find SP_INTERNAL_ERR\n"));
	FREE_ME(csBuf);
        return iRet;
}

