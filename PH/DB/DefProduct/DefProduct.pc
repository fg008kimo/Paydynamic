/*
PDProTech (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/27              [GOD]
PRD309
 - Add FindProduct Function                        2021/04/22              [ZBL]
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "DefProduct.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

static char cDebug;

void DefProduct(char cdebug)
{
	cDebug = cdebug;
}

int GetAllProduct(recordset_t *myRec)
{
	hash_t * myHash;

	EXEC SQL WHENEVER SQLERROR GOTO getallproduct_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;	

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	v_product[PD_PRODUCT_CODE_LEN + 1];

		short	ind_product = -1;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE c_cursor_getallproduct CURSOR FOR
		SELECT	DP_ID
		FROM	DEF_PRODUCT
		WHERE	DP_DISABLED = 0;

	EXEC SQL OPEN c_cursor_getallproduct;

	do
	{
		EXEC SQL FETCH c_cursor_getallproduct
		INTO
			:v_product:ind_product;

		if (SQLCODE == SQL_NOT_FOUND)
			break;

		myHash = (hash_t*)malloc(sizeof(hash_t));
		hash_init(myHash, 0);

		if (ind_product >= 0)
		{
			v_product.arr[v_product.len] ='\0';
			PutField_CString(myHash, "product", (const char*)v_product.arr);
DEBUGLOG(("GetAllProduct product = [%s]\n", v_product.arr));
		}

		RecordSet_Add(myRec, myHash);
	} while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_getallproduct;

DEBUGLOG(("GetAllProduct Normal Exit\n")); 
	return PD_OK;

getallproduct_error:
DEBUGLOG(("getallproduct_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getallproduct;
	return PD_ERR;
}

int FindProduct(char *csProduct)
{
	int iRet = PD_NOT_FOUND;

	EXEC SQL WHENEVER SQLERROR GOTO find_product_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_product[PD_PRODUCT_CODE_LEN];

		int	v_count;

		short	ind_product	= -1;
		short	ind_count	= -1;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("FindProduct: Begin\n"));

	/* product */
	hv_product.len = strlen(csProduct);
	memcpy(hv_product.arr, csProduct, hv_product.len);
	ind_product = 0;

DEBUGLOG(("- product = [%.*s]\n", hv_product.len, hv_product.arr));

	EXEC SQL 
		SELECT	COUNT(*) 
		INTO	:v_count:ind_count 
		FROM	DEF_PRODUCT 
		WHERE	DP_ID = :hv_product AND 
			DP_DISABLED = 0;

	/* count */
	if (ind_count >= 0)
	{
DEBUGLOG(("FindProduct: Normal Exit\n"));
		iRet = PD_FOUND;
	}
	else
	{
DEBUGLOG(("FindProduct: Normal Exit, Not Found\n"));
	}

	return iRet;

find_product_error:
DEBUGLOG(("find_product_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("DefProduct_FindProduct: SP_INTERNAL_ERR\n");
DEBUGLOG(("FindProduct: SP_INTERNAL_ERR\n"));
	return PD_ERR;
}
