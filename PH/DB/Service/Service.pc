/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/02/15              LokMan Chow
Add Find Service				   2011/07/22		   Cody Chan
Add Psp id					   2011/11/28		   LokMan Chow
Add IsCardTypeEnabled to handle			   2016/09/29              Elvis Wong
        check enable_card_type
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "Service.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void Service(char    cdebug)
{
        cDebug = cdebug;
}

/*
int FindURL(const unsigned char* ServiceCode,
	    const unsigned char* PspId,
                unsigned char* URL)
{
	int iRet = NOT_FOUND;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		short           hv_return_value;

                varchar hv_service_code[PD_SERVICE_CODE_LEN];
		varchar hv_psp_id[PD_PSP_ID_LEN];
		int	hv_disabled;

                varchar v_url[PD_VALUE_LEN +1 ];

		SQL_CURSOR      c_cursor_urldt;

                short   ind_url = -1;
                short   ind_service_code = -1;
                short   ind_psp_id = -1;
                short   ind_disabled = -1;
        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char*)ServiceCode);
        memcpy(hv_service_code.arr,ServiceCode,hv_service_code.len);
DEBUGLOG(("FindURL: ServiceCode = [%.*s]\n",hv_service_code.len,hv_service_code.arr)); 
        ind_service_code = 0;

	hv_psp_id.len = strlen((const char*)PspId);
        memcpy(hv_psp_id.arr,PspId,hv_psp_id.len);
DEBUGLOG(("FindURL: psp_id = [%.*s]\n",hv_psp_id.len,hv_psp_id.arr));
        ind_psp_id = 0;

	hv_disabled=0;
        ind_disabled = 0;

	EXEC SQL ALLOCATE       :c_cursor_urldt;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_service_geturl(:hv_service_code:ind_service_code,
                                                                 :hv_psp_id:ind_psp_id,
								 :hv_disabled:ind_disabled,
                                                                 :c_cursor_urldt);
                END;
        END-EXEC;

	if (hv_return_value > 0)  {
DEBUGLOG(("Find Found\n"));
                for (;;) {
                        myHash = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(myHash,0);

                        ind_url = -1;

                        EXEC SQL WHENEVER NOTFOUND DO break;
                        EXEC SQL FETCH :c_cursor_urldt
                        INTO
                                :v_url:ind_url;

			if (ind_url >= 0) {
                        	v_url.arr[v_url.len] = '\0';
                        	strcpy((char*)URL,(const char*)v_url.arr);
				iRet = FOUND;
DEBUGLOG(("URL = [%s]\n",URL));
			}
		}
	}
	
	EXEC SQL CLOSE :c_cursor_urldt;
	EXEC SQL FREE :c_cursor_urldt;

DEBUGLOG(("RET = [%d]\n",iRet));
	return iRet;

find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL CLOSE :c_cursor_urldt;
	EXEC SQL FREE :c_cursor_urldt;
    	EXEC SQL WHENEVER SQLERROR CONTINUE;
    	return NOT_FOUND;
}

int FindService(const unsigned char* ServiceCode,
	       const unsigned char* TxnCountry)
{

	int iRet = NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO find_service_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
		varchar hv_country[PD_COUNTRY_LEN];
		int	hv_disabled;

		short	v_cnt;

        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char*)ServiceCode);
        memcpy(hv_service_code.arr,ServiceCode,hv_service_code.len);
DEBUGLOG(("FindService: ServiceCode = [%.*s]\n",hv_service_code.len,hv_service_code.arr)); 

	hv_country.len = strlen((const char*)TxnCountry);
        memcpy(hv_country.arr,TxnCountry,hv_country.len);
DEBUGLOG(("FindService: country = [%.*s]\n",hv_country.len,hv_country.arr));

	hv_disabled=0;

	EXEC SQL DECLARE c_cursor_get CURSOR FOR
		select count(*)
		 from def_service_code
	         where sc_code =: hv_service_code
                   and sc_txn_country =: hv_country;


	EXEC SQL OPEN c_cursor_get;
	do{	
		EXEC SQL FETCH c_cursor_get
                INTO
			:v_cnt;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
DEBUGLOG(("FindService: cnt = [%d]\n",v_cnt));
		if (v_cnt > 0)  
              		iRet = FOUND;
        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_get;

DEBUGLOG(("FindService RET = [%d]\n",iRet));
	return iRet;

find_service_error:
DEBUGLOG(("find_service_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_get;
    return NOT_FOUND;
}
*/

int FindCountryByService(const unsigned char* ServiceCode, char* TxnCountry)
{

	int iRet = NOT_FOUND;

/*        EXEC SQL WHENEVER SQLERROR GOTO find_country_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
		int     hv_disabled;

		varchar v_country[PD_COUNTRY_LEN+1];

		short	ind_country=-1;

        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char*)ServiceCode);
        memcpy(hv_service_code.arr,ServiceCode,hv_service_code.len);
DEBUGLOG(("FindCountryByService: ServiceCode = [%.*s]\n",hv_service_code.len,hv_service_code.arr)); 

	hv_disabled=0;

	EXEC SQL DECLARE c_cursor_find_country CURSOR FOR
		select sc_txn_country
                 from def_service_code
                where sc_code = :hv_service_code;

	EXEC SQL OPEN c_cursor_find_country;
	do{	
		EXEC SQL FETCH c_cursor_find_country
                INTO
			:v_country:ind_country;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if(ind_country>=0){
			v_country.arr[v_country.len]='\0';
			strcpy(TxnCountry, (const char*)v_country.arr);
DEBUGLOG(("FindCountryByService: country = [%s]\n",TxnCountry));

			iRet = FOUND;
		}

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_find_country;
*/
DEBUGLOG(("FindCountryByService iRet = [%d]\n",iRet));
	return iRet;
/*
find_country_error:
DEBUGLOG(("find_country_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_find_country;
    return NOT_FOUND;
*/
}

int IsSelectBank(const unsigned char* ServiceCode)
{

	int iRet = PD_FALSE;

        EXEC SQL WHENEVER SQLERROR GOTO isselectbank_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
		int     hv_disabled;

		int v_select_bank;

		short	ind_select_bank=-1;

        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char*)ServiceCode);
        memcpy(hv_service_code.arr,ServiceCode,hv_service_code.len);
DEBUGLOG(("IsSelectBank: ServiceCode = [%.*s]\n",hv_service_code.len,hv_service_code.arr)); 

	hv_disabled=0;

	EXEC SQL DECLARE c_cursor_isselectbank CURSOR FOR
		select sc_select_bank
                 from def_service_code
                where sc_code = :hv_service_code;

	EXEC SQL OPEN c_cursor_isselectbank;
	do{	
		EXEC SQL FETCH c_cursor_isselectbank
                INTO
			:v_select_bank:ind_select_bank;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if(ind_select_bank>=0){
			iRet = v_select_bank;
DEBUGLOG(("IsSelectBank: select_bank = [%d]\n",iRet));
		}

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_isselectbank;

DEBUGLOG(("IsSelectBank iRet = [%d]\n",iRet));
	return iRet;

isselectbank_error:
DEBUGLOG(("isselectbank_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_isselectbank;
    return PD_ERR;
}

int IsUseLB(const unsigned char* ServiceCode)
{

	int iRet = PD_FALSE;

        EXEC SQL WHENEVER SQLERROR GOTO isuse_lb_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
		int     hv_disabled;

		int	v_use_lb;

		short	ind_use_lb=-1;

        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char*)ServiceCode);
        memcpy(hv_service_code.arr,ServiceCode,hv_service_code.len);
DEBUGLOG(("IsUseLB: ServiceCode = [%.*s]\n",hv_service_code.len,hv_service_code.arr)); 

	hv_disabled=0;

	EXEC SQL DECLARE c_cursor_isuse_lb CURSOR FOR
		select sc_use_lb
                 from def_service_code
                where sc_code = :hv_service_code;

	EXEC SQL OPEN c_cursor_isuse_lb;
	do{	
		EXEC SQL FETCH c_cursor_isuse_lb
                INTO
			:v_use_lb:ind_use_lb;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if(ind_use_lb>=0){
			iRet = v_use_lb;
DEBUGLOG(("IsUseLB: use_lb = [%d]\n",iRet));
		}

        }while(PD_TRUE);

	EXEC SQL CLOSE c_cursor_isuse_lb;

DEBUGLOG(("IsUseLB iRet = [%d]\n",iRet));
	return iRet;

isuse_lb_error:
DEBUGLOG(("isuse_lb_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_isuse_lb;
    return PD_ERR;
}

int IsCardTypeEnabled(const unsigned char* ServiceCode)
{
	int iRet = PD_FALSE;

        EXEC SQL WHENEVER SQLERROR GOTO iscardtypeenabled_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_service_code[PD_SERVICE_CODE_LEN];

                int             v_enable_card_type;

                short           ind_enable_card_type = -1;

        EXEC SQL END DECLARE SECTION;

	// service_code
	hv_service_code.len = strlen((const char*)ServiceCode);
        memcpy(hv_service_code.arr,ServiceCode,hv_service_code.len);
DEBUGLOG(("IsCardTypeEnabled: ServiceCode = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

        EXEC SQL DECLARE c_cursor_iscardtypeenabled CURSOR FOR
                SELECT  DEPOSIT_CARD_TYPE_OPT_ENABLE
                FROM    DEF_SERVICE_CODE
                WHERE   SC_CODE = :hv_service_code;

        EXEC SQL OPEN c_cursor_iscardtypeenabled;
        do {
                EXEC SQL FETCH c_cursor_iscardtypeenabled
                INTO
                        :v_enable_card_type:ind_enable_card_type;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

/* enable_card_type */
                if (ind_enable_card_type >= 0) {
DEBUGLOG(("IsCardTypeEnabled() enable_card_type = [%d]\n",v_enable_card_type));
                        iRet = v_enable_card_type;
                }

                break;
        } while (PD_TRUE);
        EXEC SQL CLOSE c_cursor_iscardtypeenabled;

	if (iRet == PD_TRUE) {
DEBUGLOG(("IsCardTypeEnabled true [%d]\n",iRet));
        } else {
DEBUGLOG(("IsCardTypeEnabled false [%d]\n",iRet));
        }

        return iRet;

iscardtypeenabled_error:
DEBUGLOG(("iscardtypeenabled_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("IsCardTypeEnabled::iscardtypeenabled_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_iscardtypeenabled;
    return PD_ERR;
}

