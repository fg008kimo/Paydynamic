/*
PDProTech (c)2018. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2018/01/10              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "TxnSuppInfo.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char cDebug;


void TxnSuppInfo(char cdebug)
{
	cDebug = cdebug;
}


int Add(const hash_t *hRls)
{
	char *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO add_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

	short hv_return_value;

	varchar hv_txn_id[PD_TXN_SEQ_LEN + 1];
	varchar hv_info_type[PD_INFO_TYPE_LEN + 1];
	varchar hv_info_value[PD_INFO_VALUE_LEN + 1];
	varchar hv_add_user[PD_USER_LEN + 1];

	short ind_txn_id = -1;
	short ind_info_type = -1;
	short ind_info_value = -1;
	short ind_add_user = -1;

	EXEC SQL END DECLARE SECTION;
DEBUGLOG(("Add: Begin\n"));

// txn_id 
	if (GetField_CString(hRls, "txn_id", &csTmp)) {
		hv_txn_id.len = strlen(csTmp);
		memcpy(hv_txn_id.arr, csTmp, hv_txn_id.len);
		ind_txn_id = 0;
DEBUGLOG(("Add: txn_id = [%.*s][%d]\n", hv_txn_id.len, hv_txn_id.arr, hv_txn_id.len));
	}

// info_type
	if (GetField_CString(hRls, "info_type", &csTmp)) {
		hv_info_type.len = strlen(csTmp);
		memcpy(hv_info_type.arr, csTmp, hv_info_type.len);
		ind_info_type = 0;
DEBUGLOG(("Add: info_type = [%.*s][%d]\n", hv_info_type.len, hv_info_type.arr, hv_info_type.len));
	}

// info_value
	if (GetField_CString(hRls, "info_value", &csTmp)) {
		hv_info_value.len = strlen(csTmp);
		memcpy(hv_info_value.arr, csTmp, hv_info_value.len);
		ind_info_value = 0;
DEBUGLOG(("Add: info_value = [%.*s][%d]\n", hv_info_value.len, hv_info_value.arr, hv_info_value.len));
        }

// add_user
	if (GetField_CString(hRls, "add_user", &csTmp)) {
		hv_add_user.len = strlen(csTmp);
		memcpy(hv_add_user.arr, csTmp, hv_add_user.len);
		ind_add_user = 0;
DEBUGLOG(("Add: add_user = [%.*s][%d]\n", hv_add_user.len, hv_add_user.arr, hv_add_user.len));
	}

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_txn_supp_info_insert(
					:hv_txn_id:ind_txn_id,
					:hv_info_type:ind_info_type,
					:hv_info_value:ind_info_value,
					:hv_add_user:ind_add_user);
		END;
        END-EXEC;

DEBUGLOG(("Add: Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK) {
DEBUGLOG(("Add: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
ERRLOG("TxnSuppInfo_Add: SP_OTHER_ERR\n");
DEBUGLOG(("Add: SP_OTHER_ERR\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
ERRLOG("TxnSuppInfo_Add: SP_ERR\n");
DEBUGLOG(("Add: SP_ERR\n"));
		return PD_ERR;
	}

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("TxnSuppInfo_Add: SP_INTERNAL_ERR\n");
DEBUGLOG(("Add: SP_INTERNAL_ERR\n"));
	return PD_INTERNAL_ERR;
}


int Get(const char *csTxnId, const char *csInfoType, hash_t *hRls)
{
	int iCnt = 0;
	char csTag[PD_TAG_LEN + 1];

	EXEC SQL WHENEVER SQLERROR GOTO get_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_txn_id[PD_TXN_SEQ_LEN + 1];
		varchar hv_info_type[PD_INFO_TYPE_LEN + 1];

		int v_exec_seq;
		varchar v_info_value[PD_INFO_VALUE_LEN + 1];

		short ind_exec_seq = -1;
		short ind_info_value = -1;
	EXEC SQL END DECLARE SECTION;

	hv_txn_id.len = strlen(csTxnId);
	memcpy(hv_txn_id.arr, csTxnId, hv_txn_id.len);
DEBUGLOG(("Get txn_id = [%.*s]\n", hv_txn_id.len, hv_txn_id.arr));

	hv_info_type.len = strlen(csInfoType);
	memcpy(hv_info_type.arr, csInfoType, hv_info_type.len);
DEBUGLOG(("Get info_type = [%.*s]\n", hv_info_type.len, hv_info_type.arr));

	EXEC SQL DECLARE c_cursor_get CURSOR FOR
		select	ts_exec_seq,
			ts_info_value
		from	txn_supp_info
		where	ts_txn_id = :hv_txn_id
		and	ts_info_type = :hv_info_type
		order by ts_exec_seq;

	EXEC SQL OPEN c_cursor_get;
	do {
		EXEC SQL FETCH c_cursor_get
		INTO
			:v_exec_seq:ind_exec_seq,
			:v_info_value:ind_info_value;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		if (ind_exec_seq >= 0) {
DEBUGLOG(("Get exec_seq = [%d]\n", v_exec_seq));
		}

		if (ind_info_value >= 0) {
			v_info_value.arr[v_info_value.len] = '\0';
			sprintf(csTag, "info_value_%d", iCnt);
			PutField_CString(hRls, csTag, (const char*)v_info_value.arr);
DEBUGLOG(("Get info_value = [%s]\n", (const char*)v_info_value.arr));
		}

		iCnt++;
		PutField_Int(hRls, "info_value_count", iCnt);
	} while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_get;

	if (iCnt > 0) {
DEBUGLOG(("Get Normal Exit\n"));
		return PD_OK;
	}
	else {
DEBUGLOG(("Get Normal Exit, Not Found\n"));
		return PD_ERR;
	}

get_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_get;
	return PD_ERR;
}

