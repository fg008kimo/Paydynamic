/*
PDProTech (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2018/11/21              LokMan Chow
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "TxnFieldCheck.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


static char    cDebug;

void TxnFieldCheck(char    cdebug)
{
        cDebug = cdebug;
}


int FindParam(const char* csChannelCode,
              const char* csTxnCode,
	      recordset_t* myRec)
{
	int iRet = PD_OK;
	hash_t *myHash;
	
        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_channel_code[PD_CHANNEL_CODE_LEN +1];
		varchar	hv_txn_code[PD_TXN_CODE_LEN +1];

		varchar v_field_tag[PD_TAG_LEN + 1];
		varchar v_ref_def_table[PD_TMP_BUF_LEN + 1];
		varchar v_ref_def_field[PD_TMP_BUF_LEN + 1];
		int	v_mandatory;
		int	v_only_digit;
		int	v_min_len;
		int	v_max_len;

                short   ind_field_tag = -1;
                short   ind_ref_def_table = -1;
                short   ind_ref_def_field = -1;
                short   ind_mandatory = -1;
                short   ind_only_digit = -1;
                short   ind_min_len = -1;
                short   ind_max_len = -1;
        EXEC SQL END DECLARE SECTION;

	hv_channel_code.len = strlen(csChannelCode);
        memcpy(hv_channel_code.arr,csChannelCode,hv_channel_code.len);
DEBUGLOG(("FindParam: channel code = [%.*s][%d]\n",hv_channel_code.len,hv_channel_code.arr,hv_channel_code.len)); 

	hv_txn_code.len = strlen(csTxnCode);
        memcpy(hv_txn_code.arr,csTxnCode,hv_txn_code.len);
DEBUGLOG(("FindParam: txn code = [%.*s][%d]\n",hv_txn_code.len,hv_txn_code.arr,hv_txn_code.len)); 


	EXEC SQL DECLARE c_cursor_find CURSOR FOR
		 select tfc_field_tag,
			tfc_mandatory,
			tfc_only_digit,
			tfc_min_len,
			tfc_max_len,
			tfc_ref_def_table,
			tfc_ref_def_field
                   from txn_field_check
                  Where tfc_channel_code = :hv_channel_code
                    And tfc_txn_code = :hv_txn_code;

	EXEC SQL OPEN c_cursor_find;
        do {
                EXEC SQL FETCH c_cursor_find
                INTO
                        :v_field_tag:ind_field_tag,
			:v_mandatory:ind_mandatory,
			:v_only_digit:ind_only_digit,
			:v_min_len:ind_min_len,
			:v_max_len:ind_max_len,
			:v_ref_def_table:ind_ref_def_table,
			:v_ref_def_field:ind_ref_def_field;

		if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

		if (ind_field_tag >= 0) {
                        v_field_tag.arr[v_field_tag.len] ='\0';
                        PutField_CString(myHash,"field_tag",(const char*)v_field_tag.arr);
DEBUGLOG((" field_tag = [%s]\n",v_field_tag.arr));
                }

		if (ind_mandatory >= 0) {
                        PutField_Int(myHash,"mandatory",v_mandatory);
DEBUGLOG((" mandatory = [%d]\n",v_mandatory));
                }

		if (ind_only_digit >= 0) {
                        PutField_Int(myHash,"only_digit",v_only_digit);
DEBUGLOG((" only_digit = [%d]\n",v_only_digit));
                }

		if (ind_min_len >= 0) {
                        PutField_Int(myHash,"min_len",v_min_len);
DEBUGLOG((" min_len = [%d]\n",v_min_len));
                }

		if (ind_max_len >= 0) {
                        PutField_Int(myHash,"max_len",v_max_len);
DEBUGLOG((" max_len = [%d]\n",v_max_len));
                }

		if (ind_ref_def_table >= 0) {
                        v_ref_def_table.arr[v_ref_def_table.len] ='\0';
                        PutField_CString(myHash,"ref_def_table",(const char*)v_ref_def_table.arr);
DEBUGLOG((" ref_def_table = [%s]\n",v_ref_def_table.arr));
                }

		if (ind_ref_def_field >= 0) {
                        v_ref_def_field.arr[v_ref_def_field.len] ='\0';
                        PutField_CString(myHash,"ref_def_field",(const char*)v_ref_def_field.arr);
DEBUGLOG((" ref_def_field = [%s]\n",v_ref_def_field.arr));
                }

                RecordSet_Add(myRec,myHash);
	
	}while(PD_TRUE);
	
	EXEC SQL CLOSE c_cursor_find;

DEBUGLOG(("FindParam Normal Exit iRet[%d]\n",iRet));
        return iRet;

find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_find;
    return PD_ERR;
}



int ChkDefReference(const char* csParam, const char* csRefTable, const char* csRefField)
{
        int     iRet = PD_OK;
	char*   csBuf;

        EXEC SQL WHENEVER SQLERROR GOTO check_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar         hv_dynstmt[1024];
		varchar		hv_param[PD_TMP_BUF_LEN];

		int	v_cnt;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("ChkDefReference\n"));

	hv_param.len = strlen(csParam);
	memcpy(hv_param.arr, csParam, hv_param.len);

	csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"select count(1) from ");
	strcat((char*)hv_dynstmt.arr, csRefTable);
	strcat((char*)hv_dynstmt.arr, " where ");
	strcat((char*)hv_dynstmt.arr, csRefField);
	strcat((char*)hv_dynstmt.arr, " = :v1");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len, hv_dynstmt.arr));
	
	EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL DECLARE C CURSOR FOR PS;

	EXEC SQL OPEN C USING :hv_param;
DEBUGLOG((" v1 = [%.*s]\n", hv_param.len, hv_param.arr));

	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;;)
	{
		EXEC SQL FETCH C INTO :v_cnt;
	}

	if(v_cnt <= 0){
		iRet = PD_ERR;
	}

	EXEC SQL CLOSE C;

DEBUGLOG(("ChkDefReference Normal Exit[%d]\n",iRet));
        return iRet;

check_error:
DEBUGLOG(("check_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE C;
    return PD_ERR;
}

