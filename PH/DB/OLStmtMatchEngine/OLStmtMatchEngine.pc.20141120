/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/10/31              Dirk Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "internal.h"
#include "dbutility.h"
#include "OLStmtMatchEngine.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char cDebug;

void OLStmtMatchEngine(char cdebug)
{
	cDebug = cdebug;
}

/*
int GetStmtRule(const hash_t *hRls, recordset_t *myRec)
{
	int iRet = PD_ERR;

	char *csTmp;

	int iCnt;

	hash_t *myHash;
	myHash = (hash_t*) malloc (sizeof(hash_t));
	hash_init(myHash, 0);

	EXEC SQL WHENEVER SQLERROR GOTO getstmtruleerror;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_trigger_type[PD_TRIGGER_TYPE];
		varchar	hv_bank_acct_type[PD_ACCT_TYPE_LEN];
		varchar	hv_baid_txn_code[PD_TXN_CODE_LEN];

		//Recordset data
		int     v_rule_id;
		int	v_sub_rule_id;
		int	v_action_seq;
		varchar	v_action_type[PD_STMT_MATCH_ACTION_DESC_LEN+1];
		int	v_action_filter_id;
		int	v_exit_on_error;
		varchar	v_party[PD_STMT_MATCH_PARTY_LEN+1];
		varchar	v_filter[PD_STMT_MATCH_FILTER_LEN+1];
		varchar	v_operator[PD_STMT_MATCH_OPERATOR_LEN+1];
		varchar v_value[PD_STMT_MATCH_VALUE_LEN+1];

		short   ind_rule_id = -1;
		short   ind_sub_rule_id = -1;
		short   ind_action_seq = -1;
		short	ind_action_type = -1;
		short	ind_action_filter_id = -1;
		short	ind_exit_on_error = -1;
		short	ind_party = -1;
		short	ind_filter = -1;
		short	ind_operator = -1;
		short	ind_value = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hRls,"trigger_type",&csTmp)) {
		hv_trigger_type.len = strlen(csTmp);
		strncpy((char*)hv_trigger_type.arr, csTmp, hv_trigger_type.len);
DEBUGLOG(("GetStmtRule trigger_type = [%s]\n", hv_trigger_type.len, hv_trigger_type.arr));
	} else {
DEBUGLOG(("GetStmtRule trigger_type NOT FOUND!\n"));
		iRet = INT_TRIGGER_TYPE_NOT_FOUND;
	}

	if (GetField_CString(hRls,"bank_acct_type",&csTmp)) {
		hv_bank_acct_type.len = strlen(csTmp);
		strncpy((char*)hv_bank_acct_type.arr, csTmp, hv_bank_acct_type.len);
DEBUGLOG(("GetStmtRule bank_acct_type = [%s]\n", hv_bank_acct_type.len, hv_bank_acct_type.arr));
	} else {
DEBUGLOG(("GetStmtRule bank_acct_type NOT FOUND!\n"));
		iRet = INT_AC_NATURE_NOT_FOUND;
	}

	if (GetField_CString(hRls,"txn_code",&csTmp)) {
		hv_baid_txn_code.len = strlen(csTmp);
		strncpy((char*)hv_baid_txn_code.arr, csTmp, hv_baid_txn_code.len);
DEBUGLOG(("GetStmtRule txn_code = [%s]\n", hv_baid_txn_code.len, hv_baid_txn_code.arr));
	} else {
DEBUGLOG(("GetStmtRule txn_code NOT FOUND!\n"));
		iRet = INT_BAID_TXN_CODE_NOT_FOUND;
	}

	EXEC SQL DECLARE getstmtrulecursor CURSOR FOR
		SELECT	OSME_RULE_ID,
			OSMR_SUB_RULE_ID,
			OSMR_ACTION_SEQ, 
			OSMR_ACTION_TYPE, 
			OSMR_ACTION_FILTER_ID, 
			OSMR_EXIT_ON_ERROR,
			OSMF_PARTY,
			OSMF_FILTER,
			OSMF_OPERATOR,
			OSMF_VALUE
		FROM	(SELECT	OSME_RULE_ID,
				OSMR_SUB_RULE_ID, 
				OSMR_ACTION_SEQ, 
				OSMR_ACTION_TYPE, 
				OSMR_ACTION_FILTER_ID, 
				OSMR_EXIT_ON_ERROR
			 FROM	OL_STMT_MATCH_ENGINE,
				OL_STMT_MATCH_RULE
			 WHERE	OSME_TRIGGER_TYPE = :hv_trigger_type 
			 AND	OSME_BANK_ACCT_TYPE = :hv_bank_acct_type
			 AND	OSME_BAID_TXN_CODE = :hv_baid_txn_code
			 AND	OSME_DISABLED = 0
			 AND	OSMR_DISABLED = 0
			 AND	OSME_RULE_ID = OSMR_RULE_ID
			) tblA,
			(SELECT	OSMF_ACTION_FILTER_ID,
				OSMF_PARTY,
				OSMF_FILTER,
				OSMF_OPERATOR,
				OSMF_VALUE 
			 FROM	OL_STMT_MATCH_FILTER
			 WHERE	OSMF_DISABLED = 0
			) tblB
		WHERE   tblA.OSMR_ACTION_FILTER_ID = tblB.OSMF_ACTION_FILTER_ID(+)
		ORDER BY tblA.OSME_RULE_ID,
			 tblA.OSMR_SUB_RULE_ID,
			 tblA.OSMR_ACTION_SEQ;

	EXEC SQL OPEN getstmtrulecursor;
	for (;;) {
		EXEC SQL FETCH getstmtrulecursor
		INTO	:v_rule_id:ind_rule_id,
			:v_sub_rule_id:ind_sub_rule_id,
			:v_action_seq:ind_action_seq,
			:v_action_type:ind_action_type,
			:v_action_filter_id:ind_action_filter_id,
			:v_exit_on_error:ind_exit_on_error,
			:v_party:ind_party,
			:v_filter:ind_filter,
			:v_operator:ind_operator,
			:v_value:ind_value;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

		//rule_id
		if (ind_rule_id >= 0) {
			PutField_Int(myHash, "rule_id", v_rule_id);
DEBUGLOG(("GetStmtRule rule_id = [%d]\n", v_rule_id));
		}

		//sub_rule_id
		if (ind_sub_rule_id >= 0) {
			PutField_Int(myHash, "sub_rule_id", v_sub_rule_id);
DEBUGLOG(("GetStmtRule sub_rule_id = [%d]\n", v_sub_rule_id));
		}

		//action_seq
		if (ind_action_seq >= 0) {
			PutField_Int(myHash, "action_seq", v_action_seq);
DEBUGLOG(("GetStmtRule action_seq = [%d]\n", v_action_seq));
		}

		//action_type
		if (ind_action_type >= 0) {
			v_action_type.arr[v_action_type.len] = '\0';
			PutField_CString(myHash, "action_type", (const char*)v_action_type.arr);
DEBUGLOG(("GetStmtRule action_type = [%s]\n", v_action_type.arr));
		}
		
		//action_filter_id
		if (ind_action_filter_id >= 0) {
			PutField_Int(myHash, "action_filter_id", v_action_filter_id);
DEBUGLOG(("GetStmtRule action_filter_id = [%d]\n", v_action_filter_id));
		}

		//exit_on_error
		if (ind_exit_on_error >= 0) {
			PutField_Int(myHash, "exit_on_error", v_exit_on_error);
DEBUGLOG(("GetStmtRule exit_on_error = [%d]\n", v_exit_on_error));
		}

		//party
		if (ind_party >= 0) {
			v_party.arr[v_party.len] = '\0';
			PutField_CString(myHash, "party", (const char*)v_party.arr);
DEBUGLOG(("GetStmtRule party = [%s]\n", v_party.arr));
		}

		//filter
		if (ind_filter >= 0) {
			v_filter.arr[v_filter.len] = '\0';
			PutField_CString(myHash, "filter", (const char*)v_filter.arr);
DEBUGLOG(("GetStmtRule filter = [%s]\n", v_filter.arr));
		}

		//operator
		if (ind_operator >= 0) {
			v_operator.arr[v_operator.len] = '\0';
			PutField_CString(myHash, "operator", (const char*)v_operator.arr);
DEBUGLOG(("GetStmtRule operator = [%s]\n", v_operator.arr));
		}

		//value
		if (ind_value >= 0) {
			v_value.arr[v_value.len] = '\0';
			PutField_CString(myHash, "value", (const char*)v_value.arr);
DEBUGLOG(("GetStmtRule value = [%s]\n", v_value.arr));
		}

		RecordSet_Add(myRec, myHash);
	}
	EXEC SQL CLOSE getstmtrulecursor;

	if (iCnt > 0 ) {
DEBUGLOG(("GetStmtRule normal exit\n"));
	} else {
DEBUGLOG(("GetStmtRule data not found\n"));
	}

	return iRet;

getstmtruleerror:
DEBUGLOG(("getstmtrule_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE getstmtrulecursor;
	return PD_ERR;
}
*/

int GetStmtRule(const hash_t *hRls, recordset_t *myRec)
{
	int iRet = PD_OK;
	char *csTmp;
	int iCnt;
	int iLastSubRuleId;
	int iLastActionSeq;
	int iLastActionFilterId;
	int iIndex;

	char *csTag = (char*) malloc (64);

	hash_t *myHash;
	myHash = (hash_t*) malloc (sizeof(hash_t));
	hash_init(myHash, 0);

	EXEC SQL WHENEVER SQLERROR GOTO getstmtrule_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_trigger_type[PD_TRIGGER_TYPE_LEN];
		varchar hv_bank_acct_type[PD_ACCT_TYPE_LEN];
		varchar hv_baid_txn_code[PD_TXN_CODE_LEN];

		int v_sub_rule_id;
		int v_action_seq;
		varchar v_action_type[PD_STMT_MATCH_ACTION_DESC_LEN + 1];
		int v_action_filter_id;
		int v_exit_on_error;
		varchar v_party[PD_STMT_MATCH_PARTY_LEN + 1];
		varchar v_filter[PD_STMT_MATCH_FILTER_LEN + 1];
		varchar v_operator[PD_STMT_MATCH_OPERATOR_LEN + 1];
		varchar v_value[PD_STMT_MATCH_VALUE_LEN + 1];

		short ind_sub_rule_id = -1;
		short ind_action_seq = -1;
		short ind_action_type = -1;
		short ind_action_filter_id = -1;
		short ind_exit_on_error = -1;
		short ind_party = -1;
		short ind_filter = -1;
		short ind_operator = -1;
		short ind_value = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hRls, "trigger_type", &csTmp)) {
		hv_trigger_type.len = strlen(csTmp);
		strncpy((char*)hv_trigger_type.arr, csTmp, hv_trigger_type.len);
DEBUGLOG(("GetStmtRule trigger_type = [%.*s]\n", hv_trigger_type.len, (const char*)hv_trigger_type.arr));
	} else {
DEBUGLOG(("GetStmtRule trigger_type not found!\n"));
		iRet = PD_ERR;
	}

	if (GetField_CString(hRls, "bank_acct_type", &csTmp)) {
		hv_bank_acct_type.len = strlen(csTmp);
		strncpy((char*)hv_bank_acct_type.arr, csTmp, hv_bank_acct_type.len);
DEBUGLOG(("GetStmtRule bank_acct_type = [%.*s]\n", hv_bank_acct_type.len, (const char*)hv_bank_acct_type.arr));
	} else {
DEBUGLOG(("GetStmtRule bank_acct_type not found!\n"));
		iRet = PD_ERR;
	}

	if (GetField_CString(hRls, "baid_txn_code", &csTmp)) {
		hv_baid_txn_code.len = strlen(csTmp);
		strncpy((char*)hv_baid_txn_code.arr, csTmp, hv_baid_txn_code.len);
DEBUGLOG(("GetStmtRule baid_txn_code = [%.*s]\n", hv_baid_txn_code.len, (const char*)hv_baid_txn_code.arr));
	} else {
DEBUGLOG(("GetStmtRule baid_txn_code not found!\n"));
		iRet = PD_ERR;
	}

	EXEC SQL DECLARE c_getstmtrule CURSOR FOR
		SELECT	OSMR_SUB_RULE_ID,
			OSMR_ACTION_SEQ, 
			OSMR_ACTION_TYPE, 
			OSMR_ACTION_FILTER_ID, 
			OSMR_EXIT_ON_ERROR,
			OSMF_PARTY,
			OSMF_FILTER,
			OSMF_OPERATOR,
			OSMF_VALUE
		FROM	(SELECT	OSMR_SUB_RULE_ID, 
				OSMR_ACTION_SEQ, 
				OSMR_ACTION_TYPE, 
				OSMR_ACTION_FILTER_ID, 
				OSMR_EXIT_ON_ERROR
				FROM	OL_STMT_MATCH_ENGINE,
					OL_STMT_MATCH_RULE
				WHERE	OSME_TRIGGER_TYPE = :hv_trigger_type 
				AND	OSME_BANK_ACCT_TYPE = :hv_bank_acct_type
				AND	OSME_BAID_TXN_CODE = :hv_baid_txn_code
				AND	OSME_DISABLED = 0
				AND	OSMR_DISABLED = 0
				AND	OSME_RULE_ID = OSMR_RULE_ID
				) rule,
				(SELECT	OSMF_ACTION_FILTER_ID,
					OSMF_PARTY,
					OSMF_FILTER,
					OSMF_OPERATOR,
					OSMF_VALUE 
				FROM	OL_STMT_MATCH_FILTER
				WHERE	OSMF_DISABLED = 0
				) filter
		WHERE	rule.OSMR_ACTION_FILTER_ID = filter.OSMF_ACTION_FILTER_ID(+)
		ORDER BY	rule.OSMR_SUB_RULE_ID,
				rule.OSMR_ACTION_SEQ;

	if (iRet == PD_OK) {
		EXEC SQL OPEN c_getstmtrule;

		for (;;) {
			EXEC SQL FETCH c_getstmtrule
			INTO	:v_sub_rule_id:ind_sub_rule_id,
				:v_action_seq:ind_action_seq,
				:v_action_type:ind_action_type,
				:v_action_filter_id:ind_action_filter_id,
				:v_exit_on_error:ind_exit_on_error,
				:v_party:ind_party,
				:v_filter:ind_filter,
				:v_operator:ind_operator,
				:v_value:ind_value;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			iCnt++;

			if ((ind_sub_rule_id >= 0) &&
				(ind_action_seq >= 0) &&
				(ind_action_type >= 0) &&
				(ind_action_filter_id >= 0) &&
				(ind_exit_on_error >= 0))
			{
				if (iCnt == 1) {

					// sub_rule_id
					PutField_Int(myHash, "sub_rule_id", v_sub_rule_id);
DEBUGLOG(("GetStmtRule sub_rule_id = [%d]\n", v_sub_rule_id));
					// action_seq
					PutField_Int(myHash, "action_seq", v_action_seq);
DEBUGLOG(("GetStmtRule action_seq = [%d]\n", v_action_seq));
					// action_type
					v_action_type.arr[v_action_type.len] = '\0';
					PutField_CString(myHash, "action_type", (const char*)v_action_type.arr);
DEBUGLOG(("GetStmtRule action_type = [%s]\n", (const char*)v_action_type.arr));
					// action_filter_id
					PutField_Int(myHash, "action_filter_id", v_action_filter_id);
DEBUGLOG(("GetStmtRule action_filter_id = [%d]\n", v_action_filter_id));
					// exit_on_error
					PutField_Int(myHash, "exit_on_error", v_exit_on_error);
DEBUGLOG(("GetStmtRule exit_on_error = [%d]\n", v_exit_on_error));

					iLastSubRuleId = v_sub_rule_id;
					iLastActionSeq = v_action_seq;
					iLastActionFilterId = v_action_filter_id;
					iIndex = 0;
				} else {
					if ((v_sub_rule_id != iLastSubRuleId) ||
						(v_action_seq != iLastActionSeq)) {

						PutField_Int(myHash, "field_cnt", iIndex);
						RecordSet_Add(myRec, myHash);
DEBUGLOG(("GetStmtRule: hash added - sub_rule_id = [%d], action_seq = [%d], action_filter_id = [%d], field_cnt = [%d]\n", iLastSubRuleId, iLastActionSeq, iLastActionFilterId, iIndex));
DEBUGLOG(("\n"));

						myHash = (hash_t*) malloc (sizeof(hash_t));
						hash_init(myHash, 0);

						// sub_rule_id
						PutField_Int(myHash, "sub_rule_id", v_sub_rule_id);
DEBUGLOG(("GetStmtRule sub_rule_id = [%d]\n", v_sub_rule_id));
						// action_seq
						PutField_Int(myHash, "action_seq", v_action_seq);
DEBUGLOG(("GetStmtRule action_seq = [%d]\n", v_action_seq));
						// action_type
						v_action_type.arr[v_action_type.len] = '\0';
						PutField_CString(myHash, "action_type", (const char*)v_action_type.arr);
DEBUGLOG(("GetStmtRule action_type = [%s]\n", (const char*)v_action_type.arr));
						// action_filter_id
						PutField_Int(myHash, "action_filter_id", v_action_filter_id);
DEBUGLOG(("GetStmtRule action_filter_id = [%d]\n", v_action_filter_id));
						// exit_on_error
						PutField_Int(myHash, "exit_on_error", v_exit_on_error);
DEBUGLOG(("GetStmtRule exit_on_error = [%d]\n", v_exit_on_error));

						iLastSubRuleId = v_sub_rule_id;
						iLastActionSeq = v_action_seq;
						iIndex = 0;
					}
					iLastActionFilterId = v_action_filter_id;
				}
			}

			if (v_action_filter_id != 0) {
				iIndex++;
			}

			// party
			if (ind_party >= 0) {
				v_party.arr[v_party.len] = '\0';
				sprintf(csTag, "party_%d", iIndex);
				PutField_CString(myHash, csTag, (const char*)v_party.arr);
DEBUGLOG(("GetStmtRule [%s] = [%s]\n", csTag, (const char*)v_party.arr));
			}

			// filter
			if (ind_filter >= 0) {
				v_filter.arr[v_filter.len] = '\0';
				sprintf(csTag, "filter_%d", iIndex);
				PutField_CString(myHash, csTag, (const char*)v_filter.arr);
DEBUGLOG(("GetStmtRule [%s] = [%s]\n", csTag, (const char*)v_filter.arr));
			}

			// operator
			if (ind_operator >= 0) {
				v_operator.arr[v_operator.len] = '\0';
				sprintf(csTag, "operator_%d", iIndex);
				PutField_CString(myHash, csTag, (const char*)v_operator.arr);
DEBUGLOG(("GetStmtRule [%s] = [%s]\n", csTag, (const char*)v_operator.arr));
			}

			// value
			if (ind_value >= 0) {
				v_value.arr[v_value.len] = '\0';
				sprintf(csTag, "value_%d", iIndex);
				PutField_CString(myHash, csTag, (const char*)v_value.arr);
DEBUGLOG(("GetStmtRule [%s] = [%s]\n", csTag, (const char*)v_value.arr));
			}
		}

		EXEC SQL CLOSE c_getstmtrule;

		if (iCnt > 0 ) {
			PutField_Int(myHash, "field_cnt", iIndex);
			RecordSet_Add(myRec, myHash);
DEBUGLOG(("GetStmtRule: hash added - sub_rule_id = [%d], action_seq = [%d], action_filter_id = [%d], field_cnt = [%d]\n", iLastSubRuleId, iLastActionSeq, iLastActionFilterId, iIndex));
DEBUGLOG(("\n"));
			iRet = PD_OK;
		} else {
DEBUGLOG(("GetStmtRule not found\n"));
ERRLOG("OLStmtMatchEngine:: GetStmtRule not found\n");
			iRet = PD_ERR;
		}
	}

	FREE_ME(csTag);

DEBUGLOG(("GetStmtRule Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getstmtrule_error:
DEBUGLOG(("getstmtrule_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLStmtMatchEngine getstmtrule_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE c_getstmtrule;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int fr_baid1_to_psp1(const int iTagCnt, const hash_t *hMatchValue, hash_t *hContext)
{
	int iRet = PD_OK;
	int iIndex;
	int iCnt = 0;
	char *csTag = (char*) malloc (64);

	char *csBaidTxnCode, *csBaidTxnId, *csSql;
	char *csParty, *csFilter, *csOperator, *csValue;

	EXEC SQL WHENEVER SQLERROR GOTO fr_baid1_to_psp1_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_dynstmt[PD_MAX_BUFFER];
		varchar hv_baid_txn_code[PD_TXN_CODE_LEN];
		varchar hv_baid_txn_id[PD_TXN_SEQ_LEN];

		varchar v_psp_txn_1_id[PD_TXN_SEQ_LEN + 1];

		short ind_psp_txn_1_id = -1;
	EXEC SQL END DECLARE SECTION;

	// get baid_txn_code
	if (!GetField_CString(hContext, "baid_txn_code", &csBaidTxnCode)) {
DEBUGLOG(("fr_baid1_to_psp1:: baid_txn_code not found\n"));
		return PD_ERR;
	} else {
DEBUGLOG(("fr_baid1_to_psp1:: baid_txn_code = [%s]\n", csBaidTxnCode));
		hv_baid_txn_code.len = strlen(csBaidTxnCode);
		memcpy(hv_baid_txn_code.arr, csBaidTxnCode, hv_baid_txn_code.len);
	}

	// get baid_txn_id
	if (!GetField_CString(hContext, "baid_txn_id", &csBaidTxnId)) {
DEBUGLOG(("fr_baid1_to_psp1:: baid_txn_id not found\n"));
		return PD_ERR;
	} else {
DEBUGLOG(("fr_baid1_to_psp1:: baid_txn_id = [%s]\n", csBaidTxnId));
		hv_baid_txn_id.len = strlen(csBaidTxnId);
		memcpy(hv_baid_txn_id.arr, csBaidTxnId, hv_baid_txn_id.len);
	}

	// get sql
	if (!GetField_CString(hMatchValue, "sql_1", &csSql)) {
DEBUGLOG(("fr_baid1_to_psp1:: sql_1 not found\n"));
		return PD_ERR;
	} else {
DEBUGLOG(("fr_baid1_to_psp1:: sql_1 = [%s]\n", csSql));
	}

/*
	strcpy((char*)hv_dynstmt.arr, "\
select oth_txn_id \
from ol_txn_header oth, \
     ol_txn_psp_detail otp, \
     ol_psp_detail opd, \
     ( \
     select opd_client_id, \
            opd_bank_acct_type, \
            obt_bank_code, \
            obt_bank_acct_num, \
            obt_txn_amt, \
            NVL( \
             (select olfs_split_amount from ol_stmt_format_split \
              where obt_bank_code = olfs_int_bank_code \
              and obt_txn_ccy = olfs_ccy \
              and olfs_code = \
	");
	// strcat((char*)hv_dynstmt.arr, " '");
	// strcat((char*)hv_dynstmt.arr, csBaidTxnCode);
	strcat((char*)hv_dynstmt.arr, ":v1");
	// strcat((char*)hv_dynstmt.arr, "' ");
	strcat((char*)hv_dynstmt.arr, "\
              and olfs_disabled = 0), \
             0) split_amt, \
            obt_txn_amt - \
            NVL( \
             (select olfs_split_amount from ol_stmt_format_split \
              where obt_bank_code = olfs_int_bank_code \
              and obt_txn_ccy = olfs_ccy \
              and olfs_code = \
	");
	// strcat((char*)hv_dynstmt.arr, " '");
	// strcat((char*)hv_dynstmt.arr, csBaidTxnCode);
	strcat((char*)hv_dynstmt.arr, ":v2");
	// strcat((char*)hv_dynstmt.arr, "' ");
	strcat((char*)hv_dynstmt.arr, "\
              and olfs_disabled = 0), \
             0) real_amt, \
            olsd_statement_timestamp \
     from ol_baid_txn, ol_psp_detail, ol_statement_detail \
     where obt_txn_id = \
	");
	// strcat((char*)hv_dynstmt.arr, " '");
	// strcat((char*)hv_dynstmt.arr, csBaidTxnId);
	strcat((char*)hv_dynstmt.arr, ":v3");
	// strcat((char*)hv_dynstmt.arr, "' ");
	strcat((char*)hv_dynstmt.arr, "\
     and obt_pid = opd_psp_id \
     and obt_txn_ccy = opd_currency_id \
     and opd_disabled = 0 \
     and opd_status = 'O' \
     and obt_stat_txn_id = olsd_stat_txn_id \
     ) baid_txn \
where 1 = 1 \
and oth.oth_txn_id = otp.otp_txn_id \
and otp.otp_psp_id = opd.opd_psp_id \
and otp.otp_txn_ccy = opd.opd_currency_id \
and opd.opd_disabled = 0 \
and opd.opd_status = 'O' \
	");
*/
	strcpy((char*)hv_dynstmt.arr, csSql);
	hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("fr_baid1_to_psp1: iTagCnt = [%d]\n", iTagCnt));

	for (iIndex = 1; iIndex <= iTagCnt; iIndex++) {
		// get party
		sprintf(csTag, "party_%d", iIndex);
		GetField_CString(hMatchValue, csTag, &csParty);
DEBUGLOG(("fr_baid1_to_psp1: [%s] = [%s]\n", csTag, csParty));

		// get filter
		sprintf(csTag, "filter_%d", iIndex);
		GetField_CString(hMatchValue, csTag, &csFilter);
DEBUGLOG(("fr_baid1_to_psp1: [%s] = [%s]\n", csTag, csFilter));

		if (strcmp(csParty, PD_BOTH_PARTY) != 0) {
			// get operator
			sprintf(csTag, "operator_%d", iIndex);
			GetField_CString(hMatchValue, csTag, &csOperator);
DEBUGLOG(("fr_baid1_to_psp1: [%s] = [%s]\n", csTag, csOperator));

			// get value
			sprintf(csTag, "value_%d", iIndex);
			GetField_CString(hMatchValue, csTag, &csValue);
DEBUGLOG(("fr_baid1_to_psp1: [%s] = [%s]\n", csTag, csValue));
		}

		// if (!strcmp(csFilter, PD_RECON_STATUS)) {
			// if (!strcmp(csParty, PD_PSP_TXN_PARTY)) {
				// strcat((char*)hv_dynstmt.arr, " and oth.oth_recon_status ");
				// strcat((char*)hv_dynstmt.arr, csOperator);
				// strcat((char*)hv_dynstmt.arr, " '");
				// strcat((char*)hv_dynstmt.arr, csValue);
				// strcat((char*)hv_dynstmt.arr, "'");
				// hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			// }
		// }

		// if (!strcmp(csFilter, PD_TXN_CODE)) {
			// if (!strcmp(csParty, PD_PSP_TXN_PARTY)) {
				// strcat((char*)hv_dynstmt.arr, " and oth.oth_txn_code ");
				// strcat((char*)hv_dynstmt.arr, csOperator);
				// strcat((char*)hv_dynstmt.arr, " '");
				// strcat((char*)hv_dynstmt.arr, csValue);
				// strcat((char*)hv_dynstmt.arr, "'");
				// hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			// }
		// }

		if (!strcmp(csFilter, PD_SYSDATE_DIFF)) {
			if (!strcmp(csParty, PD_PSP_TXN_PARTY)) {
				strcat((char*)hv_dynstmt.arr, " and sysdate ");
				strcat((char*)hv_dynstmt.arr, csOperator);
				strcat((char*)hv_dynstmt.arr, " oth.oth_approval_timestamp + ");
				strcat((char*)hv_dynstmt.arr, csValue);
				hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			}
		}

		if (!strcmp(csFilter, PD_PREV_STMT_DATE_DIFF)) {
			if (!strcmp(csParty, PD_PSP_TXN_PARTY)) {
				strcat((char*)hv_dynstmt.arr, " and oth.oth_approval_timestamp ");
				strcat((char*)hv_dynstmt.arr, csOperator);
				strcat((char*)hv_dynstmt.arr, " baid_txn.olsd_statement_timestamp + ");
				strcat((char*)hv_dynstmt.arr, csValue);
				hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			}
		}

		if (!strcmp(csFilter, PD_NEXT_STMT_DATE_DIFF)) {
			if (!strcmp(csParty, PD_PSP_TXN_PARTY)) {
				strcat((char*)hv_dynstmt.arr, " and baid_txn.olsd_statement_timestamp ");
				strcat((char*)hv_dynstmt.arr, csOperator);
				strcat((char*)hv_dynstmt.arr, " oth.oth_approval_timestamp + ");
				strcat((char*)hv_dynstmt.arr, csValue);
				hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			}
		}

		if (!strcmp(csFilter, PD_PROVIDER)) {
			if (!strcmp(csParty, PD_BOTH_PARTY)) {
				strcat((char*)hv_dynstmt.arr, " and opd.opd_client_id = baid_txn.opd_client_id");
				hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			}
		}

		if (!strcmp(csFilter, PD_BANK_CODE)) {
			if (!strcmp(csParty, PD_BOTH_PARTY)) {
				strcat((char*)hv_dynstmt.arr, " and otp.otp_bank_code = baid_txn.obt_bank_code");
				hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			}
		}

		if (!strcmp(csFilter, PD_BANK_ACCT)) {
			if (!strcmp(csParty, PD_BOTH_PARTY)) {
				strcat((char*)hv_dynstmt.arr, " and otp.otp_bank_code = baid_txn.obt_bank_code");
				strcat((char*)hv_dynstmt.arr, " and otp.otp_bank_acct_num = baid_txn.obt_bank_acct_num");
				hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			}
		}

		if (!strcmp(csFilter, PD_BANK_ACCT_NATURE)) {
			if (!strcmp(csParty, PD_BOTH_PARTY)) {
				strcat((char*)hv_dynstmt.arr, " and opd.opd_bank_acct_type = baid_txn.opd_bank_acct_type");
				hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			}
		}

		if (!strcmp(csFilter, PD_TXN_AMT)) {
			if (!strcmp(csParty, PD_BOTH_PARTY)) {
				strcat((char*)hv_dynstmt.arr, " and oth.oth_transaction_amount = baid_txn.real_amt");
				hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
			}
		}
	}

DEBUGLOG(("fr_baid1_to_psp1: SQL = [%.*s]\n", hv_dynstmt.len, hv_dynstmt.arr));

	EXEC SQL PREPARE s1 FROM :hv_dynstmt;
	EXEC SQL DECLARE c_fr_baid1_to_psp1 CURSOR FOR s1;

	EXEC SQL OPEN c_fr_baid1_to_psp1 USING :hv_baid_txn_code, :hv_baid_txn_code, :hv_baid_txn_id;
	for (;;) {
		EXEC SQL FETCH c_fr_baid1_to_psp1
		INTO :v_psp_txn_1_id:ind_psp_txn_1_id;

		if (SQLCODE == SQL_NOT_FOUND) {
			if (iCnt == 0) {
DEBUGLOG(("fr_baid1_to_psp1: no record found\n"));
				iRet = PD_ERR;
			}
			break;
		}

		if (ind_psp_txn_1_id >= 0) {
			v_psp_txn_1_id.arr[v_psp_txn_1_id.len] = '\0';
DEBUGLOG(("fr_baid1_to_psp1: psp_txn_1_id = [%s]\n", (const char*)v_psp_txn_1_id.arr));
			PutField_CString(hContext, "psp_txn_1_id", (const char*)v_psp_txn_1_id.arr);
			iCnt++;
		} else {
DEBUGLOG(("fr_baid1_to_psp1: psp_txn_1_id not found\n"));
			return PD_ERR;
		}
	}
	EXEC SQL CLOSE c_fr_baid1_to_psp1;

DEBUGLOG(("fr_baid1_to_psp1 Normal Exit\n"));
	return iRet;

fr_baid1_to_psp1_error:
DEBUGLOG(("fr_baid1_to_psp1_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLStmtMatchEngine fr_baid1_to_psp1_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE c_fr_baid1_to_psp1;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int fr_psp1_to_psp2(hash_t *hContext)
{
	char *csTmp;

	EXEC SQL WHENEVER SQLERROR GOTO fr_psp1_to_psp2_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_psp_txn_1_id[PD_TXN_SEQ_LEN];
		varchar v_psp_txn_2_id[PD_TXN_SEQ_LEN + 1];
		short ind_psp_txn_2_id = -1;
	EXEC SQL END DECLARE SECTION;

	// get psp_txn_1_id
	if (!GetField_CString(hContext, "psp_txn_1_id", &csTmp)) {
DEBUGLOG(("fr_psp1_to_psp2:: psp_txn_1_id not found\n"));
		return PD_ERR;
	} else {
DEBUGLOG(("fr_psp1_to_psp2:: psp_txn_1_id = [%s]\n", csTmp));
		hv_psp_txn_1_id.len = strlen(csTmp);
		memcpy(hv_psp_txn_1_id.arr, csTmp, hv_psp_txn_1_id.len);
	}

	EXEC SQL SELECT oth_org_txn_id
				INTO :v_psp_txn_2_id:ind_psp_txn_2_id
				FROM ol_txn_header
				WHERE oth_txn_id = :hv_psp_txn_1_id;

	if (ind_psp_txn_2_id >= 0) {
		v_psp_txn_2_id.arr[v_psp_txn_2_id.len] = '\0';
DEBUGLOG(("fr_psp1_to_psp2: psp_txn_2_id = [%s]\n", (const char*)v_psp_txn_2_id.arr));
		PutField_CString(hContext, "psp_txn_2_id", (const char*)v_psp_txn_2_id.arr);
	} else {
DEBUGLOG(("fr_psp1_to_psp2: psp_txn_2_id not found\n"));
		return PD_ERR;
	}

DEBUGLOG(("fr_psp1_to_psp2 Normal Exit\n"));
	return PD_OK;

fr_psp1_to_psp2_error:
DEBUGLOG(("fr_psp1_to_psp2_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLStmtMatchEngine fr_psp1_to_psp2_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}
