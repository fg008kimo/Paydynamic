/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/10/31              Dirk Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "internal.h"
#include "dbutility.h"
#include "OLStmtMatchEngine.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void OLStmtMatchEngine(char cdebug)
{
        cDebug = cdebug;
}

/*
int GetStmtRule(const hash_t *hRls, recordset_t *myRec)
{
	int iRet = PD_ERR;

	char *csTmp;

	int iCnt;

	hash_t *myHash;
	myHash = (hash_t*) malloc (sizeof(hash_t));
	hash_init(myHash, 0);

	EXEC SQL WHENEVER SQLERROR GOTO getstmtruleerror;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_trigger_type[PD_TRIGGER_TYPE];
		varchar	hv_bank_acct_type[PD_ACCT_TYPE_LEN];
		varchar	hv_baid_txn_code[PD_TXN_CODE_LEN];

		//Recordset data
		int     v_rule_id;
		int	v_sub_rule_id;
		int	v_action_seq;
		varchar	v_action_type[PD_STMT_MATCH_ACTION_DESC_LEN+1];
		int	v_action_filter_id;
		int	v_exit_on_error;
		varchar	v_party[PD_STMT_MATCH_PARTY_LEN+1];
		varchar	v_filter[PD_STMT_MATCH_FILTER_LEN+1];
		varchar	v_operator[PD_STMT_MATCH_OPERATOR_LEN+1];
		varchar v_value[PD_STMT_MATCH_VALUE_LEN+1];

		short   ind_rule_id = -1;
		short   ind_sub_rule_id = -1;
		short   ind_action_seq = -1;
		short	ind_action_type = -1;
		short	ind_action_filter_id = -1;
		short	ind_exit_on_error = -1;
		short	ind_party = -1;
		short	ind_filter = -1;
		short	ind_operator = -1;
		short	ind_value = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hRls,"trigger_type",&csTmp)) {
		hv_trigger_type.len = strlen(csTmp);
		strncpy((char*)hv_trigger_type.arr, csTmp, hv_trigger_type.len);
DEBUGLOG(("GetStmtRule trigger_type = [%s]\n", hv_trigger_type.len, hv_trigger_type.arr));
	} else {
DEBUGLOG(("GetStmtRule trigger_type NOT FOUND!\n"));
		iRet = INT_TRIGGER_TYPE_NOT_FOUND;
	}

	if (GetField_CString(hRls,"bank_acct_type",&csTmp)) {
		hv_bank_acct_type.len = strlen(csTmp);
		strncpy((char*)hv_bank_acct_type.arr, csTmp, hv_bank_acct_type.len);
DEBUGLOG(("GetStmtRule bank_acct_type = [%s]\n", hv_bank_acct_type.len, hv_bank_acct_type.arr));
	} else {
DEBUGLOG(("GetStmtRule bank_acct_type NOT FOUND!\n"));
		iRet = INT_AC_NATURE_NOT_FOUND;
	}

	if (GetField_CString(hRls,"txn_code",&csTmp)) {
		hv_baid_txn_code.len = strlen(csTmp);
		strncpy((char*)hv_baid_txn_code.arr, csTmp, hv_baid_txn_code.len);
DEBUGLOG(("GetStmtRule txn_code = [%s]\n", hv_baid_txn_code.len, hv_baid_txn_code.arr));
	} else {
DEBUGLOG(("GetStmtRule txn_code NOT FOUND!\n"));
		iRet = INT_BAID_TXN_CODE_NOT_FOUND;
	}

	EXEC SQL DECLARE getstmtrulecursor CURSOR FOR
		SELECT	OSME_RULE_ID,
			OSMR_SUB_RULE_ID,
			OSMR_ACTION_SEQ, 
			OSMR_ACTION_TYPE, 
			OSMR_ACTION_FILTER_ID, 
			OSMR_EXIT_ON_ERROR,
			OSMF_PARTY,
			OSMF_FILTER,
			OSMF_OPERATOR,
			OSMF_VALUE
		FROM	(SELECT	OSME_RULE_ID,
				OSMR_SUB_RULE_ID, 
				OSMR_ACTION_SEQ, 
				OSMR_ACTION_TYPE, 
				OSMR_ACTION_FILTER_ID, 
				OSMR_EXIT_ON_ERROR
			 FROM	OL_STMT_MATCH_ENGINE,
				OL_STMT_MATCH_RULE
			 WHERE	OSME_TRIGGER_TYPE = :hv_trigger_type 
			 AND	OSME_BANK_ACCT_TYPE = :hv_bank_acct_type
			 AND	OSME_BAID_TXN_CODE = :hv_baid_txn_code
			 AND	OSME_DISABLED = 0
			 AND	OSMR_DISABLED = 0
			 AND	OSME_RULE_ID = OSMR_RULE_ID
			) tblA,
			(SELECT	OSMF_ACTION_FILTER_ID,
				OSMF_PARTY,
				OSMF_FILTER,
				OSMF_OPERATOR,
				OSMF_VALUE 
			 FROM	OL_STMT_MATCH_FILTER
			 WHERE	OSMF_DISABLED = 0
			) tblB
		WHERE   tblA.OSMR_ACTION_FILTER_ID = tblB.OSMF_ACTION_FILTER_ID(+)
		ORDER BY tblA.OSME_RULE_ID,
			 tblA.OSMR_SUB_RULE_ID,
			 tblA.OSMR_ACTION_SEQ;

	EXEC SQL OPEN getstmtrulecursor;
	for (;;) {
		EXEC SQL FETCH getstmtrulecursor
		INTO	:v_rule_id:ind_rule_id,
			:v_sub_rule_id:ind_sub_rule_id,
			:v_action_seq:ind_action_seq,
			:v_action_type:ind_action_type,
			:v_action_filter_id:ind_action_filter_id,
			:v_exit_on_error:ind_exit_on_error,
			:v_party:ind_party,
			:v_filter:ind_filter,
			:v_operator:ind_operator,
			:v_value:ind_value;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

		//rule_id
		if (ind_rule_id >= 0) {
			PutField_Int(myHash, "rule_id", v_rule_id);
DEBUGLOG(("GetStmtRule rule_id = [%d]\n", v_rule_id));
		}

		//sub_rule_id
		if (ind_sub_rule_id >= 0) {
			PutField_Int(myHash, "sub_rule_id", v_sub_rule_id);
DEBUGLOG(("GetStmtRule sub_rule_id = [%d]\n", v_sub_rule_id));
		}

		//action_seq
		if (ind_action_seq >= 0) {
			PutField_Int(myHash, "action_seq", v_action_seq);
DEBUGLOG(("GetStmtRule action_seq = [%d]\n", v_action_seq));
		}

		//action_type
		if (ind_action_type >= 0) {
			v_action_type.arr[v_action_type.len] = '\0';
			PutField_CString(myHash, "action_type", (const char*)v_action_type.arr);
DEBUGLOG(("GetStmtRule action_type = [%s]\n", v_action_type.arr));
		}
		
		//action_filter_id
		if (ind_action_filter_id >= 0) {
			PutField_Int(myHash, "action_filter_id", v_action_filter_id);
DEBUGLOG(("GetStmtRule action_filter_id = [%d]\n", v_action_filter_id));
		}

		//exit_on_error
		if (ind_exit_on_error >= 0) {
			PutField_Int(myHash, "exit_on_error", v_exit_on_error);
DEBUGLOG(("GetStmtRule exit_on_error = [%d]\n", v_exit_on_error));
		}

		//party
		if (ind_party >= 0) {
			v_party.arr[v_party.len] = '\0';
			PutField_CString(myHash, "party", (const char*)v_party.arr);
DEBUGLOG(("GetStmtRule party = [%s]\n", v_party.arr));
		}

		//filter
		if (ind_filter >= 0) {
			v_filter.arr[v_filter.len] = '\0';
			PutField_CString(myHash, "filter", (const char*)v_filter.arr);
DEBUGLOG(("GetStmtRule filter = [%s]\n", v_filter.arr));
		}

		//operator
		if (ind_operator >= 0) {
			v_operator.arr[v_operator.len] = '\0';
			PutField_CString(myHash, "operator", (const char*)v_operator.arr);
DEBUGLOG(("GetStmtRule operator = [%s]\n", v_operator.arr));
		}

		//value
		if (ind_value >= 0) {
			v_value.arr[v_value.len] = '\0';
			PutField_CString(myHash, "value", (const char*)v_value.arr);
DEBUGLOG(("GetStmtRule value = [%s]\n", v_value.arr));
		}

		RecordSet_Add(myRec, myHash);
	}
	EXEC SQL CLOSE getstmtrulecursor;

	if (iCnt > 0 ) {
DEBUGLOG(("GetStmtRule normal exit\n"));
	} else {
DEBUGLOG(("GetStmtRule data not found\n"));
	}

	return iRet;

getstmtruleerror:
DEBUGLOG(("getstmtrule_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE getstmtrulecursor;
	return PD_ERR;
}
*/

int GetStmtRule(const hash_t *hRls, recordset_t *myRec)
{
	int iRet = PD_OK;
	char *csTmp;
	int iCnt;
	int iLastSubRuleId;
	int iLastActionSeq;
	int iLastActionFilterId;
	int iIndex;

	char *csTag = (char*) malloc (64);

	hash_t *myHash;
	myHash = (hash_t*) malloc (sizeof(hash_t));
	hash_init(myHash, 0);

	EXEC SQL WHENEVER SQLERROR GOTO getstmtrule_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_trigger_type[PD_TRIGGER_TYPE_LEN];
		varchar hv_bank_acct_type[PD_ACCT_TYPE_LEN];
		varchar hv_baid_txn_code[PD_TXN_CODE_LEN];

		int v_sub_rule_id;
		int v_action_seq;
		varchar v_action_type[PD_STMT_MATCH_ACTION_DESC_LEN + 1];
		int v_action_filter_id;
		int v_exit_on_error;
		varchar v_party[PD_STMT_MATCH_PARTY_LEN + 1];
		varchar v_filter[PD_STMT_MATCH_FILTER_LEN + 1];
		varchar v_operator[PD_STMT_MATCH_OPERATOR_LEN + 1];
		varchar v_value[PD_STMT_MATCH_VALUE_LEN + 1];

		short ind_sub_rule_id = -1;
		short ind_action_seq = -1;
		short ind_action_type = -1;
		short ind_action_filter_id = -1;
		short ind_exit_on_error = -1;
		short ind_party = -1;
		short ind_filter = -1;
		short ind_operator = -1;
		short ind_value = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hRls, "trigger_type", &csTmp)) {
		hv_trigger_type.len = strlen(csTmp);
		strncpy((char*)hv_trigger_type.arr, csTmp, hv_trigger_type.len);
DEBUGLOG(("GetStmtRule trigger_type = [%.*s]\n", hv_trigger_type.len, (const char*)hv_trigger_type.arr));
	} else {
DEBUGLOG(("GetStmtRule trigger_type not found!\n"));
		iRet = PD_ERR;
	}

	if (GetField_CString(hRls, "bank_acct_type", &csTmp)) {
		hv_bank_acct_type.len = strlen(csTmp);
		strncpy((char*)hv_bank_acct_type.arr, csTmp, hv_bank_acct_type.len);
DEBUGLOG(("GetStmtRule bank_acct_type = [%.*s]\n", hv_bank_acct_type.len, (const char*)hv_bank_acct_type.arr));
	} else {
DEBUGLOG(("GetStmtRule bank_acct_type not found!\n"));
		iRet = PD_ERR;
	}

	if (GetField_CString(hRls, "baid_txn_code", &csTmp)) {
		hv_baid_txn_code.len = strlen(csTmp);
		strncpy((char*)hv_baid_txn_code.arr, csTmp, hv_baid_txn_code.len);
DEBUGLOG(("GetStmtRule baid_txn_code = [%.*s]\n", hv_baid_txn_code.len, (const char*)hv_baid_txn_code.arr));
	} else {
DEBUGLOG(("GetStmtRule baid_txn_code not found!\n"));
		iRet = PD_ERR;
	}

	EXEC SQL DECLARE c_getstmtrule CURSOR FOR
		SELECT	OSMR_SUB_RULE_ID,
			OSMR_ACTION_SEQ, 
			OSMR_ACTION_TYPE, 
			OSMR_ACTION_FILTER_ID, 
			OSMR_EXIT_ON_ERROR,
			OSMF_PARTY,
			OSMF_FILTER,
			OSMF_OPERATOR,
			OSMF_VALUE
		FROM	(SELECT	OSMR_SUB_RULE_ID, 
				OSMR_ACTION_SEQ, 
				OSMR_ACTION_TYPE, 
				OSMR_ACTION_FILTER_ID, 
				OSMR_EXIT_ON_ERROR
				FROM	OL_STMT_MATCH_ENGINE,
					OL_STMT_MATCH_RULE
				WHERE	OSME_TRIGGER_TYPE = :hv_trigger_type 
				AND	OSME_BANK_ACCT_TYPE = :hv_bank_acct_type
				AND	OSME_BAID_TXN_CODE = :hv_baid_txn_code
				AND	OSME_DISABLED = 0
				AND	OSMR_DISABLED = 0
				AND	OSME_RULE_ID = OSMR_RULE_ID
				) rule,
				(SELECT	OSMF_ACTION_FILTER_ID,
					OSMF_PARTY,
					OSMF_FILTER,
					OSMF_OPERATOR,
					OSMF_VALUE 
				FROM	OL_STMT_MATCH_FILTER
				WHERE	OSMF_DISABLED = 0
				) filter
		WHERE	rule.OSMR_ACTION_FILTER_ID = filter.OSMF_ACTION_FILTER_ID(+)
		ORDER BY	rule.OSMR_SUB_RULE_ID,
				rule.OSMR_ACTION_SEQ;

	if (iRet == PD_OK) {
		EXEC SQL OPEN c_getstmtrule;

		for (;;) {
			EXEC SQL FETCH c_getstmtrule
			INTO	:v_sub_rule_id:ind_sub_rule_id,
				:v_action_seq:ind_action_seq,
				:v_action_type:ind_action_type,
				:v_action_filter_id:ind_action_filter_id,
				:v_exit_on_error:ind_exit_on_error,
				:v_party:ind_party,
				:v_filter:ind_filter,
				:v_operator:ind_operator,
				:v_value:ind_value;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			iCnt++;

			if ((ind_sub_rule_id >= 0) &&
				(ind_action_seq >= 0) &&
				(ind_action_type >= 0) &&
				(ind_action_filter_id >= 0) &&
				(ind_exit_on_error >= 0))
			{
				if (iCnt == 1) {

					// sub_rule_id
					PutField_Int(myHash, "sub_rule_id", v_sub_rule_id);
DEBUGLOG(("GetStmtRule sub_rule_id = [%d]\n", v_sub_rule_id));
					// action_seq
					PutField_Int(myHash, "action_seq", v_action_seq);
DEBUGLOG(("GetStmtRule action_seq = [%d]\n", v_action_seq));
					// action_type
					v_action_type.arr[v_action_type.len] = '\0';
					PutField_CString(myHash, "action_type", (const char*)v_action_type.arr);
DEBUGLOG(("GetStmtRule action_type = [%s]\n", (const char*)v_action_type.arr));
					// action_filter_id
					PutField_Int(myHash, "action_filter_id", v_action_filter_id);
DEBUGLOG(("GetStmtRule action_filter_id = [%d]\n", v_action_filter_id));
					// exit_on_error
					PutField_Int(myHash, "exit_on_error", v_exit_on_error);
DEBUGLOG(("GetStmtRule exit_on_error = [%d]\n", v_exit_on_error));

					iLastSubRuleId = v_sub_rule_id;
					iLastActionSeq = v_action_seq;
					iLastActionFilterId = v_action_filter_id;
					iIndex = 0;
				} else {
					if ((v_sub_rule_id != iLastSubRuleId) ||
						(v_action_seq != iLastActionSeq)) {

						PutField_Int(myHash, "field_cnt", iIndex);
						RecordSet_Add(myRec, myHash);
DEBUGLOG(("GetStmtRule: hash added - sub_rule_id = [%d], action_seq = [%d], action_filter_id = [%d], field_cnt = [%d]\n", iLastSubRuleId, iLastActionSeq, iLastActionFilterId, iIndex));
DEBUGLOG(("\n"));

						myHash = (hash_t*) malloc (sizeof(hash_t));
						hash_init(myHash, 0);

						// sub_rule_id
						PutField_Int(myHash, "sub_rule_id", v_sub_rule_id);
DEBUGLOG(("GetStmtRule sub_rule_id = [%d]\n", v_sub_rule_id));
						// action_seq
						PutField_Int(myHash, "action_seq", v_action_seq);
DEBUGLOG(("GetStmtRule action_seq = [%d]\n", v_action_seq));
						// action_type
						v_action_type.arr[v_action_type.len] = '\0';
						PutField_CString(myHash, "action_type", (const char*)v_action_type.arr);
DEBUGLOG(("GetStmtRule action_type = [%s]\n", (const char*)v_action_type.arr));
						// action_filter_id
						PutField_Int(myHash, "action_filter_id", v_action_filter_id);
DEBUGLOG(("GetStmtRule action_filter_id = [%d]\n", v_action_filter_id));
						// exit_on_error
						PutField_Int(myHash, "exit_on_error", v_exit_on_error);
DEBUGLOG(("GetStmtRule exit_on_error = [%d]\n", v_exit_on_error));

						iLastSubRuleId = v_sub_rule_id;
						iLastActionSeq = v_action_seq;
						iIndex = 0;
					}
					iLastActionFilterId = v_action_filter_id;
				}
			}

			if (v_action_filter_id != 0) {
				iIndex++;
			}

			// party
			if (ind_party >= 0) {
				v_party.arr[v_party.len] = '\0';
				sprintf(csTag, "party_%d", iIndex);
				PutField_CString(myHash, csTag, (const char*)v_party.arr);
DEBUGLOG(("GetStmtRule [%s] = [%s]\n", csTag, (const char*)v_party.arr));
			}

			// filter
			if (ind_filter >= 0) {
				v_filter.arr[v_filter.len] = '\0';
				sprintf(csTag, "filter_%d", iIndex);
				PutField_CString(myHash, csTag, (const char*)v_filter.arr);
DEBUGLOG(("GetStmtRule [%s] = [%s]\n", csTag, (const char*)v_filter.arr));
			}

			// operator
			if (ind_operator >= 0) {
				v_operator.arr[v_operator.len] = '\0';
				sprintf(csTag, "operator_%d", iIndex);
				PutField_CString(myHash, csTag, (const char*)v_operator.arr);
DEBUGLOG(("GetStmtRule [%s] = [%s]\n", csTag, (const char*)v_operator.arr));
			}

			// value
			if (ind_value >= 0) {
				v_value.arr[v_value.len] = '\0';
				sprintf(csTag, "value_%d", iIndex);
				PutField_CString(myHash, csTag, (const char*)v_value.arr);
DEBUGLOG(("GetStmtRule [%s] = [%s]\n", csTag, (const char*)v_value.arr));
			}
		}

		EXEC SQL CLOSE c_getstmtrule;

		if (iCnt > 0 ) {
			PutField_Int(myHash, "field_cnt", iIndex);
			RecordSet_Add(myRec, myHash);
DEBUGLOG(("GetStmtRule: hash added - sub_rule_id = [%d], action_seq = [%d], action_filter_id = [%d], field_cnt = [%d]\n", iLastSubRuleId, iLastActionSeq, iLastActionFilterId, iIndex));
DEBUGLOG(("\n"));
			iRet = PD_OK;
		} else {
DEBUGLOG(("GetStmtRule not found\n"));
ERRLOG("OLStmtMatchEngine:: GetStmtRule not found\n");
			iRet = PD_ERR;
		}
	}

	free(csTag);

DEBUGLOG(("GetStmtRule Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getstmtrule_error:
DEBUGLOG(("getstmtrule_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("OLStmtMatchEngine getstmtrule_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE c_getstmtrule;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

