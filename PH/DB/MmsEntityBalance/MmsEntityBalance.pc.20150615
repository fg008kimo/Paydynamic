/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/04/29              David Wong
replace nature by imitate pid			   2015/05/20		   LokMan Chow
replace imitate pid by nature_id		   2015/06/10		   Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "MmsEntityBalance.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char cDebug;

void MmsEntityBalance(char cdebug)
{
	cDebug = cdebug;
}


int Update(const hash_t *hRec)
{
	char *csTmp;
	double dTmp;

	EXEC SQL WHENEVER SQLERROR GOTO update_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_entity_id[PD_MMS_ENTITY_ID_LEN];
		varchar hv_from_ccy[PD_CCY_ID_LEN];
		varchar hv_ccy[PD_CCY_ID_LEN];
		varchar hv_nature_id[PD_NATURE_ID_LEN];
		double hv_acct_bal;
		double hv_prepaid;
		double hv_intransit;
		double hv_lien;
		varchar hv_update_user[PD_UPDATE_USER_LEN];

		short ind_entity_id = -1;
		short ind_from_ccy = -1;
		short ind_ccy = -1;
		short ind_nature_id = -1;
		short ind_acct_bal = -1;
		short ind_prepaid = -1;
		short ind_intransit = -1;
		short ind_lien = -1;
		short ind_update_user = -1;

		short hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));

	if (GetField_CString(hRec, "entity_id", &csTmp)) {
		hv_entity_id.len = strlen(csTmp);
		strncpy((char *)hv_entity_id.arr, csTmp, hv_entity_id.len);
		ind_entity_id = 0;
DEBUGLOG(("Update: entity_id = [%.*s]\n", hv_entity_id.len, hv_entity_id.arr));
	}

	if (GetField_CString(hRec, "from_ccy", &csTmp)) {
		hv_from_ccy.len = strlen(csTmp);
		strncpy((char *)hv_from_ccy.arr, csTmp, hv_from_ccy.len);
		ind_from_ccy = 0;
DEBUGLOG(("Update: from_ccy = [%.*s]\n", hv_from_ccy.len, hv_from_ccy.arr));
	}

	if (GetField_CString(hRec, "ccy", &csTmp)) {
		hv_ccy.len = strlen(csTmp);
		strncpy((char *)hv_ccy.arr, csTmp, hv_ccy.len);
		ind_ccy = 0;
DEBUGLOG(("Update: ccy = [%.*s]\n", hv_ccy.len, hv_ccy.arr));
	}

	if (GetField_CString(hRec, "nature_id", &csTmp)) {
		hv_nature_id.len = strlen(csTmp);
		strncpy((char *)hv_nature_id.arr, csTmp, hv_nature_id.len);
		ind_nature_id = 0;
DEBUGLOG(("Update: nature_id = [%.*s]\n", hv_nature_id.len, hv_nature_id.arr));
	}

	if (GetField_Double(hRec, "acct_bal", &dTmp)) {
		hv_acct_bal = dTmp;
DEBUGLOG(("Update: acct_bal = [%f]\n", hv_acct_bal));
	} else {
		hv_acct_bal = 0.0;
	}
	ind_acct_bal = 0;

	if (GetField_Double(hRec, "prepaid", &dTmp)) {
		hv_prepaid = dTmp;
DEBUGLOG(("Update: prepaid = [%f]\n", hv_prepaid));
	} else {
		hv_prepaid = 0.0;
	}
	ind_prepaid = 0;

	if (GetField_Double(hRec, "intransit", &dTmp)) {
		hv_intransit = dTmp;
DEBUGLOG(("Update: intransit = [%f]\n", hv_intransit));
	} else {
		hv_intransit = 0.0;
	}
	ind_intransit = 0;

	if (GetField_Double(hRec, "lien", &dTmp)) {
		hv_lien = dTmp;
DEBUGLOG(("Update: lien = [%f]\n", hv_lien));
	} else {
		hv_lien = 0.0;
	}
	ind_lien = 0;

	if (GetField_CString(hRec, "update_user", &csTmp)) {
		hv_update_user.len = strlen(csTmp);
		strncpy((char *)hv_update_user.arr, csTmp, hv_update_user.len);
		ind_update_user = 0;
DEBUGLOG(("Update: update_user = [%.*s]\n", hv_update_user.len, hv_update_user.arr));
	}

	EXEC SQL EXECUTE
		BEGIN
		:hv_return_value := sp_mms_entity_balance_update(
					:hv_entity_id:ind_entity_id,
					:hv_from_ccy:ind_from_ccy,
					:hv_ccy:ind_ccy,
					:hv_nature_id:ind_nature_id,
					:hv_acct_bal:ind_acct_bal,
					:hv_prepaid:ind_prepaid,
					:hv_intransit:ind_intransit,
					:hv_lien:ind_lien,
					:hv_update_user:ind_update_user);
		END;
	END-EXEC;

DEBUGLOG(("Update: Ret = [%d]\n", hv_return_value));

	if (hv_return_value == SP_OK) {
DEBUGLOG(("Update: Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
ERRLOG("MmsEntityBalance_Update: SP_OTHER_ERR\n");
DEBUGLOG(("Update: SP_OTHER_ERR\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
ERRLOG("MmsEntityBalance_Update: SP_ERR\n");
DEBUGLOG(("Update: SP_ERR\n"));
		return PD_ERR;
	}

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MmsEntityBalance_Update: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int GetEntityBalance(const hash_t *hRec, recordset_t *myRec)
{
	int iRet = PD_OK;

	char *csTmp;
	int iCnt;

	hash_t *myHash;

	EXEC SQL WHENEVER SQLERROR GOTO getentitybalance_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_entity_id[PD_MMS_ENTITY_ID_LEN];
		varchar hv_from_ccy[PD_CCY_ID_LEN];
		varchar hv_ccy[PD_CCY_ID_LEN];
		varchar hv_nature_id[PD_NATURE_ID_LEN];

		double v_acct_bal;
		double v_prepaid;
		double v_intransit;
		double v_lien;
		short ind_acct_bal = -1;
		short ind_prepaid = -1;
		short ind_intransit = -1;
		short ind_lien = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hRec, "entity_id", &csTmp)) {
		hv_entity_id.len = strlen(csTmp);
		strncpy((char *)hv_entity_id.arr, csTmp, hv_entity_id.len);
DEBUGLOG(("GetEntityBalance: entity_id = [%.*s]\n", hv_entity_id.len, hv_entity_id.arr));
	}

	if (GetField_CString(hRec, "from_ccy", &csTmp)) {
		hv_from_ccy.len = strlen(csTmp);
		strncpy((char *)hv_from_ccy.arr, csTmp, hv_from_ccy.len);
DEBUGLOG(("GetEntityBalance: from_ccy = [%.*s]\n", hv_from_ccy.len, hv_from_ccy.arr));
	}

	if (GetField_CString(hRec, "ccy", &csTmp)) {
		hv_ccy.len = strlen(csTmp);
		strncpy((char *)hv_ccy.arr, csTmp, hv_ccy.len);
DEBUGLOG(("GetEntityBalance: ccy = [%.*s]\n", hv_ccy.len, hv_ccy.arr));
	}

	if (GetField_CString(hRec, "nature_id", &csTmp)) {
		hv_nature_id.len = strlen(csTmp);
		strncpy((char *)hv_nature_id.arr, csTmp, hv_nature_id.len);
DEBUGLOG(("GetEntityBalance: nature_id = [%.*s]\n", hv_nature_id.len, hv_nature_id.arr));
	}

	if (iRet == PD_OK) {
		EXEC SQL DECLARE c_getentitybalance CURSOR FOR
			SELECT	meb_acct_bal,
					meb_prepaid,
					meb_intransit,
					meb_lien
			FROM	mms_entity_balance
			WHERE	meb_entity_id = :hv_entity_id
			AND		meb_from_ccy = :hv_from_ccy
			AND		meb_ccy = :hv_ccy
			AND		meb_nature_id = :hv_nature_id;

		EXEC SQL OPEN c_getentitybalance;
		for (;;) {
			EXEC SQL FETCH c_getentitybalance
			INTO	:v_acct_bal:ind_acct_bal,
					:v_prepaid:ind_prepaid,
					:v_intransit:ind_intransit,
					:v_lien:ind_lien;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			iCnt++;

			myHash = (hash_t*) malloc (sizeof(hash_t));
			hash_init(myHash, 0);

			if (ind_acct_bal >= 0) {
				PutField_Double(myHash, "acct_bal", v_acct_bal);
DEBUGLOG(("GetEntityBalance acct_bal = [%f]\n", v_acct_bal));
			}

			if (ind_prepaid >= 0) {
				PutField_Double(myHash, "prepaid", v_prepaid);
DEBUGLOG(("GetEntityBalance prepaid = [%f]\n", v_prepaid));
			}

			if (ind_intransit >= 0) {
				PutField_Double(myHash, "intransit", v_intransit);
DEBUGLOG(("GetEntityBalance intransit = [%f]\n", v_intransit));
			}

			if (ind_lien >= 0) {
				PutField_Double(myHash, "lien", v_lien);
DEBUGLOG(("GetEntityBalance lien = [%f]\n", v_lien));
			}

			RecordSet_Add(myRec, myHash);
		}
		EXEC SQL CLOSE c_getentitybalance;

		if (iCnt > 0) {
DEBUGLOG(("GetEntityBalance: recordset added\n"));
		} else {
DEBUGLOG(("GetEntityBalance no record found\n"));
ERRLOG("MmsEntityBalAcct:: GetEntityBalance no record found\n");
			iRet = PD_ERR;
		}
	}

DEBUGLOG(("GetEntityBalance Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getentitybalance_error:
DEBUGLOG(("getentitybalance_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MmsEntityPsp getentitybalance_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE c_getentitybalance;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int GetEntityBalanceForUpdate(const hash_t *hRec, recordset_t *myRec)
{
	int iRet = PD_OK;

	char *csTmp;
	int iCnt;

	hash_t *myHash;

	EXEC SQL WHENEVER SQLERROR GOTO getentitybalance_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_entity_id[PD_MMS_ENTITY_ID_LEN];
		varchar hv_from_ccy[PD_CCY_ID_LEN];
		varchar hv_ccy[PD_CCY_ID_LEN];
		varchar hv_nature_id[PD_NATURE_ID_LEN];

		double v_acct_bal;
		double v_prepaid;
		double v_intransit;
		double v_lien;
		short ind_acct_bal = -1;
		short ind_prepaid = -1;
		short ind_intransit = -1;
		short ind_lien = -1;
	EXEC SQL END DECLARE SECTION;

	if (GetField_CString(hRec, "entity_id", &csTmp)) {
		hv_entity_id.len = strlen(csTmp);
		strncpy((char *)hv_entity_id.arr, csTmp, hv_entity_id.len);
DEBUGLOG(("GetEntityBalanceForUpdate: entity_id = [%.*s]\n", hv_entity_id.len, hv_entity_id.arr));
	}

	if (GetField_CString(hRec, "from_ccy", &csTmp)) {
		hv_from_ccy.len = strlen(csTmp);
		strncpy((char *)hv_from_ccy.arr, csTmp, hv_from_ccy.len);
DEBUGLOG(("GetEntityBalanceForUpdate: from_ccy = [%.*s]\n", hv_from_ccy.len, hv_from_ccy.arr));
	}

	if (GetField_CString(hRec, "ccy", &csTmp)) {
		hv_ccy.len = strlen(csTmp);
		strncpy((char *)hv_ccy.arr, csTmp, hv_ccy.len);
DEBUGLOG(("GetEntityBalanceForUpdate: ccy = [%.*s]\n", hv_ccy.len, hv_ccy.arr));
	}

	if (GetField_CString(hRec, "nature_id", &csTmp)) {
		hv_nature_id.len = strlen(csTmp);
		strncpy((char *)hv_nature_id.arr, csTmp, hv_nature_id.len);
DEBUGLOG(("GetEntityBalanceForUpdate: nature_id = [%.*s]\n", hv_nature_id.len, hv_nature_id.arr));
	}

	if (iRet == PD_OK) {
		EXEC SQL DECLARE c_getentitybalanceforupdate CURSOR FOR
			SELECT	meb_acct_bal,
					meb_prepaid,
					meb_intransit,
					meb_lien
			FROM	mms_entity_balance
			WHERE	meb_entity_id = :hv_entity_id
			AND		meb_from_ccy = :hv_from_ccy
			AND		meb_ccy = :hv_ccy
			AND		meb_nature_id = :hv_nature_id
			FOR UPDATE;

		EXEC SQL OPEN c_getentitybalanceforupdate;
		for (;;) {
			EXEC SQL FETCH c_getentitybalanceforupdate
			INTO	:v_acct_bal:ind_acct_bal,
					:v_prepaid:ind_prepaid,
					:v_intransit:ind_intransit,
					:v_lien:ind_lien;

			if (SQLCODE == SQL_NOT_FOUND) {
				break;
			}

			iCnt++;

			myHash = (hash_t*) malloc (sizeof(hash_t));
			hash_init(myHash, 0);

			if (ind_acct_bal >= 0) {
				PutField_Double(myHash, "acct_bal", v_acct_bal);
DEBUGLOG(("GetEntityBalanceForUpdate acct_bal = [%f]\n", v_acct_bal));
			}

			if (ind_prepaid >= 0) {
				PutField_Double(myHash, "prepaid", v_prepaid);
DEBUGLOG(("GetEntityBalanceForUpdate prepaid = [%f]\n", v_prepaid));
			}

			if (ind_intransit >= 0) {
				PutField_Double(myHash, "intransit", v_intransit);
DEBUGLOG(("GetEntityBalanceForUpdate intransit = [%f]\n", v_intransit));
			}

			if (ind_lien >= 0) {
				PutField_Double(myHash, "lien", v_lien);
DEBUGLOG(("GetEntityBalanceForUpdate lien = [%f]\n", v_lien));
			}

			RecordSet_Add(myRec, myHash);
		}
		EXEC SQL CLOSE c_getentitybalanceforupdate;

		if (iCnt > 0) {
DEBUGLOG(("GetEntityBalanceForUpdate: recordset added\n"));
		} else {
DEBUGLOG(("GetEntityBalanceForUpdate no record found\n"));
ERRLOG("MmsEntityBalAcct:: GetEntityBalanceForUpdate no record found\n");
			iRet = PD_ERR;
		}
	}

DEBUGLOG(("GetEntityBalanceForUpdate Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

getentitybalance_error:
DEBUGLOG(("getentitybalance_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("MmsEntityPsp getentitybalance_error code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE c_getentitybalanceforupdate;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}
