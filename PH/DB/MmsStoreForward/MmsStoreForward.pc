/*
Partnerdelight (c)2015. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/05/29              Cody Chan
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <oraca.h>
#include <sqlca.h>
#include "MmsStoreForward.h"
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug;
void MmsStoreForward(char    cdebug)
{
        cDebug = cdebug;
}

int Add(const hash_t *hRls)
{
        char		*csTmp;
        char        	cTmp;
	int		iCommit = PD_TRUE;


        EXEC SQL WHENEVER SQLERROR GOTO add_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

        short 		hv_return_value;

	varchar		hv_txn_id[PD_TXN_SEQ_LEN];	
	varchar		hv_node_id[PD_MMS_NODE_ID_LEN];
	char		hv_to;
	char		hv_status;
	varchar		hv_add_user[PD_USER_LEN];



	short		ind_txn_id = -1;
	short		ind_node_id = -1;
	short		ind_to = -1;
	short		ind_status = -1;
	short		ind_add_user = -1;

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Add: Begin\n"));

        if (GetField_Int(hRls,"db_commit",&iCommit)) {
DEBUGLOG(("Add:db_commit = [%d]\n",iCommit));
	}


/* txn_seq */
        if (GetField_CString(hRls,"txn_seq",&csTmp)) {
                hv_txn_id.len = strlen(csTmp);
                memcpy(hv_txn_id.arr,csTmp,hv_txn_id.len);
                ind_txn_id = 0;
DEBUGLOG(("Add:txn_id = [%.*s]\n",hv_txn_id.len,hv_txn_id.arr));
        }
/* node_id */
        if (GetField_CString(hRls,"node_id",&csTmp)) {
                hv_node_id.len = strlen(csTmp);
                memcpy(hv_node_id.arr,csTmp,hv_node_id.len);
                ind_node_id = 0;
DEBUGLOG(("Add:node_id = [%.*s]\n",hv_node_id.len,hv_node_id.arr));
        }

/* direction_to */ 
        if (GetField_Char(hRls,"direction_to",&cTmp)) {
		hv_to = cTmp;
                ind_to = 0;
DEBUGLOG(("Add:direction_to = [%c]\n",hv_to));
	}

/* Status */ 
        if (GetField_Char(hRls,"status",&cTmp)) {
		hv_status = cTmp;
                ind_status = 0;
DEBUGLOG(("Add:status = [%c]\n",hv_status));
        }


/* add user */
        if (GetField_CString(hRls,"add_user",&csTmp)) {
                hv_add_user.len = strlen(csTmp);
                memcpy(hv_add_user.arr,csTmp,hv_add_user.len);
                ind_add_user = 0;
DEBUGLOG(("Add:add_user = [%.*s]\n",hv_add_user.len,hv_add_user.arr));
        }

	EXEC SQL EXECUTE
                BEGIN
			:hv_return_value := sp_mms_store_forward_insert(
					:hv_txn_id:ind_txn_id,
					:hv_node_id:ind_node_id,
					:hv_to:ind_to,
					:hv_status:ind_status,
					:hv_add_user:ind_add_user);
	        END;
        END-EXEC;



DEBUGLOG(("Add:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK) {
DEBUGLOG(("Add:Normal Exit\n"));
		if (iCommit == PD_TRUE)
			TxnCommit();
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("MmsTransaction_Add: SP_OTHER_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_OTHER_ERR TxnAbort\n"));
		TxnAbort();
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("MmsTransaction_Add: SP_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_ERR TxnAbort\n"));
		TxnAbort();
                return PD_ERR;
        }

add_error:
DEBUGLOG(("add_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("MmsStoreForward_Add: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Add: SP_INTERNAL_ERR TxnAbort\n"));
	TxnAbort();
        return PD_INTERNAL_ERR;
}


int GetPendingSF(const char cMode,
                recordset_t* myRec)
{

        hash_t *myHash;
DEBUGLOG(("GetPendingSF: begin()\n"));

        EXEC SQL WHENEVER SQLERROR GOTO getpendingsf_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                char    hv_status;
                char    hv_mode;

                varchar v_txn_id[PD_TXN_SEQ_LEN + 1];
                varchar v_node_id[PD_MMS_NODE_ID_LEN + 1];

                short   ind_txn_id = -1;
                short   ind_node_id = -1;

        EXEC SQL END DECLARE SECTION;


        hv_status = PD_MMS_SF_RETRY;
DEBUGLOG(("GetPendingSF status = [%c]\n",hv_status));

	hv_mode = cMode;
DEBUGLOG(("GetPendingSF mode = [%c]\n",hv_mode));

        EXEC SQL DECLARE c_cursor_getpendingsf CURSOR FOR
                select MSF_TXN_ID,
                       MSF_NODE_ID
                  from MMS_STORE_FORWARD
                 where MSF_STATUS = :hv_status
		 and  MSF_TO = :hv_mode
                 and  MSF_NEXT_TRY <  sysdate;

DEBUGLOG(("GetPendingSF: open cursor\n"));
        EXEC SQL OPEN c_cursor_getpendingsf;
        do {
                EXEC SQL FETCH c_cursor_getpendingsf
                INTO
                        :v_txn_id:ind_txn_id,
			:v_node_id:ind_node_id;

                if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("GetPendingSF: data not found\n"));
                        break;
                }

DEBUGLOG(("GetPendingSF: found data\n"));
                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

                if (ind_txn_id >= 0 ) {
                        v_txn_id.arr[v_txn_id.len] ='\0';
                        PutField_CString(myHash,"txn_id",(const char*)v_txn_id.arr);
DEBUGLOG(("GetPendingSF: txn_id = [%s]\n",(const char*)v_txn_id.arr));
                }
                if (ind_node_id >= 0 ) {
                        v_node_id.arr[v_node_id.len] ='\0';
                        PutField_CString(myHash,"node_id",(const char*)v_node_id.arr);
DEBUGLOG(("GetPendingSF: node_id = [%s]\n",(const char*)v_node_id.arr));
                }
                RecordSet_Add(myRec,myHash);
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getpendingsf;

DEBUGLOG(("GetPendingSF Normal Exit\n"));
        return  PD_OK;

getpendingsf_error:
DEBUGLOG(("getpendingsf_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getpendingsf;
        return PD_ERR;
}

