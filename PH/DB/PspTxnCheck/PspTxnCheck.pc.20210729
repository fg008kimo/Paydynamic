/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/06/25              Stan Poon
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "PspTxnCheck.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


char    cDebug;

void PspTxnCheck(char    cdebug)
{
        cDebug = cdebug;
}


int GetAll(recordset_t *myRec)
{
	int 	iCnt = 0;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getall_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		v_party_id[PD_PSP_ID_LEN + 1];
		varchar		v_cutoff_time[PD_DATETIME_LEN + 1];
		int		v_check_count;
		int		v_min_success_count;
		int		v_start_buffer_period;
		int		v_min_total;

		short		ind_party_id = -1;
		short		ind_cutoff_time = -1;
		short		ind_check_count = -1;
		short		ind_min_success_count = -1;
		short		ind_start_buffer_period = -1;
		short		ind_min_total = -1;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE c_cursor_getall CURSOR FOR
		SELECT	PC_PARTY_ID,
			TO_CHAR(PC_CUTOFF_CHECKING_TIME,'YYYYMMDDHH24MISS'),
			PC_CHECK_COUNT,
			PC_MIN_SUCCESS_COUNT,
			PC_START_BUFFER_PERIOD,
			PC_MIN_TOTAL
		FROM	PSP_TXN_CHECK
		WHERE	PC_DISABLED = 0;

        EXEC SQL OPEN c_cursor_getall;
        do {
		EXEC SQL FETCH c_cursor_getall
		INTO	:v_party_id:ind_party_id,
			:v_cutoff_time:ind_cutoff_time,
			:v_check_count:ind_check_count,
			:v_min_success_count:ind_min_success_count,
			:v_start_buffer_period:ind_start_buffer_period,
			:v_min_total:ind_min_total;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}	

		iCnt++;

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* party_id */	
		if (ind_party_id >= 0) {
			v_party_id.arr[v_party_id.len] = '\0';
			PutField_CString(myHash, "party_id", (const char *)v_party_id.arr);
DEBUGLOG(("GetAll party_id = [%s]\n",v_party_id.arr));
		}

/* cutoff_time */	
		if (ind_cutoff_time >= 0) {
			v_cutoff_time.arr[v_cutoff_time.len] = '\0';
			PutField_CString(myHash, "cutoff_time", (const char *)v_cutoff_time.arr);
DEBUGLOG(("GetAll cutoff_time = [%s]\n",v_cutoff_time.arr));
		}

/* check_count */
		if (ind_check_count >= 0) {
			PutField_Int(myHash, "check_count", v_check_count);
DEBUGLOG(("GetAll check_count = [%d]\n", v_check_count));
		}

/* min_success_count */
		if (ind_min_success_count >= 0) {
			PutField_Int(myHash, "min_success_count", v_min_success_count);
DEBUGLOG(("GetAll min_success_count = [%d]\n", v_min_success_count));
		}

/* start_buffer_period */
		if (ind_start_buffer_period >= 0) {
			PutField_Int(myHash, "start_buffer_period", v_start_buffer_period);
DEBUGLOG(("GetAll start_buffer_period = [%d]\n", v_start_buffer_period));
		}

/* min_total */
		if (ind_min_total >= 0) {
			PutField_Int(myHash, "min_total", v_min_total);
DEBUGLOG(("GetAll min_total = [%d]\n", v_min_total));
		}
	
		RecordSet_Add(myRec, myHash);
	}
	while (PD_TRUE);
	EXEC SQL CLOSE c_cursor_getall;

        if (iCnt > 0 ) {
DEBUGLOG(("GetAll Normal Exit\n"));
                return  PD_OK;
        }
        else {
DEBUGLOG(("GetAll Normal Exit, Not Found\n"));
                return PD_NOT_FOUND;
        }

getall_error:
DEBUGLOG(("getall_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getall;
        return PD_ERR;

}
