/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission 
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/06/25              [STP]
add Replicate                                      2021/07/29              [MIC]
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlca.h>
#include "common.h"
#include "utilitys.h"
#include "dbutility.h"
#include "PspTxnCheck.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


static char cDebug;

void PspTxnCheck(char    cdebug)
{
        cDebug = cdebug;
}

int Replicate(void)
{

	EXEC SQL WHENEVER SQLERROR GOTO replicate_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		
		char        hv_party_type;
		
		short       ind_party_type = -1;
		
		short       hv_return_value;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Replicate: Begin\n"));

/*party_type*/
	hv_party_type = PD_TYPE_PSP;
	ind_party_type = 0;
	


	EXEC SQL EXECUTE
	    BEGIN

		:hv_return_value := sp_psp_txn_check_rpl(
			:hv_party_type:ind_party_type
		);

	    END;
	END-EXEC;


DEBUGLOG(("Replicate:Ret = [%d]\n",hv_return_value));
	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("Replicate:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR)  {
		ERRLOG("PspTxnCheck_Replicate: SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("Replicate: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR)  {
		ERRLOG("PspTxnCheck_Replicate: SP_ERR TxnAbort\n");
		DEBUGLOG(("Replicate: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}


	if (hv_return_value == SP_NOT_FOUND)  {
		ERRLOG("PspTxnCheck_Replicate: SP_NOT_FOUND TxnAbort\n");
		DEBUGLOG(("Replicate: SP_NOT_FOUND TxnAbort\n"));
		return PD_NOT_FOUND;
	}

replicate_error:
DEBUGLOG(("replicate_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("PspTxnCheck_Replicate: SP_INTERNAL_ERR\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;


}



int GetAll(recordset_t *myRec)
{
	int 	iCnt = 0;
	hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getall_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		v_party_id[PD_PSP_ID_LEN + 1];
		varchar		v_cutoff_time[PD_DATETIME_LEN + 1];
		int		v_check_count;
		int		v_min_success_count;
		int		v_start_buffer_period;
		int		v_min_total;

		short		ind_party_id = -1;
		short		ind_cutoff_time = -1;
		short		ind_check_count = -1;
		short		ind_min_success_count = -1;
		short		ind_start_buffer_period = -1;
		short		ind_min_total = -1;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE c_cursor_getall CURSOR FOR
		SELECT	PC_PARTY_ID,
			TO_CHAR(PC_CUTOFF_CHECKING_TIME,'YYYYMMDDHH24MISS'),
			PC_CHECK_COUNT,
			PC_MIN_SUCCESS_COUNT,
			PC_START_BUFFER_PERIOD,
			PC_MIN_TOTAL
		FROM	PSP_TXN_CHECK
		WHERE	PC_DISABLED = 0;

        EXEC SQL OPEN c_cursor_getall;
        do {
		EXEC SQL FETCH c_cursor_getall
		INTO	:v_party_id:ind_party_id,
			:v_cutoff_time:ind_cutoff_time,
			:v_check_count:ind_check_count,
			:v_min_success_count:ind_min_success_count,
			:v_start_buffer_period:ind_start_buffer_period,
			:v_min_total:ind_min_total;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}	

		iCnt++;

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* party_id */	
		if (ind_party_id >= 0) {
			v_party_id.arr[v_party_id.len] = '\0';
			PutField_CString(myHash, "party_id", (const char *)v_party_id.arr);
DEBUGLOG(("GetAll party_id = [%s]\n",v_party_id.arr));
		}

/* cutoff_time */	
		if (ind_cutoff_time >= 0) {
			v_cutoff_time.arr[v_cutoff_time.len] = '\0';
			PutField_CString(myHash, "cutoff_time", (const char *)v_cutoff_time.arr);
DEBUGLOG(("GetAll cutoff_time = [%s]\n",v_cutoff_time.arr));
		}

/* check_count */
		if (ind_check_count >= 0) {
			PutField_Int(myHash, "check_count", v_check_count);
DEBUGLOG(("GetAll check_count = [%d]\n", v_check_count));
		}

/* min_success_count */
		if (ind_min_success_count >= 0) {
			PutField_Int(myHash, "min_success_count", v_min_success_count);
DEBUGLOG(("GetAll min_success_count = [%d]\n", v_min_success_count));
		}

/* start_buffer_period */
		if (ind_start_buffer_period >= 0) {
			PutField_Int(myHash, "start_buffer_period", v_start_buffer_period);
DEBUGLOG(("GetAll start_buffer_period = [%d]\n", v_start_buffer_period));
		}

/* min_total */
		if (ind_min_total >= 0) {
			PutField_Int(myHash, "min_total", v_min_total);
DEBUGLOG(("GetAll min_total = [%d]\n", v_min_total));
		}
	
		RecordSet_Add(myRec, myHash);
	}
	while (PD_TRUE);
	EXEC SQL CLOSE c_cursor_getall;

        if (iCnt > 0 ) {
DEBUGLOG(("GetAll Normal Exit\n"));
                return  PD_OK;
        }
        else {
DEBUGLOG(("GetAll Normal Exit, Not Found\n"));
                return PD_NOT_FOUND;
        }

getall_error:
DEBUGLOG(("getall_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getall;
        return PD_ERR;

}
