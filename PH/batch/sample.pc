#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "curl/curl.h"
#include "ObjPtr.h"
#include "myrecordset.h"
////#include "rsa.h"
//#include <openssl/rsa.h>

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode
#define MAX_MSG_SIZE 4096

OBJPTR(BO);

char	cDebug='Y';
char	csTxnIdList[2][PD_TXN_SEQ_LEN+1]={"N000000000003122","N000000000003121"};
char	csPOTxnIdList[2][PD_TXN_SEQ_LEN+1]={"U000000000173811","U000000000173842"};
char	csBaidTxnIdList[2][PD_TXN_SEQ_LEN+1]={"A000000000028061","A000000000028062"};
char	csSMSBaidTxnIdList[1][PD_TXN_SEQ_LEN+1]={"A000000000033581"};
char	csPOBaidTxnIdList[2][PD_TXN_SEQ_LEN+1]={"A000000000027935","A000000000027845"};


int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	double dAmt1 = 0.9963548;
	double dAmt2 = 1.0049995;

	printf("Amt 1 [%lf], after round-up [%lf]\n", dAmt1, newround(dAmt1, PD_DECIMAL_LEN));
	printf("Amt 2 [%lf], after round-up [%lf]\n", dAmt2, newround(dAmt2, PD_DECIMAL_LEN));

	return SUCCESS;
}

int batch_proc_other(int argc, char* argv[])
{
/*
	if(argc<2){
printf("Usage: Message\n");
		return FAILURE;
	}
	time_t now;
	time(&now);

	char csTime[PD_DATETIME_LEN];
	sprintf(csTime,"%ld",now);
printf("now:%s\n",csTime);
*/
/*

	char    *csBuf, *csOUT;
	csBuf = (char*) malloc (100);
	csOUT = (char*) malloc (40);

	csBuf[0]='\0';
	csOUT[0]='\0';

	
	sprintf(csBuf,"%s",argv[1]);
printf("input = [%s]\n",csBuf);

	sha256sum(csBuf,strlen(csBuf),csOUT);
printf("sign len= [%ld]\n",strlen(csOUT));

	//char outputBuffer[65];
	//Hex2Ascii(outputBuffer,(unsigned char*)csOUT,32 );
        //outputBuffer[64] = '\0';

printf("sign = [%s]\n", csOUT);

	csBuf[0] = '\0';
	U2L(csOUT,strlen(csOUT),csBuf);

printf("sign = [%s]\n", csBuf);
*/

/*
	int iRet = PD_OK;
	char	*csPtr = NULL;
	hash_t  *hContext;
	hContext = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hContext,0);
	hash_t  *hResponse;
	hResponse = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hResponse,0);


	PutField_CString(hContext,"rsa_key","plk_ttpe025_pri.pem");
	PutField_CString(hContext,"rsa_privatepem","plk_ttpe025_pub.pem");
	PutField_CString(hResponse,"auth_data",argv[1]);

	BOObjPtr = CreateObj(BOPtr,"BOSecurity","GenerateDinPaySign");
	iRet = (unsigned long)(*BOObjPtr)(hContext,hResponse);
printf("GenerateDinPaySign Result = [%d]\n", iRet);

	if(iRet == PD_OK){
		if(GetField_CString(hResponse, "sign", &csPtr)){
printf("sign = [%s]\n", csPtr);
		}

		BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyDinPaySign");
		iRet = (unsigned long)(*BOObjPtr)(hContext,hResponse);
printf("VerifyDinPaySign Result = [%d]\n", iRet);
	}

	FREE_ME(hContext);
	FREE_ME(hResponse);
*/
/*
	BOObjPtr = CreateObj(BOPtr,"BOSecurity","Decrypt3DESTxnSeq");
	char* csTmpBuf;
	csTmpBuf = (char*) malloc (PD_EN_TXN_SEQ_LEN +1);
	(BOObjPtr)(argv[1],csTmpBuf);
printf("txn id = [%s]\n", csTmpBuf);
*/

	return SUCCESS;
}

/*
int batch_proc_camc(int argc, char* argv[])
{
	if(argc<2){
printf("Usage: Message\n");
		return FAILURE;
	}

	int iRet = PD_OK;

	char *csKey = (char*) malloc (MAX_MSG_SIZE + 1 );
	strcpy(csKey,"FA14A14424610CF5");

	char *csMsg= (char*) malloc (MAX_MSG_SIZE + 1 );
	strcpy(csMsg,argv[1]);

	unsigned char mact[16] = {0};
	size_t mactlen;

	CMAC_CTX *ctx = CMAC_CTX_new();
	CMAC_Init(ctx, csKey , 16, EVP_aes_128_cbc(), NULL);
	printf("message length = %lu bytes (%lu bits)\n",sizeof(csMsg), sizeof(csMsg)*8);

	CMAC_Update(ctx, csMsg, sizeof(csMsg));
	CMAC_Final(ctx, mact, &mactlen);

	printf("%s [%d]\n",mact, mactlen);

	CMAC_CTX_free(ctx);


	FREE_ME(csKey);
	FREE_ME(csMsg);
	return SUCCESS;
}

*/






















int batch_proc_aes2(int argc, char* argv[])
{
	if(argc<2){
printf("Usage: Message\n");
		return FAILURE;
	}

	int iRet = PD_OK;
	int iLen = 0;
        char    *csData;
        char    *csDecryptedInfo;
	csData = (char*) malloc (MAX_MSG_SIZE + 1 );
	char *csEncData = (char*) malloc (MAX_MSG_SIZE + 1 );
        csDecryptedInfo = (char*) malloc (PD_MAX_BUFFER);

	memset(csData,0,sizeof(csData));
        memset(csDecryptedInfo,0,sizeof(csDecryptedInfo));
        BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESEncryptData");
	iRet = (unsigned long)(*BOObjPtr)("FA14A14424610CF5",argv[1],csData,&iLen);

	if (iRet == PD_OK) {

        	memset(csEncData,0,sizeof(csEncData));
		base64_encode((unsigned char *)csData,iLen,csEncData,PD_MAX_BUFFER);

printf("BOSecurity:AESEncryptData() encrypted data = [%d][%s]\n",iLen,csEncData);

		BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESDecryptData");
		iRet = (unsigned long)(*BOObjPtr)("FA14A14424610CF5",csData,iLen,csDecryptedInfo);
        }

	if (iRet == PD_OK) {
printf("BOSecurity:AESEncryptData() input data = [%s]\n",csDecryptedInfo);
        }

	FREE_ME(csData);
        FREE_ME(csDecryptedInfo);
        return SUCCESS;
}

int batch_proc_rsa(int argc, char* argv[])
{
	if(argc<2){
printf("Usage: Message\n");
		return FAILURE;
	}

	int iRet = PD_OK;
	char    *csData;
	char    *csDecryptedInfo;
	csData = (char*) malloc (PD_MAX_BUFFER);
	csDecryptedInfo = (char*) malloc (PD_MAX_BUFFER);

	memset(csData,0,sizeof(csData));
	memset(csDecryptedInfo,0,sizeof(csDecryptedInfo));
	BOObjPtr = CreateObj(BOPtr,"BOSecurity","RSAEncryptData");
	iRet = (unsigned long)(*BOObjPtr)("TESTP00001_pub.pem",argv[1],csData,0,1);

	if (iRet == PD_OK) {
printf("BOSecurity:RSAEncryptData() sign = [%s]\n",csData);
	}


	if (iRet == PD_OK) {
		BOObjPtr = CreateObj(BOPtr, "BOSecurity", "RSAEncryptData");
		iRet = (unsigned long)(*BOObjPtr)("PNP_TESTP00001_pri.pem", csData, csDecryptedInfo, 1, 0);
	}
	if (iRet == PD_OK) {
printf("BOSecurity:RSAEncryptData() Decrypted Info = [%s]\n",csDecryptedInfo);
	}


	FREE_ME(csData);
	FREE_ME(csDecryptedInfo);
	return SUCCESS;
}


int batch_proc_3des(int argc, char* argv[])
{
	if(argc<2){
printf("Usage: txn_id\n");
		return FAILURE;
	}

	char* csTmpBuf;
	csTmpBuf = (char*) malloc (PD_EN_TXN_SEQ_LEN +1);
	BOObjPtr = CreateObj(BOPtr,"BOSecurity","Encrypt3DESTxnSeq");
	(BOObjPtr)(argv[1],csTmpBuf);
printf("encrypt from [%s] to [%s]\n",argv[1],csTmpBuf);

	FREE_ME(csTmpBuf);
        return SUCCESS;
}



int batch_proc_po_split(int argc, char* argv[])
{
	//struct timeval  tv;
	//gettimeofday(&tv, NULL);
	//unsigned int time_msec = (tv.tv_sec)*1000 + (tv.tv_usec)/1000;
	//srand(time_msec);

	double dPayoutAmt = 250000.00;
	int iSplitCnt = 8;
	double dLeftAmt = dPayoutAmt;

	double dBaseAmt = 0.0; 
	sscanf(argv[1],"%lf",&dBaseAmt);
	//double dTotalRandom = dPayoutAmt - (double)dBaseAmt*iSplitCnt;

	int iRandMax = 32767;//(int)(dTotalRandom*5/iSplitCnt);
	double dIdx = 3.2;
	int iCnt = 0;
	
printf("To split a [%.2f] payout. Split Count = [%d]\n",dPayoutAmt,iSplitCnt);
printf("Base Amount [%s], Additional Amount [%s]\n",argv[1],argv[2]);

//printf("dBaseAmt = [%f], dTotalRandom = [%f], iRandMax = [%d]\n",dBaseAmt,dTotalRandom,iRandMax);

	while(iCnt<iSplitCnt-1){
		//struct timespec tv;
		//clock_gettime(CLOCK_REALTIME, &tv);
		struct timeval  tv;
		gettimeofday(&tv, NULL);

		unsigned int time_msec = (tv.tv_sec)*1000 + (tv.tv_usec)/1000;
		srand(time_msec+iCnt);
//printf("srand(time_msec+iCnt), (%d+%d)\n",time_msec,iCnt);

		int iRand = (int)(rand()%iRandMax);
		double dRandAmt = newround(((double)iRand/dIdx),2) + (double)atoi(argv[2]);
//printf("iRand = [%d], dRandAmt = [%f]\n",iRand,dRandAmt);

		double dTmpAmt = dBaseAmt + dRandAmt;
		dLeftAmt = dLeftAmt-dTmpAmt;

		iCnt++;
printf("iCnt = [%d], dTmpAmt = [%f], dLeftAmt = [%f]\n",iCnt,dTmpAmt,dLeftAmt);

	}

printf("iCnt = [%d], dTmpAmt = [%f]\n",iCnt+1,dLeftAmt);


	return 0;
}


int batch_proc_key(int argc, char* argv[])
{
	char* csYPKey;
	csYPKey = (char*) malloc (MAX_MSG_SIZE + 1 );
	memset(csYPKey,0,sizeof(csYPKey));

	unsigned char* csTmpDATA;
	csTmpDATA = (unsigned char*) malloc (MAX_MSG_SIZE + 1 );
	memset(csTmpDATA,0,sizeof(csTmpDATA));

	char* csDATA;
	csDATA = (char*) malloc (MAX_MSG_SIZE + 1 );
	memset(csDATA,0,sizeof(csDATA));

	char* csRetData = "jSPhtoMjKaPGns/XYUg1XVTSbcJD6IqnFhtvrwwhgv8GuvZqU9GlHbPOphx4a1ZFJJHqYha/JNodTyNlbY7+7OjVhdQYENZI3JVPQCjs8/TXg/NcVLvCrN14J1d9cQJ+mkQj9JLDOcJ9uV2HeCyPdrSsrUil5ljfBDSBPaWTLMZEKXyKP8Jb2YtWCHsK49EdKZl+34qIqTx+3lS4rnenw5tCD5orAyvjY4oV6TmmiVqi3iBQQNEOEFxBAgML/oKugHtjsfSxV5zgHnOnnqImaDeiG8LOodaIeGSuP6K3Z1ZSs3oEWBRbme9Zigrbs70MJGjD92s6prDMxLTS0NLUcXu7Uo85feispCRN+dDUZ4B3yXZbOVpEh469XZ3DXg1z6Z2rBY69Xx3tgWgB4oGrzOOgwHGioxFFfULdwRVW82bjLx7ItuyJU2EGPeK5YHzlQHpnteJSDh8Nwp4x1hIWw6JkutNLQgL0rT0w2YJNEXVcSmp8rd0LyxASGH9BQYRK";

	char* csRetKey = "jCVXRsvOriNBvVQb1TL+KFFtDuDS6Gb+S2D7ysSrUW1efhZ0QgmQw7+CvUKWdT0q/6cv59gjLdUXolV8GBp2bT/Q6PkpUcGoPqTCLhVZ+WtU4uIVtKEdA4MsUFM4nePybUIBJIxlzEjflWKWqlU+UyYDmhCxapRBXpI3q50sC74=";

	char* csPrivKeyFile = "10000418926.key";

printf("url_encode(csRetData) = [%s]\n",url_encode(csRetData));
printf("url_encode(csRetKey) = [%s]\n",url_encode(csRetKey));


printf("Strat\n");
printf("decrypt csRetKey [%s]\n",csRetKey);
	BOObjPtr = CreateObj(BOPtr,"BOSecurity","RSAEncryptData");
	int iRet = (unsigned long)(*BOObjPtr)(csPrivKeyFile,csRetKey,csYPKey,PD_TRUE,PD_FALSE);
	if (iRet == PD_OK) {
printf("Yeepay Key = [%s]\n",csYPKey);
	}

printf("base64_decode csRetData\n");
	int iLen = base64_decode((char *)csRetData,(unsigned char*)csTmpDATA,PD_MAX_BUFFER);
	if (iLen > 0 ) {
printf("csTmpDATA = [%d][%s]\n",iLen,csTmpDATA);

		BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESDecryptData");
		iRet = (unsigned long)(*BOObjPtr)(csYPKey,csTmpDATA,iLen,csDATA);
printf("iRet = [%d] DATA = [%s]\n",iRet,csDATA);
        }


	FREE_ME(csYPKey);
	FREE_ME(csTmpDATA);
	FREE_ME(csDATA);

printf("End\n");
	return 0;
}



int batch_proc_aes(int argc, char* argv[])
{
	char*   csData;
	int iLen = 0;
	csData = (char*) malloc (MAX_MSG_SIZE + 1 );
	memset(csData,0,sizeof(csData));

	//char* csRSAKeyFile = "10000418926_ypub.key";
	char* csAESKey = "FA14A14424610CF5";
	char* csTmpData = "{\"amount\":1000,\"callbackurl\":\"https://dev.724168.net/be/y26/\",\"fcallbackurl\":\"https://admindev.corp.newco.local/paypage/mobile/response/?sessionid=5476BACBFD45A4D958E880653C26B37C\",\"identityid\":\"4\",\"identitytype\":2,\"merchantaccount\":\"10000418926\",\"orderid\":\"0000000001024528\",\"productcatalog\":\"1\",\"productname\":\"PAY\",\"sign\":\"Rgi9vc0wSSWGYWtMXAjvTXvb1Q8LIBtxd+qgAspDiTnSYIRSlEf7/PjJwmttBT+JcaFN5RCGLxUEgnwZitGlLae0MLFveUjJ1/0nT3FCkCxQUZ5UxPPVq1UCU+yauO5RXPDfw8QXZeUGrpxTYm0OZrg+BcRAyjlePUkc472v8D4=\",\"terminalid\":\"T1\",\"terminaltype\":3,\"transtime\":1439971548,\"userip\":\"192.168.100.122\"}";

printf("Strat\n");
printf("temp data = [%s]\n",csTmpData);
	BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESEncryptData");
	int iRet = (unsigned long)(*BOObjPtr)(csAESKey,csTmpData,csData, &iLen);
	if (iRet == PD_OK) {
printf("data = [%d][%s]\n",iLen,csData);
	}

	unsigned char*   csDecodeDATA;
	csDecodeDATA = (unsigned char*) malloc (MAX_MSG_SIZE*2 + 1 );
	memset(csDecodeDATA,0,sizeof(csDecodeDATA));

	char*   csOut;
	csOut = (char*) malloc (MAX_MSG_SIZE*2 + 1 );
	memset(csOut,0,sizeof(csOut));

//printf("base64_decode csData\n");
//	int iLen = base64_decode((char *)csData,(unsigned char*)csDecodeDATA,PD_MAX_BUFFER);
//	if (iLen > 0 ) {
//printf("csDecodeDATA = [%d][%s]\n",iLen,csDecodeDATA);

		BOObjPtr = CreateObj(BOPtr,"BOSecurity","AESDecryptData");
		iRet = (unsigned long)(*BOObjPtr)(csAESKey,csData,iLen,csOut);
printf("iRet = [%d] csOut = [%s]\n",iRet,csOut);
//        }



	FREE_ME(csData);
printf("End\n");
	return 0;
}

int batch_proc_cal_acr(int argc, char* argv[])
{
	int iRet = PD_OK;

	hash_t          *hTxn;
        hTxn = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hTxn,0);

	if(argc>3){
printf("mode[%c]\n",argv[1][0]);

		PutField_CString(hTxn,"update_user",argv[2]);
printf("update_user[%s]\n",argv[2]);

		PutField_CString(hTxn,"fx_id",argv[3]);
printf("fx_id[%s]\n",argv[3]);

		if(argv[1][0] == 'I'){
			PutField_CString(hTxn,"org_fx_id",argv[4]);
printf("org_fx_id[%s]\n",argv[4]);
		}

		BOObjPtr = CreateObj(BOPtr,"BOMMMAverageCostRate","CalculateAffectFXDT");
		iRet = (unsigned long)(*BOObjPtr)(hTxn);
printf("BOMMMAverageCostRate:CalculateAffectFXDT() iRet = [%d]\n",iRet);


	}
	else{
printf("Input mode[I/O] update_user fx_id org_fx_id(for mode [I])\n");
	}

	FREE_ME(hTxn);
	return iRet;
}


int batch_proc_rec_acr(int argc, char* argv[])
{
	int iRet = PD_OK;
	double dFrTotalAmt = 0.0;
	double dTotalAmt = 0.0;
	double dFrAmt = 0.0;
	double dAmt = 0.0;
	char	csTag[PD_TAG_LEN];
	
	hash_t          *hTxn;
        hTxn = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hTxn,0);

	if(argc>10){
		PutField_CString(hTxn,"fx_id",argv[1]);
printf("fx_id[%s]\n",argv[1]);

		PutField_CString(hTxn,"entity_id",argv[2]);
printf("entity_id [%s]\n",argv[2]);

		PutField_Char(hTxn,"direction",argv[3][0]);
printf("dircetion [%c]\n",argv[3][0]);

		PutField_CString(hTxn,"add_user",argv[4]);
printf("add_user[%s]\n",argv[4]);

		sscanf(argv[5],"%lf",&dFrTotalAmt);
		sscanf(argv[6],"%lf",&dTotalAmt);


//acr_ind = 1
		sprintf(csTag,"fx.1.occy");
		PutField_CString(hTxn,csTag,argv[7]);
printf("occy[%s]\n",argv[7]);

		sscanf(argv[8],"%lf",&dFrAmt);
		sprintf(csTag,"fx.1.framt");
		PutField_Double(hTxn,csTag,dFrAmt);
printf("framt[%lf]\n",dFrAmt);

		sprintf(csTag,"fx.1.ccy");
		PutField_CString(hTxn,csTag,argv[9]);
printf("ccy[%s]\n",argv[9]);

		sprintf(csTag,"fx.1.amt");
		sscanf(argv[10],"%lf",&dAmt);
		PutField_Double(hTxn,csTag,dAmt);
printf("amt[%lf]\n",dAmt);

		sprintf(csTag,"fx.1.acr_ind");
		PutField_Int(hTxn,csTag,1);

		

		
		if(dTotalAmt>dAmt){
//acr_ind = 0
			sprintf(csTag,"fx.2.occy");
			PutField_CString(hTxn,csTag,"000");
printf("occy[000]\n");

			sprintf(csTag,"fx.2.framt");
			PutField_Double(hTxn,csTag,dFrTotalAmt-dFrAmt);
printf("framt[%lf]\n",dFrTotalAmt-dFrAmt);

			sprintf(csTag,"fx.2.ccy");
			PutField_CString(hTxn,csTag,argv[9]);
printf("ccy[%s]\n",argv[9]);

			sprintf(csTag,"fx.2.amt");
			PutField_Double(hTxn,csTag,dTotalAmt-dAmt);
printf("amt[%lf]\n",dTotalAmt-dAmt);

			sprintf(csTag,"fx.2.acr_ind");
			PutField_Int(hTxn,csTag,0);

			PutField_Int(hTxn,"fx_cnt",2);
		}
		else if(dTotalAmt == dAmt){
			PutField_Int(hTxn,"fx_cnt",1);
		}

		BOObjPtr = CreateObj(BOPtr,"BOMMMAverageCostRate","RecordAffectFXDT");
		iRet = (unsigned long)(*BOObjPtr)(hTxn);
printf("BOMMMAverageCostRate:RecordAffectFXDT() iRet = [%d]\n",iRet);
		
	}
	else{
printf("Input: fx_id entity_id direction[I/O] add_user from_total_amt total_amt occy framt ccy amt\n");
	}


	FREE_ME(hTxn);
	return iRet;
}



int batch_proc_3(int argc, char* argv[])
{
	int iRet = PD_OK;
	int i = 0;
	int iTxnCnt = 0;
	int iBaidTxnCnt = 0;
	int iUsePF = 0;
	char csTag[PD_TAG_LEN+1];
	char *csTmp;

	hash_t          *hTxn;
        hTxn = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hTxn,0);

	if(argc>8){
		PutField_CString(hTxn,"activity",argv[1]);
printf("activity[%s]\n",argv[1]);
		PutField_CString(hTxn,"bank_stmt_type",argv[2]);
printf("bank_stmt_type [%s]\n",argv[2]);
		PutField_CString(hTxn,"input_channel",argv[3]);
printf("input_channel[%s]\n",argv[3]);
		PutField_CString(hTxn,"trigger_type",argv[4]);
printf("trigger_type[%s]\n",argv[4]);
		PutField_CString(hTxn,"recon_type",argv[5]);
printf("recon_type[%s]\n",argv[5]);

		iTxnCnt = atoi(argv[6]);
printf("txn_cnt[%s]\n",argv[6]);
		iBaidTxnCnt = atoi(argv[7]);
printf("baid_txn_cnt[%s]\n",argv[7]);
		PutField_Int(hTxn,"txn_cnt",iTxnCnt);
		PutField_Int(hTxn,"baid_txn_cnt",iBaidTxnCnt);

		iUsePF = atoi(argv[8]);
printf("use pending_fund [%s]\n",argv[8]);
		PutField_Int(hTxn,"use_pending_fund",iUsePF);

		for(i=0; i<iTxnCnt;i++){
			sprintf(csTag,"txn_id_%d",i);
			if(!strcmp(argv[2],"DEPOSIT")) {
				PutField_CString(hTxn,csTag,csTxnIdList[i]);
printf("[%s]=[%s]\n",csTag,csTxnIdList[i]);
			}
			if(!strcmp(argv[2],"PAYOUT")){
				PutField_CString(hTxn,csTag,csPOTxnIdList[i]);
printf("[%s]=[%s]\n",csTag,csPOTxnIdList[i]);
			}
		}
		for(i=0; i<iBaidTxnCnt;i++){
			sprintf(csTag,"baid_txn_id_%d",i);
			if(!strcmp(argv[2],"DEPOSIT") && !strcmp(argv[3],"OMT")){
				PutField_CString(hTxn,csTag,csBaidTxnIdList[i]);
printf("[%s]=[%s]\n",csTag,csBaidTxnIdList[i]);
			}
			if(!strcmp(argv[2],"DEPOSIT") && !strcmp(argv[3],"SMS")){
				PutField_CString(hTxn,csTag,csSMSBaidTxnIdList[i]);
printf("[%s]=[%s]\n",csTag,csSMSBaidTxnIdList[i]);
			}
			if(!strcmp(argv[2],"PAYOUT")){
				PutField_CString(hTxn,csTag,csPOBaidTxnIdList[i]);
printf("[%s]=[%s]\n",csTag,csPOBaidTxnIdList[i]);
			}
		}


		BOObjPtr = CreateObj(BOPtr,"BOOLTxnEngine","DoAction");
		iRet = (unsigned long)(*BOObjPtr)(hTxn);
printf("BOOLTxnEngine:DoAction() iRet = [%d]\n",iRet);
	
		if(iRet==PD_OK){
			if(GetField_CString(hTxn,"act_batch_id",&csTmp)){
printf("atcion batch = [%s]\n",csTmp);
			}
		}	

	}

	FREE_ME(hTxn);
	return iRet;
}


int batch_proc_2(int argc, char* argv[])
{
	int iRet = PD_OK;
	int i=0;
	int iCnt=0;

printf("Input String[%s]\n",argv[1]);
	for(i=0; i<strlen(argv[1]); i++){
		if (isascii(argv[1][i]) != 0){
printf("character [%i] isascii char [%c]\n",i,argv[1][i]);
		}
		else{
			iCnt++;
		}
	}
printf("total non-isascii char = [%d]\n",iCnt);
	return iRet;
}

int batch_proc_bkp(int argc, char* argv[])
{
	int iRet = PD_OK;
	char*   csTmp;
	char*   csTmpData;
	char*   csBuf;
	char   outMsg[MAX_MSG_SIZE + 1];

	csBuf = (char*) malloc (MAX_MSG_SIZE + 1 );
        csTmpData = (char*) malloc (MAX_MSG_SIZE + 1 );
        csTmp = (char*) malloc (MAX_MSG_SIZE + 1 );

        memset(outMsg,0,sizeof(outMsg));
DEBUGLOG(("FormatMsg here\n"));
        strcat((char*)outMsg,"https://return.csbuyment.com/cashpayment.aspx?");

	strcpy(csTmpData,"MERID");
	strcat(csTmpData,"=");
	strcat(csTmpData,"FL888000175");
	strcat(csTmpData,"&");
DEBUGLOG(("FormatMsg:: MERID = [FL888000175]\n"));

	strcat(csTmpData,"ENCTYPE");
	strcat(csTmpData,"=");
	strcat(csTmpData,"01");
	strcat(csTmpData,"&");
DEBUGLOG(("FormatMsg:: default ENCTYPE = [01]\n"));

/////////test 1/////////
/*
	strcat(csTmp,"0000000124317584|20140218|388800|100|1|01|https://npmu.v7788505.net/be/hpy/|https://pm.hb8877.net/pay208/return.php?sessionid=E387C4D751F73304BC36B1BC7D78A3C7|https://pm.hb8877.net/pay208/return.php?sessionid=E387C4D751F73304BC36B1BC7D78A3C7|GB||");

DEBUGLOG(("FormatMsg:: plainttext_data = [0000000124317584|20140218|388800|100|1|01|https://npmu.v7788505.net/be/hpy/|https://pm.hb8877.net/pay208/return.php?sessionid=E387C4D751F73304BC36B1BC7D78A3C7|https://pm.hb8877.net/pay208/return.php?sessionid=E387C4D751F73304BC36B1BC7D78A3C7|GB||]\n"));

*////////test 1//////////

/////////test 2/////////
/*	strcat(csTmp,"0000000124312606|20140218|388800|100|1|01|https://npmu.v7788505.net/be/hpy/|https://pm.hb8877.net/pay208/return.php?sessionid=E387C4D751F73304F8A5C9104D66C557|https://pm.hb8877.net/pay208/return.php?sessionid=E387C4D751F73304F8A5C9104D66C557|GB||");

DEBUGLOG(("FormatMsg:: plainttext_data = [0000000124312606|20140218|388800|100|1|01|https://npmu.v7788505.net/be/hpy/|https://pm.hb8877.net/pay208/return.php?sessio
nid=E387C4D751F73304F8A5C9104D66C557|https://pm.hb8877.net/pay208/return.php?sessionid=E387C4D751F73304F8A5C9104D66C557|GB||]\n"));
/////////test 2/////////

	char* csTmpBuf;
	csTmpBuf = (char*) malloc (MAX_MSG_SIZE + 1 );
	csBuf[0]='\0';
	base64_encode((unsigned char *)csTmp,strlen(csTmp),csBuf,PD_MAX_BUFFER);

DEBUGLOG(("FormatMsg:: DATA = [%s]\n",csBuf));
	strcpy(csTmpBuf,url_encode(csBuf));
DEBUGLOG(("FormatMsg:: url encode DATA = [%s]\n",csTmpBuf));

	strcat(csTmpData,"DATA");
	strcat(csTmpData,"=");
	strcat(csTmpData,csTmpBuf);
	strcat(csTmpData,"&");
	FREE_ME(csTmpBuf);

	strcat(csTmpData,"SIGN");
	strcat(csTmpData,"=");
*/
	/*test 1*/ //strcat(csTmpData,"eb6a0d508e7c20c03954f67798c1eccd");
	/*test 2*/ strcat(csTmpData,"84c295bd14f4546598efdc54dc6f6d5e");
	strcat(csTmpData,"&");
/*test 1*/ //DEBUGLOG(("FormatMsg:: SIGN = [eb6a0d508e7c20c03954f67798c1eccd]\n"));
/*test 2*/ DEBUGLOG(("FormatMsg:: SIGN = [84c295bd14f4546598efdc54dc6f6d5e]\n"));


	strcat(csTmpData,"BANKID");
	strcat(csTmpData,"=");
	strcat(csTmpData,"022001");
DEBUGLOG(("FormatMsg:: BANKID = [022001]\n"));

DEBUGLOG(("FormatMsg:: Tmp DATA = [%s]\n",csTmpData));

	char*   csResult;
	csResult = (char*) malloc (strlen(csTmpData) *2  +1);
	BOObjPtr = CreateObj(BOPtr,"BOSecurity","DesEncryptECB");
	/*test 1*/ //iRet = (unsigned long)(*BOObjPtr)(csTmpData,"P8000120",csResult);
	/*test 2*/ iRet = (unsigned long)(*BOObjPtr)(csTmpData,"P8000122",csResult);
	if (iRet == PD_OK) {
		base64_encode((unsigned char *)csResult,strlen(csResult),csBuf,PD_MAX_BUFFER);
		strcat((char*)outMsg,"Msg");
		strcat((char*)outMsg,"=");
		strcat((char*)outMsg,csBuf);
		strcat((char*)outMsg,"&");
DEBUGLOG(("FormatMsg:: Msg = [%s]\n",csBuf));
	}

DEBUGLOG(("FormatMsg:: outmsg = [%s]\n",outMsg));

	base64_encode((unsigned char *)outMsg,strlen((const char*)outMsg),csBuf,PD_MAX_BUFFER);
	outMsg[0] = '\0';
	strcat((char*)outMsg,"redirect_url");
	strcat((char*)outMsg,"=");
	strcat((char*)outMsg,csBuf);
	strcat((char*)outMsg,"&");
	strcat((char*)outMsg,"url_method");
	strcat((char*)outMsg,"=");
	strcat((char*)outMsg,"POST");
	strcat((char*)outMsg,"&");
	strcat((char*)outMsg,"ret_status=0");

DEBUGLOG(("FormatMsg:: outMsg = [%s]\n",outMsg));

	
	FREE_ME(csBuf);
	FREE_ME(csTmp);
	

	return iRet;

}


int batch_terminate(int argc, char* argv[])
{
    return SUCCESS;
}

