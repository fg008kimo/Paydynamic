/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/08/23              LokMan Chow
use table psp_txn_checking			   2012/01/09		   LokMan Chow
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cs_rate[PD_DATE_LEN + 1];
char    cs_count[PD_DATE_LEN + 1];
char    cs_threshold[PD_DATE_LEN + 1];
char    cs_check_period[PD_DATE_LEN + 1];
char	cs_txn_period[PD_DATE_LEN + 1];
char	cs_period_from[PD_DATE_LEN + 1];
char    cs_psp_id[PD_PSP_ID_LEN + 1];
char    cs_min_check_count[PD_DATE_LEN + 1];
char    c_rc_ind;
char    cDebug;

OBJPTR(DB);
int parse_arg(int argc,char **argv);
int process_txn(unsigned char* csPspId, unsigned char* csCount, unsigned char* csThreshold);
int process_detail(unsigned char* csPspId, unsigned char* csCount);
int find_checking_parameters(unsigned char* csPspId);
int update_last_check(unsigned char* csPspId);
char* getPspName(const unsigned  char* csPspId);
int batch_init(int argc, char* argv[])
{

    if (argc < 2) {
        printf("usage: -p psp_id\n");
        //return FAILURE;
    }
    //else
        return SUCCESS;
}




int batch_proc(int argc, char* argv[])
{
        int     iRet;
	char    csPspName[PD_PSP_NAME_LEN+1];

	iRet = parse_arg(argc,argv);
               
        if (iRet != SUCCESS) {
        	printf("usage: -p psp_id\n");
                return SUCCESS;
        }
	
	strcpy(csPspName,getPspName((const unsigned  char*)cs_psp_id));
        csPspName[strlen(csPspName)]='\0';

	iRet = find_checking_parameters((unsigned char*)cs_psp_id);

	if(iRet == SUCCESS){
		//printf("<html><body><table>");
		//printf("<tr>Message generated by System</tr>");
		printf("<tr><font size=\"4\"><td><b>WARNING:</td><td><b>Poor performance of [%s]</td></font></tr>",csPspName);
		printf("<tr><td></td><td></td></tr>");
		//printf("<tr>Statistics:</tr>");
		//printf("<tr>Most recent records:</tr>");

        	iRet = process_txn((unsigned char*)cs_psp_id,(unsigned char*)cs_count,(unsigned char*)cs_threshold);

		printf("<tr><font size=\"1\"><td>Message generated by System</td><td>[%s]</td></font></tr>",cs_psp_id);
		printf("</table></body></html>");
	}
	else if (iRet == PD_NOT_FOUND){
                iRet = SUCCESS;
        }

	//if(iRet==FAILURE){
	//	printf("<tr></tr><tr>Details:</tr>");
	//	printf("<tr><pre>[txn_id]	[txn_amount][status][ar_ind]:</pre></tr>");
       	//	iRet = process_detail((unsigned char*)cs_psp_id,(unsigned char*)cs_count);
	//}

	return iRet;


}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}


int find_checking_parameters(unsigned char* csPspId)
{
	int     iRet = PD_NOT_FOUND;

	EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_psp_id[PD_PSP_ID_LEN];

		int	v_check_period;
		int	v_txn_period;
		int	v_period_from;
		int	v_count;
		int	v_threshold;
		int	v_rate;
		char	v_rc_ind;
		int	v_min_check_count;

		short	ind_check_period = -1;
		short	ind_txn_period = -1;
		short	ind_period_from = -1;
		short	ind_count = -1;
		short	ind_threshold = -1;
		short	ind_rate = -1;
		short	ind_rc_ind = -1;
		short	ind_min_check_count = -1;

	EXEC SQL END DECLARE SECTION;

	hv_psp_id.len = strlen((char*)csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);

	EXEC SQL SELECT pc_rate, 
			pc_count,
			pc_threshold,
			pc_check_period,
			pc_txn_period,
			pc_period_from,
			pc_rc_ind,
			pc_min_count
                   INTO :v_rate:ind_rate,
			:v_count:ind_count,
			:v_threshold:ind_threshold,
			:v_check_period:ind_check_period,
			:v_txn_period:ind_txn_period,
			:v_period_from:ind_period_from,
			:v_rc_ind:ind_rc_ind,
			:v_min_check_count:ind_min_check_count
		   FROM psp_txn_checking
		   WHERE pc_psp_id = :hv_psp_id
		   AND	 pc_disabled = 0;

	if(ind_count<0)
		v_count = 0;
	sprintf(cs_count,"%d",v_count);

	if(ind_threshold<0)
		v_threshold = 0;
	sprintf(cs_threshold,"%d",v_threshold);

	if(ind_check_period<0)
		v_check_period = 0;
	sprintf(cs_check_period,"%d",v_check_period);

	if(ind_txn_period<0)
		v_txn_period = 0;
	sprintf(cs_txn_period,"%d",v_txn_period);

	if(ind_period_from<0)
		v_period_from = 0;
	sprintf(cs_period_from,"%d",v_period_from);

	if(ind_rate<0)
		v_rate = 0;
	sprintf(cs_rate,"%d",v_rate);

	if(ind_rc_ind<0)
		v_rc_ind = 'C';
	c_rc_ind = v_rc_ind;

	if(ind_min_check_count<0)
		v_min_check_count= 0;
	sprintf(cs_min_check_count,"%d",v_min_check_count);

	if((v_count*v_txn_period)!=0)
		iRet = SUCCESS;

	return iRet;

find_error:
DEBUGLOG(("find_checking_parameters error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}


int process_txn(unsigned char* csPspId, unsigned char* csCount, unsigned char* csThreshold)
{               
 
        int     iRet = SUCCESS;
	int	iPending=0;
	int	iAccept=0;
	int	iReject=0;
	int	iTotal=0;
	int	iOthers=0;
	int	iCh=0;
	int	iCnt = atoi((char*)csCount);
	int	iThreshold = atoi((char*)csThreshold);
	int	iCheck = atoi((char*)cs_check_period);
	int	iTxn = atoi((char*)cs_txn_period);
	int	iFrom = atoi((char*)cs_period_from);
	int	iRate = atoi((char*)cs_rate);
	int	iMinCnt = atoi((char*)cs_min_check_count);
	double	dRate=0.0;        

        EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
        
        EXEC SQL BEGIN DECLARE SECTION;
		
		varchar	hv_psp_id[PD_PSP_ID_LEN];
		int	hv_cnt;
		int	hv_check;
		int	hv_txn;
		int	hv_from;

		varchar	v_from_time[PD_TMP_BUF_LEN+1];
		varchar	v_to_time[PD_TMP_BUF_LEN+1];
		varchar	v_time[PD_TMP_BUF_LEN+1];
		char	v_status;
		char	v_ar_ind;
		int	v_cnt;

		short	ind_from_time = -1;
		short	ind_to_time = -1;
		short	ind_time = -1;
		short	ind_status = -1;
		short	ind_ar_ind = -1;
		short	ind_cnt = -1;


	EXEC SQL END DECLARE SECTION;

	hv_psp_id.len = strlen((char*)csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);

	hv_cnt=iCnt;
	hv_check=iCheck;
	hv_txn=iTxn;
	hv_from=iFrom;

        EXEC SQL DECLARE c_cursor_gettxn CURSOR FOR
		select  count(*),
         		th_status,
         		th_ar_ind,
			to_char(sysdate,'DD-MON-YYYY HH24:MI:SS'),
			to_char((SYSDATE - ((:hv_txn+:hv_from)/1440)),'DD-MON-YYYY HH24:MI:SS'),
			to_char((sysdate - (:hv_from/1440)),'DD-MON-YYYY HH24:MI:SS')
		  from 	( select * from
			  txn_header,
			  txn_psp_detail
    			  where	txn_header.th_txn_id = txn_psp_detail.tp_txn_id
			  and	txn_psp_detail.tp_psp_id  = :hv_psp_id
			  and	txn_header.th_txn_code in ('DSP','DSI')
			  order by th_create_timestamp DESC),
			psp_txn_checking
		where	th_create_timestamp  between (SYSDATE - ((:hv_txn+:hv_from)/1440))  and (sysdate - (:hv_from/1440))
		and	pc_psp_id = :hv_psp_id
		and	(pc_rc_ind = 'R' or rownum <= :hv_cnt)
		group by th_ar_ind,
			 th_status;
                
        EXEC SQL OPEN c_cursor_gettxn;
        do {    
                EXEC SQL FETCH c_cursor_gettxn
                INTO
		 	:v_cnt:ind_cnt,
         		:v_status:ind_status,
         		:v_ar_ind:ind_ar_ind,
		 	:v_time:ind_time,
		 	:v_from_time:ind_from_time,
		 	:v_to_time:ind_to_time;


                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if(ind_from_time<0){
			v_from_time.len=0;
			v_from_time.arr[0]='\0';
		}
		if(ind_to_time<0){
			v_to_time.len=0;
			v_to_time.arr[0]='\0';
		}
		if(ind_time<0){
			v_time.len=0;
			v_time.arr[0]='\0';
		}

		if(ind_status>=0){
			if(v_status==PD_COMPLETE){
				if(ind_ar_ind>=0){
					if(v_ar_ind==PD_ACCEPT){
						if(ind_cnt>=0)
							iAccept = v_cnt;
					}
					else if(v_ar_ind==PD_REJECT){
						if(ind_cnt>=0)
							iReject = v_cnt;
					}
				}
				else{
					v_ar_ind=' ';
				}
			}
			else if(v_status==PD_TO_PSP){
				v_ar_ind=' ';
				if(ind_cnt>=0)
					iPending = v_cnt;
			}
			else{
				if(ind_ar_ind<0){
					v_ar_ind=' ';
				}
				if(ind_cnt>=0)
					iOthers = v_cnt;
			}
		}

		//printf("<tr><pre>Status[%c] ar_ind[%c] Count[%d]</pre></tr>",v_status,v_ar_ind,v_cnt);

 	}
        while(PD_TRUE && iRet == SUCCESS);
        EXEC SQL CLOSE c_cursor_gettxn;

	printf("<tr><td>Alert time:</td><td>%.*s</td></tr>",v_time.len,v_time.arr);
	printf("<tr><td>Duration:</td><td>%.*s to %.*s</td></tr>",v_from_time.len,v_from_time.arr,v_to_time.len,v_to_time.arr);
	//printf("<tr><td>To time:</td><td>%.*s</td></tr>",v_to_time.len,v_to_time.arr);

	iTotal = iAccept+iReject+iPending+iOthers;
	if(c_rc_ind=='R'){
		if(iTotal<iMinCnt){
			printf("<tr><td>-</td><td>total count [%d]<[%d]</td></tr>",iTotal,iMinCnt);
			//printf("<tr><td>total count:</td><td>[%d]</td></tr>",iTotal);
		}
		else{
			dRate = (iAccept*100/iTotal);
			//printf("[%s] Successful rate[%.2f]\n",csPspId,dRate);
			if((int)dRate<iRate){
				printf("<tr><td>-</td><td>Successful rate is low: %.2f  (Threshold rate: %d)</td></tr>",dRate,iRate);
				iRet = FAILURE;
			}

			iCh = update_last_check(csPspId);
		}
	}
	else{
		if(iTotal<iCnt){
			printf("<tr><td>-</td><td>total count [%d]<[%d]</td></tr>",iTotal,iCnt);
		}
		else{
			if(iPending==iTotal){
				printf("<tr><td>-</td><td>All pending!!!!</td></tr>");
				iRet = FAILURE;
			}
			else{
				if(iPending>iThreshold){
					printf("<tr><td>-</td><td>Pending count exceed the threshold[%d]!!!!</td></tr>",iThreshold);
					iRet = FAILURE;
				}
			}

			iCh = update_last_check(csPspId);
		}
	}

	//if(iOthers>0){
		printf("<tr><b><td>Approved:</td><td>%d</td></b></tr>",iAccept);
		printf("<tr><b><td>Pending:</td><td>%d</td></b></tr>",iPending);
		printf("<tr><b><td>Total:</td><td>%d</td></b></tr>",iTotal);
	//}
	//else{
	//	printf("<tr><pre>[%s] Accept = %d, Reject = %d, Pending = %d, Total = %d</pre></tr>",csPspId,iAccept,iReject,iPending, iTotal);
	//}

        return iRet;
sql_error:
    DEBUGLOG(("process_txn error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_gettxn;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int process_detail(unsigned char* csPspId, unsigned char* csCount)
{               
 
        int     iRet = SUCCESS;
	int	iCnt = atoi((char*)csCount);
	int	iCheck = atoi((char*)cs_check_period);
	int	iTxn = atoi((char*)cs_txn_period);
	int	iFrom = atoi((char*)cs_period_from);

        EXEC SQL WHENEVER SQLERROR GOTO sqldt_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;
        
        EXEC SQL BEGIN DECLARE SECTION;
		
		varchar	hv_psp_id[PD_PSP_ID_LEN];
		int	hv_check;
		int	hv_txn;
		int	hv_from;
		int	hv_cnt;

		varchar v_txn_id[PD_TXN_SEQ_LEN+1];
		varchar v_amt[PD_AMOUNT_LEN+1];
		char	v_status;
		char	v_ar_ind;

		short	ind_txn_id = -1;
		short	ind_amt = -1;
		short	ind_status = -1;
		short	ind_ar_ind = -1;


	EXEC SQL END DECLARE SECTION;

	hv_psp_id.len = strlen((char*)csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);

	hv_cnt=iCnt;
	hv_check=iCheck;
	hv_txn=iTxn;
	hv_from=iFrom;

        EXEC SQL DECLARE c_cursor_gettxndt CURSOR FOR
		select  th_txn_id,
			th_transaction_amount,
         		th_status,
         		th_ar_ind
		  from 	( select * from
			  txn_header,
			  txn_psp_detail
    			  where	txn_header.th_txn_id = txn_psp_detail.tp_txn_id
			  and	txn_psp_detail.tp_psp_id  = :hv_psp_id
			  and	txn_header.th_txn_code in ('DSP','DSI')
			  order by th_create_timestamp DESC),
			psp_txn_checking
		where	th_create_timestamp  between (SYSDATE - ((:hv_txn+:hv_from)/1440))  and (sysdate - (:hv_from/1440))
		and	pc_psp_id = :hv_psp_id
		and	(pc_rc_ind = 'R' or rownum <= :hv_cnt)
		order by th_txn_id desc;
                
        EXEC SQL OPEN c_cursor_gettxndt;
        do {    
                EXEC SQL FETCH c_cursor_gettxndt
                INTO
		 	:v_txn_id:ind_txn_id,
		 	:v_amt:ind_amt,
         		:v_status:ind_status,
         		:v_ar_ind:ind_ar_ind;


                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if(ind_amt<0){
			v_amt.len=0;
			v_amt.arr[0]='\0';
		}

		if(ind_status<0)
			v_status = ' ';

		if(ind_ar_ind<0)
			v_ar_ind = ' ';

		if(ind_txn_id>=0){
			printf("<tr><pre>%.*s	%.*s	%c	%c</pre></tr>",v_txn_id.len,v_txn_id.arr,v_amt.len,v_amt.arr,v_status,v_ar_ind);
		}


 	}
        while(PD_TRUE && iRet == SUCCESS);
        EXEC SQL CLOSE c_cursor_gettxndt;

	printf("<tr></tr>");

        return iRet;
sqldt_error:
    DEBUGLOG(("process_detail error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_gettxndt;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}

int parse_arg(int argc,char **argv)
{
        char    c;
	strcpy(cs_psp_id,"");

        while ((c = getopt(argc,argv,"p:")) != EOF) {
                switch (c) {
                        case 'p':
                                strcpy(cs_psp_id, optarg);
                                break;
                        default:
                                return FAILURE;
                }
        }

        if (!strcmp(cs_psp_id,""))
                return FAILURE;

        return SUCCESS;
}

char* getPspName(const unsigned char* csPspId)
{
	int iRet = PD_NOT_FOUND;
	
	EXEC SQL WHENEVER SQLERROR GOTO getname_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_psp_id[PD_PSP_ID_LEN];
                varchar         v_name[PD_NAME_LEN + 1];
                short           ind_name = -1;
                
        EXEC SQL END DECLARE SECTION;
                        
        hv_psp_id.len = strlen((const char*)csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);

	EXEC SQL DECLARE c_cursor_getname CURSOR FOR
                select psp_name
                  from psp_detail
                 where psp_id = :hv_psp_id;

	EXEC SQL OPEN c_cursor_getname;
        do {
                EXEC SQL FETCH c_cursor_getname
                INTO
                        :v_name:ind_name;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

/* psp name */
                if (ind_name >= 0) {
                        v_name.arr[v_name.len] = '\0';
			iRet=PD_FOUND;
                }

	}
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getname;

	if(iRet==PD_FOUND)
	        return strdup((const char *)v_name.arr);
	else
		return strdup("");

getname_error:
DEBUGLOG(("getname_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getname;
        return strdup("");
}


int update_last_check(unsigned char* csPspId)
{
	int	iRet = SUCCESS;

	EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_psp_id[PD_PSP_ID_LEN];

        EXEC SQL END DECLARE SECTION;

        hv_psp_id.len = strlen((char*)csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);

        EXEC SQL UPDATE	psp_txn_checking
		 SET	pc_last_checking_time = sysdate,
			pc_update_timestamp = sysdate
		 WHERE	pc_psp_id = :hv_psp_id;
	
	return iRet;

update_error:
DEBUGLOG(("update_last_check error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}
