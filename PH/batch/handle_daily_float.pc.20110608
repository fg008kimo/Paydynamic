/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/04/18              LokMan Chow
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cs_cutoff_date[PD_DATE_LEN + 1];
char    cDebug = 'Y';

#define PD_T1_STATE	1
#define PD_T2_STATE	2

OBJPTR(DB);

int parse_arg(int argc,char **argv);
int process_bucket(const char *csCutoffDate);
int find_t1t2_date(const int iIndex, hash_t *myHash);
int find_t1t2_amount(const int iIndex, hash_t *myHash);
int process_t1t2_release(const int iIndex, const hash_t *myHash);
int update_bucket(const hash_t *myHash);
int addday(const char* csCurrentDate,int numofdate,char* csNewDate);
int is_holidays(const char* csCountry, const char* csDate);
int get_psp_release_period(const char* csCountry, const char* csPspId);
int AddTxnLog(const hash_t* hVal);

int batch_init(int argc, char* argv[])
{

    if (argc < 2) {
        printf("usage:  -d cutoff_date\n");
        return FAILURE;
    }
    else

        return SUCCESS;
}




int batch_proc(int argc, char* argv[])
{
        int     iRet;

	iRet = parse_arg(argc,argv);
               
        if (iRet != SUCCESS) {
        	printf("usage:  -d cutoff_date\n");
                return (iRet);
        }

        iRet = process_bucket(cs_cutoff_date);


DEBUGLOG(("iRet = [%d]\n",iRet));

	return iRet;


}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}




int process_bucket(const char *csCutoffDate)
{               
        int     iRet = SUCCESS;
        int     iUpdate;
	char	*csTmp;
	hash_t *myHash;

DEBUGLOG(("*****Process Bucket Start*****\n"));

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_cutoff_date[PD_DATE_LEN];

		varchar	v_posting_date[PD_DATE_LEN + 1];
		varchar	v_merchant_id[PD_MERCHANT_ID_LEN + 1];
		varchar	v_country_id[PD_COUNTRY_LEN + 1];
		varchar	v_currency_id[PD_CCY_ID_LEN + 1];
		varchar	v_psp_id[PD_PSP_ID_LEN + 1];
		varchar	v_bucket_type[PD_BUCKET_TYPE_LEN + 1];
		double	v_bal;
		varchar	v_t1_date[PD_DATE_LEN + 1];
		varchar v_t2_date[PD_DATE_LEN + 1];
		double	v_t1_amount;
		double	v_t2_amount;

		short	ind_posting_date = -1;
		short	ind_merchant_id = -1;
		short	ind_t1_amount = -1;
		short	ind_t2_amount = -1;
		short	ind_t1_date = -1;
		short	ind_t2_date = -1;
		short	ind_bal= -1;
		short	ind_psp_id= -1;
		short	ind_currency_id= -1;
		short	ind_country_id= -1;
		short	ind_bucket_type= -1;


	EXEC SQL END DECLARE SECTION;

	hv_cutoff_date.len = strlen(csCutoffDate);
        memcpy(hv_cutoff_date.arr,csCutoffDate,hv_cutoff_date.len);
DEBUGLOG(("process_bucket cutoff_date = [%.*s]\n",hv_cutoff_date.len,hv_cutoff_date.arr));


        EXEC SQL DECLARE c_cursor_get_bucket CURSOR FOR
		select 	mb_posting_date,
         		mb_merchant_id,
         		mb_country_id,
         		mb_currency_id,
         		mb_psp_id,
         		mb_bucket_type,
         		mb_bal,
         		mb_t1_released_date,
         		mb_t1_released_amt,
         		mb_t2_released_date,
         		mb_t2_released_amt
		  from 	merchant_bucket
		  where mb_bucket_type = 'FT'
		  and	mb_posting_date < :hv_cutoff_date
		  order by mb_posting_date;
		
                
        EXEC SQL OPEN c_cursor_get_bucket;
        do {    
                EXEC SQL FETCH c_cursor_get_bucket
                INTO
         		v_posting_date:ind_posting_date,
         		v_merchant_id:ind_merchant_id,
         		v_country_id:ind_country_id,
         		v_currency_id:ind_currency_id,
         		v_psp_id:ind_psp_id,
         		v_bucket_type:ind_bucket_type,
         		v_bal:ind_bal,
         		v_t1_date:ind_t1_date,
         		v_t1_amount:ind_t1_amount,
			v_t2_date:ind_t2_date,
         		v_t2_amount:ind_t2_amount;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

///////		if(!((ind_t1_date>=0)&&(strncmp(v_t1_date.arr,hv_cutoff_date.arr,hv_cutoff_date.len)<0)&&(ind_t2_date>=0)&&(strncmp(v_t2_date.arr,hv_cutoff_date.arr,hv_cutoff_date.len)<0))){

		if((ind_t1_date<0)||(ind_t2_date<0)){
			iUpdate=PD_FALSE;

			myHash = (hash_t*) malloc (sizeof(hash_t));
			hash_init(myHash,0);

			PutField_CString(myHash,"cutoff_date",csCutoffDate);

/* posting_date */
			if (ind_posting_date >= 0){
				v_posting_date.arr[v_posting_date.len]='\0';
				PutField_CString(myHash,"posting_date",v_posting_date.arr);
DEBUGLOG(("Process Bucket: posting_date =[%.*s]\n",v_posting_date.len,v_posting_date.arr));
			}

/* merchant_id */
			if (ind_merchant_id >= 0 ){
				v_merchant_id.arr[v_merchant_id.len]='\0';
				PutField_CString(myHash,"merchant_id",v_merchant_id.arr);
DEBUGLOG(("Process Bucket: merchant_id =[%.*s]\n",v_merchant_id.len,v_merchant_id.arr));
			}

/* country_id */
			if (ind_country_id >= 0 ){
				v_country_id.arr[v_country_id.len]='\0';
				PutField_CString(myHash,"country_id",v_country_id.arr);
DEBUGLOG(("Process Bucket: country_id =[%.*s]\n",v_country_id.len,v_country_id.arr));
			}

/* currency_id */
			if (ind_currency_id >= 0 ){
				v_currency_id.arr[v_currency_id.len]='\0';
				PutField_CString(myHash,"currency_id",v_currency_id.arr);
DEBUGLOG(("Process Bucket: currency_id =[%.*s]\n",v_currency_id.len,v_currency_id.arr));
			}

/* psp_id */
			if (ind_psp_id >= 0 ){
				v_psp_id.arr[v_psp_id.len]='\0';
				PutField_CString(myHash,"psp_id",v_psp_id.arr);
DEBUGLOG(("Process Bucket: psp_id =[%.*s]\n",v_psp_id.len,v_psp_id.arr));
			}

/* bucket_type */
			if (ind_bucket_type >= 0 ){
				v_bucket_type.arr[v_bucket_type.len]='\0';
				PutField_CString(myHash,"bucket_type",v_bucket_type.arr);
DEBUGLOG(("Process Bucket: bucket_type =[%.*s]\n",v_bucket_type.len,v_bucket_type.arr));
			}

/* bal */
			if (ind_bal >= 0 ){
				PutField_Double(myHash,"bal",v_bal);
DEBUGLOG(("Process Bucket: bal =[%f]\n",v_bal));
			}

/* t1_amount */
			if (ind_t1_amount >= 0 ){
				PutField_Double(myHash,"t1_amt",v_t1_amount);
DEBUGLOG(("Process Bucket: t1_amount =[%f]\n",v_t1_amount));
			}
			else{
				iRet = find_t1t2_amount(PD_T1_STATE,myHash);
			}

/* t2_amount */
			if (ind_t2_amount >= 0 ){
				PutField_Double(myHash,"t2_amt",v_t2_amount);
DEBUGLOG(("Process Bucket: t2_amount =[%f]\n",v_t2_amount));
			}
			else
			{
				iRet = find_t1t2_amount(PD_T2_STATE,myHash);
			}

/* t1_date */
			if (ind_t1_date >= 0 ){
				PutField_CString(myHash,"t1_date",v_t1_date.arr);
DEBUGLOG(("Process Bucket: t1_date =[%.*s]\n",v_t1_date.len,v_t1_date.arr));

				if(strncmp(v_t1_date.arr,hv_cutoff_date.arr,hv_cutoff_date.len)==0){
					iRet = process_t1t2_release(PD_T1_STATE,myHash);
					iUpdate=PD_TRUE;
				}
			}
			else{
				iRet = find_t1t2_date(PD_T1_STATE,myHash);
				if(GetField_CString(myHash,"t1_date",&csTmp)){
					if(strncmp(csTmp,hv_cutoff_date.arr,hv_cutoff_date.len)==0){
						iRet = process_t1t2_release(PD_T1_STATE,myHash);
						iUpdate=PD_TRUE;
					}
				}
			}

/* t2_date */
			if (ind_t2_date >= 0 ){
				PutField_CString(myHash,"t2_date",v_t2_date.arr);
DEBUGLOG(("Process Bucket: t2_date =[%.*s]\n",v_t2_date.len,v_t2_date.arr));

				if(strncmp(v_t2_date.arr,hv_cutoff_date.arr,hv_cutoff_date.len)==0){
					iRet = process_t1t2_release(PD_T2_STATE,myHash);
					iUpdate=PD_TRUE;
				}
			}
			else{
				iRet = find_t1t2_date(PD_T2_STATE,myHash);
				if(GetField_CString(myHash,"t2_date",&csTmp)){
					if(strncmp(csTmp,hv_cutoff_date.arr,hv_cutoff_date.len)==0){
						iRet = process_t1t2_release(PD_T2_STATE,myHash);
						iUpdate=PD_TRUE;
					}
				}
			}

			if((iRet==SUCCESS) && (iUpdate==PD_TRUE)){

				DBObjPtr = CreateObj(DBPtr,"DBMerchantBucket","UpdateReleaseDetails");
				iRet = (unsigned long)(DBObjPtr)(myHash);
				if(iRet!=PD_OK){
DEBUGLOG(("Process Bucket: UpdateReleaseDetails Failed\n"));
ERRLOG("handle_daily_float::Process Bucket: UpdateReleaseDetails Failed\n");
				}
				else{
DEBUGLOG(("Process Bucket: UpdateReleaseDetails Success\n"));
				}
			}


			FREE_ME(myHash);
		}
 	}
	while(PD_TRUE && (iRet ==SUCCESS));

        EXEC SQL CLOSE c_cursor_get_bucket;

	if(iRet==SUCCESS){
DEBUGLOG(("Process Bucket Normal Exit\n"));
	}
	else{
DEBUGLOG(("Process Bucket Error[%d]\n",iRet));
	}
        return iRet;

sql_error:
    DEBUGLOG(("process_bucket error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    ERRLOG("handle_daily_float::process_bucket sql error %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_get_bucket;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}






int find_t1t2_date(const int iIndex, hash_t *myHash)
{
	int iRet = SUCCESS;
	char *csDate;
	char csNewDate[PD_DATE_LEN + 1];
	char *csPsp;
	char *csCountry;
	int iT1Period,iT2Period,i;

DEBUGLOG(("*****find_t1t2_date start*****\n"));
	
	GetField_CString(myHash,"posting_date",&csDate);
	GetField_CString(myHash,"psp_id",&csPsp);
	GetField_CString(myHash,"country_id",&csCountry);


	iT1Period = get_psp_release_period(csCountry,csPsp);
	if(iT1Period==0){
		return FAILURE;
	}
	else if(iT1Period==PD_NOT_FOUND){
		return PD_NOT_FOUND;
	}
	else{
		iT2Period = iT1Period+1;
	}
	

	if(iIndex==PD_T1_STATE){

		i = iT1Period;
		do{		
			addday(csDate,i,csNewDate);

			i ++;
		}while(is_holidays(csCountry,csNewDate)==PD_TRUE);

		PutField_CString(myHash,"t1_date",csNewDate);
DEBUGLOG(("Psp[%s]: T1 release date is [%s]\n",csPsp,csNewDate));
	}
	else{
		if(GetField_CString(myHash,"t1_date",&csDate)){

			i = iT2Period-iT1Period;
			do{
				addday(csDate,i,csNewDate);

				i ++;
			}while(is_holidays(csCountry,csNewDate)==PD_TRUE);

			PutField_CString(myHash,"t2_date",csNewDate);
DEBUGLOG(("Psp[%s]: T2 release date is [%s]\n",csPsp,csNewDate));
		}
		else{
			iRet = FAILURE;
DEBUGLOG(("Failed to find T2 release date\n"));
		}
	}

	return iRet;
}





int find_t1t2_amount(const int iIndex, hash_t *myHash)
{
	int iRet = SUCCESS;
	char *csTmp;
	double dTmp;
	double dAmt=0;
	double dBal;
	hash_t* hPsp;

	hPsp = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hPsp,0);

DEBUGLOG(("*****find_t1t2_amount start*****\n"));

	GetField_CString(myHash,"psp_id",&csTmp);
///hard code
	dAmt=1000;

DEBUGLOG(("Psp[%s]: Max. Release Amount[%f]\n",csTmp,dAmt));

	GetField_Double(myHash,"bal",&dBal);
	if((dBal<dAmt) || (dAmt==0))
		dTmp = dBal;
	else
		dTmp = dAmt;

	if(iIndex==PD_T1_STATE){
		PutField_Double(myHash,"t1_amt",dTmp);
DEBUGLOG(("Final Release Amount[%f]\n",dTmp));
	}
	else{
		PutField_Double(myHash,"t2_amt",(dBal-dTmp));
DEBUGLOG(("Final Release Amount[%f]\n",(dBal-dTmp)));
	}

	FREE_ME(hPsp);
	return iRet;
}




int process_t1t2_release(const int iIndex,const hash_t *myHash)
{
	int iRet = PD_OK;
	char	*csMerchantId;
	char	*csCcyId;
	char	*csCountry;
	hash_t	*hTxn;
	double	dTmp;

	hTxn = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hTxn,0);

DEBUGLOG(("*****process_t1t2_release start*****\n"));

	if(GetField_CString(myHash,"merchant_id",&csMerchantId)){
		PutField_CString(hTxn,"merchant_id",csMerchantId);
	}
	if(GetField_CString(myHash,"currency_id",&csCcyId)){
		PutField_CString(hTxn,"currency_id",csCcyId);
	}
	if(GetField_CString(myHash,"country_id",&csCountry)){
		PutField_CString(hTxn,"country_id",csCountry);
	}


	if(iIndex==PD_T1_STATE){
		if(GetField_Double(myHash,"t1_amt",&dTmp)){
			PutField_Double(hTxn,"payout_bal",dTmp);
		}
DEBUGLOG(("process_t1t2_release DBMerchantBalance->ReleasePayoutBal\n"));
		DBObjPtr = CreateObj(DBPtr,"DBMerchantBalance","ReleasePayoutBal");
		iRet = (unsigned long)(DBObjPtr)(csMerchantId,csCountry,csCcyId,dTmp,PD_UPDATE_USER);
	}
	else{
		if(GetField_Double(myHash,"t2_amt",&dTmp)){
			PutField_Double(hTxn,"settlement_bal",dTmp);
		}
DEBUGLOG(("process_t1t2_release DBMerchantBalance->ReleaseSettlementBal\n"));
		DBObjPtr = CreateObj(DBPtr,"DBMerchantBalance","ReleaseSettlementBal");
		iRet = (unsigned long)(DBObjPtr)(csMerchantId,csCountry,csCcyId,dTmp,PD_UPDATE_USER);
	}

	if(iRet==PD_OK){
		DBObjPtr = CreateObj(DBPtr,"DBMerchantBalance","GetCurrentValues");
		iRet = (unsigned long)(DBObjPtr)(csMerchantId,csCcyId,csCountry,hTxn);
	}
	
	if(iRet==PD_OK){
		iRet = AddTxnLog(hTxn);
	}

	if(iRet==PD_OK){
DEBUGLOG(("process_t1t2_release Normal Exit\n"));
	}
	else{
DEBUGLOG(("process_t1t2_release Error[%d]\n",iRet));
ERRLOG("handle_daily_float::process_t1t2_release Error[%d]\n",iRet);
	}

	FREE_ME(hTxn);
	return iRet;
}

int get_psp_release_period(const char* csCountry, const char* csPspId)
{
	int iRet = 0;

	EXEC SQL WHENEVER SQLERROR GOTO get_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;
	
	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_country[PD_COUNTRY_LEN];
		varchar hv_psp_id[PD_PSP_ID_LEN];

		int	v_period;

		short	ind_period = -1;

	EXEC SQL END DECLARE SECTION;

	
	hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("get_psp_release_period country = [%.*s]\n",hv_country.len,hv_country.arr));

	hv_psp_id.len = strlen(csPspId);
        memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);
DEBUGLOG(("get_psp_release_period psp_id  = [%.*s]\n",hv_psp_id.len,hv_psp_id.arr));


	EXEC SQL EXECUTE
	BEGIN
		select	rp_period
		into	:v_period:ind_period
		from	rule_psp_release_period
		where	rp_psp_id=:hv_psp_id
		and	rp_country_id=:hv_country
		and	rp_disabled = '0';

	END;
	END-EXEC;

	if(ind_period>=0){
		iRet = v_period;
	}
	else{
DEBUGLOG(("get_psp_release_period [%s][%s]period not found\n",csCountry,csPspId));
ERRLOG("handle_daily_float::get_psp_release_period [%s][%s]period not found\n",csCountry,csPspId);
		iRet = PD_NOT_FOUND;
	}

	return iRet;

get_error:
DEBUGLOG(("get_psp_release_period error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("handle_daily_float::get_psp_release_period error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return 0;
}


int is_holidays(const char* csCountry, const char* csDate)
{
	int iRet = PD_FALSE;

	EXEC SQL WHENEVER SQLERROR GOTO is_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_country[PD_COUNTRY_LEN];
		varchar	hv_date[PD_DATE_LEN];

		varchar	v_desc[PD_DESC_LEN + 1];

		short	ind_desc = -1;

	EXEC SQL END DECLARE SECTION;

	hv_date.len = strlen(csDate);
        memcpy(hv_date.arr,csDate,hv_date.len);
DEBUGLOG(("is_holidays date = [%.*s]\n",hv_date.len,hv_date.arr));

	hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("is_holidays country = [%.*s]\n",hv_country.len,hv_country.arr));

	EXEC SQL EXECUTE
	BEGIN
		select	h_desc
		into	:v_desc:ind_desc
		from	holiday
		where	h_date=:hv_date
		and	h_country=:hv_country;

	END;
	END-EXEC;

	if(ind_desc>=0){
DEBUGLOG(("Holiday!! [%.*s]\n",v_desc.len,v_desc.arr));
		iRet = PD_TRUE;
	}
	else{
DEBUGLOG(("Not a holiday\n"));
	}

	return iRet;

is_error:
    DEBUGLOG(("is_holidays error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    ERRLOG("handle_daily_float::is_holidays error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}


int parse_arg(int argc,char **argv)
{
        char    c;
	strcpy(cs_cutoff_date,"");

        while ((c = getopt(argc,argv,"d:")) != EOF) {
                switch (c) {
                        case 'd':
                                strcpy(cs_cutoff_date, optarg);
                                break;
                        default:
                                return FAILURE;
                }
        }

        if (!strcmp(cs_cutoff_date,"")) 
                return FAILURE;

        return SUCCESS;
}


int addday(const char* csCurrentDate,int numofdate,char* csNewDate)
{               
	static int vday[] = {-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 29};
        int i_year, i_dd, i_mm, i;
        char buf[40];   
                
        sprintf(buf,"%c%c%c%c", csCurrentDate[0], csCurrentDate[1], csCurrentDate[2], csCurrentDate[3]);
        i_year = atoi(buf);
        sprintf(buf, "%c%c", csCurrentDate[4], csCurrentDate[5]);
        i_mm = atoi(buf);
        sprintf(buf, "%c%c", csCurrentDate[6], csCurrentDate[7]);
        i_dd = atoi(buf);

        i_dd = i_dd + numofdate;
        do
        {
		if(isleap(i_year) && i_mm==2)
			i = 13;
		else
			i = i_mm;

		if(i_dd <= vday[i])
			break;

		i_dd = i_dd - vday[i];

                i_mm = i_mm + 1;
                if (i_mm > 12 )
                {
                        i_year = i_year + (int)(i_mm / 12);
                        i_mm = i_mm % 12;
                }


        }while(PD_TRUE);

        sprintf(csNewDate, "%04d%02d%02d", i_year, i_mm, i_dd);

DEBUGLOG(("addday: NewDate[%s]\n",csNewDate));
        return(PD_OK);
}


int AddTxnLog(const hash_t* hVal)
{
	int 	iRet = PD_OK;
	char	*csTxnSeq;
	char	*csTmp;
	double	dTmp;

	hash_t	*hTxn;
	hTxn = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hTxn,0);

	DBObjPtr = CreateObj(DBPtr,"DBTxnSeq","GetNextTxnSeq");
        strcpy(csTxnSeq,(*DBObjPtr)());
        csTxnSeq[strlen(csTxnSeq)]='\0';
	PutField_CString(hTxn,"txn_seq",csTxnSeq);
DEBUGLOG(("AddTxnLog:: txn_id = [%s]\n",csTxnSeq));
	
	if(GetField_CString(hVal,"cutoff_date",&csTmp)){
		PutField_CString(hTxn,"host_posting_date",csTmp);
DEBUGLOG(("AddTxnLog:: host_posting_date = [%s]\n",csTmp));
	}

	if(GetField_CString(hVal,"merchant_id",&csTmp)){
		PutField_CString(hTxn,"merchant_id",csTmp);
DEBUGLOG(("AddTxnLog:: merchant_id = [%s]\n",csTmp));
	}

	PutField_CString(hTxn,"add_user",PD_UPDATE_USER);
//	PutField_CString(hTxn,"channel_code",);
	PutField_CString(hTxn,"txn_code","RPS");
	PutField_CString(hTxn,"process_type","0200");
	PutField_CString(hTxn,"process_code","500001");
////////////////

	if(GetField_CString(hVal,"currency_id",&csTmp)){
		PutField_CString(hTxn,"txn_ccy",csTmp);
DEBUGLOG(("AddTxnLog:: txn_ccy = [%s]\n",csTmp));
	}

	if(GetField_CString(hVal,"country_id",&csTmp)){
		PutField_CString(hTxn,"txn_country",csTmp);
DEBUGLOG(("AddTxnLog:: txn_country = [%s]\n",csTmp));
	}

	if(GetField_Double(hVal,"payout_bal",&dTmp)){
		PutField_Double(hTxn,"payout_bal",dTmp);
DEBUGLOG(("AddTxnLog:: payout_bal = [%f]\n",dTmp));
	}

	if(GetField_Double(hVal,"settlement_bal",&dTmp)){
		PutField_Double(hTxn,"settlement_bal",dTmp);
DEBUGLOG(("AddTxnLog:: settlement_bal = [%f]\n",dTmp));
	}

	if(GetField_Double(hVal,"total_float",&dTmp)){
		PutField_Double(hTxn,"total_float",dTmp);
DEBUGLOG(("AddTxnLog:: total_float = [%f]\n",dTmp));
	}

	if(GetField_Double(hVal,"total_reserved_amount",&dTmp)){
		PutField_Double(hTxn,"total_reserved_amount",dTmp);
DEBUGLOG(("AddTxnLog:: total_reserved_amount = [%f]\n",dTmp));
	}

	if(GetField_Double(hVal,"total_tfr_hold",&dTmp)){
		PutField_Double(hTxn,"total_tfr_hold",dTmp);
DEBUGLOG(("AddTxnLog:: total_tfr_hold = [%f]\n",dTmp));
	}

	if(GetField_Double(hVal,"total_payout_hold",&dTmp)){
		PutField_Double(hTxn,"total_payout_hold",dTmp);
DEBUGLOG(("AddTxnLog:: total_payout_hold = [%f]\n",dTmp));
	}

	if(GetField_Double(hVal,"total_settlement_hold",&dTmp)){
		PutField_Double(hTxn,"total_settlement_hold",dTmp);
DEBUGLOG(("AddTxnLog:: total_settlement_hold = [%f]\n",dTmp));
	}

	if(GetField_Double(hVal,"payout_in_transit",&dTmp)){
		PutField_Double(hTxn,"payout_in_transit",dTmp);
DEBUGLOG(("AddTxnLog:: payout_in_transit = [%f]\n",dTmp));
	}

	if(GetField_Double(hVal,"settlement_in_transit",&dTmp)){
		PutField_Double(hTxn,"settlement_in_transit",dTmp);
DEBUGLOG(("AddTxnLog:: settlement_in_transit = [%f]\n",dTmp));
	}


	DBObjPtr = CreateObj(DBPtr,"DBTransaction","Add");
	iRet = (unsigned long) ((*DBObjPtr)(hTxn));

	if (iRet == PD_OK ) {
		DBObjPtr = CreateObj(DBPtr,"DBTransaction","AddDetail");
		iRet = (unsigned long) ((*DBObjPtr)(hTxn));
	}

	if (iRet == PD_OK ) {
		DBObjPtr = CreateObj(DBPtr,"DBTransaction","UpdateDetail");
		iRet = (unsigned long) ((*DBObjPtr)(hTxn));
	}

DEBUGLOG(("AddTxnLog:: iRet = [%d]\n",iRet));

	FREE_ME(hTxn);
	return iRet;
}
