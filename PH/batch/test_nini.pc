#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <sqlca.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "myrecordset.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

static char	cDebug = 'Y';
char		csFunc[PD_TAG_LEN] = "";
char		csTxnCode[PD_TXN_CODE_LEN];
char		csServiceCode[PD_SERVICE_CODE_LEN] = "";
char		csDesc[PD_DESC_LEN+1] = "";
double		dDailyLimit = 0.0;
int		iSysSupport = -1;
int         	bUpdateDailyLimit=0;
char		csPspChannel[PD_PSP_CHANNEL_CODE_LEN];
hash_t		*argHash;


OBJPTR(DB);

static int parse_arg_test_nini(int argc, char ** argv);

static int parse_arg_psp_param_check(int argc, char ** argv);

static int parse_arg_txn_balance_log(int argc, char ** argv);

int batch_proc_test_nini(int argc, char * argv[]);

int batch_proc_psp_param_check(int argc, char * argv[]);

int batch_proc_txn_balance_log(int argc, char * argv[]);

void printDetailOfTestNini(hash_t*  myHash);

void printDetailOfPspParamCheck(hash_t*  myHash);

int checkFunction (const char *func);

static int parse_arg(int argc, char ** argv)
{
	return parse_arg_txn_balance_log(argc,argv);
}

int batch_init(int argc, char * argv[])
{
       	argHash = (hash_t *)malloc(sizeof(hash_t));
        hash_init(argHash, 0);
        
	return SUCCESS;
}

int batch_proc(int argc, char * argv[])
{
	if (parse_arg(argc, argv) != PD_OK)
	{
		exit(1);
	}

printf("batch_proc end\n");
	return batch_proc_txn_balance_log(argc,argv);
}


void printDetailOfTestNini(hash_t*  myHash){
        char	* csTmp = NULL;
        double	dTmp = 0.0;
        int	iTmp = 0;
        
printf("================================\n");
        printf("TxnCode [%s]\n", csTxnCode);
	if (GetField_CString(myHash, "service_code", &csTmp))
printf("ServiceCode = [%s]\n", csTmp);
	else{
        	printf("ServiceCode [%s]\n", csServiceCode);
	}
	if (GetField_CString(myHash, "desc", &csTmp))
printf("Desc = [%s]\n", csTmp);

	if (GetField_Int(myHash, "sys_support", &iTmp))
printf("SysSupport = [%d]\n", iTmp);

	if (GetField_Double(myHash, "daily_limit", &dTmp))
printf("DailyLimit = [%lf]\n", dTmp);

}
	
int  getDetailOfTestNini(){

        int iRet = PD_OK;
        hash_t  * myHash;
        myHash = (hash_t *)malloc(sizeof(hash_t));
        hash_init(myHash, 0);
        
	DBObjPtr = CreateObj(DBPtr, "DBTestNini", "GetDetail");
        iRet =(unsigned long)(DBObjPtr)(csTxnCode,csServiceCode,myHash);
	
	printDetailOfTestNini(myHash);
	return iRet;

}

static int parse_arg_test_nini(int argc, char ** argv)
{

printf("Usage: %s -t <TxnCode> -s <ServiceCode> -d <Desc> -l <DailyLimit> -p <SysSupport> -f <FUNCTION>\n", argv[0]);
	char c;

	while ((c = getopt(argc, argv, "t:s:d:l:p:f:")) != EOF)
	{
		switch (c)
		{
			case 't':
				strcpy(csTxnCode, optarg);
				break;

			case 's':
				strcpy(csServiceCode, optarg);
				break;

			case 'd':
				strcpy(csDesc, optarg);
				break;

			case 'l':
				sscanf(optarg, "%lf", &dDailyLimit);
				bUpdateDailyLimit=1;
				break;
			case 'p':
				iSysSupport = atoi(optarg);
				break;
			case 'f':
				strcpy(csFunc, optarg);
				break;

			default:
				return PD_ERR;
		}
	}
    if(!strcmp(csFunc, "")){
printf("Fail in parsing arguments\n");
		return PD_ERR;
    }
    if(!strcmp(csFunc, "Add")){
        if ( !strcmp(csTxnCode, "")  || !strcmp(csServiceCode, "")  || !strcmp(csDesc, "") || (dDailyLimit < 0.0)|| (iSysSupport < 0) || !strcmp(csFunc, "")){
    printf("Fail in parsing arguments\n");
            return PD_ERR;
        }
    }
    if(!strcmp(csFunc, "GetDetail")|| !strcmp(csFunc, "Update")){
            if ( (!strcmp(csTxnCode, "") || !strcmp(csServiceCode, "") )){
printf("Fail in parsing arguments\n");
                return PD_ERR;
            }
    }
    if(!strcmp(csFunc, "GetDetailByTxnCode")){
            if ( !strcmp(csTxnCode, "") ){
printf("Fail in parsing arguments\n");
                return PD_ERR;
            }
    }
printf("TxnCode: %s , ServiceCode: %s, Desc: %s, DailyLimit: %lf , SysSupport: %d, FUNCTION: %s\n", csTxnCode, csServiceCode, csDesc, dDailyLimit,iSysSupport, csFunc);
	return PD_OK;
}


void printDetailOfPspParamCheck(hash_t*  myHash){
        int	iTmp = 1;
        
printf("================================\n");

	if (GetField_Int(myHash, "verify_sign", &iTmp))
printf("VerifySign = [%d]\n", iTmp);

	if (GetField_Int(myHash, "amt_in_dec", &iTmp))
printf("AmtInDecimal = [%d]\n", iTmp);

	if (GetField_Int(myHash, "txn_date_present", &iTmp))
printf("TxnDatePresent = [%d]\n", iTmp);


}
	
int  getDetailOfPspParamCheck(){

        int iRet = PD_OK;
        hash_t  * myHash;
        myHash = (hash_t *)malloc(sizeof(hash_t));
        hash_init(myHash, 0);
        
	DBObjPtr = CreateObj(DBPtr, "DBPspParamCheck", "GetDetail");
        iRet =(unsigned long)(DBObjPtr)(csPspChannel,myHash);
	
	if(iRet == PD_FOUND){
		printDetailOfPspParamCheck(myHash);
	}

	FREE_ME(myHash);
	
	return iRet;

}

static int parse_arg_txn_balance_log(int argc, char ** argv)
{

printf("Usage: %s -d <TxnAprvDate> -p <PARTY_TYPE> -c <IS_COMPLETED> -u <UPDATE_USER>-f <FUNCTION>\n", argv[0]);
	char 	c;
	char	csTxnDate[PD_TXN_DATE_LEN] = "";
	char	cPartyType;
	int  	iTmp;
	char 	csUser[PD_UPDATE_USER_LEN]="";
	int 	iRet = PD_OK;	
	
	memset(csTxnDate, '\0', sizeof(csTxnDate)); 
	memset(csUser, '\0', sizeof(csUser)); 
	
	while ((c = getopt(argc, argv, "d:p:c:u:f:")) != EOF)
        {       
                switch (c)
                {
                        
                        case 'd':
				strcpy(csTxnDate, optarg);
                                PutField_CString(argHash,"txn_aprv_date",csTxnDate);
                                break;
                        case 'p':
				cPartyType =optarg[0];
                                PutField_Char(argHash,"party_type",cPartyType);
                                break;
                        case 'c':
				iTmp = atoi(optarg);
                                PutField_Int(argHash,"is_completed",iTmp);
                                break;
                        case 'u':
				strcpy(csUser, optarg);
                                PutField_CString(argHash,"update_user",csUser);
                                break;
                        
                        case 'f':
                                strcpy(csFunc, optarg);
                                break;
                        
                        default:
                                return PD_ERR;
                }
        }

	if(checkFunction("UpdateBalLog") == PD_ERR && checkFunction("IsCompleted")){
		return PD_ERR;
	}

	if(!strcmp("UpdateBalLog",csFunc)){
	
		if(!GetField_Int(argHash,"is_completed",&iTmp)){
			iRet = PD_ERR;
		}
printf("is_completed [%i]\n",iTmp);

		if( !strcmp(csUser,"")){
			iRet = PD_ERR;
		}

	}
	if( !strcmp(csTxnDate,"")){
		iRet = PD_ERR;
	}
printf("txn_aprv_date :[%s] \n",csTxnDate);

	if(! GetField_Char(argHash,"party_type",&cPartyType)){
		iRet = PD_ERR;
	}
printf("party_type [%c]\n",cPartyType);



	if(iRet != PD_OK){
printf("Fail in parsing arguments\n");
	}



	return iRet;

}
static int parse_arg_psp_param_check(int argc, char ** argv)
{

printf("Usage: %s -c <PspChannel> -f <FUNCTION>\n", argv[0]);
	char c;

	while ((c = getopt(argc, argv, "c:f:")) != EOF)
	{
		switch (c)
		{
			case 'c':
				strcpy(csPspChannel, optarg);
				break;

			case 'f':
				strcpy(csFunc, optarg);
				break;

			default:
				return PD_ERR;
		}
	}
	if(!strcmp(csFunc, "")){
printf("Fail in parsing arguments\n");
		return PD_ERR;
	}
	if(!strcmp(csFunc, "GetDetail")){
        	if ( !strcmp(csPspChannel, "")){
printf("Fail in parsing arguments\n");
        		return PD_ERR;
        	}
	}else{

printf("Invalid Function!!\n");
	return PD_ERR;
	}

printf("PspChannel: %s , FUNCTION: %s\n", csPspChannel, csFunc);

	return PD_OK;
}

int checkFunction(const char *funcName){
	if(!strcmp(csFunc, "")){
printf("!! Missing Function !!\n");
		return PD_ERR;
	}
	if(!strcmp(csFunc, funcName)){
printf("FUNCTION: %s\n", csFunc);
		return PD_OK;
	}else{
printf("Invalid Function!!\n");
		return PD_ERR;
	}

}


int batch_proc_txn_balance_log(int argc, char * argv[]){

	int iRet = PD_OK;
	char 	*csTxnDate = NULL;
	char	cPartyType;
	
	
	if( GetField_CString(argHash,"txn_aprv_date",&csTxnDate)){
printf("####select from txn_balance_log where txn_aprv_date = %s and",csTxnDate);

	}

	if( GetField_Char(argHash,"party_type",&cPartyType)){
printf("  party_type = %c \n",cPartyType);
	}

	DBObjPtr = CreateObj(DBPtr, "DBTxnBalanceLog", csFunc);
	if(!strcmp("UpdateBalLog",csFunc))
	{
	
        	iRet =(unsigned long)(DBObjPtr)(argHash);
	
		if(iRet != PD_OK){
printf("DBTxnBalanceLog_UpdateBalLog Failed!");
			iRet = PD_ERR;
		}
	}

	if(!strcmp("IsCompleted",csFunc))
	{
		
        	iRet =(unsigned long)(DBObjPtr)(csTxnDate,cPartyType);
	
		if(iRet == PD_TRUE)
		{
printf("DBTxnBalanceLog_IsCompleted True!\n");
			iRet = PD_OK;
		}else
		{
		printf("DBTxnBalanceLog_IsCompleted False!\n");
		iRet = PD_OK;
		
		}

	}

	
	EXEC SQL WHENEVER SQLERROR GOTO get_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_txn_date[PD_TXN_DATE_LEN];
		char		hv_party_type;
		int		v_is_completed;
		varchar		v_update_user[PD_UPDATE_USER_LEN +1];
		short		ind_is_completed = -1;
		short		ind_update_user = -1;
		EXEC SQL END DECLARE SECTION;
	
		hv_txn_date.len = strlen(csTxnDate);
		memcpy(hv_txn_date.arr, csTxnDate, hv_txn_date.len);
		hv_party_type = cPartyType;

		EXEC SQL SELECT	tb_is_completed,tb_update_user 
			INTO	: v_is_completed: ind_is_completed,
				: v_update_user: ind_update_user
			FROM TXN_BALANCE_LOG
			WHERE tb_txn_aprv_date = :hv_txn_date
			AND	tb_party_type = :hv_party_type;


		if(ind_update_user>=0){
			v_update_user.arr[v_update_user.len] = '\0';
printf("####Result: update_user = %s  ",v_update_user.arr);
		}
		if(ind_is_completed >=0 ){
printf("  is_completed = %d\n",v_is_completed);
		}
		
	

	return iRet;
get_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;	

}
int batch_proc_psp_param_check(int argc, char * argv[])
{
	int	iRet = PD_OK;
	hash_t	* hIn;

	hIn = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hIn, 0);

	if(strcmp(csPspChannel, "")){
		PutField_CString(hIn, "psp_channel", csPspChannel);
	}

	if(!strcmp(csFunc,"GetDetail")){
		iRet = getDetailOfPspParamCheck();
	}

printf("PspParamCheck: %s iRet = [%d]\n", csFunc, iRet);

	FREE_ME(hIn);

	return iRet;
}

int batch_proc_test_nini(int argc, char * argv[])
{
	int iRet = PD_OK;

	hash_t	* hIn;
	hIn = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hIn, 0);

	if(strcmp(csTxnCode, "")){
		PutField_CString(hIn, "txn_code", csTxnCode);
	}
	if(strcmp(csServiceCode, "")){
		PutField_CString(hIn, "service_code", csServiceCode);
	}
	if(strcmp(csDesc, "")){
		PutField_CString(hIn, "desc", csDesc);
	}
	if(strcmp(csTxnCode, "")){
		PutField_CString(hIn, "txn_code", csTxnCode);
	}
	if(strcmp(csServiceCode, "")){
		PutField_CString(hIn, "service_code", csServiceCode);
	}
	if(strcmp(csDesc, "")){
		PutField_CString(hIn, "desc", csDesc);
	}
	if(iSysSupport>=0){
		PutField_Int(hIn, "sys_support", iSysSupport);
	}
	if(dDailyLimit>=0 && bUpdateDailyLimit){
		PutField_Double(hIn, "daily_limit", dDailyLimit);
	}
	PutField_CString(hIn, "add_user", PD_UPDATE_USER);
	PutField_CString(hIn, "update_user", PD_UPDATE_USER);


	if (!strcmp(csFunc, "Add") ){
printf("Call TestNini: %s\n", csFunc);
		DBObjPtr = CreateObj(DBPtr, "DBTestNini", csFunc);
		iRet = (unsigned long)(DBObjPtr)(hIn);
		getDetailOfTestNini();
	}
	else if (!strcmp(csFunc, "Update")){
printf("Call TestNini: %s\n", csFunc);
		DBObjPtr = CreateObj(DBPtr, "DBTestNini", csFunc);
		iRet = (unsigned long)(DBObjPtr)(hIn);
		getDetailOfTestNini();
	}
	else if(!strcmp(csFunc,"GetDetail")){
		iRet = getDetailOfTestNini();
	}
	else if(!strcmp(csFunc,"GetDetailByTxnCode")){
		recordset_t     * rInfoSet;

		rInfoSet = (recordset_t *)malloc(sizeof(recordset_t));
		recordset_init(rInfoSet, 0);

		DBObjPtr = CreateObj(DBPtr, "DBTestNini", csFunc);
        	iRet = (unsigned long)(DBObjPtr)(csTxnCode,rInfoSet);
		if (iRet == PD_FOUND)
                {
			hash_t*  hRec;	
                        hRec = RecordSet_GetFirst(rInfoSet);

                        while (hRec)
                        {
				printDetailOfTestNini(hRec);
				hRec = RecordSet_GetNext(rInfoSet);
			}
		}
		RecordSet_Destroy(rInfoSet);
                FREE_ME(rInfoSet);

	}
	else
	{
		iRet = PD_ERR;
printf("Invalid Function!!\n");
	}

printf("TestNini: %s iRet = [%d]\n", csFunc, iRet);

	FREE_ME(hIn);

printf("batch_proc end\n");
	return iRet;
}


int batch_terminate(int argc, char * argv[])
{
	FREE_ME(argHash);	
	return SUCCESS;
}

