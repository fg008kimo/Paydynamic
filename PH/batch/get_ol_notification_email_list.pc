/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/06/07              LokMan Chow
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"
#include "dates.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cs_merchant_id[PD_MERCHANT_ID_LEN + 1];
char    cs_funct[PD_CODE_LEN +1];

char    cDebug = 'Y';

OBJPTR(DB);
OBJPTR(Txn);

int parse_arg(int argc,char **argv);
int process_list(const char *csMerchantId, const char *csFunction);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}




int batch_proc(int argc, char* argv[])
{
        int     iRet;

	iRet = parse_arg(argc,argv);
               
        if (iRet != SUCCESS) {
		printf("usage:  -m merchant_id -f function\n");
                return (iRet);
        }

	if(iRet==PD_OK){
		iRet = process_list(cs_merchant_id,cs_funct);
	}


	return iRet;


}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}

int parse_arg(int argc,char **argv)
{
	char    c;
	strcpy(cs_merchant_id,"");
	strcpy(cs_funct,"");

	while ((c = getopt(argc,argv,"m:f:")) != EOF) {
		switch (c) {
			case 'm':
				strcpy(cs_merchant_id, optarg);
				break;
			case 'f':
				strcpy(cs_funct, optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (!strcmp(cs_merchant_id,"") || !strcmp(cs_funct,""))
		return FAILURE;

	return SUCCESS;
}


int process_list(const char *csMerchantId, const char *csFunction)
{
        int     iRet = PD_OK;
	int	iCnt = 0;

DEBUGLOG(("--------------process_list--------------\n"));
	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_merchant_id[PD_MERCHANT_ID_LEN +1];
		varchar	hv_funct[PD_CODE_LEN+1];
		varchar	v_email[PD_CUSTOMER_EMAIL_LEN+1];

		short	ind_merchant_id = -1;
		short	ind_funct = -1;
		short	ind_email = -1;

		short   hv_return_value;
                SQL_CURSOR      c_cursor_getlist;
	EXEC SQL END DECLARE SECTION;

	hv_merchant_id.len = strlen(csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);
	ind_merchant_id = 0;
DEBUGLOG(("process_list merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));

	hv_funct.len = strlen(csFunction);
	memcpy(hv_funct.arr,csFunction,hv_funct.len);
	ind_funct= 0;
DEBUGLOG(("process_list function = [%.*s]\n",hv_funct.len,hv_funct.arr));

	EXEC SQL ALLOCATE       :c_cursor_getlist;
        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_ol_rule_email_notify_find(:hv_merchant_id:ind_merchant_id,
								      :hv_funct:ind_funct,
								      :c_cursor_getlist);
                END;
        END-EXEC;

        if (hv_return_value > 0 ) {
DEBUGLOG(("process_list: Found!\n"));
                for (;;) {
			ind_email = -1;
			
			EXEC SQL WHENEVER NOTFOUND DO break;
                        EXEC SQL FETCH :c_cursor_getlist
                        INTO    :v_email:ind_email;

                        if (SQLCODE == SQL_NOT_FOUND) {
                                break;
                        }

			if(ind_email>=0){
                                v_email.arr[v_email.len] = '\0';
				printf("%s\n",v_email.arr);
DEBUGLOG(("process_list: email = [%s]\n",v_email.arr));
				iCnt++;
                        }
		}
	}
	EXEC SQL CLOSE :c_cursor_getlist;
	EXEC SQL FREE :c_cursor_getlist;


	if(iCnt>0){
DEBUGLOG(("-------------- [%d]Record Found --------------\n",iCnt));
	}
	else{
DEBUGLOG(("-------------- NO Email Found--------------\n"));
		iRet = PD_ERR;
	}

	return	iRet;

sql_error:
    DEBUGLOG(("process_list error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    ERRLOG("get_ol_notification_email_list::process_list sql error %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_getlist;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}
