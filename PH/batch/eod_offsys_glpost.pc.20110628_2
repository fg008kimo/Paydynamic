/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/21	             Simon Fung
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "eod_offsys_glpost.h"
#include "mymd5.h"
#include "eod_glutility.h"
#include "ObjPtr.h"

OBJPTR(BO);

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define	PD_MY_DELIMITOR	","
#define	PD_FILE_DELIMITOR "	"
#define	PD_HASHKEY_DELIMITOR ":"

#define	PD_CHAR		0x0D
#define	PD_SPACE	0x20

char    cDebug = 'Y';
char    cs_inputfile[PD_MAX_FILE_LEN + 1];
char    cs_date[PD_DATE_LEN + 1];

int parse_arg(int argc,char **argv);
int verify_file(FILE *fin);
int process_file(FILE *fin);
int myGroupRecs(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], hash_t *hTxn, char* csKey, double dAmt, int* iJnlKeyCnt);
int myPostTxn(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], const hash_t *hTxn, const int iJnlKeyCnt);

//int process_txn();

int batch_init(int argc, char* argv[])
{
	if (argc < 1) {
		printf("usage: -d Date\n");
	    return FAILURE;
	}
	else
	    return SUCCESS;
}



int batch_proc(int argc, char* argv[])
{
	FILE	*fin;
	int	iRet;
  //char cs_infile_name[PD_MAX_FILE_LEN + 1];

	
	iRet = parse_arg(argc,argv);

	if (iRet != SUCCESS) {
    		printf("*usage: -d Date\n");
		return (iRet);
	}
	
	DEBUGLOG(("File Path = [%s]\n", getenv("REPORT_DATA")));
	DEBUGLOG(("File directory = [%s]\n", OFFLINE_DATA_FOLDER));
	DEBUGLOG(("File Prefix = [%s]\n", OFFLINE_DATA_FILE_PREFIX));
	DEBUGLOG(("File Date = [%s]\n",cs_date));
	
	sprintf(cs_inputfile, "%s/%s/%s_%s.csv", getenv("REPORT_DATA"), OFFLINE_DATA_FOLDER, OFFLINE_DATA_FILE_PREFIX, cs_date);

	fin = fopen(cs_inputfile,"r");
	if (fin == NULL) {
		DEBUGLOG(("Error Opening file = [%s]\n",cs_inputfile));
		return FAILURE;
	}

	DEBUGLOG(("Opened file = [%s] for read\n",cs_inputfile));

	//iRet = verify_file(fin,fout);
	//DEBUGLOG(("verify_file reslut = [%d]\n",iRet));	
	
	iRet = SUCCESS;
	
	if (iRet == SUCCESS) {
		rewind(fin);
		iRet = process_file(fin);
	}

	fclose(fin);

	return iRet;

}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}
                     
int parse_arg(int argc,char **argv)
{               
	char    c;
	strcpy(cs_inputfile,"");
	          
	while ((c = getopt(argc,argv,"d:")) != EOF) {
	  switch (c) {
      case 'd':
              strcpy(cs_date, optarg);
              break;
      default:
              return FAILURE;
	  }
	}       
	
	DEBUGLOG(("[%s]\n",cs_date));
	if (!strcmp(cs_date,""))
	  return FAILURE;
	  
	return SUCCESS; 
}               

int verify_file(FILE *fin)
{
	int iRet = FAILURE;
	int iLineCnt = 0;
	int	iCount = 0;
	int iMerchKeyCnt;
	int iPSPKeyCnt;
	char    csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
	char    cs_input_buf[PD_MAX_BUFFER +1];;
	char	*p=NULL;
	char csKey[PD_TMP_MSG_BUF_LEN];
	
	char *csSign;
	csSign = (char*) malloc (1024 * 2 +1);
	char *csOUT;
	csOUT = (char*) malloc (1024 * 2 +1);

  iMerchKeyCnt = 0;
  iPSPKeyCnt = 0;
  
  fgets(cs_input_buf,PD_MAX_BUFFER,fin);
  if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A || cs_input_buf[strlen(cs_input_buf) - 1] == 0x10)
         cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
	strcpy(cs_input_buf,TrimAllChar(cs_input_buf,strlen(cs_input_buf),PD_CHAR));

	DEBUGLOG(("%s\n",cs_input_buf));
	
	iCount = 0;
	
	// Breakdown header line
  p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
  if (p == NULL) {
		DEBUGLOG(("Invalid File Header"));
		return FAILURE;
	}
  strcpy(csList[iCount],p);
  iCount++;

  while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
    strcpy(csList[iCount],p);
    iCount++;
  }               

	if (iCount == HEADER_ITEM_SIZE) {

		// Build Key
		strcpy(csKey, csList[IDX_HD_TXN_CNT]);
		strcat(csKey, csList[IDX_HD_TXN_AMT]);
		strcat(csKey, csList[IDX_HD_FEE_AMT]);
		strcat(csKey, csList[IDX_HD_NET_AMT]);
		strcat(csKey, csList[IDX_HD_MU_AMT]);
		DEBUGLOG(("Bulid Header MD5 Key = [%s]\n",csKey));
		
		strcpy(csSign, csList[IDX_HD_CHECKSUM]);		

		DEBUGLOG(("Header Checksum = [%s]\n",csSign));
		md5sum(csKey,strlen(csKey),csOUT);
		DEBUGLOG(("Calculated Header Checksum = [%s]\n",csOUT));
		
		if (strcmp(csSign,csOUT)!=0) {
			DEBUGLOG(("Invalid Header Checksum [%s] <> Calculated:[%s]\n",csSign, csOUT));
			return FAILURE;
		}		

		iLineCnt = 0;

	  while (fgets(cs_input_buf,PD_MAX_BUFFER, fin) != NULL) {
	
	  	if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A)
				cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
			strcpy(cs_input_buf,TrimAllChar(cs_input_buf,strlen(cs_input_buf),PD_CHAR));
			DEBUGLOG(("%s\n",cs_input_buf));
	    iCount = 0;
	
	    p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
	    if (p == NULL) {
				DEBUGLOG(("Invalid File Detail"));
				return FAILURE;
			}
	    strcpy(csList[iCount],p);
	    iCount++;
	
	    while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
		    strcpy(csList[iCount],p);
		    iCount++;
	    }               
	
			if (iCount == DETAIL_ITEM_SIZE) {
				iLineCnt++;
				
				// Detail
				/*
				DEBUGLOG(("IDX_TXN_TYPE=[%s]\n",csList[IDX_TXN_TYPE]));
				DEBUGLOG(("IDX_COUNTRY_CODE=[%s]\n",csList[IDX_COUNTRY_CODE]));
				DEBUGLOG(("IDX_TXN_DATE=[%s]\n",csList[IDX_TXN_DATE]));
				DEBUGLOG(("IDX_TXN_ID=[%s]\n",csList[IDX_TXN_ID]));
				DEBUGLOG(("IDX_MERCHANT=[%s]\n",csList[IDX_MERCHANT]));
				DEBUGLOG(("IDX_PSP=[%s]\n",csList[IDX_PSP]));
				DEBUGLOG(("IDX_TXN_AMT_CCY=[%s]\n",csList[IDX_TXN_AMT_CCY]));
				DEBUGLOG(("IDX_TXN_AMT=[%s]\n",csList[IDX_TXN_AMT]));
				DEBUGLOG(("IDX_TXN_FEE_CCY=[%s]\n",csList[IDX_TXN_FEE_CCY]));
				DEBUGLOG(("IDX_TXN_FEE=[%s]\n",csList[IDX_TXN_FEE]));
				DEBUGLOG(("IDX_NET_AMT_CCY=[%s]\n",csList[IDX_NET_AMT_CCY]));
				DEBUGLOG(("IDX_NET_AMT=[%s]\n",csList[IDX_NET_AMT]));
				DEBUGLOG(("IDX_MU_AMT_CCY=[%s]\n",csList[IDX_MU_AMT_CCY]));
				DEBUGLOG(("IDX_MU_AMT=[%s]\n",csList[IDX_MU_AMT]));
				DEBUGLOG(("IDX_PSP_AMT_CCY=[%s]\n",csList[IDX_PSP_AMT_CCY]));
				DEBUGLOG(("IDX_PSP_AMT=[%s]\n",csList[IDX_PSP_AMT]));
				DEBUGLOG(("IDX_TXN_STATUS=[%s]\n",csList[IDX_TXN_STATUS]));
				DEBUGLOG(("IDX_DTL_CHECKSUM=[%s]\n",csList[IDX_DTL_CHECKSUM]));
				DEBUGLOG(("IDX_MERCHANT_REF=[%s]\n",csList[IDX_MERCHANT_REF]));
				md5(concat(country code,merchant, txn amt, txn free amt,  net amt, markup amt, psp/deliveried amt))
				*/
				
				// Build Key
				strcpy(csKey, csList[IDX_COUNTRY_CODE]);
				strcat(csKey, csList[IDX_MERCHANT]);
				strcat(csKey, csList[IDX_TXN_AMT]);
				strcat(csKey, csList[IDX_TXN_FEE]);
				strcat(csKey, csList[IDX_NET_AMT]);
				strcat(csKey, csList[IDX_MU_AMT]);
				strcat(csKey, csList[IDX_PSP_AMT]);
				DEBUGLOG(("Bulid MD5 Key = [%s]\n",csKey));
				
				strcpy(csSign, csList[IDX_DTL_CHECKSUM]);		

				DEBUGLOG(("Detail Checksum = [%s]\n",csSign));
				md5sum(csKey,strlen(csKey),csOUT);
				
				DEBUGLOG(("Calculated Checksum = [%s]\n",csOUT));
				
				if (strcmp(csSign,csOUT)!=0) {
					DEBUGLOG(("Invalid Detail Checksum [%s] <> Calculated:[%s]\n",csSign, csOUT));
					return FAILURE;
				}			
			}	else {
				DEBUGLOG(("Invalid Detail size =[%d]\n",iCount));
				return FAILURE;
			}			
		}
	} else {
		DEBUGLOG(("Invalid Header size =[%d]\n",iCount));
		return FAILURE;
	}

	if (iLineCnt == 0) {
		DEBUGLOG(("No File Detail Found\n"));
	}

	DEBUGLOG(("verify_file completed return =[%d]\n",iRet));

	iRet = SUCCESS;
	
	return iRet;
}

int process_file(FILE *fin)
{
	int iRet = FAILURE;
	int iLineCnt = 0;
	int	iCount;
	int iJnlKeyCnt=0;	
	char    csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
	char    csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN];
	char    cs_input_buf[PD_MAX_BUFFER +1];;
	char	*p;
	char csPartyType[1];
	double 	dTmpAmt;
	hash_t *hTxnAmt;
	char csKey[PD_TMP_MSG_BUF_LEN];

  hTxnAmt = (hash_t*) malloc (sizeof(hash_t));
  hash_init(hTxnAmt,0);
	
  iCount = 0;
  
  fgets(cs_input_buf,PD_MAX_BUFFER,fin);
  if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A || cs_input_buf[strlen(cs_input_buf) - 1] == 0x10)
         cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
	strcpy(cs_input_buf,TrimAllChar(cs_input_buf,strlen(cs_input_buf),PD_CHAR));

	DEBUGLOG(("%s\n",cs_input_buf));

	iLineCnt = 0;

  while (fgets(cs_input_buf,PD_MAX_BUFFER, fin) != NULL) {
		iLineCnt++;
		
  	if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A)
			cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
		strcpy(cs_input_buf,TrimAllChar(cs_input_buf,strlen(cs_input_buf),PD_CHAR));
		DEBUGLOG(("%s\n",cs_input_buf));
    iCount = 0;

    p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
    if (p == NULL)
			return FAILURE;
    strcpy(csList[iCount],TrimAllChar(p, strlen(p), PD_SPACE));
    iCount++;

    while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
	    strcpy(csList[iCount],TrimAllChar(p, strlen(p), PD_SPACE));
	    iCount++;
    }               

		if (1) {
		
			// Detail
			/*
			DEBUGLOG(("IDX_TXN_TYPE=[%s]\n",csList[IDX_TXN_TYPE]));
			DEBUGLOG(("IDX_COUNTRY_CODE=[%s]\n",csList[IDX_COUNTRY_CODE]));
			DEBUGLOG(("IDX_TXN_DATE=[%s]\n",csList[IDX_TXN_DATE]));
			DEBUGLOG(("IDX_TXN_ID=[%s]\n",csList[IDX_TXN_ID]));
			DEBUGLOG(("IDX_MERCHANT=[%s]\n",csList[IDX_MERCHANT]));
			DEBUGLOG(("IDX_PSP=[%s]\n",csList[IDX_PSP]));
			DEBUGLOG(("IDX_TXN_AMT_CCY=[%s]\n",csList[IDX_TXN_AMT_CCY]));
			DEBUGLOG(("IDX_TXN_AMT=[%s]\n",csList[IDX_TXN_AMT]));
			DEBUGLOG(("IDX_TXN_FEE_CCY=[%s]\n",csList[IDX_TXN_FEE_CCY]));
			DEBUGLOG(("IDX_TXN_FEE=[%s]\n",csList[IDX_TXN_FEE]));
			DEBUGLOG(("IDX_NET_AMT_CCY=[%s]\n",csList[IDX_NET_AMT_CCY]));
			DEBUGLOG(("IDX_NET_AMT=[%s]\n",csList[IDX_NET_AMT]));
			DEBUGLOG(("IDX_MU_AMT_CCY=[%s]\n",csList[IDX_MU_AMT_CCY]));
			DEBUGLOG(("IDX_MU_AMT=[%s]\n",csList[IDX_MU_AMT]));
			DEBUGLOG(("IDX_PSP_AMT_CCY=[%s]\n",csList[IDX_PSP_AMT_CCY]));
			DEBUGLOG(("IDX_PSP_AMT=[%s]\n",csList[IDX_PSP_AMT]));
			DEBUGLOG(("IDX_TXN_STATUS=[%s]\n",csList[IDX_TXN_STATUS]));
			DEBUGLOG(("IDX_DTL_CHECKSUM=[%s]\n",csList[IDX_DTL_CHECKSUM]));
			DEBUGLOG(("IDX_MERCHANT_REF=[%s]\n",csList[IDX_MERCHANT_REF]));
			*/
			
			// Convert Transaction Type to PD TXN CODE
			if (!strcmp(csList[IDX_TXN_TYPE],DSP_TYPE)) {
				// Deposit
				strcpy(csList[IDX_TXN_TYPE],PD_OFFSYS_DEPOSIT_TXN_CODE);
			} else if (!strcmp(csList[IDX_TXN_TYPE],WTD_TYPE)) {
				// Payout 
				strcpy(csList[IDX_TXN_TYPE],PD_OFFSYS_PAYOUT_TXN_CODE);
			} else if (!strcmp(csList[IDX_TXN_TYPE],MST_TYPE)) { 
				// Settlement
				strcpy(csList[IDX_TXN_TYPE],PD_OFFSYS_SETTLEMENT_TXN_CODE);
			} else {
				// Unknown
				DEBUGLOG(("Unknown Transaction Type =[%s]\n",csList[IDX_TXN_TYPE]));
				continue;
			}
			
			// Flaten into 2D
			// by Txn Type, Country, Txn Date, Merchant, Txn Currency, Txn Fee Currency, Txn Net Amt Currency, Txn Markup Currency, PSP/Delivered Currency.
			
			// Build Key for Merchant Net Amount
			// ========================================================================
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_TYPE_NET_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
			strcat(csKey, csPartyType);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_MERCHANT]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_NET_AMT_CCY]);

						
			// Insert into summary hash table 
			DEBUGLOG(("csKey = [%s]\n",csKey));
			
			// Net Txn Amt
			if (!is_numeric(csList[IDX_NET_AMT])) {
				DEBUGLOG(("Invalid Net Amount at line [%d]\n",iLineCnt));
				return FAILURE;
			}
			
			dTmpAmt = atof(csList[IDX_NET_AMT]);
			DEBUGLOG(("Current TxnNet  = [%f]\n",dTmpAmt));
			// Check key exists
			DEBUGLOG(("before myGroupRecs JKey count = [%d]\n",iJnlKeyCnt));
			iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
			DEBUGLOG(("after myGroupRecs JKey count = [%d]\n",iJnlKeyCnt));
					
			// ========================================================================
			
			// Build Key for PSP Txn Amount
			// ========================================================================
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_TYPE_TXN_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			//strcat(csKey, PD_TYPE_PSP);
			sprintf(csPartyType, "%c", PD_TYPE_PSP);
			strcat(csKey, csPartyType);			
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_PSP]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_AMT_CCY]);

			// Insert into summary hash table 
			DEBUGLOG(("csKey = [%s]\n",csKey));

			if (!is_numeric(csList[IDX_TXN_AMT])) {
				DEBUGLOG(("Invalid Txn Amount at line [%d]\n",iLineCnt));
				return FAILURE;
			}
			
			// Txn Amt
			dTmpAmt = atof(csList[IDX_TXN_AMT]);
			DEBUGLOG(("Current TxnAmt  = [%f]\n",dTmpAmt));
			// Check key exists
			iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);

			// ========================================================================

			// Build Key for Fee Amount
			// ========================================================================
			if (strlen(csList[IDX_TXN_FEE])>0) {
				if (!is_numeric(csList[IDX_TXN_FEE])) {
					DEBUGLOG(("Invalid Txn Fee at line [%d]\n",iLineCnt));
					return FAILURE;
				}
				
				// Txn Fee
				dTmpAmt = atof(csList[IDX_TXN_FEE]);
				
				if (dTmpAmt != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_FEE);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					//strcat(csKey, PD_TYPE_GLOBAL);
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);						
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_FEE_CCY]);
										
					// Insert into summary hash table 
					DEBUGLOG(("csKey = [%s]\n",csKey));
					
					DEBUGLOG(("Current TxnFee  = [%f]\n",dTmpAmt));
					// Check key exists
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);

				}
			}
			// ========================================================================

			// Build Key for Markup Fee Amount
			// ========================================================================
			if (strlen(csList[IDX_MU_AMT])>0) {
				/*
				if (!is_numeric(csList[IDX_MU_AMT])) {
					DEBUGLOG(("Invalid Markup Fee at line [%d]\n",iLineCnt));
					return FAILURE;
				}
				*/

				// MU Fee
				dTmpAmt = atof(csList[IDX_MU_AMT]);
				
				if (dTmpAmt != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_XU);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);	
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_MU_AMT_CCY]);
										
					// Insert into summary hash table 
					DEBUGLOG(("csKey = [%s]\n",csKey));
					
					// Txn MU
					DEBUGLOG(("Current MUFee  = [%f]\n",dTmpAmt));
					// Check key exists
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);

				}
			}
			// ========================================================================

			// Build Key for PSP/Deliver Amount
			// ========================================================================
			if (strlen(csList[IDX_PSP_AMT])>0) {
				/*
				if (!is_numeric(csList[IDX_PSP_AMT])) {
					DEBUGLOG(("Invalid PSP/Deliver Amount at line [%d]\n",iLineCnt));
					return FAILURE;
				}
				*/

				// PSP/Deliver Amount
				dTmpAmt = atof(csList[IDX_PSP_AMT]);
				
				if (dTmpAmt != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_PSP_AMT);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					
					if (strcmp(csList[IDX_TXN_TYPE],MST_TYPE)==0) {						
						//strcat(csKey, PD_TYPE_MERCHANT);
						sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
						strcat(csKey, csPartyType);							
					} else {
						//strcat(csKey, PD_TYPE_PSP);
						sprintf(csPartyType, "%c", PD_TYPE_PSP);
						strcat(csKey, csPartyType);							
					}
					
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					if (strcmp(csList[IDX_TXN_TYPE],MST_TYPE)==0)
						strcat(csKey, csList[IDX_MERCHANT]);
					else
						strcat(csKey, csList[IDX_PSP]);
						
					strcat(csKey, PD_HASHKEY_DELIMITOR);						
					strcat(csKey, csList[IDX_PSP_AMT_CCY]);
												
					// Insert into summary hash table 
					DEBUGLOG(("csKey = [%s]\n",csKey));
					
					// Txn MU
					DEBUGLOG(("Current PSP Amt  = [%f]\n",dTmpAmt));
					// Check key exists
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);

				}
			}
			// ========================================================================
		} // if
	}
	
	iRet = myPostTxn(csJnlKeys, hTxnAmt, iJnlKeyCnt);
	
	// Clean up
	hash_destroy(hTxnAmt);
	FREE_ME(hTxnAmt);
	
	iRet = SUCCESS;
	return iRet;
}

int myGroupRecs(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], hash_t *hTxn, char *csKey, double dAmt, int *iJnlKeyCnt) 
{
		double dTmpAmt;
		int	iRet = PD_OK;
		
		if (GetField_Double(hTxn,csKey,&dTmpAmt)) {
			//DEBUGLOG(("Found Txn [%s] = [%f]\n",csKey, dTmpAmt));
			// Sum
			dTmpAmt = dTmpAmt + dAmt;

		} else {				
			// Add new
			// Update Key chains
			strcpy(csJnlKeys[*iJnlKeyCnt],csKey);
			(*iJnlKeyCnt)++;
			dTmpAmt = dAmt;				
			//DEBUGLOG(("New Txn [%s] = [%f]\n",csKey, dTmpAmt));
		}
		PutField_Double(hTxn,csKey,dTmpAmt);

		
		return iRet;
}

int myPostTxn(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], const hash_t *hTxn, const int iJnlKeyCnt) 
{	
	int	iRet = PD_OK;
	int iTmp, iCount;
	hash_t*	hReq;
	char    csKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN];
	char	*p;
	char 	csTmpKey[IMPORT_MAX_KEY];
	double 	dTmpAmt;

	recordset_t *rRecordSet;
	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));	
	recordset_init(rRecordSet,0);

	if (iJnlKeyCnt == 0) { 
		DEBUGLOG(("No Journal Key"));
	} else {
		for (iTmp=0;iTmp<iJnlKeyCnt;iTmp++) {
			if (strlen(csJnlKeys[iTmp])>0) {
				DEBUGLOG(("Journal Key [%d] = [%s]\n",iTmp, csJnlKeys[iTmp]));
	
				strcpy(csTmpKey, csJnlKeys[iTmp]);
		
				if (GetField_Double(hTxn,csTmpKey,&dTmpAmt)) {
					
					// Break key into fields
					iCount = 0;
			    p = mystrtok(csTmpKey,PD_HASHKEY_DELIMITOR);
			    if (p == NULL)
						return FAILURE;
			    strcpy(csKeys[iCount],p);
			    iCount++;
			
			    while ((p = mystrtok(NULL,PD_HASHKEY_DELIMITOR)) != NULL) {
				    strcpy(csKeys[iCount],p);
				    iCount++;
			    } 
					/*
					DEBUGLOG(("HASHKEY_IDX_AMT_TYPE=[%s]\n",csKeys[HASHKEY_IDX_AMT_TYPE]));	
					DEBUGLOG(("HASHKEY_IDX_TXN_DATE=[%s]\n",csKeys[HASHKEY_IDX_TXN_DATE]));
					DEBUGLOG(("HASHKEY_IDX_TXN_TYPE=[%s]\n",csKeys[HASHKEY_IDX_TXN_TYPE]));
					DEBUGLOG(("HASHKEY_IDX_TXN_STATUS=[%s]\n",csKeys[HASHKEY_IDX_TXN_STATUS]));
					DEBUGLOG(("HASHKEY_IDX_COUNTRY_CODE=[%s]\n",csKeys[HASHKEY_IDX_COUNTRY_CODE]));
					DEBUGLOG(("HASHKEY_IDX_PARTY_TYPE=[%c]\n",csKeys[HASHKEY_IDX_PARTY_TYPE][0]));
					DEBUGLOG(("HASHKEY_IDX_PARTY_ID=[%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
					DEBUGLOG(("HASHKEY_IDX_AMT_CCY=[%s]\n",csKeys[HASHKEY_IDX_AMT_CCY]));	
					DEBUGLOG(("Amount [%s] = [%f]\n",csTmpKey, dTmpAmt));
					*/

					hReq = (hash_t*) malloc (sizeof(hash_t));
					hash_init(hReq,0);
					
					//if (GetField_CString(hContext,"PHDATE",&csPtr))  {
					PutField_CString(hReq,"host_posting_date",cs_date);
					//}					
					
					/* txn code */
					PutField_CString(hReq,"txn_code",csKeys[HASHKEY_IDX_TXN_TYPE]);
					
					/* txn country */
					PutField_CString(hReq,"txn_country",csKeys[HASHKEY_IDX_COUNTRY_CODE]);
					
					/* product */
					PutField_CString(hReq,"product",OFFLINE_PRODUCT_CODE);
					
					/* ccy */
					PutField_CString(hReq,"ccy",csKeys[HASHKEY_IDX_AMT_CCY]);
					
					/* txn_type */
					PutField_CString(hReq,"txn_type",csKeys[HASHKEY_IDX_AMT_TYPE]);
					
					/* amount */
					PutField_Double(hReq,"amount",dTmpAmt);
					
					/* party type */
					PutField_Char(hReq,"type",csKeys[HASHKEY_IDX_PARTY_TYPE][0]);
					
					/* party id */
					PutField_CString(hReq,"id",csKeys[HASHKEY_IDX_PARTY_ID]);
					
					RecordSet_Add(rRecordSet,hReq);
						
				} else {
					DEBUGLOG(("Not Found for Key [%s]\n",csTmpKey));
					iRet = FAILURE;
					break;
				}
			
			} else {
				continue;
			}
		}
	}
		
	BOObjPtr = CreateObj(BOPtr,"BOCrrPost","PostPHTxn");
	iRet = (unsigned long)(*BOObjPtr)(rRecordSet);

	// Clean up
	RecordSet_Destroy(rRecordSet);
	hash_destroy(hReq);
	FREE_ME(hReq);	
	FREE_ME(p);
	
	return iRet;
}
