#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <sqlca.h>
#include <unistd.h>
#include <regex.h>
#include <ctype.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "internal.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "myrecordset.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

static char	cDebug = 'Y';
// TestZale
/*
char	cGroup;
char	csFunc[PD_TAG_LEN + 1];
char	csRemark[PD_REMARK_LEN + 1];
char	csTxnCode[PD_TXN_CODE_LEN + 1];
double	dValue = 0.0;
int	iFlag = 0;
*/
// PspBalance
/*
char	cType;
char	csCcy[PD_CCY_ID_LEN + 1];
char	csCountry[PD_COUNTRY_LEN + 1];
char	csPspId[PD_PSP_ID_LEN + 1];
char	csUser[PD_USER_LEN + 1];
double	dAmount = 0.0;
*/
// MerchantBalance
/*
char	csUser[PD_USER_LEN + 1];
double	dNetAmount = 0.0;
double	dReservedAmt = 0.0;
*/
// TxnBalanceDetail
/*
char	csTxnId[PD_TXN_SEQ_LEN + 1];
char	csAprvDate[PD_TXN_DATE_LEN + 1];
char	cUpdStatus;
char	csTxnCode[PD_TXN_CODE_LEN + 1];
char	csMerchantId[PD_MERCHANT_ID_LEN + 1];
char	csServiceCode[PD_SERVICE_CODE_LEN + 1];
char	csCountryId[PD_COUNTRY_LEN + 1];
char	csNetCcy[PD_CURRENCY_ID_LEN + 1];
char	csPspId[PD_PSP_ID_LEN + 1];
char	csPspCcy[PD_CURRENCY_ID_LEN + 1];
char	csFunc[PD_TAG_LEN + 1];
double	dOpenBal = 0.0;
double	dCurrentBal = 0.0;
double	dTotalFloat = 0.0;
double	dTotalReservedAmt = 0.0;
double	dTotalHold = 0.0;
double	dFundinPayout = 0.0;
double	dReservedPayout = 0.0;
double	dTotalFloatAfterPayout = 0.0;
double	dOpenBalSettlement = 0.0;
double	dCurrentBalSettlement = 0.0;
double	dTotalFloatSettlement = 0.0;
double	dTotalHoldSettlement = 0.0;
double	dPspBal = 0.0;
double	dPspTotalFloat = 0.0;
double	dPspHold = 0.0;
*/
// OLAcctCreation
/*
char	csUser[PD_USER_LEN + 1];
int	iFileId = 0;
*/
// OLBaidIntraLogGen
/*
long lBatchId = 0;
*/
// PspAmtDiffRange
/*
char	csPspId[PD_PSP_ID_LEN + 1];
char	csUser[PD_USER_LEN + 1];
char	cType;
char	cSign;
double	dValue = 0.0;
int	iDisabled = 0;
*/
// PspRestrictIpRegion
/*
char	csFunc[PD_TAG_LEN + 1];
char	csPspId[PD_PSP_ID_LEN + 1];
char	csRegionCode[PD_COUNTRY_LEN + 1];
char	csUser[PD_USER_LEN + 1];
int	iDisabled = 0;
*/
// IsValid
//char	csTarget[PD_TMP_BUF_LEN + 1];

OBJPTR(DB);

static int parse_arg(int argc, char ** argv)
{
//	char	c;
//	int	iParamCnt = 0;

	// TestZale
/*
	while ((c = getopt(argc, argv, "c:g:b:v:r:f:")) != EOF)
	{
		switch (c)
		{
			case 'c':
				memset(csTxnCode, '\0', sizeof(csTxnCode));
				strcpy(csTxnCode, optarg);
				//csTxnCode[PD_TXN_CODE_LEN + 1] = '\0';

				break;

			case 'g':
				cGroup = optarg[0];
				break;

			case 'b':
				iFlag = atoi(optarg);
				break;

			case 'v':
				sscanf(optarg, "%lf", &dValue);
				break;

			case 'r':
				memset(csRemark, '\0', sizeof(csRemark));
				strcpy(csRemark, optarg);
				//csRemark[strlen(csRemark) + 1] = '\0';

				break;

			case 'f':
				memset(csFunc, '\0', sizeof(csFunc));
				strcpy(csFunc, optarg);
				//csFunc[strlen(csFunc) + 1] = '\0';

				break;

			default:
				return PD_ERR;
		}
	}

	if (!strcmp(csTxnCode, "") || (cGroup == '\0') || (iFlag < 0) || (dValue < 0.0) || !strcmp(csRemark, "") || !strcmp(csFunc, ""))
	{
printf("Fail in parsing arguments\n");
		return PD_ERR;
	}

printf("TXN_CODE [%s], GROUP [%c], FLAG [%d], VALUE [%lf], REMARK [%s], FUNCTION [%s]\n", csTxnCode, cGroup, iFlag, dValue, csRemark, csFunc);
*/

	// PspBalance
/*
	while ((c = getopt(argc, argv, "p:n:c:t:v:u:")) != EOF)
	{
		switch (c)
		{
			case 'p':
				memset(csPspId, '\0', sizeof(csPspId));
				strcpy(csPspId, optarg);
				//csPspId[PD_PSP_ID_LEN + 1] = '\0';

				break;

			case 'n':
				memset(csCountry, '\0', sizeof(csCountry));
				strcpy(csCountry, optarg);
				//csCountry[PD_COUNTRY_LEN + 1] = '\0';

				break;

			case 'c':
				memset(csCcy, '\0', sizeof(csCcy));
				strcpy(csCcy, optarg);
				//csCcy[PD_CCY_ID_LEN + 1] = '\0';

				break;

			case 't':
				cType = optarg[0];
				break;

			case 'v':
				sscanf(optarg, "%lf", &dAmount);
				break;

			case 'u':
				memset(csUser, '\0', sizeof(csUser));
				strcpy(csUser, optarg);
				//csUser[strlen(csUser) + 1] = '\0';

				break;

			default:
				return PD_ERR;
		}
	}

	if (!strcmp(csPspId, "") || !strcmp(csCountry, "") || !strcmp(csCcy, "") || (cType == '\0') || (cType != PD_PSP_FLOAT && cType != PD_PSP_BAL) || (dAmount < 0.0) || !strcmp(csUser, ""))
	{
printf("PSP_ID [%s], COUNTRY [%s], CCY [%s], TYPE [%c], AMOUNT [%lf], USER [%s]\n", csPspId, csCountry, csCcy, cType, dAmount, csUser);
printf("Please noted: <TYPE> must be \"PD_PSP_FLOAT\" or \"PD_PSP_BAL\"\n");
printf("Fail in parsing arguments\n");
		return PD_ERR;
	}

printf("PSP_ID [%s], COUNTRY [%s], CCY [%s], TYPE [%c], AMOUNT [%lf], USER [%s]\n", csPspId, csCountry, csCcy, cType, dAmount, csUser);
*/

	// MerchantBalance
/*
	while ((c = getopt(argc, argv, "v:r:u:")) != EOF)
	{
		switch (c)
		{
			case 'v':
				sscanf(optarg, "%lf", &dNetAmount);
				break;

			case 'r':
				sscanf(optarg, "%lf", &dReservedAmt);
				break;

			case 'u':
				memset(csUser, '\0', sizeof(csUser));
				strcpy(csUser, optarg);
				//csUser[strlen(csUser) + 1] = '\0';

				break;

			default:
				return PD_ERR;
		}
	}

	if ((dNetAmount < 0.0) || (dReservedAmt < 0.0) || !strcmp(csUser, ""))
	{
printf("Fail in parsing arguments\n");
		return PD_ERR;
	}

printf("NET_AMOUNT [%lf], RESERVED_AMOUNT [%lf], USER [%s]\n", dNetAmount, dReservedAmt, csUser);
	return PD_OK;
*/

	// TxnBalanceDetail
/*
	while ((c = getopt(argc, argv, "a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:")) != EOF)
	{
		switch (c)
		{
			case 'a':
				memset(csTxnId, '\0', sizeof(csTxnId));
				strcpy(csTxnId, optarg);
				iParamCnt++;

				break;

			case 'b':
				memset(csAprvDate, '\0', sizeof(csAprvDate));
				strcpy(csAprvDate, optarg);
				iParamCnt++;

				break;

			case 'c':
				cUpdStatus = optarg[0];
				iParamCnt++;

				break;

			case 'd':
				memset(csTxnCode, '\0', sizeof(csTxnCode));
				strcpy(csTxnCode, optarg);
				iParamCnt++;

				break;

			case 'e':
				memset(csMerchantId, '\0', sizeof(csMerchantId));
				strcpy(csMerchantId, optarg);
				iParamCnt++;

				break;

			case 'f':
				memset(csServiceCode, '\0', sizeof(csServiceCode));
				strcpy(csServiceCode, optarg);
				iParamCnt++;

				break;

			case 'g':
				memset(csCountryId, '\0', sizeof(csCountryId));
				strcpy(csCountryId, optarg);
				iParamCnt++;

				break;

			case 'h':
				memset(csNetCcy, '\0', sizeof(csNetCcy));
				strcpy(csNetCcy, optarg);
				iParamCnt++;

				break;

			case 'i':
				sscanf(optarg, "%lf", &dOpenBal);
				iParamCnt++;

				break;

			case 'j':
				sscanf(optarg, "%lf", &dCurrentBal);
				iParamCnt++;

				break;

			case 'k':
				sscanf(optarg, "%lf", &dTotalFloat);
				iParamCnt++;

				break;

			case 'l':
				sscanf(optarg, "%lf", &dTotalReservedAmt);
				iParamCnt++;

				break;

			case 'm':
				sscanf(optarg, "%lf", &dTotalHold);
				iParamCnt++;

				break;

			case 'n':
				sscanf(optarg, "%lf", &dFundinPayout);
				iParamCnt++;

				break;

			case 'o':
				sscanf(optarg, "%lf", &dReservedPayout);
				iParamCnt++;

				break;

			case 'p':
				sscanf(optarg, "%lf", &dTotalFloatAfterPayout);
				iParamCnt++;

				break;

			case 'q':
				sscanf(optarg, "%lf", &dOpenBalSettlement);
				iParamCnt++;

				break;

			case 'r':
				sscanf(optarg, "%lf", &dCurrentBalSettlement);
				iParamCnt++;

				break;

			case 's':
				sscanf(optarg, "%lf", &dTotalFloatSettlement);
				iParamCnt++;

				break;

			case 't':
				sscanf(optarg, "%lf", &dTotalHoldSettlement);
				iParamCnt++;

				break;

			case 'u':
				memset(csPspId, '\0', sizeof(csPspId));
				strcpy(csPspId, optarg);
				iParamCnt++;

				break;

			case 'v':
				memset(csPspCcy, '\0', sizeof(csPspCcy));
				strcpy(csPspCcy, optarg);
				iParamCnt++;

				break;

			case 'w':
				sscanf(optarg, "%lf", &dPspBal);
				iParamCnt++;

				break;

			case 'x':
				sscanf(optarg, "%lf", &dPspTotalFloat);
				iParamCnt++;

				break;

			case 'y':
				sscanf(optarg, "%lf", &dPspHold);
				iParamCnt++;

				break;

			case 'z':
				memset(csFunc, '\0', sizeof(csFunc));
				strcpy(csFunc, optarg);
				iParamCnt++;

				break;

			default:
				return PD_ERR;
		}
	}

	if (iParamCnt != 26)
	{
printf("Fail in parsing arguments\n");
		return PD_ERR;
	}

printf("TXN_ID [%s], APRV_DATE [%s], UPD_STATUS [%c], TXN_CODE [%s], MERCHANT_ID [%s], SERVICE_CODE [%s], COUNTRY [%s], NET_CCY [%s], OPEN_BAL [%lf], CURRENT_BAL [%lf], TOTAL_FLOAT [%lf], TOTAL_RESERVED_AMT [%lf], TOTAL_HOLD [%lf], FUNDIN_PAYOUT [%lf], RESERVED_PAYOUT [%lf], TOTAL_FLOAT_AFTER_PAYOUT [%lf], OPEN_BAL_SETTLEMENT [%lf], CURRENT_BAL_SETTLEMENT [%lf], TOTLE_FLOAT_SETTLEMENT [%lf], TOTLE_HOLD_SETTLEMENT [%lf], PSP_ID [%s], PSP_CCY [%s], PSP_BAL [%lf], PSP_TOTAL_FLOAT [%lf], PSP_HOLD [%lf], FUNCTION [%s]\n", csTxnId, csAprvDate, cUpdStatus, csTxnCode, csMerchantId, csServiceCode, csCountryId, csNetCcy, dOpenBal, dCurrentBal, dTotalFloat, dTotalReservedAmt, dTotalHold, dFundinPayout, dReservedPayout, dTotalFloatAfterPayout, dOpenBalSettlement, dCurrentBalSettlement, dTotalFloatSettlement, dTotalHoldSettlement, csPspId, csPspCcy, dPspBal, dPspTotalFloat, dPspHold, csFunc);
	return PD_OK;
*/

	// OLAcctCreation
/*
	while ((c = getopt(argc, argv, "f:u:")) != EOF)
	{
		switch (c)
		{
			case 'f':
				iFileId = atoi(optarg);
				break;

			case 'u':
				memset(csUser, '\0', sizeof(csUser));
				strcpy(csUser, optarg);

				break;

			default:
				return PD_ERR;
		}
	}

	if ((iFileId <= 0) || (!strcmp(csUser, "")))
	{
printf("Fail in parsing arguments\n");
		return PD_ERR;
	}

printf("FILE_ID [%d], USER [%s]\n", iFileId, csUser);
	return PD_OK;
*/

	// OLBaidIntraLogGen
/*
	while ((c = getopt(argc, argv, "b:")) != EOF)
	{
		switch (c)
		{
			case 'b':
				sscanf(optarg, "%lu", &lBatchId);
				break;

			default:
				return PD_ERR;
		}
	}

	if (lBatchId <= 0)
	{
printf("Fail in parsing arguments\n");
		return PD_ERR;
	}

printf("BATCH_ID [%lu]\n", lBatchId);
	return PD_OK;
*/

	// PspAmtDiffRange
/*
	while ((c = getopt(argc, argv, "p:t:s:v:d:u:")) != EOF)
	{
		switch (c)
		{
			case 'p':
				memset(csPspId, '\0', sizeof(csPspId));
				strcpy(csPspId, optarg);

				break;

			case 't':
				cType = optarg[0];
				break;

			case 's':
				cSign = optarg[0];
				break;

			case 'v':
				sscanf(optarg, "%lf", &dValue);
				break;

			case 'd':
				iDisabled = atoi(optarg);
				break;

			case 'u':
				memset(csUser, '\0', sizeof(csUser));
				strcpy(csUser, optarg);

				break;

			default:
				return PD_ERR;
		}
	}

	if (!strcmp(csPspId, "") || (cType == '\0') || (cSign == '\0') || (dValue < 0.0) || iDisabled < 0 || !strcmp(csUser, ""))
	{
printf("Fail in parsing arguments\n");
		return PD_ERR;
	}

printf("PSP_ID [%s], TYPE [%c], SIGN [%c], VALUE [%lf], DISABLED [%d], USER [%s]\n", csPspId, cType, cSign, dValue, iDisabled, csUser);
	return PD_OK;
*/

	// PspRestrictIpRegion
/*
	while ((c = getopt(argc, argv, "p:r:d:u:f:")) != EOF)
	{
		switch (c)
		{
			case 'p':
				memset(csPspId, '\0', sizeof(csPspId));
				strcpy(csPspId, optarg);

				break;

			case 'r':
				memset(csRegionCode, '\0', sizeof(csRegionCode));
				strcpy(csRegionCode, optarg);

				break;

			case 'd':
				iDisabled = atoi(optarg);
				break;

			case 'u':
				memset(csUser, '\0', sizeof(csUser));
				strcpy(csUser, optarg);

				break;

			case 'f':
				memset(csFunc, '\0', sizeof(csFunc));
				strcpy(csFunc, optarg);

				break;

			default:
				return PD_ERR;
		}
	}

	if (!strcmp(csPspId, "") || !strcmp(csRegionCode, "") || iDisabled < 0 || !strcmp(csUser, "") || !strcmp(csFunc, ""))
	{
printf("Fail in parsing arguments\n");
		return PD_ERR;
	}

printf("PSP_ID [%s], REGION_CODE [%s], DISABLED [%d], USER [%s], FUNCTION [%s]\n", csPspId, csRegionCode, iDisabled, csUser, csFunc);
	return PD_OK;
*/

	// IsValid
/*
	while ((c = getopt(argc, argv, "t:")) != EOF)
	{
		switch (c)
		{
			case 't':
				memset(csTarget, '\0', sizeof(csTarget));
				strcpy(csTarget, optarg);

				break;

			default:
				return PD_ERR;
		}
	}

printf("TARGET [%s]\n", csTarget);
*/
	return PD_OK;
}

int batch_init(int argc, char * argv[])
{
	// TestZale / PspBalance / PspAmtDiffRange
	//if (argc < 13)
	// MerchantBalance
	//if (argc < 7)
	// TxnBalanceDetail
	//if (argc < 53)
	// OLAccrCreation
	//if (argc < 5)
	// OLBaidIntraLogGen
	//if (argc < 3)
	// PspRestrictIpRegion
	//if (argc < 11)
	// IsValid
	//if (argc < 3)
	//{
		// TestZale
//printf("Usage: %s -c <TXN_CODE> -g <GROUP> -b <FLAG> -v <VALUE> -r <REMARK> -f <FUNCTION>\n", argv[0]);

		// PspBalance
//printf("Usage: %s -p <PSP_ID> -n <COUNTRY> -c <CCY> -t <TYPE> -v <AMOUNT> -u <USER>\n", argv[0]);
//printf("Note : <TYPE> must be \"PD_PSP_FLOAT\" or \"PD_PSP_BAL\"\n");

		// MerchantBalance
//printf("Usage: %s -v <NET_AMOUNT> -r <RESERVED_AMOUNT> -u <USER>\n", argv[0]);
//printf("Note : <MERCHANT_ID> K000000001 / <COUNTRY> CN / [CCY] CNY / [SERVICE_CODE] TLN\n");

		// TxnBalanceDetail
//printf("Usage: %s -a <TXN_ID> -b <APRV_DATE> -c <UPD_STATUS> -d <TXN_CODE> -e <MERCHANT_ID> -f <SERVICE_CODE> -g <COUNTRY> -h <NET_CCY> -h <OPEN_BAL> -j <CURRENT_BAL> -k <TOTAL_FLOAT> -l <TOTAL_RESERVED_AMT> -m <TOTAL_HOLD> -n <FUNDIN_PAYOUT> -o <RESERVED_PAYOUT> -p <TOTAL_FLOAT_AFTER_PAYOUT> -q <OPEN_BAL_SETTLEMENT> -r <CURRENT_BAL_SETTLEMENT> -s <TOTLE_FLOAT_SETTLEMENT> -t <TOTLE_HOLD_SETTLEMENT> -u <PSP_ID> -v <PSP_CCY> -w <PSP_BAL> -x <PSP_TOTAL_FLOAT> -y <PSP_HOLD> -z <FUNCTION>\n", argv[0]);

		// OLAcctCreation
//printf("Usage: %s -f <FILE_ID> -u <USER>\n", argv[0]);

		// OLBaidIntraLogGen
//printf("Usage: %s -b <BATCH_ID>\n", argv[0]);

		// PspAmtDiffRange
//printf("Usage: %s -p <PSP_ID> -t <TYPE> -s <SIGN> -v <VALUE> -d <DISABLED> -u <USER>\n", argv[0]);

		// PspRestrictIpRegion
//printf("Usage: %s -p <PSP_ID> -r <REGION_CODE> -d <DISABLED> -u <USER> -f <FUNCTION>\n", argv[0]);
//		return FAILURE;

		// IsValid
//printf("Usage: %s -t <TARGET>\n", argv[0]);
//		return FAILURE;
//	}
//	else
		return SUCCESS;
}

int batch_proc(int argc, char * argv[])
{
	if (parse_arg(argc, argv) != PD_OK)
	{
		exit(1);
	}

	// TestZale
/*
	char	cTmp;
	char	* csTmp = NULL;
	double	dTmp = 0.0;
	int	iTmp = 0;
	int	iRet = PD_OK;
	hash_t	* hIn;
	hash_t	* hOut;

	hIn = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hIn, 0);

	hOut = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hOut, 0);

	PutField_CString(hIn, "txn_code", csTxnCode);
	PutField_Char(hIn, "group", cGroup);
	PutField_Int(hIn, "flag", iFlag);
	PutField_Double(hIn, "value", dValue);
	PutField_CString(hIn, "remark", csRemark);
	PutField_CString(hIn, "create_user", PD_UPDATE_USER);

printf("Call TestZale: %s\n", csFunc);

	DBObjPtr = CreateObj(DBPtr, "DBTestZale", csFunc);

	if (!strcmp(csFunc, "Add") || !strcmp(csFunc, "Update"))
		iRet = (unsigned long)(DBObjPtr)(hIn);
	else if (!strcmp(csFunc, "UpdateReturn") || !strcmp(csFunc, "UpdateReturnCursor"))
		iRet = (unsigned long)(DBObjPtr)(hIn, hOut);
	else
	{
		iRet = PD_ERR;
printf("Invalid Function!!\n");
	}

printf("TestZale: %s iRet = [%d]\n", csFunc, iRet);
*/

	// TestZale - Old
/*
	if (iRet == PD_OK)
	{
printf("Call TestZale: GetByTxnCode [%s]\n", csTxnCode);

		DBObjPtr = CreateObj(DBPtr, "DBTestZale", "GetByTxnCode");

		if ((unsigned long)(DBObjPtr)(csTxnCode, hOut) == PD_FOUND)
		{
			if (GetField_Char(hOut, "group", &cTmp))
printf("Group = [%c]\n", cTmp);

			if (GetField_Int(hOut, "flag", &iTmp))
printf("Flag = [%d]\n", iTmp);

			if (GetField_Double(hOut, "value", &dTmp))
printf("Value = [%lf]\n", dTmp);

			if (GetField_CString(hOut, "remark", &csTmp))
printf("Remark = [%s]\n", csTmp);
		}
	}

	if (iRet == PD_OK)
	{
printf("Call TestZale: GetByGroup [%c]\n", cGroup);

		int		iCnt = 0;
		hash_t		* hRec;
		recordset_t	* rInfoSet;

		rInfoSet = (recordset_t *)malloc(sizeof(recordset_t));
		recordset_init(rInfoSet, 0);

		DBObjPtr = CreateObj(DBPtr, "DBTestZale", "GetByGroup");

		if ((unsigned long)(DBObjPtr)(cGroup, rInfoSet) == PD_FOUND)
		{
			hRec = RecordSet_GetFirst(rInfoSet);

			while (hRec)
			{
				if (GetField_CString(hRec, "txn_code", &csTmp))
printf("[%d] Txn_Code = [%s]\n", iCnt, csTmp);

				if (GetField_Int(hRec, "flag", &iTmp))
printf("[%d] Flag = [%d]\n", iCnt, iTmp);

				if (GetField_Double(hRec, "value", &dTmp))
printf("[%d] Value = [%lf]\n", iCnt, dTmp);

				if (GetField_CString(hRec, "remark", &csTmp))
printf("[%d] Remark = [%s]\n", iCnt, csTmp);

				iCnt++;
				hRec = RecordSet_GetNext(rInfoSet);
			}
		}

		RecordSet_Destroy(rInfoSet);
		FREE_ME(rInfoSet);
	}
*/

	// TestZale - New
/*
	if (iRet == PD_OK)
	{
		if (!strcmp(csFunc, "Add") || !strcmp(csFunc, "Update"))
		{
printf("Call TestZale: GetByTxnCode [%s]\n", csTxnCode);

			DBObjPtr = CreateObj(DBPtr, "DBTestZale", "GetByTxnCode");

			if ((unsigned long)(DBObjPtr)(csTxnCode, hOut) == PD_FOUND)
			{
				if (GetField_Char(hOut, "group", &cTmp))
printf("Group = [%c]\n", cTmp);

				if (GetField_Int(hOut, "flag", &iTmp))
printf("Flag = [%d]\n", iTmp);

				if (GetField_Double(hOut, "value", &dTmp))
printf("Value = [%lf]\n", dTmp);

				if (GetField_CString(hOut, "remark", &csTmp))
printf("Remark = [%s]\n", csTmp);
			}

printf("Call TestZale: GetByGroup [%c]\n", cGroup);

			int		iCnt = 0;
			hash_t		* hRec;
			recordset_t	* rInfoSet;

			rInfoSet = (recordset_t *)malloc(sizeof(recordset_t));
			recordset_init(rInfoSet, 0);

			DBObjPtr = CreateObj(DBPtr, "DBTestZale", "GetByGroup");

			if ((unsigned long)(DBObjPtr)(cGroup, rInfoSet) == PD_FOUND)
			{
				hRec = RecordSet_GetFirst(rInfoSet);

				while (hRec)
				{
					if (GetField_CString(hRec, "txn_code", &csTmp))
printf("[%d] Txn_Code = [%s]\n", iCnt, csTmp);

					if (GetField_Int(hRec, "flag", &iTmp))
printf("[%d] Flag = [%d]\n", iCnt, iTmp);

					if (GetField_Double(hRec, "value", &dTmp))
printf("[%d] Value = [%lf]\n", iCnt, dTmp);

					if (GetField_CString(hRec, "remark", &csTmp))
printf("[%d] Remark = [%s]\n", iCnt, csTmp);

					iCnt++;
					hRec = RecordSet_GetNext(rInfoSet);
				}
			}

			RecordSet_Destroy(rInfoSet);
			FREE_ME(rInfoSet);
		}
		else
		{
			// UpdateReturn or UpdateReturnCursor
printf("Call TestZale: UpdateReturn / UpdateReturnCursor - Display updated results\n");

			if (GetField_Char(hOut, "group", &cTmp))
printf("Group = [%c]\n", cTmp);

			if (GetField_Int(hOut, "flag", &iTmp))
printf("Flag(updated) = [%d]\n", iTmp);

			if (GetField_Double(hOut, "value", &dTmp))
printf("Value(updated) = [%lf]\n", dTmp);

			if (GetField_CString(hOut, "remark", &csTmp))
printf("Remark = [%s]\n", csTmp);
		}
	}

	FREE_ME(hIn);
	FREE_ME(hOut);
*/

	// PspBalance
/*
	double	dTmp = 0.0;
	int	iRet = PD_OK;
	hash_t	* hOut;

	hOut = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hOut, 0);

printf("Call PspBalance: CreditBalanceRet\n");

	DBObjPtr = CreateObj(DBPtr, "DBPspBalance", "CreditBalanceRet");
	iRet = (unsigned long)(DBObjPtr)(csPspId, csCountry, csCcy, cType, dAmount, csUser, hOut);

printf("Call PspBalance: CreditBalanceRet iRet = [%d]\n", iRet);

	if (iRet == PD_OK)
	{
printf("Call PspBalance: CreditBalanceRet - Display updated results\n");

		if (GetField_Double(hOut, "psp_bal", &dTmp))
printf("PSP Balance = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "total_float", &dTmp))
printf("Total Float = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "total_hold", &dTmp))
printf("Total Hold = [%lf]\n", dTmp);
	}

	FREE_ME(hOut);
*/

	// MerchantBalance
/*
	double	dTmp = 0.0;
	int	iRet = PD_OK;
	hash_t	* hOut;

	hOut = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hOut, 0);

printf("MERCHANT_ID [K000000001], COUNTRY [CN], CCY [CNY], SERVICE_CODE [TLN], NET_AMOUNT [%lf], RESERVED_AMOUNT [%lf], USER [%s]\n", dNetAmount, dReservedAmt, csUser);
printf("Call MerchantBalance: UpdateFloatRet\n");

	DBObjPtr = CreateObj(DBPtr, "DBMerchantBalance", "UpdateFloatRet");
	iRet = (unsigned long)(DBObjPtr)("K000000001", "CN", "CNY", "TLN", dNetAmount, dReservedAmt, csUser, hOut);

printf("Call MerchantBalance: UpdateFloatRet iRet = [%d]\n", iRet);

	if (iRet == PD_OK)
	{
printf("Call MerchantBalance: UpdateFloatRet - Display updated results\n");

		if (GetField_Double(hOut, "current_bal", &dTmp))
printf("Current Balance = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "current_bal_settlement", &dTmp))
printf("Current Settlement Balance = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "total_float", &dTmp))
printf("Total Float = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "total_float_after_payout", &dTmp))
printf("Total Float After Payout = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "total_float_settlement", &dTmp))
printf("Total Float Settlement = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "total_reserved_amount", &dTmp))
printf("Total Reserved Amount = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "fundin_payout", &dTmp))
printf("Fundin Payout = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "reserved_payout", &dTmp))
printf("Reserved Payout = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "total_hold", &dTmp))
printf("Total Hold = [%lf]\n", dTmp);

		if (GetField_Double(hOut, "total_hold_settlement", &dTmp))
printf("Total Hold Settlement = [%lf]\n", dTmp);
	}

	FREE_ME(hOut);
*/

	// TxnBalanceDetail
/*
	char	* csTmp = NULL;
	double	dTmp = 0.0;
	int	iRet = PD_OK;
	hash_t	* hIn;

	hIn = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hIn, 0);

	PutField_CString(hIn, "txn_id", csTxnId);
	PutField_CString(hIn, "txn_aprv_date", csAprvDate);
	PutField_Char(hIn, "upd_status", cUpdStatus);
	PutField_CString(hIn, "txn_code", csTxnCode);
	PutField_CString(hIn, "merchant_id", csMerchantId);
	PutField_CString(hIn, "service_code", csServiceCode);
	PutField_CString(hIn, "country_id", csCountryId);
	PutField_CString(hIn, "net_ccy", csNetCcy);
	PutField_Double(hIn, "open_bal", dOpenBal);
	PutField_Double(hIn, "current_bal", dCurrentBal);
	PutField_Double(hIn, "total_float", dTotalFloat);
	PutField_Double(hIn, "total_reserved_amt", dTotalReservedAmt);
	PutField_Double(hIn, "total_hold", dTotalHold);
	PutField_Double(hIn, "fundin_payout", dFundinPayout);
	PutField_Double(hIn, "reserved_payout", dReservedPayout);
	PutField_Double(hIn, "total_float_after_payout", dTotalFloatAfterPayout);
	PutField_Double(hIn, "open_bal_settlement", dOpenBalSettlement);
	PutField_Double(hIn, "current_bal_settlement", dCurrentBalSettlement);
	PutField_Double(hIn, "total_float_settlement", dTotalFloatSettlement);
	PutField_Double(hIn, "total_hold_settlement", dTotalHoldSettlement);
	PutField_CString(hIn, "psp_id", csPspId);
	PutField_CString(hIn, "psp_ccy", csPspCcy);
	PutField_Double(hIn, "psp_bal", dPspBal);
	PutField_Double(hIn, "psp_total_float", dPspTotalFloat);
	PutField_Double(hIn, "psp_hold", dPspHold);
	PutField_CString(hIn, "create_user", PD_UPDATE_USER);

printf("Call TxnBalanceDetail: %s\n", csFunc);

	DBObjPtr = CreateObj(DBPtr, "DBTxnBalanceDetail", csFunc);

	if (!strcmp(csFunc, "AddBalDetail"))
		iRet = (unsigned long)(DBObjPtr)(hIn);
	else if (!strcmp(csFunc, "UpdateStatus"))
		iRet = (unsigned long)(DBObjPtr)(csTxnId, cUpdStatus);
	else
	{
		iRet = PD_ERR;
printf("Invalid Function!!\n");
	}

printf("TxnBalanceDetail: %s iRet = [%d]\n", csFunc, iRet);

	if (iRet == PD_OK)
	{
printf("Call TxnBalanceDetail: GetBalDetails\n");

		int		iCnt = 0;
		hash_t		* hRec;
		recordset_t	* rInfoSet;

		rInfoSet = (recordset_t *)malloc(sizeof(recordset_t));
		recordset_init(rInfoSet, 0);

		DBObjPtr = CreateObj(DBPtr, "DBTxnBalanceDetail", "GetBalDetails");

		if ((unsigned long)(DBObjPtr)(hIn, rInfoSet) == PD_FOUND)
		{
			hRec = RecordSet_GetFirst(rInfoSet);

			while (hRec)
			{
				if (GetField_CString(hRec, "txn_id", &csTmp))
				{
printf("[%d] Txn_Id = [%s]\n", iCnt, csTmp);
				}

				if (GetField_CString(hRec, "txn_code", &csTmp))
				{
printf("[%d] Txn_Code = [%s]\n", iCnt, csTmp);
				}

				if (GetField_CString(hRec, "merchant_id", &csTmp))
				{
printf("[%d] Merchant_Id = [%s]\n", iCnt, csTmp);
				}

				if (GetField_CString(hRec, "service_code", &csTmp))
				{
printf("[%d] Service_Code = [%s]\n", iCnt, csTmp);
				}

				if (GetField_CString(hRec, "country_id", &csTmp))
				{
printf("[%d] Country = [%s]\n", iCnt, csTmp);
				}

				if (GetField_CString(hRec, "net_ccy", &csTmp))
				{
printf("[%d] Net_Ccy = [%s]\n", iCnt, csTmp);
				}

				if (GetField_Double(hRec, "open_bal", &dTmp))
				{
printf("[%d] Open_Bal = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "current_bal", &dTmp))
				{
printf("[%d] Current_Bal = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "total_float", &dTmp))
				{
printf("[%d] Total_Float = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "total_reserved_amt", &dTmp))
				{
printf("[%d] Total_Reserved_Amt = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "total_hold", &dTmp))
				{
printf("[%d] Total_Hold = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "fundin_payout", &dTmp))
				{
printf("[%d] Fundin_Payout = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "reserved_payout", &dTmp))
				{
printf("[%d] Reserved_Payout = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "total_float_after_payout", &dTmp))
				{
printf("[%d] Total_Float_After_Payout = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "open_bal_settlement", &dTmp))
				{
printf("[%d] Open_Bal_Settlement = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "current_bal_settlement", &dTmp))
				{
printf("[%d] Current_Bal_Settlement = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "total_float_settlement", &dTmp))
				{
printf("[%d] Total_Float_Settlement = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "total_hold_settlement", &dTmp))
				{
printf("[%d] Total_Hold_Settlement = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_CString(hRec, "psp_id", &csTmp))
				{
printf("[%d] Psp_Id = [%s]\n", iCnt, csTmp);
				}

				if (GetField_CString(hRec, "psp_ccy", &csTmp))
				{
printf("[%d] Psp_Ccy = [%s]\n", iCnt, csTmp);
				}

				if (GetField_Double(hRec, "psp_bal", &dTmp))
				{
printf("[%d] Psp_Bal = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "psp_total_float", &dTmp))
				{
printf("[%d] Psp_Total_Float = [%lf]\n", iCnt, dTmp);
				}

				if (GetField_Double(hRec, "psp_hold", &dTmp))
				{
printf("[%d] Psp_Hold = [%lf]\n", iCnt, dTmp);
				}

				iCnt++;
				hRec = RecordSet_GetNext(rInfoSet);
			}

			RecordSet_Destroy(rInfoSet);
			FREE_ME(rInfoSet);
		}
	}

	FREE_ME(hIn);
*/

	// OLAcctCreation
/*
	char	cTmp;
	char	* csTmp = NULL;
	double	dTmp = 0.0;
	int	iRet = PD_ERR;
	hash_t	* hIn;
	hash_t	* hOut;

	hIn = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hIn, 0);

	hOut = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hOut, 0);

	PutField_Int(hIn, "file_id", iFileId);
	PutField_CString(hIn, "create_user", csUser);

printf("Call OLAcctCreation: GetHeaderByFileId\n");

	DBObjPtr = CreateObj(DBPtr, "DBOLAcctCreation", "GetHeaderByFileId");
	iRet = (unsigned long)(DBObjPtr)(iFileId, hOut);

printf("OLAcctCreation: GetHeaderByFileId iRet = [%d]\n", iRet);

	if (iRet == PD_OK)
	{
		if (GetField_CString(hOut, "raw_filename", &csTmp))
		{
printf("Raw_FileName = [%s]\n", csTmp);
		}
		else
		{
printf("Oops! Raw_FileName missing\n");
		}

		if (GetField_Char(hOut, "status", &cTmp))
		{
printf("Status = [%c]\n", cTmp);

			if (cTmp == PD_INIT)
			{
				DBObjPtr = CreateObj(DBPtr, "DBOLAcctCreation", "MatchHeaderStatusForUpdate");
				iRet = (unsigned long)(DBObjPtr)(iFileId, PD_INIT);

printf("OLAcctCreation: MatchHeaderStatusForUpdate iRet = [%d]\n", iRet);

				if (iRet == PD_FOUND)
				{
					PutField_Char(hIn, "status", PD_PROCESSING);

					DBObjPtr = CreateObj(DBPtr, "DBOLAcctCreation", "UpdateHeader");
					iRet = (unsigned long)(DBObjPtr)(hIn);

printf("OLAcctCreation: UpdateHeader iRet = [%d]\n", iRet);

					if (iRet == PD_OK)
					{
						int i = 0;

						for (i = 0; i < 4; i++)
						{
							PutField_Int(hIn, "seq", i + 1);

							if (i % 2 == 0)
							{
								PutField_CString(hIn, "provider_name", "123456789");
								PutField_CString(hIn, "provider_id", "998877");
								PutField_CString(hIn, "acct_type", PD_NATURE_DEPOSIT);
								PutField_CString(hIn, "bank_name", "AA Bank");
								PutField_CString(hIn, "int_bank_code", "080808");
								PutField_CString(hIn, "bank_acct_num", "11223344556677");
								PutField_CString(hIn, "bank_acct_short_name", "Testing AA");
								PutField_CString(hIn, "owner_name", "testing01");
								PutField_CString(hIn, "province", "XXAAXXAAXXAA");
								PutField_CString(hIn, "city", "Taipei");
								PutField_CString(hIn, "branch_name", "77665544332211");
								PutField_Double(hIn, "init_bal", dTmp);
								PutField_Int(hIn, "support_sms_stmt", PD_DISABLED);
								PutField_CString(hIn, "registered_mobile", "0912345678");
								PutField_Int(hIn, "apply_deposit_cost", PD_DISABLED);
								PutField_CString(hIn, "merchant_short_name", "tt01tt");
								PutField_CString(hIn, "merchant_id", "ttdeposit");

								DBObjPtr = CreateObj(DBPtr, "DBOLAcctCreation", "AddDetail");
								iRet = (unsigned long)(DBObjPtr)(hIn);

printf("OLAcctCreation: AddDetail iRet = [%d]\n", iRet);
							}
							else
							{
								PutField_Int(hIn, "msg_code", INT_ERR);
								PutField_CString(hIn, "line_content", "QZZXCVBNM,ASDFGHJKL,QERTYUIOP,1234567890");

								DBObjPtr = CreateObj(DBPtr, "DBOLAcctCreation", "AddError");
								iRet = (unsigned long)(DBObjPtr)(hIn);

printf("OLAcctCreation: AddError iRet = [%d]\n", iRet);
							}
						}

						if (iRet == PD_OK)
						{
							PutField_CString(hIn, "convert_filename", "AF00000000000001");
							PutField_Int(hIn, "total_count", 4);
							PutField_Int(hIn, "accept_count", 2);
							PutField_Char(hIn, "status", PD_COMPLETE);
							PutField_Int(hIn, "msg_code", PD_OK);

							DBObjPtr = CreateObj(DBPtr, "DBOLAcctCreation", "UpdateHeader");
							iRet = (unsigned long)(DBObjPtr)(hIn);

printf("OLAcctCreation: UpdateHeader iRet = [%d]\n", iRet);
						}
					}
				}
			}
			else
			{
printf("Oops! Status should be \"Initiated\"\n");
			}
		}
	}

	hash_destroy(hIn);
	FREE_ME(hIn);

	hash_destroy(hOut);
	FREE_ME(hOut);
*/

	// OLBaidIntraLogGen
/*
	char		cStatus[] = {'A', 'C', 'P', 'R', '\0'};
	int		iCnt = 0;
	int		iRet = PD_ERR;
	hash_t		* hRec;
	recordset_t	* rInfoSet;

	rInfoSet = (recordset_t *)malloc(sizeof(recordset_t));
	recordset_init(rInfoSet, 0);

printf("Call OLBaidIntraLogGen: GetDetailByBatchId\n");

	DBObjPtr = CreateObj(DBPtr, "DBOLBaidIntraLogGen", "GetDetailByBatchId");

	if ((unsigned long)(DBObjPtr)(lBatchId, rInfoSet) == FOUND)
	{
		hRec = RecordSet_GetFirst(rInfoSet);

		while (hRec)
		{
			char	cTmp;
			char	* csBuf = NULL;
			char	* csStmtTxnId = NULL;
			char	* csTmp = NULL;
			int	iTmp = 0;
			hash_t	* hIn;

			csBuf = (char *)malloc(PD_TMP_BUF_LEN);

			hIn = (hash_t *)malloc(sizeof(hash_t));
			hash_init(hIn, 0);

			sprintf(csBuf, "%lu", lBatchId);
			PutField_CString(hIn, "batch_id", csBuf);

			if (GetField_CString(hRec, "stmt_txn_id", &csStmtTxnId))
			{
printf("[%d] Statement_Txn_Id = [%s]\n", iCnt, csStmtTxnId);
				PutField_CString(hIn, "stmt_txn_id", csStmtTxnId);
			}

			if (GetField_Char(hRec, "status", &cTmp))
			{
printf("[%d] Status = [%c]\n", iCnt, cTmp);
				PutField_Char(hIn, "status", cStatus[iCnt]);
			}

			if (GetField_CString(hRec, "gen_txn_id_fr", &csTmp))
			{
printf("[%d] Generate_Txn_Id_From = [%s]\n", iCnt, csTmp);
			}
			else
			{
				sprintf(csBuf, "%d", iCnt + 1);
				PutField_CString(hIn, "gen_txn_id_fr", csBuf);
			}

			if (GetField_CString(hRec, "gen_txn_id_to", &csTmp))
			{
printf("[%d] Generate_Txn_Id_To = [%s]\n", iCnt, csTmp);
			}
			else
			{
				sprintf(csBuf, "%d", iCnt + 2);
				PutField_CString(hIn, "gen_txn_id_to", csBuf);
			}

			if (GetField_Int(hRec, "ret_code", &iTmp))
			{
printf("[%d] Result_Code = [%d]\n", iCnt, iTmp);
			}
			else
				PutField_Int(hIn, "ret_code", iCnt + 1000);

printf("[%d] Call OLBaidIntraLogGen: UpdateByStmtTxnId\n", iCnt);

			DBObjPtr = CreateObj(DBPtr, "DBOLBaidIntraLogGen", "UpdateByStmtTxnId");
			iRet = (unsigned long)(DBObjPtr)(hIn);

printf("[%d] Call OLBaidIntraLogGen: UpdateByStmtTxnId iRet = [%d]\n", iCnt, iRet);

			FREE_ME(csBuf);

			hash_destroy(hIn);
			FREE_ME(hIn);

			iCnt++;
			hRec = RecordSet_GetNext(rInfoSet);
		}
	}

	RecordSet_Destroy(rInfoSet);
	FREE_ME(rInfoSet);
*/

	// PspAmtDiffRange
/*
	char	cTmp;
	double	dTmp = 0.0;
	int	iRet = PD_OK;
	hash_t	* hIn;
	hash_t	* hOut;

	hIn = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hIn, 0);

	hOut = (hash_t *)malloc(sizeof(hash_t));
	hash_init(hOut, 0);

	PutField_CString(hIn, "psp_id", csPspId);
	PutField_Char(hIn, "type", cType);
	PutField_Char(hIn, "sign", cSign);
	PutField_Double(hIn, "value", dValue);
	PutField_Int(hIn, "disabled", iDisabled);
	PutField_CString(hIn, "create_user", csUser);

printf("Call PspAmtDiffRange: Update\n");

	DBObjPtr = CreateObj(DBPtr, "DBPspAmtDiffRange", "Update");
	iRet = (unsigned long)(DBObjPtr)(hIn);

printf("Call PspAmtDiffRange: Update iRet = [%d]\n", iRet);

	if (iRet == PD_OK)
	{
printf("Call PspAmtDiffRange: Find type, sign and value by [%s]\n", csPspId);

		DBObjPtr = CreateObj(DBPtr, "DBPspAmtDiffRange", "Find");
		iRet = (unsigned long)(DBObjPtr)(csPspId, hOut);

		if (iRet == PD_FOUND)
		{
			if (GetField_Char(hOut, "type", &cTmp))
			{
printf("Type = [%c]\n", cTmp);
			}

			if (GetField_Char(hOut, "sign", &cTmp))
			{
printf("Sign = [%c]\n", cTmp);
			}

			if (GetField_Double(hOut, "value", &dTmp))
			{
printf("Value = [%lf]\n", dTmp);
			}

			iRet = PD_OK;
		}
	}

	FREE_ME(hIn);
	FREE_ME(hOut);
*/

	// PspRestrictIpRegion
/*
	int iRet = PD_ERR;

	if (!strcmp(csFunc, "Update") || !strcmp(csFunc, "UpdateByPspId") || !strcmp(csFunc, "IsSupportIpRegion"))
	{
printf("Call PspRestrictIpRegion: %s\n", csFunc);

		DBObjPtr = CreateObj(DBPtr, "DBPspRestrictIpRegion", csFunc);

		if (!strcmp(csFunc, "Update") || !strcmp(csFunc, "UpdateByPspId"))
		{
			hash_t	* hIn;

			hIn = (hash_t *)malloc(sizeof(hash_t));
			hash_init(hIn, 0);

			PutField_CString(hIn, "psp_id", csPspId);
			PutField_CString(hIn, "region_code", csRegionCode);
			PutField_Int(hIn, "disabled", iDisabled);
			PutField_CString(hIn, "create_user", csUser);

			iRet = (unsigned long)(DBObjPtr)(hIn);

			FREE_ME(hIn);
		}
		else
			iRet = (unsigned long)(DBObjPtr)(csPspId, csRegionCode);
	}
	else
	{
printf("Invalid Function!!\n");
	}

printf("Call PspRestrictIpRegion: %s iRet = [%d]\n", csFunc, iRet);
printf("batch_proc end\n");
*/

	// IsValid
/*
	int iRet = PD_ERR;

printf("Call TestZale: IsValid\n");

	DBObjPtr = CreateObj(DBPtr, "DBTestZale", "IsValid");
	iRet = (unsigned long)(DBObjPtr)();

printf("TestZale: IsValid iRet = [%d]\n", iRet);
*/
/*

	char	* csPattern = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~!@#$%^&*()_+`-=[]\\;\',./{}|:\"<>?";
	int	iCount = 0;
	int	iRet = PD_OK;

printf("Pattern = [%s] | Len = [%d]\n", csPattern, (int)strlen(csPattern));
printf("Target = [%s] | Len = [%d]\n", csTarget, (int)strlen(csTarget));

	iCount = strspn(csTarget, csPattern);

printf("Match counts between target and pattern = [%d]\n", iCount);
*/

	//const char	* csPattern = "^[a-z0-9.,;/?%&_=-]+$";
	//const char	* csPattern = "^[a-z0-9.,:;~@/!?%&_=-]+$";
	//const char	* csPattern = "^[a-z0-9.,:;\'~@/!?%&#_=-]+$";
	//const char	* csPattern = "^[][a-z0-9.,:;\'()~@/!?%&#$*_=+-]+$";
	//const char	* csPattern = "^[][a-z0-9._~:/?#@!$&\'()*+,;=%-]+$";
/*
	char		* csTarget = "~!@#$%^&*()_+`-=[]\\;\',./{}|:\"<>?";
	const char	* csPattern = "^[][a-z0-9~!@#$%^&*()_+`=\\;\',./{}|:\"<>?-]+$";
	const size_t	sMatch = 1;
	int		iRet = PD_OK;
	int		iStatus;
	regex_t		rePreg;
	regmatch_t	reResult[1];

printf("Pattern = %s\n", csPattern);

	iStatus = regcomp(&rePreg, csPattern, REG_EXTENDED | REG_ICASE);

	if (iStatus != SUCCESS)
	{
printf("Compile regular expression failed...\n");
		return PD_ERR;
	}

	iStatus = regexec(&rePreg, csTarget, sMatch, reResult, 0);

	if (iStatus == REG_NOMATCH)
	{
printf("Invalid characters within the target = [%s]\n", csTarget);
	}
	else if (iStatus == 0)
	{
printf("Valid target = [%s]\n", csTarget);
	}
	else
	{
		char	csErrorMsg[256];

		regerror(iStatus, &rePreg, csErrorMsg, sizeof(csErrorMsg));
printf("Error meessage = [%s]\n", csErrorMsg);
	}

	regfree(&rePreg);

	return iRet;
*/

	int iRet = PD_NOT_FOUND;

	EXEC SQL WHENEVER SQLERROR GOTO find_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		int	v_count;

		short	ind_count	= -1;
	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("FindProduct: Begin\n"));

	EXEC SQL 
		SELECT	COUNT(*) 
		INTO	:v_count:ind_count 
		FROM	DEF_PRODUCT 
		WHERE	DP_ID = 'ABC' AND 
			DP_DISABLED = 0;

	/* count */
	if (ind_count > 0)
	{
printf("Normal Exit\n");
		iRet = PD_FOUND;
	}
	else
	{
printf("Normal Exit, Not Found\n");
	}

	return iRet;

find_error:
printf("find_error code %d\n", sqlca.sqlcode);
printf("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

int batch_terminate(int argc, char * argv[])
{
	return SUCCESS;
}
