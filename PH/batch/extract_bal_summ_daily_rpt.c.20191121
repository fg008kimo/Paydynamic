
/* Result Sets Interface */
#ifndef SQL_CRSR
#  define SQL_CRSR
  struct sql_cursor
  {
    unsigned int curocn;
    void *ptr1;
    void *ptr2;
    unsigned int magic;
  };
  typedef struct sql_cursor sql_cursor;
  typedef struct sql_cursor SQL_CURSOR;
#endif /* SQL_CRSR */

/* Thread Safety */
typedef void * sql_context;
typedef void * SQL_CONTEXT;

/* Object support */
struct sqltvn
{
  unsigned char *tvnvsn; 
  unsigned short tvnvsnl; 
  unsigned char *tvnnm;
  unsigned short tvnnml; 
  unsigned char *tvnsnm;
  unsigned short tvnsnml;
};
typedef struct sqltvn sqltvn;

struct sqladts
{
  unsigned int adtvsn; 
  unsigned short adtmode; 
  unsigned short adtnum;  
  sqltvn adttvn[1];       
};
typedef struct sqladts sqladts;

static struct sqladts sqladt = {
  1,1,0,
};

/* Binding to PL/SQL Records */
struct sqltdss
{
  unsigned int tdsvsn; 
  unsigned short tdsnum; 
  unsigned char *tdsval[1]; 
};
typedef struct sqltdss sqltdss;
static struct sqltdss sqltds =
{
  1,
  0,
};

/* File name & Package Name */
struct sqlcxp
{
  unsigned short fillen;
           char  filnam[30];
};
static struct sqlcxp sqlfpn =
{
    29,
    "extract_bal_summ_daily_rpt.pc"
};


static unsigned int sqlctx = 1877300805;


static struct sqlexd {
   unsigned long  sqlvsn;
   unsigned int   arrsiz;
   unsigned int   iters;
   unsigned int   offset;
   unsigned short selerr;
   unsigned short sqlety;
   unsigned int   occurs;
            short *cud;
   unsigned char  *sqlest;
            char  *stmt;
   sqladts *sqladtp;
   sqltdss *sqltdsp;
   unsigned char  **sqphsv;
   unsigned long  *sqphsl;
            int   *sqphss;
            short **sqpind;
            int   *sqpins;
   unsigned long  *sqparm;
   unsigned long  **sqparc;
   unsigned short  *sqpadto;
   unsigned short  *sqptdso;
   unsigned int   sqlcmax;
   unsigned int   sqlcmin;
   unsigned int   sqlcincr;
   unsigned int   sqlctimeout;
   unsigned int   sqlcnowait;
            int   sqfoff;
   unsigned int   sqcmod;
   unsigned int   sqfmod;
   unsigned char  *sqhstv[6];
   unsigned long  sqhstl[6];
            int   sqhsts[6];
            short *sqindv[6];
            int   sqinds[6];
   unsigned long  sqharm[6];
   unsigned long  *sqharc[6];
   unsigned short  sqadto[6];
   unsigned short  sqtdso[6];
} sqlstm = {12,6};

/* SQLLIB Prototypes */
extern sqlcxt ( void **, unsigned int *,
                   struct sqlexd *, struct sqlcxp * );
extern sqlcx2t( void **, unsigned int *,
                   struct sqlexd *, struct sqlcxp * );
extern sqlbuft( void **, char * );
extern sqlgs2t( void **, char * );
extern sqlorat( void **, unsigned int *, void * );

/* Forms Interface */
static int IAPSUCC = 0;
static int IAPFAIL = 1403;
static int IAPFTL  = 535;
extern void sqliem( unsigned char *, signed int * );

 static char *sq0001 = 
"SELECT MB_MERCHANT_ID , MB_COUNTRY , MB_CCY_ID , MB_SERVICE_CODE FROM MERCH\
ANT_BAL_ACCT ORDER BY MB_MERCHANT_ID , MB_COUNTRY , MB_CCY_ID , MB_SERVICE_CO\
DE            ";

 static char *sq0003 = 
"SELECT BAL AS OPEN_BALANCE FROM ( SELECT SEQ , BAL /*+ opt_param('optimizer\
_index_cost_adj',1) opt_param('optimizer_index_caching',99) +*/ FROM ( SELECT\
 1 AS SEQ , NVL ( td_current_bal , 0 ) + NVL ( td_current_bal_settlement , 0 \
) - NVL ( td_total_reserved_amount , 0 ) - NVL ( td_total_hold , 0 ) - NVL ( \
td_total_hold_settlement , 0 ) AS BAL FROM TXN_DETAIL , TXN_HEADER WHERE TH_A\
PPROVAL_TIMESTAMP < to_date ( :b0 , 'yyyymmdd' ) AND TH_MERCHANT_ID = :b1 AND\
 TH_AR_IND = 'A' AND TH_SERVICE_CODE = :b2 AND TH_NET_CCY = :b3 AND TH_TXN_ID\
 = TD_TXN_ID AND TD_TXN_COUNTRY = :b4 ORDER BY TH_APPROVAL_TIMESTAMP DESC , T\
H_TXN_ID DESC ) WHERE ROWNUM < 2 UNION ALL SELECT 2 AS SEQ , 0 FROM DUAL orde\
r by SEQ ) WHERE ROWNUM < 2 ORDER BY BAL DESC            ";

 static char *sq0005 = 
"SELECT BAL AS CLOSE_BALANCE FROM ( SELECT SEQ , BAL /*+ opt_param('optimize\
r_index_cost_adj',1) opt_param('optimizer_index_caching',99) +*/ FROM ( SELEC\
T 1 AS SEQ , NVL ( td_current_bal , 0 ) + NVL ( td_current_bal_settlement , 0\
 ) - NVL ( td_total_reserved_amount , 0 ) - NVL ( td_total_hold , 0 ) - NVL (\
 td_total_hold_settlement , 0 ) AS BAL FROM TXN_DETAIL , TXN_HEADER WHERE TH_\
APPROVAL_TIMESTAMP < to_date ( :b0 , 'yyyymmdd' ) + 1 AND TH_MERCHANT_ID = :b\
1 AND TH_AR_IND = 'A' AND TH_SERVICE_CODE = :b2 AND TH_NET_CCY = :b3 AND TH_T\
XN_ID = TD_TXN_ID AND TD_TXN_COUNTRY = :b4 ORDER BY TH_APPROVAL_TIMESTAMP DES\
C , TH_TXN_ID DESC ) WHERE ROWNUM < 2 UNION ALL SELECT 2 AS SEQ , 0 FROM DUAL\
 order by SEQ ) WHERE ROWNUM < 2 ORDER BY BAL DESC            ";

 static char *sq0007 = 
"FIN' , 'MPOR' , 'MAPO' , 'MAPF' , 'M\
FLT' , 'HOPO' , 'UOPO' ) AND TE_PARTY_TYPE = 'M' AND TE_CCY = :b4 AND TE_TXN_\
ID = TXN_HEADER . TH_TXN_ID AND TE_TXN_ELEMENT_TYPE = DT_TYPE AND TXN_HEADER \
. TH_TXN_CODE = TC_CODE ) LEFT JOIN MAP_TXN_ELEMENT ON TE_TXN_ELEMENT_TYPE = \
MT_ELEMENT AND TH_TXN_CODE = MT_TXN_CODE WHERE TD_TXN_ID = TE_TXN_ID AND TD_T\
XN_COUNTRY = :b5 ) GROUP BY TXN_CODE_DESC , TXN_ELEMENT_TYPE_DESC , TXN_CCY O\
RDER BY TXN_CODE_DESC , TXN_ELEMENT_TYPE_DESC            ";

typedef struct { unsigned short len; unsigned char arr[1]; } VARCHAR;
typedef struct { unsigned short len; unsigned char arr[1]; } varchar;

/* CUD (Compilation Unit Data) Array */
static short sqlcud0[] =
{12,4130,871,0,0,
5,0,0,1,166,0,9,185,0,2049,0,0,0,1,0,
20,0,0,1,0,0,13,188,0,0,4,0,0,1,0,2,9,0,0,2,9,0,0,2,9,0,0,2,9,0,0,
51,0,0,1,0,0,15,461,0,0,0,0,0,1,0,
66,0,0,1,0,0,15,474,0,0,0,0,0,1,0,
81,0,0,2,0,0,32,475,0,0,0,0,0,1,0,
96,0,0,3,748,0,9,859,0,2049,5,5,0,1,0,1,9,0,0,1,9,0,0,1,9,0,0,1,9,0,0,1,9,0,0,
131,0,0,3,0,0,13,864,0,0,1,0,0,1,0,2,4,0,0,
150,0,0,3,0,0,15,893,0,0,0,0,0,1,0,
165,0,0,3,0,0,15,902,0,0,0,0,0,1,0,
180,0,0,4,0,0,32,903,0,0,0,0,0,1,0,
195,0,0,5,753,0,9,1023,0,2049,5,5,0,1,0,1,9,0,0,1,9,0,0,1,9,0,0,1,9,0,0,1,9,0,
0,
230,0,0,5,0,0,13,1027,0,0,1,0,0,1,0,2,4,0,0,
249,0,0,5,0,0,15,1055,0,0,0,0,0,1,0,
264,0,0,5,0,0,15,1064,0,0,0,0,0,1,0,
279,0,0,6,0,0,32,1065,0,0,0,0,0,1,0,
294,0,0,7,1502,0,9,1222,0,2049,6,6,0,1,0,1,9,0,0,1,9,0,0,1,9,0,0,1,9,0,0,1,9,0,
0,1,9,0,0,
333,0,0,7,0,0,13,1226,0,0,6,0,0,1,0,2,9,0,0,2,9,0,0,2,9,0,0,2,3,0,0,2,4,0,0,2,
4,0,0,
372,0,0,7,0,0,15,1313,0,0,0,0,0,1,0,
387,0,0,7,0,0,15,1321,0,0,0,0,0,1,0,
402,0,0,8,0,0,32,1322,0,0,0,0,0,1,0,
};


/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                            Change Date     Change By
------------------------------------------    ------------    --------------
Init Version                                  2019/10/30      Michael Chow
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "ObjPtr.h"


#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define PD_REC_ENABLED     0
#define PD_FILE_PREFIX	   "bal_summary"

OBJPTR(DB);

char csDate[PD_DATE_LEN + 1];
char csInMerchantId[PD_MERCHANT_ID_LEN+1];
char csInCcyId[PD_COUNTRY_CODE_LEN+1];
char csInCountryCode[PD_CCY_ID_LEN+1];
char csInServiceCode[PD_SERVICE_CODE_LEN+1];

static char cDebug = 'Y';

int parse_arg(int argc,char **argv);

int process_data(const char* csTxnDate); 

int process_single_acct(const char* csTxnDate,
                        const char* csMerchantId,
                        const char* csCcyId,
                        const char* csCountryCode,
                        const char* csServiceCode);

int process_balsumm(const char* csMerchantId,
                     const char* csCcyId,
                     const char* csCountryCode,
                     const char* csServiceCode,
                     const char* csReportDate,
                     FILE *fp);

int process_openbal(const char* csMerchantId,
					const char* csCcyId,
					const char* csCountryCode,
					const char* csServiceCode,
					const char* csReportDate,
					FILE *fp);
					
int process_closebal(const char* csMerchantId,
					const char* csCcyId,
					const char* csCountryCode,
					const char* csServiceCode,
					const char* csReportDate,
					FILE *fp);
					 
					 
int mkFullPathDir(const char* csYearMthDy);

char* getYYYY(const char* csTxnDate);

char* getYYYYMM(const char* csTxnDate);

int chkSpInMID(const char* csMerchantId);

void format_commas(double dInNum, char* csOutNum);

int batch_init(int argc, char* argv[])
{
	if (argc < 3) {
		printf("usage: -d Date\n");

		return FAILURE;
	}
	else if (argc > 3 && argc < 11) {
		printf("usage: -d Date"
		       " -m Merchant_ID"
		       " -o Country_code"
		       " -c CCY_ID"
		       " -s Service_code\n"
		);

		return FAILURE;
	}
	else
  		return SUCCESS;
}

int batch_proc(int argc, char* argv[])
{
	int iRet;

	iRet = parse_arg(argc,argv);
         
	if (iRet != SUCCESS) {
		if (argc < 3)
			printf("usage: -d Date\n");
		else if (argc > 3 && argc < 11) {
			printf("usage: -d Date"
			       " -m Merchant_ID"
			       " -o Country_code"
			       " -c CCY_ID"
			       " -s Service_code\n"
			);
		}

		return (iRet);
	}

	if (argc == 3){
		iRet = process_data(csDate);
	}
	else
	{
		iRet = process_single_acct(csDate,csInMerchantId,csInCcyId,
		                           csInCountryCode,csInServiceCode);
	}

	return iRet;
}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}

int process_data(const char* csTxnDate)
{               
	int     iRet = SUCCESS;
	char    csMerchantId[PD_MERCHANT_ID_LEN+1];
	char    csCountryCode[PD_COUNTRY_CODE_LEN+1];
	char    csCcyId[PD_CCY_ID_LEN+1];
	char    csServiceCode[PD_SERVICE_CODE_LEN+1];
	char    csUploadFilename[PD_UPLOAD_FILENAME_LEN+1];
	char    csUploadFullFile[PD_PATH_LEN+1];
	char    csTmp[PD_TMP_BUF_LEN+1];
	char    csTmpCmd[PD_TMP_BUF_LEN+1];
	char    csYear[PD_YYYY_LEN+1];
	char    csYearMth[PD_YYYYMM_LEN+1];
	FILE    *fp;
	hash_t* hBalSumm;
	hBalSumm = (hash_t*) malloc (sizeof(hash_t));
	
	/* EXEC SQL WHENEVER SQLERROR GOTO sql_error; */ 

	/* EXEC SQL WHENEVER NOTFOUND CONTINUE; */ 

  
	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		/* varchar v_merchant_id[PD_MERCHANT_ID_LEN+1]; */ 
struct { unsigned short len; unsigned char arr[16]; } v_merchant_id;

		/* varchar v_service_code[PD_SERVICE_CODE_LEN+1]; */ 
struct { unsigned short len; unsigned char arr[4]; } v_service_code;

		/* varchar v_country_code[PD_COUNTRY_CODE_LEN+1]; */ 
struct { unsigned short len; unsigned char arr[3]; } v_country_code;

		/* varchar v_ccy_id[PD_CCY_ID_LEN+1]; */ 
struct { unsigned short len; unsigned char arr[4]; } v_ccy_id;

    
		short   ind_merchant_id  = -1;
		short   ind_service_code = -1;
		short   ind_country_code = -1;
		short   ind_ccy_id       = -1;
	/* EXEC SQL END DECLARE SECTION; */ 


	/* EXEC SQL DECLARE c_cursor_getMerBalAcct CURSOR FOR
		SELECT MB_MERCHANT_ID,
		       MB_COUNTRY,
		       MB_CCY_ID,
		       MB_SERVICE_CODE
		FROM MERCHANT_BAL_ACCT
		ORDER BY MB_MERCHANT_ID,MB_COUNTRY,MB_CCY_ID,MB_SERVICE_CODE
		; */ 


	/* EXEC SQL OPEN c_cursor_getMerBalAcct; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 0;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0001;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )5;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
 if (sqlca.sqlcode < 0) goto sql_error;
}



	do {
		/* EXEC SQL FETCH c_cursor_getMerBalAcct
		INTO :v_merchant_id:ind_merchant_id,
		     :v_country_code:ind_country_code,
		     :v_ccy_id:ind_ccy_id,
		     :v_service_code:ind_service_code; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 12;
  sqlstm.arrsiz = 4;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )20;
  sqlstm.selerr = (unsigned short)1;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqfoff = (         int )0;
  sqlstm.sqfmod = (unsigned int )2;
  sqlstm.sqhstv[0] = (unsigned char  *)&v_merchant_id;
  sqlstm.sqhstl[0] = (unsigned long )18;
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         short *)&ind_merchant_id;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned long )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqhstv[1] = (unsigned char  *)&v_country_code;
  sqlstm.sqhstl[1] = (unsigned long )5;
  sqlstm.sqhsts[1] = (         int  )0;
  sqlstm.sqindv[1] = (         short *)&ind_country_code;
  sqlstm.sqinds[1] = (         int  )0;
  sqlstm.sqharm[1] = (unsigned long )0;
  sqlstm.sqadto[1] = (unsigned short )0;
  sqlstm.sqtdso[1] = (unsigned short )0;
  sqlstm.sqhstv[2] = (unsigned char  *)&v_ccy_id;
  sqlstm.sqhstl[2] = (unsigned long )6;
  sqlstm.sqhsts[2] = (         int  )0;
  sqlstm.sqindv[2] = (         short *)&ind_ccy_id;
  sqlstm.sqinds[2] = (         int  )0;
  sqlstm.sqharm[2] = (unsigned long )0;
  sqlstm.sqadto[2] = (unsigned short )0;
  sqlstm.sqtdso[2] = (unsigned short )0;
  sqlstm.sqhstv[3] = (unsigned char  *)&v_service_code;
  sqlstm.sqhstl[3] = (unsigned long )6;
  sqlstm.sqhsts[3] = (         int  )0;
  sqlstm.sqindv[3] = (         short *)&ind_service_code;
  sqlstm.sqinds[3] = (         int  )0;
  sqlstm.sqharm[3] = (unsigned long )0;
  sqlstm.sqadto[3] = (unsigned short )0;
  sqlstm.sqtdso[3] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
  if (sqlca.sqlcode < 0) goto sql_error;
}



		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

/* Extract report data */
		hash_init(hBalSumm,0);
		PutField_CString(hBalSumm,"report_code",PD_BAL_SUMM_REPORT_CODE);
/* Table Field merchant_id */
		if (ind_merchant_id >= 0)
		{
			sprintf(csTmp,"%.*s",v_merchant_id.len,v_merchant_id.arr);
			strcpy(csMerchantId, csTmp); 
			PutField_CString(hBalSumm,"merchant_id",csTmp);
		}
  
/* Table Field country */
		if (ind_country_code >= 0)
		{
			sprintf(csTmp,"%.*s",v_country_code.len,v_country_code.arr);
			strcpy(csCountryCode, csTmp);
			PutField_CString(hBalSumm,"country",csTmp);
		}

/* Table Field CCY_ID */
		if (ind_ccy_id >= 0)
		{
			sprintf(csTmp,"%.*s",v_ccy_id.len,v_ccy_id.arr);
			strcpy(csCcyId, csTmp);
			PutField_CString(hBalSumm,"ccy",csTmp);
		}

/* Table Field service_code */
		if (ind_service_code >= 0)
		{
			sprintf(csTmp,"%.*s",v_service_code.len,v_service_code.arr);
			strcpy(csServiceCode, csTmp);
			PutField_CString(hBalSumm,"service_code",csTmp);
		}


/* Table Field  disabled*/
		PutField_Int(hBalSumm,"disabled",PD_REC_ENABLED);

/* Addition field Report Data */
		if (strlen(csTxnDate) > 0)
		{
			PutField_CString(hBalSumm,"report_date",csTxnDate);
		}

		/* Skip the record if MID contains space */ 
		if (chkSpInMID(csMerchantId) == PD_ERR)
			continue;

		
		sprintf(csUploadFilename, 
				"%s_%s_%s_%s_%s_%s.zip",
				PD_FILE_PREFIX,
				csMerchantId,
				csCountryCode,
				csCcyId,
				csServiceCode,
				csTxnDate);

/* Addition field Filename */
		PutField_CString(hBalSumm,"filename",csUploadFilename);

/* Addition field Update_user */
		PutField_CString(hBalSumm,"user",PD_UPDATE_USER);

/* Extract year and year month */
		strcpy(csYear, getYYYY(csTxnDate));

		strcpy(csYearMth, getYYYYMM(csTxnDate));

/* Check and make current balance report folder */
		if (mkFullPathDir(csTxnDate) != PD_OK)
		{
DEBUGLOG(("process_data:unable to create path [%s %s %s]\n",csYear, csYearMth, csTxnDate));
			return FAILURE;
		}

		sprintf(csUploadFullFile,"%s/%s/%s/%s/%s/%s_%s_%s_%s_%s_%s.xls",  
		        getenv("PREGEN_RPT_HOME"), PD_FILE_PREFIX, csYear, csYearMth, csTxnDate, PD_FILE_PREFIX,
		        csMerchantId, csCountryCode, csCcyId, csServiceCode, 
		        csTxnDate);
		        
		fp = fopen(csUploadFullFile,"w");
		if (fp == NULL) {
DEBUGLOG(("process_data:unable to open [%s]\n",csUploadFullFile));
			return FAILURE;
		}

/* create xml header */
		fprintf(fp,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
		fprintf(fp,"<?mso-application progid=\"Excel.Sheet\"?>\n");
		fprintf(fp,"<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\n");
		fprintf(fp,"\txmlns:o=\"urn:schemas-microsoft-com:office:office\"\n");
		fprintf(fp,"\t xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\n");
		fprintf(fp,"\t xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"\n");
		fprintf(fp,"\t xmlns:html=\"http://www.w3.org/TR/REC-html40\">\n");
		fprintf(fp,"<Styles>\n");
		fprintf(fp,"\t<Style ss:ID=\"shd\">\n");
		fprintf(fp,"\t\t<ss:Font ss:Bold=\"1\"/>\n");
		fprintf(fp,"\t\t<Alignment ss:Horizontal=\"Center\" ss:Vertical=\"Center\"/>\n");
		fprintf(fp,"\t</Style>\n");
		fprintf(fp,"\t<Style ss:ID=\"sdt\">\n");
		fprintf(fp,"\t\t<NumberFormat ss:Format=\"yyyy-mm-dd hh:mm:ss\"/>\n");
		fprintf(fp,"\t</Style>\n");
		fprintf(fp,"</Styles>\n");
		fprintf(fp,"<Worksheet ss:Name=\"Balance Summary\">\n");
		fprintf(fp,"<Table>\n");
		
/* create open bal header */
		fprintf(fp,"<Row>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\"> </Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Opening Balance</Data></Cell>\n");
		fprintf(fp,"</Row>\n");

/* process Open balance data */
		if (process_openbal(csMerchantId,
		                     csCcyId,
		                     csCountryCode,
		                     csServiceCode,
		                     csTxnDate,
		                     fp
		    ) == PD_OK){
/* Addition field Status */
		}
		else
		{
/* Addition field Status */
			iRet=PD_ERR;
DEBUGLOG(("process_openbal failed!!!!!!\n"));
		}

/* process CB Ledger data */
		fprintf(fp,"<Row>\n");
		fprintf(fp,"</Row>\n");
		fprintf(fp,"<Row>\n");
		fprintf(fp,"</Row>\n");


		fprintf(fp,"<Row>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Transaction Type</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Sub Transaction Type</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Transaction Currency</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Count</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Credit</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Debit</Data></Cell>\n");
		fprintf(fp,"</Row>\n");

/* process CB Ledger  data */
		if(iRet==PD_OK){
			if (process_balsumm(csMerchantId,
						csCcyId,
						csCountryCode,
						csServiceCode,
						csTxnDate,
						fp
				) == PD_OK){
			}
			else{
				iRet=PD_ERR;
DEBUGLOG(("process_balsumm failed!!!!!!\n"));
			}
		}
		

		
/* create close bal header */
		fprintf(fp,"<Row>\n");
		fprintf(fp,"</Row>\n");
		fprintf(fp,"<Row>\n");
                fprintf(fp,"</Row>\n");


		fprintf(fp,"<Row>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\"> </Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Closing Balance</Data></Cell>\n");
		fprintf(fp,"</Row>\n");
		

/* process close balance data */
		if(iRet==PD_OK){
			if (process_closebal(csMerchantId,
						csCcyId,
						csCountryCode,
						csServiceCode,
						csTxnDate,
						fp
				) == PD_OK){
			}
			else{
				iRet=PD_ERR;
DEBUGLOG(("process_closebal failed!!!!!!\n"));
			}
		}
		
		if(iRet==PD_OK){
/* Addition field Status */
			PutField_Char(hBalSumm,"status",PD_PREGEN_RPT_COMPLETED); 
		}
		else{
/* Addition field Status */
			PutField_Char(hBalSumm,"status",PD_PREGEN_RPT_FAILURE);
		}
		
		
		
		

/* create xml footer */
		fprintf(fp, "</Table>\n");
		fprintf(fp, "</Worksheet>\n");
		fprintf(fp, "</Workbook>\n");

		fclose(fp);

/* zip the report */
		sprintf(csTmpCmd, 
		        "zip_pregenrpt.sh %s %s %s %s %s %s %s 1>/dev/null",
		        csTxnDate,
		        csMerchantId,
		        csCountryCode,
		        csCcyId,
		        csServiceCode,
			getenv("PREGEN_RPT_HOME"),
			PD_FILE_PREFIX);
		
		
		if (system(csTmpCmd) == PD_ERR)
		{
DEBUGLOG(("extract_bal_summ_daily_rpt::zip: fail %s\n", csTmpCmd));
		}
		else
		{
DEBUGLOG(("extract_bal_summ_daily_rpt::zip: success %s\n", csTmpCmd));
		}


/* ChkExist Insert/update pregen_daily_report */
		DBObjPtr = CreateObj(DBPtr,"DBPregenDailyReport","ChkExist");
		if ((*DBObjPtr)(hBalSumm) != PD_OK) 
		{
			DBObjPtr = CreateObj(DBPtr,"DBPregenDailyReport","UpdateStatus");
			if ((*DBObjPtr)(hBalSumm) != PD_OK) 
				iRet = PD_ERR;
		}
		else
		{
			DBObjPtr = CreateObj(DBPtr,"DBPregenDailyReport","Add");
			if ((*DBObjPtr)(hBalSumm) != PD_OK) 
				iRet = PD_ERR;
		}

		if (iRet == PD_OK)
		{
DEBUGLOG(("extract_bal_summ_daily_rpt::commit: MerchantId[%s] Country[%s] CcyId[%s] ServiceCode[%s] TxnDate[%s]\n", csMerchantId,csCountryCode,csCcyId,csServiceCode,csTxnDate));
			TxnCommit();
		}



		hash_destroy(hBalSumm);

	} while (PD_TRUE);

	/* EXEC SQL CLOSE c_cursor_getMerBalAcct; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 4;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )51;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
 if (sqlca.sqlcode < 0) goto sql_error;
}



	if (hBalSumm)
	{
		FREE_ME(hBalSumm);
	}

	return iRet;

sql_error:
DEBUGLOG(("extract_bal_summ_daily_rpt::process_data: error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	/* EXEC SQL WHENEVER SQLERROR CONTINUE; */ 

	/* EXEC SQL CLOSE c_cursor_getMerBalAcct; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 4;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )66;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


	/* EXEC SQL ROLLBACK RELEASE; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 4;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )81;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



	if (hBalSumm) 
	{
		hash_destroy(hBalSumm);
	}
   	FREE_ME(hBalSumm);

	return PD_ERR;
}

int process_single_acct(const char* csTxnDate,
                        const char* csMerchantId,
                        const char* csCcyId,
                        const char* csCountryCode,
                        const char* csServiceCode)
{               
	int     iRet = SUCCESS;
	char    csUploadFilename[PD_UPLOAD_FILENAME_LEN+1];
	char    csUploadFullFile[PD_PATH_LEN+1];
	char    csTmpCmd[PD_TMP_BUF_LEN+1];
	char    csYear[PD_YYYY_LEN+1];
	char    csYearMth[PD_YYYYMM_LEN+1];
	FILE    *fp;
	hash_t* hBalSumm;


/* Report data */
	hBalSumm = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hBalSumm,0);
 
 	PutField_CString(hBalSumm,"report_code",PD_BAL_SUMM_REPORT_CODE);
	
/* Table Field merchant_id */
	if (strlen(csMerchantId) > 0)
	{
		PutField_CString(hBalSumm,"merchant_id",csMerchantId);
	}
  
/* Table Field country */
	if (strlen(csCountryCode) > 0)
	{
		PutField_CString(hBalSumm,"country",csCountryCode);
	}

/* Table Field CCY_ID */
	if (strlen(csCcyId) > 0)
	{
		PutField_CString(hBalSumm,"ccy",csCcyId);
	}

/* Table Field service_code */
	if (strlen(csServiceCode) >= 0)
	{
		PutField_CString(hBalSumm,"service_code",csServiceCode);
	}


/* Addition field Report Data */
	if (strlen(csTxnDate) > 0)
	{
		PutField_CString(hBalSumm,"report_date",csTxnDate);
	}

	sprintf(csUploadFilename, 
	        "%s_%s_%s_%s_%s_%s.zip", PD_FILE_PREFIX, csMerchantId, csCountryCode,
	        csCcyId, csServiceCode, csTxnDate);

/* Addition field Filename */
	PutField_CString(hBalSumm,"filename",csUploadFilename);

/* Addition field Update_user */
	PutField_CString(hBalSumm,"user",PD_UPDATE_USER);

/* Extract year and year month */
	strcpy(csYear, getYYYY(csTxnDate));

	strcpy(csYearMth, getYYYYMM(csTxnDate));

/* Check and make current balance report folder */
	if (mkFullPathDir(csTxnDate) != PD_OK)
	{
DEBUGLOG(("process_data:unable to create path [%s]\n", csTxnDate));
		return FAILURE;
	}
	
	sprintf(csUploadFullFile,"%s/%s/%s/%s/%s/%s_%s_%s_%s_%s_%s.xls",  
	        getenv("PREGEN_RPT_HOME"), PD_FILE_PREFIX, csYear, csYearMth, csTxnDate, PD_FILE_PREFIX,
	        csMerchantId, csCountryCode, csCcyId, csServiceCode, 
	        csTxnDate);

	fp = fopen(csUploadFullFile,"w");
	if (fp == NULL) {
DEBUGLOG(("process_data:unable to open [%s]\n",csUploadFullFile));
		return FAILURE;
	}

/* create xml header */
	fprintf(fp,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
	fprintf(fp,"<?mso-application progid=\"Excel.Sheet\"?>\n");
	fprintf(fp,"<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\n");
	fprintf(fp,"\txmlns:o=\"urn:schemas-microsoft-com:office:office\"\n");
	fprintf(fp,"\t xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\n");
	fprintf(fp,"\t xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"\n");
	fprintf(fp,"\t xmlns:html=\"http://www.w3.org/TR/REC-html40\">\n");
	fprintf(fp,"<Styles>\n");
	fprintf(fp,"\t<Style ss:ID=\"shd\">\n");
	fprintf(fp,"\t\t<ss:Font ss:Bold=\"1\"/>\n");
	fprintf(fp,"\t\t<Alignment ss:Horizontal=\"Center\" ss:Vertical=\"Center\"/>\n");
	fprintf(fp,"\t</Style>\n");
	fprintf(fp,"\t<Style ss:ID=\"sdt\">\n");
	fprintf(fp,"\t\t<NumberFormat ss:Format=\"yyyy-mm-dd hh:mm:ss\"/>\n");
	fprintf(fp,"\t</Style>\n");
	fprintf(fp,"</Styles>\n");
	fprintf(fp,"<Worksheet ss:Name=\"Balance Summary\">\n");
	fprintf(fp,"<Table>\n");
	fprintf(fp,"<Row>\n");

/* create open bal header */
	fprintf(fp,"\t<Cell><Data ss:Type=\"String\"> </Data></Cell>\n");
	fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Opening Balance</Data></Cell>\n");
	
	fprintf(fp,"</Row>\n");

/* process Open balance data */
		if (process_openbal(csMerchantId,
		                     csCcyId,
		                     csCountryCode,
		                     csServiceCode,
		                     csTxnDate,
		                     fp
		    ) == PD_OK){
/* Addition field Status */
		}
		else
		{
/* Addition field Status */
			iRet=PD_ERR;
DEBUGLOG(("process_openbal failed!!!!!!\n"));
		}

/* create balance summary txn header */
		fprintf(fp,"<Row>\n");
		fprintf(fp,"</Row>\n");
		fprintf(fp,"<Row>\n");
		fprintf(fp,"</Row>\n");

		fprintf(fp,"<Row>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Transaction Type</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Sub Transaction Type</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Transaction Currency</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Count</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Credit</Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Debit</Data></Cell>\n");
		fprintf(fp,"</Row>\n");

/* process balance summary data */
		if(iRet==PD_OK){
			if (process_balsumm(csMerchantId,
						csCcyId,
						csCountryCode,
						csServiceCode,
						csTxnDate,
						fp
				) == PD_OK){
			}
			else{
				iRet=PD_ERR;
DEBUGLOG(("process_balsumm failed!!!!!!\n"));
			}
		}
			

		
/* create close bal header */
		fprintf(fp,"<Row>\n");
		fprintf(fp,"</Row>\n");
		fprintf(fp,"<Row>\n");
		fprintf(fp,"</Row>\n");

		fprintf(fp,"<Row>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\"> </Data></Cell>\n");
		fprintf(fp,"\t<Cell><Data ss:Type=\"String\">Closing Balance</Data></Cell>\n");
		fprintf(fp,"</Row>\n");
		

/* process close balance data */
		if(iRet==PD_OK){
			if (process_closebal(csMerchantId,
						csCcyId,
						csCountryCode,
						csServiceCode,
						csTxnDate,
						fp
				) == PD_OK){
			}
			else{
				iRet=PD_ERR;
DEBUGLOG(("process_closebal failed!!!!!!\n"));
			}
		}
		
		if(iRet==PD_OK){
/* Addition field Status */
			PutField_Char(hBalSumm,"status",PD_PREGEN_RPT_COMPLETED); 
		}
		else{
/* Addition field Status */
			PutField_Char(hBalSumm,"status",PD_PREGEN_RPT_FAILURE);
		}
		
		
/* create xml footer */
	fprintf(fp, "</Table>\n");
	fprintf(fp, "</Worksheet>\n");
	fprintf(fp, "</Workbook>\n");

	fclose(fp);

/* zip the report */
	sprintf(csTmpCmd, 
		"zip_pregenrpt.sh %s %s %s %s %s %s %s 1>/dev/null",
		csTxnDate,
		csMerchantId,
		csCountryCode,
		csCcyId,
		csServiceCode,
		getenv("PREGEN_RPT_HOME"),
		PD_FILE_PREFIX);

	if (system(csTmpCmd) == PD_ERR)
	{
DEBUGLOG(("extract_bal_summ_daily_rpt::zip: fail %s\n", csTmpCmd));
	}
	else
	{
DEBUGLOG(("extract_bal_summ_daily_rpt::zip: success %s\n", csTmpCmd));
	}

/* ChkExist Insert/update pregen_daily_report */
	DBObjPtr = CreateObj(DBPtr,"DBPregenDailyReport","ChkExist");
	if ((*DBObjPtr)(hBalSumm) > 0) 
	{
		DBObjPtr = CreateObj(DBPtr,"DBPregenDailyReport","UpdateStatus");
		if ((*DBObjPtr)(hBalSumm) != PD_OK) 
			iRet = PD_ERR;
	}
	else
	{
		DBObjPtr = CreateObj(DBPtr,"DBPregenDailyReport","Add");
		if ((*DBObjPtr)(hBalSumm) != PD_OK) 
			iRet = PD_ERR;
	}

	if (iRet == PD_OK)
	{
DEBUGLOG(("extract_bal_summ_daily_rpt::commit: MerchantId[%s] Country[%s] CcyId[%s] ServiceCode[%s] TxnDate[%s]\n", csMerchantId,csCountryCode,csCcyId,csServiceCode,csTxnDate));
		TxnCommit();
	}

	if (hBalSumm)
	{
		hash_destroy(hBalSumm);
		FREE_ME(hBalSumm);
	}


	return iRet;
}



int process_openbal(const char* csMerchantId,
                     const char* csCcyId,
                     const char* csCountryCode,
                     const char* csServiceCode,
                     const char* csReportDate,
                     FILE *fp)
{
	int   	iRet = SUCCESS;

	double  dOpenBalance;
	char csTmp[PD_TMP_BUF_LEN+1];


	/* EXEC SQL WHENEVER SQLERROR GOTO openbal_sql_error; */ 

	/* EXEC SQL WHENEVER NOTFOUND CONTINUE; */ 

  
	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		/* varchar hv_merchant_id[PD_MERCHANT_ID_LEN]; */ 
struct { unsigned short len; unsigned char arr[15]; } hv_merchant_id;

		/* varchar hv_service_code[PD_SERVICE_CODE_LEN]; */ 
struct { unsigned short len; unsigned char arr[3]; } hv_service_code;

		/* varchar hv_country_code[PD_COUNTRY_CODE_LEN]; */ 
struct { unsigned short len; unsigned char arr[2]; } hv_country_code;

		/* varchar hv_ccy_id[PD_CCY_ID_LEN]; */ 
struct { unsigned short len; unsigned char arr[3]; } hv_ccy_id;

		/* varchar	hv_report_date[PD_DATE_LEN]; */ 
struct { unsigned short len; unsigned char arr[8]; } hv_report_date;

    
		double  v_open_balance;

		short   ind_open_balance = -1;	
		
		

	/* EXEC SQL END DECLARE SECTION; */ 


DEBUGLOG(("process_openbal:Begin\n"));

	if(strlen(csMerchantId) > 0)
	{
		hv_merchant_id.len = strlen(csMerchantId);
		strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
DEBUGLOG(("process_openbal:merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
	} else {
DEBUGLOG(("process_openbal:merchant_id is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_openbal: merchant_id is missing\n");
		return PD_ERR;
	}

	if(strlen(csCcyId) > 0)
	{
		hv_ccy_id.len = strlen(csCcyId);
		strncpy((char *)hv_ccy_id.arr, csCcyId, hv_ccy_id.len);
DEBUGLOG(("process_openbal:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
	} else {
DEBUGLOG(("process_openbal:ccy_id is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_openbal: ccy_id is missing\n");
		return PD_ERR;
	}

	if(strlen(csCountryCode) > 0)
	{
		hv_country_code.len = strlen(csCountryCode);
		strncpy((char *)hv_country_code.arr, csCountryCode, hv_country_code.len);
DEBUGLOG(("process_openbal:country = [%.*s]\n",hv_country_code.len,hv_country_code.arr));
	} else {
DEBUGLOG(("process_openbal:country is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_openbal: country is missing\n");
		return PD_ERR;
	}

	if(strlen(csServiceCode) > 0)
	{
		hv_service_code.len = strlen(csServiceCode);
		strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
DEBUGLOG(("process_openbal:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
	} else {
DEBUGLOG(("process_openbal:service_code is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_openbal: service_code is missing\n");
		return PD_ERR;
	}

	if(strlen(csReportDate) > 0)
	{
		hv_report_date.len = strlen(csReportDate);
		strncpy((char *)hv_report_date.arr, csReportDate, hv_report_date.len);
DEBUGLOG(("process_openbal:report_date = [%.*s]\n",hv_report_date.len,hv_report_date.arr));
	} else {
DEBUGLOG(("process_openbal:report_date is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_openbal: report_date is missing\n");
		return PD_ERR;
	}


	/* EXEC SQL DECLARE c_cursor_getopenbal CURSOR FOR
		SELECT  BAL AS OPEN_BALANCE FROM
		(
			SELECT SEQ, BAL /o+ opt_param('optimizer_index_cost_adj',1) opt_param('optimizer_index_caching',99) o/
			FROM
			(
				SELECT 1 AS SEQ, NVL(td_current_bal, 0) + NVL(td_current_bal_settlement, 0) - NVL(td_total_reserved_amount, 0) - NVL(td_total_hold, 0) - NVL(td_total_hold_settlement, 0) AS BAL FROM
				TXN_DETAIL,
				TXN_HEADER
				WHERE TH_APPROVAL_TIMESTAMP < to_date(:hv_report_date, 'yyyymmdd')
				AND  TH_MERCHANT_ID = :hv_merchant_id
				AND  TH_AR_IND = 'A'
				AND  TH_SERVICE_CODE = :hv_service_code
				AND  TH_NET_CCY = :hv_ccy_id
				AND  TH_TXN_ID = TD_TXN_ID
				AND  TD_TXN_COUNTRY = :hv_country_code
				ORDER BY TH_APPROVAL_TIMESTAMP DESC, TH_TXN_ID DESC
			)
			WHERE ROWNUM < 2
			UNION ALL
			SELECT 2 AS SEQ,0 FROM DUAL order by SEQ
		)
		WHERE ROWNUM < 2 ORDER BY BAL DESC; */ 

	/* EXEC SQL OPEN c_cursor_getopenbal; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 5;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0003;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )96;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlstm.sqhstv[0] = (unsigned char  *)&hv_report_date;
 sqlstm.sqhstl[0] = (unsigned long )10;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         short *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned long )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (unsigned char  *)&hv_merchant_id;
 sqlstm.sqhstl[1] = (unsigned long )17;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         short *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned long )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (unsigned char  *)&hv_service_code;
 sqlstm.sqhstl[2] = (unsigned long )5;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         short *)0;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned long )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (unsigned char  *)&hv_ccy_id;
 sqlstm.sqhstl[3] = (unsigned long )5;
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         short *)0;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned long )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (unsigned char  *)&hv_country_code;
 sqlstm.sqhstl[4] = (unsigned long )4;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         short *)0;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned long )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
 if (sqlca.sqlcode < 0) goto openbal_sql_error;
}





	do {
		/* EXEC SQL FETCH c_cursor_getopenbal
		INTO
			:v_open_balance:ind_open_balance
		; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 12;
  sqlstm.arrsiz = 5;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )131;
  sqlstm.selerr = (unsigned short)1;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqfoff = (         int )0;
  sqlstm.sqfmod = (unsigned int )2;
  sqlstm.sqhstv[0] = (unsigned char  *)&v_open_balance;
  sqlstm.sqhstl[0] = (unsigned long )sizeof(double);
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         short *)&ind_open_balance;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned long )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
  if (sqlca.sqlcode < 0) goto openbal_sql_error;
}



		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		fprintf(fp,"<Row>\n");

/*	v_open_balance	*/
		if(ind_open_balance >= 0)
		{
			dOpenBalance  = v_open_balance;
/* debug  */
			format_commas(dOpenBalance, csTmp);
			/*fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">%.2f</Data></Cell>\n",dOpenBalance);*/
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\">%s</Data></Cell>\n",csCcyId);
			fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">%s</Data></Cell>\n",csTmp);
/*DEBUGLOG(("process_openbal v_open_balance = [%f]\n",v_open_balance));*/
		}
		else
			fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">0</Data></Cell>\n");
		fprintf(fp,"</Row>\n");


	} while (PD_TRUE);

	
	/* EXEC SQL CLOSE c_cursor_getopenbal; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 5;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )150;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
 if (sqlca.sqlcode < 0) goto openbal_sql_error;
}


	

	return iRet;

openbal_sql_error:
DEBUGLOG(("extract_bal_summ_daily_rpt:process_openbal code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	/* EXEC SQL WHENEVER SQLERROR CONTINUE; */ 

	/* EXEC SQL CLOSE c_cursor_getopenbal; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 5;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )165;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


	/* EXEC SQL ROLLBACK RELEASE; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 5;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )180;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



	return PD_ERR;
}




int process_closebal(const char* csMerchantId,
                     const char* csCcyId,
                     const char* csCountryCode,
                     const char* csServiceCode,
                     const char* csReportDate,
                     FILE *fp)
{
	int   	iRet = SUCCESS;

	double  dCloseBalance;
	char csTmp[PD_TMP_BUF_LEN+1];


	/* EXEC SQL WHENEVER SQLERROR GOTO closebal_sql_error; */ 

	/* EXEC SQL WHENEVER NOTFOUND CONTINUE; */ 

  
	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		/* varchar hv_merchant_id[PD_MERCHANT_ID_LEN]; */ 
struct { unsigned short len; unsigned char arr[15]; } hv_merchant_id;

		/* varchar hv_service_code[PD_SERVICE_CODE_LEN]; */ 
struct { unsigned short len; unsigned char arr[3]; } hv_service_code;

		/* varchar hv_country_code[PD_COUNTRY_CODE_LEN]; */ 
struct { unsigned short len; unsigned char arr[2]; } hv_country_code;

		/* varchar hv_ccy_id[PD_CCY_ID_LEN]; */ 
struct { unsigned short len; unsigned char arr[3]; } hv_ccy_id;

		/* varchar	hv_report_date[PD_DATE_LEN]; */ 
struct { unsigned short len; unsigned char arr[8]; } hv_report_date;

    
		double  v_close_balance;

		short   ind_close_balance = -1;	
		
		

	/* EXEC SQL END DECLARE SECTION; */ 


DEBUGLOG(("process_closebal:Begin\n"));

	if(strlen(csMerchantId) > 0)
	{
		hv_merchant_id.len = strlen(csMerchantId);
		strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
DEBUGLOG(("process_closebal:merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
	} else {
DEBUGLOG(("process_closebal:merchant_id is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_closebal: merchant_id is missing\n");
		return PD_ERR;
	}

	if(strlen(csCcyId) > 0)
	{
		hv_ccy_id.len = strlen(csCcyId);
		strncpy((char *)hv_ccy_id.arr, csCcyId, hv_ccy_id.len);
DEBUGLOG(("process_closebal:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
	} else {
DEBUGLOG(("process_closebal:ccy_id is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_closebal: ccy_id is missing\n");
		return PD_ERR;
	}

	if(strlen(csCountryCode) > 0)
	{
		hv_country_code.len = strlen(csCountryCode);
		strncpy((char *)hv_country_code.arr, csCountryCode, hv_country_code.len);
DEBUGLOG(("process_closebal:country = [%.*s]\n",hv_country_code.len,hv_country_code.arr));
	} else {
DEBUGLOG(("process_closebal:country is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_closebal: country is missing\n");
		return PD_ERR;
	}

	if(strlen(csServiceCode) > 0)
	{
		hv_service_code.len = strlen(csServiceCode);
		strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
DEBUGLOG(("process_closebal:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
	} else {
DEBUGLOG(("process_closebal:service_code is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_closebal: service_code is missing\n");
		return PD_ERR;
	}

	if(strlen(csReportDate) > 0)
	{
		hv_report_date.len = strlen(csReportDate);
		strncpy((char *)hv_report_date.arr, csReportDate, hv_report_date.len);
DEBUGLOG(("process_closebal:report_date = [%.*s]\n",hv_report_date.len,hv_report_date.arr));
	} else {
DEBUGLOG(("process_closebal:report_date is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_closebal: report_date is missing\n");
		return PD_ERR;
	}

	
	/* EXEC SQL DECLARE c_cursor_getclosebal CURSOR FOR
		SELECT  BAL AS CLOSE_BALANCE FROM
		(
			SELECT SEQ, BAL /o+ opt_param('optimizer_index_cost_adj',1) opt_param('optimizer_index_caching',99) o/
			FROM
			(
				SELECT 1 AS SEQ, NVL(td_current_bal, 0) + NVL(td_current_bal_settlement, 0) - NVL(td_total_reserved_amount, 0) - NVL(td_total_hold, 0) - NVL(td_total_hold_settlement, 0) AS BAL FROM
				TXN_DETAIL,
				TXN_HEADER
				WHERE TH_APPROVAL_TIMESTAMP < to_date(:hv_report_date, 'yyyymmdd')+1
				AND  TH_MERCHANT_ID = :hv_merchant_id
				AND  TH_AR_IND = 'A'
				AND  TH_SERVICE_CODE = :hv_service_code
				AND  TH_NET_CCY = :hv_ccy_id
				AND  TH_TXN_ID = TD_TXN_ID
				AND  TD_TXN_COUNTRY = :hv_country_code
				ORDER BY TH_APPROVAL_TIMESTAMP DESC, TH_TXN_ID DESC
			)
			WHERE ROWNUM < 2
			UNION ALL
			SELECT 2 AS SEQ ,0 FROM DUAL order by SEQ
		)
		WHERE ROWNUM < 2 ORDER BY BAL DESC; */ 

	/* EXEC SQL OPEN c_cursor_getclosebal; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 5;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0005;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )195;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlstm.sqhstv[0] = (unsigned char  *)&hv_report_date;
 sqlstm.sqhstl[0] = (unsigned long )10;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         short *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned long )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (unsigned char  *)&hv_merchant_id;
 sqlstm.sqhstl[1] = (unsigned long )17;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         short *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned long )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (unsigned char  *)&hv_service_code;
 sqlstm.sqhstl[2] = (unsigned long )5;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         short *)0;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned long )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (unsigned char  *)&hv_ccy_id;
 sqlstm.sqhstl[3] = (unsigned long )5;
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         short *)0;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned long )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (unsigned char  *)&hv_country_code;
 sqlstm.sqhstl[4] = (unsigned long )4;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         short *)0;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned long )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
 if (sqlca.sqlcode < 0) goto closebal_sql_error;
}


		

	do {
		/* EXEC SQL FETCH c_cursor_getclosebal
		INTO
			:v_close_balance:ind_close_balance
		; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 12;
  sqlstm.arrsiz = 5;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )230;
  sqlstm.selerr = (unsigned short)1;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqfoff = (         int )0;
  sqlstm.sqfmod = (unsigned int )2;
  sqlstm.sqhstv[0] = (unsigned char  *)&v_close_balance;
  sqlstm.sqhstl[0] = (unsigned long )sizeof(double);
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         short *)&ind_close_balance;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned long )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
  if (sqlca.sqlcode < 0) goto closebal_sql_error;
}



		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		fprintf(fp,"<Row>\n");

/*	v_close_balance	*/
		if(ind_close_balance >= 0)
		{
			dCloseBalance  = v_close_balance;
/* debug  */
			format_commas(dCloseBalance, csTmp);
			/*fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">%.2f</Data></Cell>\n",dCloseBalance);*/
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\">%s</Data></Cell>\n",csCcyId);
			fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">%s</Data></Cell>\n",csTmp);
/*DEBUGLOG(("process_closebal v_close_balance = [%f]\n",v_close_balance));*/
		}
		else
			fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">0</Data></Cell>\n");
		fprintf(fp,"</Row>\n");

	} while (PD_TRUE);

	
	/* EXEC SQL CLOSE c_cursor_getclosebal; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 5;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )249;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
 if (sqlca.sqlcode < 0) goto closebal_sql_error;
}


	

	return iRet;

closebal_sql_error:
DEBUGLOG(("extract_bal_summ_daily_rpt:process_closebal code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	/* EXEC SQL WHENEVER SQLERROR CONTINUE; */ 

	/* EXEC SQL CLOSE c_cursor_getclosebal; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 5;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )264;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


	/* EXEC SQL ROLLBACK RELEASE; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 5;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )279;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



	return PD_ERR;
}





int process_balsumm(const char* csMerchantId,
                     const char* csCcyId,
                     const char* csCountryCode,
                     const char* csServiceCode,
                     const char* csReportDate,
                     FILE *fp)
{
	int   	iRet = SUCCESS;

	char    csTxnDesc[PD_DESC_LEN+1];
	char    csTxnElementTypeDesc[PD_DESC_LEN+1];
	char    csTxnCcy[PD_CCY_ID_LEN+1];
	double  dCredit;
	double  dDebit;
	
	char csTmp[PD_TMP_BUF_LEN+1];


	/* EXEC SQL WHENEVER SQLERROR GOTO balsumm_sql_error; */ 

	/* EXEC SQL WHENEVER NOTFOUND CONTINUE; */ 

  
	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		/* varchar hv_merchant_id[PD_MERCHANT_ID_LEN]; */ 
struct { unsigned short len; unsigned char arr[15]; } hv_merchant_id;

		/* varchar hv_service_code[PD_SERVICE_CODE_LEN]; */ 
struct { unsigned short len; unsigned char arr[3]; } hv_service_code;

		/* varchar hv_country_code[PD_COUNTRY_CODE_LEN]; */ 
struct { unsigned short len; unsigned char arr[2]; } hv_country_code;

		/* varchar hv_ccy_id[PD_CCY_ID_LEN]; */ 
struct { unsigned short len; unsigned char arr[3]; } hv_ccy_id;

		/* varchar	hv_report_date[PD_DATE_LEN]; */ 
struct { unsigned short len; unsigned char arr[8]; } hv_report_date;

    
		
		/* varchar v_txn_desc[PD_DESC_LEN+1]; */ 
struct { unsigned short len; unsigned char arr[51]; } v_txn_desc;

		/* varchar v_txn_element_type_desc[PD_DESC_LEN+1]; */ 
struct { unsigned short len; unsigned char arr[51]; } v_txn_element_type_desc;

		/* varchar v_txn_ccy[PD_CCY_ID_LEN+1]; */ 
struct { unsigned short len; unsigned char arr[4]; } v_txn_ccy;

		int		v_count;
		double  v_credit;
		double  v_debit;
		
		
		short   ind_txn_desc = -1;
		short   ind_txn_element_type_desc = -1;
		short   ind_txn_ccy = -1;		
		short   ind_count = -1;
		short   ind_credit = -1;
		short   ind_debit = -1;
		


	/* EXEC SQL END DECLARE SECTION; */ 


DEBUGLOG(("process_balsumm:Begin\n"));

	if(strlen(csMerchantId) > 0)
	{
		hv_merchant_id.len = strlen(csMerchantId);
		strncpy((char *)hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
DEBUGLOG(("process_balsumm:merchant_id = [%.*s]\n",hv_merchant_id.len,hv_merchant_id.arr));
	} else {
DEBUGLOG(("process_balsumm:merchant_id is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_balsumm: merchant_id is missing\n");
		return PD_ERR;
	}

	if(strlen(csCcyId) > 0)
	{
		hv_ccy_id.len = strlen(csCcyId);
		strncpy((char *)hv_ccy_id.arr, csCcyId, hv_ccy_id.len);
DEBUGLOG(("process_balsumm:ccy_id = [%.*s]\n",hv_ccy_id.len,hv_ccy_id.arr));
	} else {
DEBUGLOG(("process_balsumm:ccy_id is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_balsumm: ccy_id is missing\n");
		return PD_ERR;
	}

	if(strlen(csCountryCode) > 0)
	{
		hv_country_code.len = strlen(csCountryCode);
		strncpy((char *)hv_country_code.arr, csCountryCode, hv_country_code.len);
DEBUGLOG(("process_balsumm:country = [%.*s]\n",hv_country_code.len,hv_country_code.arr));
	} else {
DEBUGLOG(("process_balsumm:country is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_balsumm: country is missing\n");
		return PD_ERR;
	}

	if(strlen(csServiceCode) > 0)
	{
		hv_service_code.len = strlen(csServiceCode);
		strncpy((char *)hv_service_code.arr, csServiceCode, hv_service_code.len);
DEBUGLOG(("process_balsumm:service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));
	} else {
DEBUGLOG(("process_balsumm:service_code is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_balsumm: service_code is missing\n");
		return PD_ERR;
	}

	if(strlen(csReportDate) > 0)
	{
		hv_report_date.len = strlen(csReportDate);
		strncpy((char *)hv_report_date.arr, csReportDate, hv_report_date.len);
DEBUGLOG(("process_balsumm:report_date = [%.*s]\n",hv_report_date.len,hv_report_date.arr));
	} else {
DEBUGLOG(("process_balsumm:report_date is missing\n"));
ERRLOG("extract_bal_summ_daily_rpt::process_balsumm: report_date is missing\n");
		return PD_ERR;
	}
		
/* TXN */
	/* EXEC SQL DECLARE c_cursor_getbalsumm CURSOR FOR
	
	SELECT  TXN_CODE_DESC AS TXN_DESC,
			TXN_ELEMENT_TYPE_DESC AS TXN_ELEMENT_DESC,
			TXN_CCY AS TXN_CCY,
			COUNT(*) AS COUNTER,
			SUM(CREDIT_AMOUNT) AS CREDIT_AMT,
			SUM(DEBIT_AMOUNT) AS DEBIT_AMT FROM
	(SELECT  TC_DESC AS TXN_CODE_DESC
			,NVL(MT_DESC, DT_DESC) AS TXN_ELEMENT_TYPE_DESC
			,TE_CCY AS TXN_CCY
			,CASE WHEN (TE_AMT_TYPE = 'CR') THEN TE_AMOUNT ELSE 0 END AS CREDIT_AMOUNT
			,CASE WHEN (TE_AMT_TYPE = 'DR') THEN TE_AMOUNT ELSE 0 END AS DEBIT_AMOUNT
	FROM  TXN_DETAIL,
	( SELECT TE_TXN_ID
		,TH_TXN_CODE
		,TE_TXN_ELEMENT_TYPE
		,DT_DESC
		,TE_AMOUNT
		,TE_CCY
		,TE_AMT_TYPE
		,TC_DESC
	FROM TXN_ELEMENTS,
	( SELECT TH_TXN_ID
		,TH_TXN_CODE
		FROM TXN_HEADER
		WHERE TH_APPROVAL_TIMESTAMP >= TO_DATE(:hv_report_date, 'yyyymmdd') AND TH_APPROVAL_TIMESTAMP < TO_DATE(:hv_report_date, 'yyyymmdd')+1
		AND  TH_MERCHANT_ID = :hv_merchant_id
		AND  TH_AR_IND = 'A'
		AND  TH_TXN_CODE NOT IN ('RLS','RLA')
		AND  TH_SERVICE_CODE = :hv_service_code
	) TXN_HEADER,DEF_ELEMENT_TYPE,TXN_CODE
	WHERE TE_TXN_ELEMENT_TYPE IN ('TAMT','TFEE','TRNF','RAMT','UAMT','HAMT','MFIN','MPOR','MAPO','MAPF','MFLT','HOPO','UOPO')
		AND  TE_PARTY_TYPE = 'M'
		AND  TE_CCY = :hv_ccy_id
		AND  TE_TXN_ID = TXN_HEADER.TH_TXN_ID
		AND  TE_TXN_ELEMENT_TYPE = DT_TYPE
		AND  TXN_HEADER.TH_TXN_CODE = TC_CODE
	)
	LEFT JOIN MAP_TXN_ELEMENT ON TE_TXN_ELEMENT_TYPE = MT_ELEMENT AND TH_TXN_CODE = MT_TXN_CODE
	WHERE TD_TXN_ID = TE_TXN_ID AND TD_TXN_COUNTRY = :hv_country_code) GROUP BY TXN_CODE_DESC, TXN_ELEMENT_TYPE_DESC, TXN_CCY ORDER BY TXN_CODE_DESC, TXN_ELEMENT_TYPE_DESC; */ 

  
	/* EXEC SQL OPEN c_cursor_getbalsumm; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 6;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlbuft((void **)0,
   "SELECT TXN_CODE_DESC AS TXN_DESC , TXN_ELEMENT_TYPE_DESC AS TXN_ELEMENT_\
DESC , TXN_CCY AS TXN_CCY , COUNT ( * ) AS COUNTER , SUM ( CREDIT_AMOUNT ) A\
S CREDIT_AMT , SUM ( DEBIT_AMOUNT ) AS DEBIT_AMT FROM ( SELECT TC_DESC AS TX\
N_CODE_DESC , NVL ( MT_DESC , DT_DESC ) AS TXN_ELEMENT_TYPE_DESC , TE_CCY AS\
 TXN_CCY , CASE WHEN ( TE_AMT_TYPE = 'CR' ) THEN TE_AMOUNT ELSE 0 END AS CRE\
DIT_AMOUNT , CASE WHEN ( TE_AMT_TYPE = 'DR' ) THEN TE_AMOUNT ELSE 0 END AS D\
EBIT_AMOUNT FROM TXN_DETAIL , ( SELECT TE_TXN_ID , TH_TXN_CODE , TE_TXN_ELEM\
ENT_TYPE , DT_DESC , TE_AMOUNT , TE_CCY , TE_AMT_TYPE , TC_DESC FROM TXN_ELE\
MENTS , ( SELECT TH_TXN_ID , TH_TXN_CODE FROM TXN_HEADER WHERE TH_APPROVAL_T\
IMESTAMP >= TO_DATE ( :b0 , 'yyyymmdd' ) AND TH_APPROVAL_TIMESTAMP < TO_DATE\
 ( :b0 , 'yyyymmdd' ) + 1 AND TH_MERCHANT_ID = :b2 AND TH_AR_IND = 'A' AND T\
H_TXN_CODE NOT IN ( 'RLS' , 'RLA' ) AND TH_SERVICE_CODE = :b3 ) TXN_HEADER ,\
 DEF_ELEMENT_TYPE , TXN_CODE WHERE TE_TXN_ELEMENT_TYPE IN ( 'TAMT' , 'TFEE' \
, 'TRNF' , 'RAMT' , 'UAMT' , 'HAMT' , 'M");
 sqlstm.stmt = sq0007;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )294;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlstm.sqhstv[0] = (unsigned char  *)&hv_report_date;
 sqlstm.sqhstl[0] = (unsigned long )10;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         short *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned long )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (unsigned char  *)&hv_report_date;
 sqlstm.sqhstl[1] = (unsigned long )10;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         short *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned long )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (unsigned char  *)&hv_merchant_id;
 sqlstm.sqhstl[2] = (unsigned long )17;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         short *)0;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned long )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (unsigned char  *)&hv_service_code;
 sqlstm.sqhstl[3] = (unsigned long )5;
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         short *)0;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned long )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (unsigned char  *)&hv_ccy_id;
 sqlstm.sqhstl[4] = (unsigned long )5;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         short *)0;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned long )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqhstv[5] = (unsigned char  *)&hv_country_code;
 sqlstm.sqhstl[5] = (unsigned long )4;
 sqlstm.sqhsts[5] = (         int  )0;
 sqlstm.sqindv[5] = (         short *)0;
 sqlstm.sqinds[5] = (         int  )0;
 sqlstm.sqharm[5] = (unsigned long )0;
 sqlstm.sqadto[5] = (unsigned short )0;
 sqlstm.sqtdso[5] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
 if (sqlca.sqlcode < 0) goto balsumm_sql_error;
}


	
	do {
	
		/* EXEC SQL FETCH c_cursor_getbalsumm
		INTO
			:v_txn_desc:ind_txn_desc,
			:v_txn_element_type_desc:ind_txn_element_type_desc,
			:v_txn_ccy:ind_txn_ccy,
			:v_count:ind_count,
			:v_credit:ind_credit,
			:v_debit:ind_debit
		; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 12;
  sqlstm.arrsiz = 6;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )333;
  sqlstm.selerr = (unsigned short)1;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqfoff = (         int )0;
  sqlstm.sqfmod = (unsigned int )2;
  sqlstm.sqhstv[0] = (unsigned char  *)&v_txn_desc;
  sqlstm.sqhstl[0] = (unsigned long )53;
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         short *)&ind_txn_desc;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned long )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqhstv[1] = (unsigned char  *)&v_txn_element_type_desc;
  sqlstm.sqhstl[1] = (unsigned long )53;
  sqlstm.sqhsts[1] = (         int  )0;
  sqlstm.sqindv[1] = (         short *)&ind_txn_element_type_desc;
  sqlstm.sqinds[1] = (         int  )0;
  sqlstm.sqharm[1] = (unsigned long )0;
  sqlstm.sqadto[1] = (unsigned short )0;
  sqlstm.sqtdso[1] = (unsigned short )0;
  sqlstm.sqhstv[2] = (unsigned char  *)&v_txn_ccy;
  sqlstm.sqhstl[2] = (unsigned long )6;
  sqlstm.sqhsts[2] = (         int  )0;
  sqlstm.sqindv[2] = (         short *)&ind_txn_ccy;
  sqlstm.sqinds[2] = (         int  )0;
  sqlstm.sqharm[2] = (unsigned long )0;
  sqlstm.sqadto[2] = (unsigned short )0;
  sqlstm.sqtdso[2] = (unsigned short )0;
  sqlstm.sqhstv[3] = (unsigned char  *)&v_count;
  sqlstm.sqhstl[3] = (unsigned long )sizeof(int);
  sqlstm.sqhsts[3] = (         int  )0;
  sqlstm.sqindv[3] = (         short *)&ind_count;
  sqlstm.sqinds[3] = (         int  )0;
  sqlstm.sqharm[3] = (unsigned long )0;
  sqlstm.sqadto[3] = (unsigned short )0;
  sqlstm.sqtdso[3] = (unsigned short )0;
  sqlstm.sqhstv[4] = (unsigned char  *)&v_credit;
  sqlstm.sqhstl[4] = (unsigned long )sizeof(double);
  sqlstm.sqhsts[4] = (         int  )0;
  sqlstm.sqindv[4] = (         short *)&ind_credit;
  sqlstm.sqinds[4] = (         int  )0;
  sqlstm.sqharm[4] = (unsigned long )0;
  sqlstm.sqadto[4] = (unsigned short )0;
  sqlstm.sqtdso[4] = (unsigned short )0;
  sqlstm.sqhstv[5] = (unsigned char  *)&v_debit;
  sqlstm.sqhstl[5] = (unsigned long )sizeof(double);
  sqlstm.sqhsts[5] = (         int  )0;
  sqlstm.sqindv[5] = (         short *)&ind_debit;
  sqlstm.sqinds[5] = (         int  )0;
  sqlstm.sqharm[5] = (unsigned long )0;
  sqlstm.sqadto[5] = (unsigned short )0;
  sqlstm.sqtdso[5] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
  if (sqlca.sqlcode < 0) goto balsumm_sql_error;
}



		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		
		fprintf(fp,"<Row>\n");

/* txn_desc	*/
		if(ind_txn_desc >= 0)
		{
			v_txn_desc.arr[v_txn_desc.len] = '\0';
			strcpy(csTxnDesc,(const char*)v_txn_desc.arr);
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\">%s</Data></Cell>\n",csTxnDesc);
/*DEBUGLOG(("process_balsumm v_txn_desc = [%s]\n", v_txn_desc.arr));*/
		}
		else
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\"> </Data></Cell>\n");

/*	v_txn_element_type_desc */
		if (ind_txn_element_type_desc >= 0)
		{
			v_txn_element_type_desc.arr[v_txn_element_type_desc.len] = '\0';
			strcpy(csTxnElementTypeDesc,(const char*)v_txn_element_type_desc.arr);
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\">%s</Data></Cell>\n",csTxnElementTypeDesc);
/*DEBUGLOG(("process_balsumm v_txn_element_type_desc = [%s]\n", v_txn_element_type_desc.arr));*/
		}
		else
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\"> </Data></Cell>\n");
/*	v_txn_ccy	*/
		if (ind_txn_ccy >= 0)
		{
			v_txn_ccy.arr[v_txn_ccy.len] = '\0';
			strcpy(csTxnCcy,(const char*)v_txn_ccy.arr);
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\">%s</Data></Cell>\n",csTxnCcy);
/*DEBUGLOG(("process_balsumm v_txn_ccy = [%s]\n", v_txn_ccy.arr));*/
		}
		else
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\"> </Data></Cell>\n");
/*	v_count	*/
		if (ind_count >= 0)
		{
			//v_count.arr[v_count.len] = '\0';
			//strcpy(csTxnCcy,(const char*)v_count.arr);
			sprintf(csTmp, "%d", v_count);
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\">%s</Data></Cell>\n",csTmp);
/*DEBUGLOG(("process_balsumm v_count = [%s]\n", v_count.arr));*/
		}
		else
			fprintf(fp,"\t<Cell><Data ss:Type=\"String\"> </Data></Cell>\n");
			
/*	v_credit	*/
		if (ind_credit >= 0)
		{
			dCredit = v_credit;
			format_commas(dCredit, csTmp);
			/*fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">%.2f</Data></Cell>\n",dCredit);*/
			fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">%s</Data></Cell>\n",csTmp);
/*DEBUGLOG(("process_balsumm v_credit = [%f]\n",v_credit));*/
		}
		else
			fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">0</Data></Cell>\n");

/*	v_debit	*/
		if(ind_debit >= 0)
		{
			dDebit = v_debit;
			format_commas(dDebit, csTmp);
			/*fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">%.2f</Data></Cell>\n",dDebit);*/
			fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">%s</Data></Cell>\n",csTmp);
/*DEBUGLOG(("process_balsumm v_debit = [%f]\n",v_debit));*/
		}
		else
			fprintf(fp,"\t<Cell><Data ss:Type=\"Number\">0</Data></Cell>\n");

		fprintf(fp,"</Row>\n");

	} while (PD_TRUE);
	
	/* EXEC SQL CLOSE c_cursor_getbalsumm; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 6;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )372;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
 if (sqlca.sqlcode < 0) goto balsumm_sql_error;
}


		
	return iRet;

balsumm_sql_error:
DEBUGLOG(("extract_bal_summ_daily_rpt:process_balsumm code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	/* EXEC SQL WHENEVER SQLERROR CONTINUE; */ 

	/* EXEC SQL CLOSE c_cursor_getbalsumm; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 6;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )387;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


	/* EXEC SQL ROLLBACK RELEASE; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 12;
 sqlstm.arrsiz = 6;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )402;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



	return PD_ERR;
}



int mkFullPathDir(const char * csYearMthDy) 
{
	int  iRet = SUCCESS;
	char csTmpCmd[PD_TMP_BUF_LEN+1];

	
	sprintf(csTmpCmd, 
			"mkdir_pregenrpt_tree.sh %s %s %s 1> /dev/null",		
			csYearMthDy, getenv("PREGEN_RPT_HOME"),PD_FILE_PREFIX);
	
	if (system(csTmpCmd) == PD_ERR)
	{
		iRet = PD_ERR;
	}

	return iRet;
}

char* getYYYY(const char* csTxnDate)
{
	char csTmpYYYY[PD_YYYY_LEN+1];

	strncpy(csTmpYYYY, csTxnDate, PD_YYYY_LEN);
	csTmpYYYY[PD_YYYY_LEN] = '\0';

	return csTmpYYYY;
}

char* getYYYYMM(const char* csTxnDate)
{
	char csTmpYYYYMM[PD_YYYYMM_LEN+1];

	strncpy(csTmpYYYYMM, csTxnDate, PD_YYYYMM_LEN);
	csTmpYYYYMM[PD_YYYYMM_LEN] = '\0';

	return csTmpYYYYMM;
}

int chkSpInMID(const char* csMerchantId)
{
	int iCnt = 0;

	for (iCnt; iCnt < strlen(csMerchantId); iCnt++)
		if (csMerchantId[iCnt] == 32)
			return PD_ERR;

	return SUCCESS;
}

void format_commas(double dInNum, char* csOutNum)
{
	char csTmpNum[PD_TMP_BUF_LEN+1];
	int  iCnt;
	int  iCnt2;

	sprintf(csTmpNum, "%.2f", dInNum);

	if (strlen(csTmpNum) <= 6)
	{
		strcpy (csOutNum, csTmpNum);

		return;
	}
	
	/* Reverse order */
	iCnt2 = 0;
	for (iCnt = strlen(csTmpNum) - 1; iCnt >= 0; iCnt--)
	{
		csOutNum[iCnt2] = csTmpNum[iCnt];
		iCnt2++;
	}
	csOutNum[iCnt2] = '\0';

	csTmpNum[0] = csOutNum[0];
	csTmpNum[1] = csOutNum[1];
	csTmpNum[2] = csOutNum[2];
	iCnt2=3;
	for (iCnt = 3; iCnt < strlen(csOutNum); iCnt++)
	{
		csTmpNum[iCnt2] = csOutNum[iCnt];
		iCnt2++;
		if (((iCnt+1) % 3 == 0) && (iCnt+1 < strlen(csOutNum)))
		{
			csTmpNum[iCnt2] = ',';
			iCnt2++;
		}
	}
	csTmpNum[iCnt2] = '\0';

	/* Reverse order */
	iCnt2 = 0;
	for (iCnt = strlen(csTmpNum) - 1; iCnt >= 0; iCnt--)
	{
		csOutNum[iCnt2] = csTmpNum[iCnt];
		iCnt2++;
	}
	csOutNum[iCnt2] = '\0';
	
	return;
}

int parse_arg(int argc,char **argv)
{
	char c;
	strcpy(csDate,"");
	strcpy(csInMerchantId,"");
	strcpy(csInCcyId,"");
	strcpy(csInCountryCode,"");
	strcpy(csInServiceCode,"");

	while ((c = getopt(argc,argv,"d:m:c:o:s:")) != EOF) {
		switch (c) {
			case 'd':
				strcpy(csDate, optarg);
				break;
			case 'm':
				strcpy(csInMerchantId, optarg);
				break;
			case 'c':
				strcpy(csInCcyId, optarg);
				break;
			case 'o':
				strcpy(csInCountryCode, optarg);
				break;
			case 's':
				strcpy(csInServiceCode, optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (!strcmp(csDate,""))
		return FAILURE;

	if (argc > 3) {
		if (!strcmp(csInMerchantId,""))
			return FAILURE;

		if (!strcmp(csInCcyId,""))
			return FAILURE;

		if (!strcmp(csInCountryCode,""))
			return FAILURE;

		if (!strcmp(csInServiceCode,""))
			return FAILURE;
	}

	return SUCCESS;
}

