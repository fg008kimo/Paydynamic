/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/09/12              Dirk Wong 
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"
#include "internal.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

int cnt=0;
int tpl_create=0;
int iTplType=0;
char *content;
char csTag[PD_TAG_LEN+1];
char csTmp[PD_TMP_BUF_LEN+1];
char cDebug;

int iDynCnt=0;

OBJPTR(BO);

int parse_arg(int argc,char **argv);

int batch_init(int argc, char* argv[])
{
        return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	int     iRet = parse_arg(argc,argv);
	int	iChk = 0;
	int 	iMonthEndDate = 0;
	int	iCurrDayPlusThirtyDayDate = 0;

	hash_t *hContext;
	
	if (iRet != SUCCESS) {
		iTplType = 0;
	}

	hContext = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hContext,0);

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar v_curr_day_date[PD_DATE_LEN+1];
		varchar v_curr_day_plus_thirty_day_date[PD_DATE_LEN+1];
		varchar v_month_end_date[PD_DATE_LEN+1];
		varchar v_alert_date[PD_DATE_LEN+1];
		varchar	v_mobile[PD_CUSTOMER_TEL_LEN+1];
		varchar	v_carriers[PD_DESC_LEN+1];
		varchar	v_country[PD_DESC_LEN+1];
		varchar v_last_topup_date[PD_DATE_LEN+1];
		varchar	v_next_topup_date[PD_DATE_LEN+1];

		short	ind_curr_day_date = -1;
		short	ind_curr_day_plus_thirty_day_date = -1;
		short	ind_month_end_date = -1;
		//short	ind_alert_date = -1;
		short	ind_mobile = -1;
		short	ind_carriers = -1;
		short	ind_country = -1;
		short	ind_last_topup_date = -1;
		short	ind_next_topup_date = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE c_cursor_getalertdate CURSOR FOR
		//SELECT	TO_CHAR(LAST_DAY(TRUNC(SYSDATE)),'YYYYMMDD')
		SELECT	TO_CHAR(TRUNC(SYSDATE),'YYYYMMDD'),
			TO_CHAR(TRUNC(SYSDATE)+30,'YYYYMMDD'),
			TO_CHAR(LAST_DAY(TRUNC(SYSDATE)),'YYYYMMDD')
		FROM	DUAL;

	EXEC SQL OPEN c_cursor_getalertdate;
	do {
		EXEC SQL FETCH c_cursor_getalertdate
		INTO
			//:v_alert_date:ind_alert_date;
			:v_curr_day_date:ind_curr_day_date,
			:v_curr_day_plus_thirty_day_date:ind_curr_day_plus_thirty_day_date,
			:v_month_end_date:ind_month_end_date;
		
		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
	}
	while(PD_TRUE);
	EXEC SQL CLOSE c_cursor_getalertdate;

	sprintf(csTmp,"%.*s",v_curr_day_plus_thirty_day_date.len,v_curr_day_plus_thirty_day_date.arr);	
	iCurrDayPlusThirtyDayDate = atoi(csTmp);

	sprintf(csTmp,"%.*s",v_month_end_date.len,v_month_end_date.arr);
	iMonthEndDate = atoi(csTmp);

	if (iCurrDayPlusThirtyDayDate >= iMonthEndDate) {
		v_alert_date.len = v_curr_day_plus_thirty_day_date.len;
        	memcpy(v_alert_date.arr,v_curr_day_plus_thirty_day_date.arr,v_curr_day_plus_thirty_day_date.len);
	} else {
		v_alert_date.len = v_month_end_date.len;
        	memcpy(v_alert_date.arr,v_month_end_date.arr,v_month_end_date.len);
	}

//printf("iCurrDayPlusThirtyDayDate=%d\n",iCurrDayPlusThirtyDayDate);
//printf("iMonthEndDate=%d\n",iMonthEndDate);
//printf("v_alert_date.arr=%s\n",v_alert_date.arr);

	EXEC SQL DECLARE c_cursor_getmobilelist CURSOR FOR
		SELECT  A.OSC_MOBILE,
			B.DSC_CARRIER_NAME,
			C.COUNTRY_NAME,
			A.OSC_LAST_TOPUP_DATE,
			A.OSC_NEXT_TOPUP_DATE
		FROM    OL_SIM_CARDS A,
			OL_DEF_SIM_CARRIERS B,
			COUNTRY C 
		WHERE   A.OSC_CARRIERS = B.DSC_CARRIER_CODE
		AND     A.OSC_COUNTRY = C.COUNTRY_CODE
		//AND     A.OSC_NEXT_TOPUP_DATE >= :v_curr_day_date
		AND     A.OSC_NEXT_TOPUP_DATE <= :v_alert_date
		AND     A.OSC_STATUS != 'D'
		ORDER BY A.OSC_NEXT_TOPUP_DATE;	

	EXEC SQL OPEN c_cursor_getmobilelist;
	do {
		EXEC SQL FETCH c_cursor_getmobilelist
		INTO
			:v_mobile:ind_mobile,
			:v_carriers:ind_carriers,
			:v_country:ind_country,
			:v_last_topup_date:ind_last_topup_date,
			:v_next_topup_date:ind_next_topup_date;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		/*fmobile*/
			sprintf(csTag,"fmobile-%d",iChk);
			sprintf(csTmp,"%.*s",v_mobile.len,v_mobile.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
		/*fcarriers*/
			sprintf(csTag,"fcarriers-%d",iChk);
			sprintf(csTmp,"%.*s",v_carriers.len,v_carriers.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
		/*fcountry*/
			sprintf(csTag,"fcountry-%d",iChk);
			sprintf(csTmp,"%.*s",v_country.len,v_country.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
		/*flast_topup_date*/
			sprintf(csTag,"flast_topup_date-%d",iChk);
			sprintf(csTmp,"%.*s",v_last_topup_date.len,v_last_topup_date.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
		/*fnext_topup_date*/
			sprintf(csTag,"fnext_topup_date-%d",iChk);
			sprintf(csTmp,"%.*s",v_next_topup_date.len,v_next_topup_date.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);

		iChk ++;
	}
	while(PD_TRUE && iRet == SUCCESS);
	EXEC SQL CLOSE c_cursor_getmobilelist;

/*stimestamp*/
	iDynCnt = set_tpl_dyn_int(hContext,iDynCnt,"stimestamp-0","SEC","stimestamp-0",0);
/*ftimestamp*/
	iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,"ftimestamp-0","STR","stimestamp-0",write_tpl_timestamp());

/*stitle*/
	iDynCnt = set_tpl_dyn_int(hContext,iDynCnt,"stitle-0","SEC","stitle-0",0);
/*ftitle*/

	sprintf(csTmp, "Sim Cards Topup hit by %.*s",v_alert_date.len,v_alert_date.arr);
	iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,"ftitle-0","STR","stitle-0",csTmp);

	if (iChk == 0)
	{
		//Print no record
		iDynCnt = set_tpl_dyn_int(hContext, iDynCnt, "stbl_norecord-0", "SEC", "stbl_norecord-0", 0);
		sprintf(csTmp,"%.*s",v_alert_date.len,v_alert_date.arr);
		iDynCnt = set_tpl_dyn_cstring(hContext, iDynCnt, "fnext_topup_date-0", "STR", "stbl_norecord-0", csTmp);
	}
	else
	{
		iDynCnt = set_tpl_dyn_int(hContext, iDynCnt, "stbl_head-0", "SEC", "stbl_head-0", 0);
		iDynCnt = set_tpl_dyn_int(hContext, iDynCnt, "stbl_body-0", "SEC", "stbl_body-0", iChk);
	}

	iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,"g_subject","GLO","STR","Sim Cards Monthly Report");

	PutField_CString(hContext,"source","BATCH");
	PutField_CString(hContext,"funct","SIM_CARD_REPORT");
	PutField_Char(hContext,"party_type",'G');
	PutField_CString(hContext,"party_id","000");

	PutField_Int(hContext,"total_dyn",iDynCnt);

	BOObjPtr = CreateObj(BOPtr,"BOAlertEmail","ProcessTpl");
	if((unsigned long)((*BOObjPtr)(hContext) != PD_OK)){
		iRet=INT_CODE_ERROR;
		PutField_Int(hContext,"internal_error",iRet);
DEBUGLOG(("Authorize::ProcessTpl Failed\n"));
ERRLOG("TxnMgtByUsALT::Authorize::ProcessTpl Failed, iRet=%d\n", iRet);
	}
	else
	{
DEBUGLOG(("Authorize::ProcessTpl Success\n"));
	}

	FREE_ME(hContext);

	return iRet;

sql_error:
DEBUGLOG(("sim_card_monthly_report error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getalertdate;
    EXEC SQL CLOSE c_cursor_getmobilelist;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int batch_terminate(int argc, char* argv[])
{
        return SUCCESS;
}

int parse_arg(int argc,char **argv)
{
/*
        char    c;

        if (argc < 2) {
                return PD_ERR;
        }
        while ((c = getopt(argc,argv,"t:")) != EOF) {
                switch (c) {
                        case 't':
                                iTplType = atoi(optarg);
                                break;
                        default:
                                return PD_ERR;
                }
        }
*/
        return SUCCESS;
}
