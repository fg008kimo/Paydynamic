/*
Partnerdelight. (c)2010. All rights reserved. No part of this software may be reproduced in any form without written 
permission of an authorized representative of Partnerdelight


Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2010/08/13              Cody Chan
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sqlcpr.h>
#include <sys/types.h>
#include <time.h>

#include "common.h"
#include "utilitys.h"
#include "private_key.h"
#include "dbuser.h"
#include "dbutility.h"
#include "myrecordset.h"
#include "queue_utility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define MY_WEB_TOKEN            "&"
#define MY_WEB_FIELD_TOKEN      "="

char    cDebug;
int         	return_code;

int sql_error(char *msg);
int batch_init(int argc, char** argv);
int batch_proc(int argc, char** argv);
int batch_terminate(int argc, char** argv);
int is_non_holidays(const char* csCountry, const char* csDate);
char* mon_fmt_int2char(int iMon);

int main(int argc, char*argv[])
{

	ConnectDB();

	return_code=batch_init(argc, argv);
        if (return_code == FAILURE) {
DEBUGLOG(("main: section validation error\n"));
            	EXEC SQL ROLLBACK;
                return(FAILURE);
        }
    	else
        {
/* DEBUGLOG(("main: batch_init() success\n")); */
                return_code=batch_proc(argc, argv);
/* DEBUGLOG(("main: batch_proc return code [%d]\n",return_code));  */
                if (return_code != SUCCESS)
                {
                EXEC SQL ROLLBACK;
                        /*return(FAILURE); */
                        return(return_code);
                }
        }

        return_code=batch_terminate(argc, argv);
    /*    printf("main: batch_terminate return code [%d]\n", return_code); */

/* DEBUGLOG(("RET = [%d][%d]\n",return_code,SUCCESS)); */
        if (return_code != SUCCESS) {
            EXEC SQL ROLLBACK;
DEBUGLOG(("Rollback\n"));
	}
        else {
                EXEC SQL COMMIT WORK;
/* DEBUGLOG(("Commit\n")); */
	}
        return(SUCCESS);
}


int sql_error(char *msg)
{
        char err_msg[128];
        size_t buf_len, msg_len;

        printf("Oracle Error: return code [%d]\n", sqlca.sqlcode);

        EXEC SQL WHENEVER SQLERROR CONTINUE;

        printf("%s\n", msg);
        buf_len = sizeof (err_msg);
        sqlglm((unsigned char *)err_msg, &buf_len, &msg_len);
        printf("%.*s\n", (int)msg_len, err_msg);

        EXEC SQL ROLLBACK RELEASE;
DEBUGLOG(("Rollback\n"));
        return FAILURE;
}
int GetLastHostPostingDate(unsigned char* csLastPostingDate)
{
        EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar v_value[PD_VALUE_LEN + 1];

                short   ind_value = -1;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE c_cursor_getdate CURSOR FOR
                select sys_val
                  from system_control
                 Where sys_code = 'LTPHDATE';

        EXEC SQL OPEN c_cursor_getdate;
        do {
                EXEC SQL FETCH c_cursor_getdate
                INTO
                        :v_value:ind_value;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if (ind_value >= 0) {
                        v_value.arr[v_value.len] = '\0';
                        strcpy((char*)csLastPostingDate,(const char*)v_value.arr);
/* DEBUGLOG(("GetLastHostPostingDate:: lms_date = [%s]\n",csLastPostingDate)); */
                }
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getdate;

        return SUCCESS;
sql_error:
    DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getdate;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}



int GetCurrHostPostingDate(unsigned char* csCurrHostPostingDate)
{
        EXEC SQL WHENEVER SQLERROR GOTO getcurrlmsdate_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar v_value[PD_VALUE_LEN + 1];

                short   ind_value = -1;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE c_cursor_getcurrlmsdate CURSOR FOR
                select sys_val
                  from system_control
                 Where sys_code = 'CTPHDATE';

/*
        EXEC SQL DECLARE c_cursor_getcurrlmsdate CURSOR FOR
                select sys_val
                  from system_control
                 Where sys_code = 'CTPHDATE';
*/

        EXEC SQL OPEN c_cursor_getcurrlmsdate;
        do {
                EXEC SQL FETCH c_cursor_getcurrlmsdate
                INTO
                        :v_value:ind_value;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if (ind_value >= 0) {
                        v_value.arr[v_value.len] = '\0';
                        strcpy((char*)csCurrHostPostingDate,(const char*)v_value.arr);
                }
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getcurrlmsdate;

        return SUCCESS;
getcurrlmsdate_error:
    DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getcurrlmsdate;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}



int GetLastEODDate(unsigned char* csLastEODDate)
{
        EXEC SQL WHENEVER SQLERROR GOTO geteoddate_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar v_value[PD_VALUE_LEN + 1];

                short   ind_value = -1;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE c_cursor_geteoddate CURSOR FOR
                select sys_val
                  from system_control
                 Where sys_code = 'LTEODDATE';

        EXEC SQL OPEN c_cursor_geteoddate;
        do {
                EXEC SQL FETCH c_cursor_geteoddate
                INTO
                        :v_value:ind_value;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if (ind_value >= 0) {
                        v_value.arr[v_value.len] = '\0';
                        strcpy((char*)csLastEODDate,(const char*)v_value.arr);
                }
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_geteoddate;

        return SUCCESS;
geteoddate_error:
    DEBUGLOG(("geteoddate_error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_geteoddate;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}

int GetCurrEODDate(unsigned char* csCurrEODDate)
{
        EXEC SQL WHENEVER SQLERROR GOTO getcurreoddate_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar v_value[PD_VALUE_LEN + 1];

                short   ind_value = -1;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE c_cursor_getcurreoddate CURSOR FOR
                select sys_val
                  from system_control
                 Where sys_code = 'CTEODDATE';

        EXEC SQL OPEN c_cursor_getcurreoddate;
        do {
                EXEC SQL FETCH c_cursor_getcurreoddate
                INTO
                        :v_value:ind_value;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if (ind_value >= 0) {
                        v_value.arr[v_value.len] = '\0';
                        strcpy((char*)csCurrEODDate,(const char*)v_value.arr);
                }
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getcurreoddate;

        return SUCCESS;
getcurreoddate_error:
    DEBUGLOG(("getcurreoddate_error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getcurreoddate;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}


int CreateReportPath(unsigned char* csPspId,unsigned char* csCurrentPath)
{
	char    csHostDate[PD_DATE_LEN + 1];
	char    cs_outfile_name[PD_MAX_FILE_LEN + 1];

        if (GetCurrEODDate((unsigned char*)csHostDate) != SUCCESS)
                return FAILURE;

/* create report path */
        sprintf((char*)csCurrentPath, "%s", getenv("REPORT_HOME"));
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s", getenv("REPORT_HOME"),PD_YYYY_LEN,csHostDate);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s/%s", getenv("REPORT_HOME"),PD_YYYY_LEN,csHostDate,csPspId);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s/%s/%.*s", getenv("REPORT_HOME"),PD_YYYY_LEN,csHostDate,csPspId,PD_YYYYMM_LEN,csHostDate);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s/%s/%.*s/%s", getenv("REPORT_HOME"), PD_YYYY_LEN,csHostDate,csPspId,PD_YYYYMM_LEN,csHostDate,csHostDate);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);

        system(cs_outfile_name);

/* create report data folder if not created */
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", getenv("REPORT_DATA"));
       system(cs_outfile_name);

	return SUCCESS;
}


int CreateReportPathD(unsigned char* csCurrentPath)
{
	char    csHostDate[PD_DATE_LEN + 1];
	char    cs_outfile_name[PD_MAX_FILE_LEN + 1];

        if (GetCurrEODDate((unsigned char *)csHostDate) != SUCCESS)
                return FAILURE;

/* create report path */
        sprintf((char*)csCurrentPath, "%s", getenv("REPORT_HOME"));
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s", getenv("REPORT_HOME"),PD_YYYY_LEN,csHostDate);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s/%.*s", getenv("REPORT_HOME"),PD_YYYY_LEN,csHostDate,PD_YYYYMM_LEN,csHostDate);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s/%.*s/%s", getenv("REPORT_HOME"), PD_YYYY_LEN,csHostDate,PD_YYYYMM_LEN,csHostDate,csHostDate);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);

        system(cs_outfile_name);

/* create report data folder if not created */
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", getenv("REPORT_DATA"));
       system(cs_outfile_name);

	return SUCCESS;
}


int CreateReportPathCustomized(unsigned char* csCurrentPath,const char* csHostDate)
{
        char    cs_outfile_name[PD_MAX_FILE_LEN + 1];

/* create report path */
        sprintf((char*)csCurrentPath, "%s", getenv("REPORT_HOME"));
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s", getenv("REPORT_HOME"),PD_YYYY_LEN,csHostDate);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s/%.*s", getenv("REPORT_HOME"),PD_YYYY_LEN,csHostDate,PD_YYYYMM_LEN,csHostDate);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);
        system(cs_outfile_name);

        sprintf((char*)csCurrentPath, "%s/%.*s/%.*s/%s", getenv("REPORT_HOME"), PD_YYYY_LEN,csHostDate,PD_YYYYMM_LEN,csHostDate,csHostDate);
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", csCurrentPath);

        system(cs_outfile_name);

/* create report data folder if not created */
        sprintf((char*)cs_outfile_name, "mkdir %s >/dev/null 2>&1", getenv("REPORT_DATA"));
       system(cs_outfile_name);

        return SUCCESS;
}


int is_weekend(const char* csDate)
{
        int iRet = PD_FALSE;
        int iDow;

        iDow = day_of_week((const unsigned char *)csDate);
DEBUGLOG(("is_weekend: date[%s] day of week [%d]\n",csDate,iDow));
        if((iDow==0)||(iDow==6)){
                iRet = PD_TRUE;
        }

        return iRet;
}


int is_holidays(const char* csCountry, const char* csServiceCode, const char* csDate)
{
        int iRet = PD_FALSE;

        EXEC SQL WHENEVER SQLERROR GOTO is_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar hv_country[PD_COUNTRY_LEN];
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
                varchar hv_date[PD_DATE_LEN];

                varchar v_desc[PD_DESC_LEN + 1];

                short   ind_desc = -1;

        EXEC SQL END DECLARE SECTION;

        hv_date.len = strlen(csDate);
        memcpy(hv_date.arr,csDate,hv_date.len);
DEBUGLOG(("is_holidays date = [%.*s]\n",hv_date.len,hv_date.arr));

        hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("is_holidays country = [%.*s]\n",hv_country.len,hv_country.arr));

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("is_holidays service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

        EXEC SQL EXECUTE
        BEGIN
                select  h_desc
                into    :v_desc:ind_desc
                from    holiday
                where   h_date=:hv_date
                and     h_country=:hv_country
                and     h_service_code=:hv_service_code
		and	h_is_non_holiday = 0;

        END;
        END-EXEC;

        if(ind_desc>=0){
DEBUGLOG(("is holiday [%.*s]\n",v_desc.len,v_desc.arr));
                iRet = PD_TRUE;
        }
/*	if(is_weekend(csDate)==PD_TRUE){
		iRet = is_non_holidays(csCountry,csDate);
        }
*/
        return iRet;

is_error:
    DEBUGLOG(("is_holidays error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    ERRLOG("handle_daily_float::is_holidays error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}


int FindServiceReleasePeriod(const char* csServiceCode,
				const char* csReleaseType,	
				int* iReleasePeriod)
{

        int     iRet = SUCCESS;

DEBUGLOG(("FindServiceReleasePeriod\n"));
        EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
		varchar	hv_release_type[PD_RLS_TYPE_LEN];
                short   v_release_period;

                short   ind_release_period = -1;

        EXEC SQL END DECLARE SECTION;

	hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindServiceRelease service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_release_type.len = strlen(csReleaseType);
        memcpy(hv_release_type.arr,csReleaseType,hv_release_type.len);
DEBUGLOG(("FindServiceRelease release_type = [%.*s]\n",hv_release_type.len,hv_release_type.arr));

        EXEC SQL DECLARE c_cursor_get_service CURSOR FOR
                SELECT  rs_release_period
                  FROM  def_service_code,
                        rule_service_release_period
                 WHERE sc_code = rs_service_code
                   AND rs_disabled = 0
		   AND rs_service_code = :hv_service_code
                   AND rs_release_type = :hv_release_type;

        EXEC SQL OPEN c_cursor_get_service;
        do {
                EXEC SQL FETCH c_cursor_get_service
                INTO
                        v_release_period:ind_release_period;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if (ind_release_period >= 0) {
DEBUGLOG(("FindServiceReleasePeriod release period = [%d]\n",v_release_period));
			*iReleasePeriod = v_release_period;
                }
		else 
			*iReleasePeriod = 0;


        }while(PD_TRUE);
        EXEC SQL CLOSE c_cursor_get_service;

        return  iRet;

sql_error:
    DEBUGLOG(("FindServiceReleasePeriod error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    ERRLOG("batchcomm::FindServiceReleasePeriod sql error %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_get_service;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}

char* FindPostingDate(const char* csCountry,
			const char* csServiceCode,
			const char* csCurrentPostingDate,
				int iReleasePeriod)
{

	static	char	csDate[PD_DATE_LEN +1];

DEBUGLOG(("FindPostingDate\n"));
        EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_country[PD_COUNTRY_LEN];
		varchar hv_service_code[PD_SERVICE_CODE_LEN];
		varchar	hv_posting_date[PD_DATE_LEN];
                short   hv_release_period;

		varchar	v_posting_date[PD_DATE_LEN +1];

		short	ind_posting_date = -1;
        EXEC SQL END DECLARE SECTION;

	hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("FindPostingDate country = [%.*s]\n",hv_country.len,hv_country.arr));

	hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindPostingDate service_code = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

	hv_posting_date.len = strlen(csCurrentPostingDate);
        memcpy(hv_posting_date.arr,csCurrentPostingDate,hv_posting_date.len);
DEBUGLOG(("FindPostingDate CurrentPostingDate = [%.*s]\n",hv_posting_date.len,hv_posting_date.arr));

	hv_release_period = iReleasePeriod;
DEBUGLOG(("FindPostingDate release period = [%d]\n",hv_release_period));

        EXEC SQL EXECUTE
        BEGIN
                select  release_pkg.find_release_date(:hv_posting_date,:hv_country,:hv_service_code,:hv_release_period)
                into    :v_posting_date:ind_posting_date
                from    dual;

        END;
        END-EXEC;


	if (ind_posting_date >= 0) {
		v_posting_date.arr[v_posting_date.len] = '\0';
DEBUGLOG(("FindPostingDate posting_date = [%.*s]\n",v_posting_date.len,v_posting_date.arr));
		strcpy(csDate,(const char*)v_posting_date.arr);
	}
	else {
		csDate[0] ='\0';
	}
        return csDate;

sql_error:
    DEBUGLOG(("FindPostingDate error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    ERRLOG("batchcomm::FindServiceReleasePeriod sql error %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return NULL;
}


int is_non_holidays(const char* csCountry, const char* csDate)
{
        int iRet = PD_FALSE;

        EXEC SQL WHENEVER SQLERROR GOTO isn_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar hv_country[PD_COUNTRY_LEN];
                varchar hv_date[PD_DATE_LEN];

                varchar v_desc[PD_DESC_LEN + 1];

                short   ind_desc = -1;

        EXEC SQL END DECLARE SECTION;

        hv_date.len = strlen(csDate);
        memcpy(hv_date.arr,csDate,hv_date.len);
DEBUGLOG(("is_non_holidays date = [%.*s]\n",hv_date.len,hv_date.arr));

        hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("is_non_holidays country = [%.*s]\n",hv_country.len,hv_country.arr));

        EXEC SQL EXECUTE
        BEGIN
                select  h_desc
                into    :v_desc:ind_desc
                from    holiday
                where   h_date=:hv_date
                and     h_country=:hv_country
		and	h_is_non_holiday = 1;

        END;
        END-EXEC;

        if(ind_desc>=0){
DEBUGLOG(("Non-Holiday!! [%.*s]\n",v_desc.len,v_desc.arr));
        }
        else{
DEBUGLOG(("Holiday\n"));
                iRet = PD_TRUE;
        }

        return iRet;

isn_error:
    DEBUGLOG(("is_non_holidays error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("batchcommon::is_holidays error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}

char* FindVNCPostingDate(const char* csCountry,
                        const char* csCurrentPostingDate,
                                int iReleasePeriod)
{

        static  char    csDate[PD_DATE_LEN +1];

DEBUGLOG(("FindVNCPostingDate\n"));
        EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_country[PD_COUNTRY_LEN];
                varchar hv_posting_date[PD_DATE_LEN];
                short   hv_release_period;

                varchar v_posting_date[PD_DATE_LEN +1];

                short   ind_posting_date = -1;
        EXEC SQL END DECLARE SECTION;

        hv_country.len = strlen(csCountry);
        memcpy(hv_country.arr,csCountry,hv_country.len);
DEBUGLOG(("FindVNCPostingDate country = [%.*s]\n",hv_country.len,hv_country.arr));

        hv_posting_date.len = strlen(csCurrentPostingDate);
        memcpy(hv_posting_date.arr,csCurrentPostingDate,hv_posting_date.len);
DEBUGLOG(("FindVNCPostingDate CurrentPostingDate = [%.*s]\n",hv_posting_date.len,hv_posting_date.arr));

        hv_release_period = iReleasePeriod;
DEBUGLOG(("FindVNCPostingDate release period = [%d]\n",hv_release_period));

        EXEC SQL EXECUTE
        BEGIN
                select  release_pkg.find_vnc_release_date(:hv_posting_date,:hv_country,:hv_release_period)
                into    :v_posting_date:ind_posting_date
                from    dual;

        END;
        END-EXEC;


        if (ind_posting_date >= 0) {
                v_posting_date.arr[v_posting_date.len] = '\0';
DEBUGLOG(("FindVNCPostingDate posting_date = [%.*s]\n",v_posting_date.len,v_posting_date.arr));
                strcpy(csDate,(const char*)v_posting_date.arr);
        }
        else {
                csDate[0] ='\0';
        }
        return csDate;

sql_error:
    DEBUGLOG(("FindVNCPostingDate error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    ERRLOG("batchcomm::FindServiceReleasePeriod sql error %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return NULL;
}

