#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <curl/curl.h>
#include <string.h>
#include <unistd.h>




int	NP = 10;
int  counter = 0;
#define         RET_STRING      "[Succeed]"


#define DL      "&"
#define VL      "txn_url"
char    csResult[] ="process_type=0208&process_code=200002&status=0&txn_url=aHR0cHM6Ly9kZXYuNzI0MTY4Lm5ldC9mZS9jbG4vZy8/c2Vzc2lvbmlkPTU0NzZCQUNCRkQ0NUE0RDlBMTgxNEMxQTA2QjA1NTFF&mer_ref=303322013053111371369971475855048492&mer_id=K000000001&enctype=1&signature=66a472ffc491b832411aed51c25fb88f";

char* decode(char *inString)
{
        char csCmd[1024];

        sprintf(csCmd,"echo %s | base64 -d",inString);
        FILE *fp = popen(csCmd, "r");
        char *ln = NULL;
        size_t len = 0;

        char    *csResult;
        while (getline(&ln, &len, fp) != -1)
        csResult = (char*) malloc (len +1);
        strcpy(csResult,ln);

        free(ln);
        pclose(fp);
        return csResult;
}

char* decode_url(char* InString)
{
        char *p;
	char  *ptr = NULL;
        char *csReturn;
        char *result = NULL;
        result = strtok( csResult, DL );
        while( result != NULL ) {
                if ((p = strstr(result,VL)) != NULL) {
                        csReturn = (char*) malloc (strlen(p) +1);
                        memcpy(csReturn,&p[strlen(VL)] +1, strlen(p) - strlen(VL) - 1);
                        csReturn[strlen(p) - strlen(VL) - 1] = '\0';
			ptr = decode(csReturn);
                        break;
                }
                result = strtok( NULL, DL );
        }
	return ptr;
}
char* GetTxn(void)
{
        FILE *fp = popen("gentxn.sh 10000", "r");
        char *ln = NULL;
        size_t len = 0;

	char    *csResult;
        while (getline(&ln, &len, fp) != -1)
        //        fputs(ln, stdout);
	csResult = (char*) malloc (len +1);
	strcpy(csResult,ln);

        free(ln);
	pclose(fp);
	return csResult;
}

static int parse_arg(int argc,char **argv);

struct arg_struct {
    char url[512 +1];
    char message[2048 +1];
};

struct string
{
        char *ptr;
        size_t len;
};

void init_string(struct string *s)
{
        s->len = 0;
        s->ptr = malloc(s->len+1);
        if (s->ptr == NULL)
        {
                fprintf(stderr, "malloc() failed\n");
                exit(EXIT_FAILURE);
        }
        s->ptr[0] = '\0';
}

size_t writefunc(void *ptr, size_t size, size_t nmemb, struct string *s)
{
        size_t new_len = s->len + size*nmemb;
        s->ptr = realloc(s->ptr, new_len+1);
        if (s->ptr == NULL)
        {
                fprintf(stderr, "realloc() failed\n");
                exit(EXIT_FAILURE);
        }
        memcpy(s->ptr+s->len, ptr, size*nmemb);
        s->ptr[new_len] = '\0';
        s->len = new_len;

        return size*nmemb;
}
int main(int argc, char **argv)
{
        int     iRet = 0;
	int	n =0;
        char    *csBuf;

        CURL    *curl;

        curl = curl_easy_init();
	struct arg_struct args;
	strcpy(args.url,"https://dev.724168.net/fe/def/DSP.php");

	
        if (argc < 1) {
                fprintf(stderr, "Usage : stresstest -n # of txn\n");
                exit(1);
        }

	if (parse_arg(argc, argv) != 0) {
                exit(1);
        }



        if (curl) {

		struct string sBuffer;
                init_string(&sBuffer);
/* try to set */
                curl_easy_setopt(curl,CURLOPT_URL,args.url);
printf("url set to [%s]\n",args.url);
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc);
                curl_easy_setopt(curl, CURLOPT_WRITEDATA, &sBuffer);
#ifdef SKIP_PEER_VERIFICATION
    /*
     * If you want to connect to a site who isn't using a certificate that is
     * signed by one of the certs in the CA bundle you have, you can skip the
     * verification of the server's certificate. This makes the connection
     * A LOT LESS SECURE.
     *  
     * If you have a CA cert for the server stored someplace else than in the
     * default bundle, then the CURLOPT_CAPATH option might come handy for
     * you.     
     */ 
                curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);

#endif                  
                        
#ifdef SKIP_HOSTNAME_VERFICATION
    /*
     * If the site you're connecting to uses a different host name that what
     * they have mentioned in their server certificate's commonName (or
     * subjectAltName) fields, libcurl will refuse to connect. You can skip
     * this check, but this will make the connection less secure.
     */
                curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
#endif
/* set post data */
		for ( n = 1 ; n <= NP; n++) {
			char *p;
			char *pUrl;
			char *pArg;
			char csTmp[2048];
			char csUrl[2048];
                	init_string(&sBuffer);
			csBuf = GetTxn();
printf("txn [%d] try to send....\n",n);
//printf("csBuf = [%s]\n",csBuf);
                	curl_easy_setopt(curl,CURLOPT_URL,args.url);
                	curl_easy_setopt(curl,CURLOPT_POSTFIELDS,csBuf);
                	iRet = curl_easy_perform(curl);
printf("txn [%d] Send DATA  Result = [%d]\n", n,iRet);
                	if (iRet == 0) {
printf("txn [%d] Recv DATA  Result = [%s] len =[%d]\n", n,sBuffer.ptr,sBuffer.len);
			 	p = decode_url(sBuffer.ptr);
				if (p != NULL) {
				pUrl = strtok(p,"?");
				strcpy(csUrl,pUrl);
				strcat(csUrl,"?");
					if (pUrl != NULL) {
printf("p = [%s]\n",csUrl);
						pArg = strtok(NULL,"?");
						strcpy(csTmp,pArg);
						strcat(csTmp,"&");
						strcat(csTmp,"process_type=0200&process_code=200002&verno=1&Submit=Submit");
printf("out = [%s]\n",csTmp);
						iRet = SendStep2(csUrl,csTmp);
						if (iRet == 0) {
printf("step2 sent\n");
						}
						else {
printf("send submit bank error\n");
						}
					}
					else {
printf("url error!!!\n");
					}
				}else {
printf("decode url error\n");
				}
                	}
			else {
printf("txn [%d] Recv DATA  error!!!\n",n);
			}
			free(csBuf);
			free(sBuffer.ptr);
		}
                curl_easy_cleanup(curl);
        }
	return 0;

}



static int parse_arg(int argc,char **argv)
{               
        unsigned char   c;
        int             i;
                        
        while ((i = getopt(argc,argv,"n:")) != EOF && c != 0xff) {
                c = i;
                switch (c) {
                        case 'n':
				NP = atoi(optarg);
                                break;
                        default:
                                return 1;
                }
        }
        
        return 0;
}       

int SendStep2(char* csUrl, char* csArg)
{
        int     iRet = 0;
	int	n =0;

        CURL    *curl;
        curl = curl_easy_init();

        if (curl) {

		struct string sBuffer;
                init_string(&sBuffer);
/* try to set */
                curl_easy_setopt(curl,CURLOPT_URL,csUrl);
printf("url set to [%s]\n",csUrl);
               	curl_easy_setopt(curl,CURLOPT_POSTFIELDS,csArg);
printf("postfileds set to [%s]\n",csArg);
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc);
                curl_easy_setopt(curl, CURLOPT_WRITEDATA, &sBuffer);
#ifdef SKIP_PEER_VERIFICATION
    /*
     * If you want to connect to a site who isn't using a certificate that is
     * signed by one of the certs in the CA bundle you have, you can skip the
     * verification of the server's certificate. This makes the connection
     * A LOT LESS SECURE.
     *  
     * If you have a CA cert for the server stored someplace else than in the
     * default bundle, then the CURLOPT_CAPATH option might come handy for
     * you.     
     */ 
                curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);

#endif                  
                        
#ifdef SKIP_HOSTNAME_VERFICATION
    /*
     * If the site you're connecting to uses a different host name that what
     * they have mentioned in their server certificate's commonName (or
     * subjectAltName) fields, libcurl will refuse to connect. You can skip
     * this check, but this will make the connection less secure.
     */
                curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
#endif
/* set post data */
printf("txn [%d] try to send....\n",n);
               	iRet = curl_easy_perform(curl);
printf("txn [%d] Send DATA  Result = [%d]\n", n,iRet);
               	if (iRet == 0) {
printf("txn [%d] Recv DATA  Result = [%s] len =[%d]\n", n,sBuffer.ptr,(int)sBuffer.len);
		}
		else {
printf("send step 2 error\n");
		}
                curl_easy_cleanup(curl);
        }
	return 0;

}

