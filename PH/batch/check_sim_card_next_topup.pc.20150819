/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/09/12              Dirk Wong 
Modify to send alert within 14 Days		   2015/02/05		   Dirk Wong
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"
#include "internal.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

int iTplType=0;
char csTag[PD_TAG_LEN+1];
char csTmp[PD_TMP_BUF_LEN+1];
char cDebug;

int iDynCnt=0;

OBJPTR(BO);

int parse_arg(int argc,char **argv);

int batch_init(int argc, char* argv[])
{
        return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	int     iRet = parse_arg(argc,argv);
	int	iChk = 0;

	hash_t *hContext;

	if (iRet != SUCCESS) {
		iTplType = 0;
	}

	hContext = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hContext,0);

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar v_alert_date[PD_DATE_LEN+1];
		short	ind_alert_date = -1;

		varchar	v_mobile[PD_CUSTOMER_TEL_LEN+1];
		varchar	v_carriers[PD_DESC_LEN+1];
		varchar	v_country[PD_DESC_LEN+1];
		varchar v_last_topup_date[PD_DATE_LEN+1];
		varchar	v_next_topup_date[PD_DATE_LEN+1];

		short	ind_mobile = -1;
		short	ind_carriers = -1;
		short	ind_country = -1;
		short	ind_last_topup_date = -1;
		short	ind_next_topup_date = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE c_cursor_getalertdate CURSOR FOR
		SELECT	TO_CHAR(TRUNC(SYSDATE)+14,'YYYYMMDD')
		FROM	DUAL;

	EXEC SQL OPEN c_cursor_getalertdate;
	do {
		EXEC SQL FETCH c_cursor_getalertdate
		INTO
			:v_alert_date:ind_alert_date;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
	}
	while(PD_TRUE);
	EXEC SQL CLOSE c_cursor_getalertdate;

	EXEC SQL DECLARE c_cursor_getmobilelist CURSOR FOR
		SELECT  A.OSC_MOBILE,
			B.DSC_CARRIER_NAME,
			C.COUNTRY_NAME,
			A.OSC_LAST_TOPUP_DATE,
			A.OSC_NEXT_TOPUP_DATE
		FROM    OL_SIM_CARDS A,
			OL_DEF_SIM_CARRIERS B,
			COUNTRY C 
		WHERE   A.OSC_CARRIERS = B.DSC_CARRIER_CODE
		AND     A.OSC_COUNTRY = C.COUNTRY_CODE
		AND     A.OSC_NEXT_TOPUP_DATE <= :v_alert_date
		AND	A.OSC_STATUS != 'D'
		ORDER BY A.OSC_LAST_TOPUP_DATE;	

	EXEC SQL OPEN c_cursor_getmobilelist;
	do {
		EXEC SQL FETCH c_cursor_getmobilelist
		INTO
			:v_mobile:ind_mobile,
			:v_carriers:ind_carriers,
			:v_country:ind_country,
			:v_last_topup_date:ind_last_topup_date,
			:v_next_topup_date:ind_next_topup_date;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		/*fmobile*/
			sprintf(csTag,"fmobile-%d",iChk);
			sprintf(csTmp,"%.*s",v_mobile.len,v_mobile.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
		/*fcarriers*/
			sprintf(csTag,"fcarriers-%d",iChk);
			sprintf(csTmp,"%.*s",v_carriers.len,v_carriers.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
		/*fcountry*/
			sprintf(csTag,"fcountry-%d",iChk);
			sprintf(csTmp,"%.*s",v_country.len,v_country.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
		/*flast_topup_date*/
			sprintf(csTag,"flast_topup_date-%d",iChk);
			sprintf(csTmp,"%.*s",v_last_topup_date.len,v_last_topup_date.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
		/*fnext_topup_date*/
			sprintf(csTag,"fnext_topup_date-%d",iChk);
			sprintf(csTmp,"%.*s",v_next_topup_date.len,v_next_topup_date.arr);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);

		iChk ++;
	}
	while(PD_TRUE && iRet == SUCCESS);
	EXEC SQL CLOSE c_cursor_getmobilelist;

/*stimestamp*/
	iDynCnt = set_tpl_dyn_int(hContext,iDynCnt,"stimestamp-0","SEC","stimestamp-0",0);
/*ftimestamp*/
	iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,"ftimestamp-0","STR","stimestamp-0",write_tpl_timestamp());

/*stitle*/
	iDynCnt = set_tpl_dyn_int(hContext,iDynCnt,"stitle-0","SEC","stitle-0",0);
/*ftitle*/
	sprintf(csTmp, "Sim Cards Topup Next hit on %.*s",v_alert_date.len,v_alert_date.arr);
	iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,"ftitle-0","STR","stitle-0",csTmp);

	if (iChk == 0)
	{
		//Print no record
		iDynCnt = set_tpl_dyn_int(hContext, iDynCnt, "stbl_norecord-0", "SEC", "stbl_norecord-0", 0);
		sprintf(csTmp,"%.*s",v_alert_date.len,v_alert_date.arr);
		iDynCnt = set_tpl_dyn_cstring(hContext, iDynCnt, "fnext_topup_date-0", "STR", "stbl_norecord-0", csTmp);
	}
	else
	{
		iDynCnt = set_tpl_dyn_int(hContext, iDynCnt, "stbl_head-0", "SEC", "stbl_head-0", 0);
		iDynCnt = set_tpl_dyn_int(hContext, iDynCnt, "stbl_body-0", "SEC", "stbl_body-0", iChk);
	}

	iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,"subject","GLO","STR","Sim Cards Top-up Next Two Weeks");

	PutField_CString(hContext,"source","BATCH");
	PutField_CString(hContext,"funct","SIM_CARD_REPORT");
	PutField_Char(hContext,"party_type",'G');
	PutField_CString(hContext,"party_id","000");

	PutField_Int(hContext,"total_dyn",iDynCnt);

	BOObjPtr = CreateObj(BOPtr,"BOAlertEmail","ProcessTpl");
	if((unsigned long)((*BOObjPtr)(hContext) != PD_OK)){
		iRet=INT_CODE_ERROR;
		PutField_Int(hContext,"internal_error",iRet);
DEBUGLOG(("Authorize::ProcessTpl Failed\n"));
ERRLOG("TxnMgtByUsALT::Authorize::ProcessTpl Failed, iRet=%d\n", iRet);
	}
	else
	{
DEBUGLOG(("Authorize::ProcessTpl Success\n"));
	}

	FREE_ME(hContext);

	return iRet;

sql_error:
DEBUGLOG(("check_sim_card_next_topup error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getalertdate;
    EXEC SQL CLOSE c_cursor_getmobilelist;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int batch_terminate(int argc, char* argv[])
{
        return SUCCESS;
}


int parse_arg(int argc,char **argv)
{
/*
        char    c;

        if (argc < 2) {
                return PD_ERR;
        }
        while ((c = getopt(argc,argv,"t:")) != EOF) {
                switch (c) {
                        case 't':
                                iTplType = atoi(optarg);
                                break;
                        default:
                                return PD_ERR;
                }
        }
*/
        return SUCCESS;
}
