/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/09/11              Stan Poon
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "batchcommon.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char	cs_current_ph_date[PD_DATE_LEN + 1];
char	cs_last_ph_date[PD_DATE_LEN + 1];
char	cDebug = 'Y';

int	parse_arg(int argc,char **argv);
int	is_first_day_of_week(const char* csDate);
int	is_first_day_of_month(const char* csDate);
//int	reset_stat(char* csDate, char cType);
int	remove_stat(char cType);
int	update_stat(char* csDate, char cType);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	int iRet = SUCCESS;

	iRet = parse_arg(argc,argv);
	if(iRet != SUCCESS){
		printf("usage: -l last_ph_date -c current_ph_date\n");
		return (iRet);
	}

	if(iRet == SUCCESS){
		if (is_first_day_of_week(cs_current_ph_date) == PD_TRUE) {
			//iRet = reset_stat(cs_last_ph_date, PD_WEEKLY);
			iRet = remove_stat(PD_WEEKLY);
		} else {
			iRet = update_stat(cs_last_ph_date, PD_WEEKLY);
		}
	}

	if(iRet == SUCCESS){
		if (is_first_day_of_month(cs_current_ph_date) == PD_TRUE) {
			//iRet = reset_stat(cs_last_ph_date, PD_MONTHLY);
			iRet = remove_stat(PD_MONTHLY);
		} else {
			iRet = update_stat(cs_last_ph_date, PD_MONTHLY);
		}
	}


	return iRet;
}


int is_first_day_of_week(const char* csDate)
{
	int iRet = PD_FALSE;
	int i=0;
	
	i=day_of_week((const unsigned char *)csDate);
	if(i==1){
		iRet = PD_TRUE;
DEBUGLOG(("is_first_day_of_week = TRUE\n"));
	}
	else if(i==PD_ERR){
DEBUGLOG(("is_first_day_of_week invalid date[%s]\n", csDate));
	}
	else{
DEBUGLOG(("is_first_day_of_week = FALSE\n"));
	}
	
	return iRet;
}


int is_first_day_of_month(const char* csDate)
{
	int iRet = PD_FALSE;

	if(strncmp(&csDate[PD_YYYYMM_LEN],"01",PD_DD_LEN)==0){
		iRet = PD_TRUE;
DEBUGLOG(("is_first_day_of_month = TRUE\n"));
	}
	else{
DEBUGLOG(("is_first_day_of_month = FALSE\n"));
	}

	return iRet;
}


int parse_arg(int argc,char **argv)
{
	char	c;
	strcpy(cs_last_ph_date,"");
	strcpy(cs_current_ph_date,"");

	while ((c = getopt(argc,argv,"l:c:")) != EOF) {
		switch (c) {
			case 'l':
				strcpy(cs_last_ph_date, optarg);
				break;
			case 'c':
				strcpy(cs_current_ph_date, optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (!strcmp(cs_last_ph_date,"") || !strcmp(cs_current_ph_date,""))
		return FAILURE;

	return SUCCESS;
}


/*
int reset_stat(char* csDate, char cType)
{
	EXEC SQL WHENEVER SQLERROR GOTO reset_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_date[PD_DATE_LEN];
		char	hv_type;

		short	hv_return_value;

	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("reset_stat: Begin\n"));

	hv_date.len = strlen(csDate);
	strncpy((char*)hv_date.arr, csDate, hv_date.len);

	hv_type = cType;

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_txn_counters_reset(:hv_date,
								:hv_type);
		END;
	END-EXEC;

DEBUGLOG(("reset_stat:Ret = [%d]\n",hv_return_value));

	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("reset_stat:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
		ERRLOG("reset_stat_non_daily:reset_stat SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("reset_stat: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
		ERRLOG("reset_stat_non_daily:reset_stat SP_ERR TxnAbort\n");
		DEBUGLOG(("reset_stat: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

reset_error:
DEBUGLOG(("reset_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("reset_stat_non_daily:reset_stat SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;


}
*/

int remove_stat(char cType)
{
	EXEC SQL WHENEVER SQLERROR GOTO reset_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		char	hv_type;

	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("remove_stat: Begin\n"));

	hv_type = cType;

	EXEC SQL	DELETE FROM TXN_COUNTERS
			WHERE tc_type = :hv_type;

	return PD_OK;

reset_error:
DEBUGLOG(("reset_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("reset_stat_non_daily:remove_stat SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;


}


int update_stat(char* csDate, char cType)
{
	EXEC SQL WHENEVER SQLERROR GOTO update_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_date[PD_DATE_LEN];
		char	hv_type;

		short	hv_return_value;

	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("update_stat: Begin\n"));

	hv_date.len = strlen(csDate);
	strncpy((char*)hv_date.arr, csDate, hv_date.len);

	hv_type = cType;

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_txn_counters_update(:hv_date,
									:hv_type);
		END;
	END-EXEC;

DEBUGLOG(("update_stat:Ret = [%d]\n",hv_return_value));

	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("update_stat:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
		ERRLOG("reset_stat_non_daily:update_stat SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("update_stat: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
		ERRLOG("reset_stat_non_daily:update_stat SP_ERR TxnAbort\n");
		DEBUGLOG(("update_stat: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("reset_stat_non_daily:update_stat SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}

