/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2010/10/21              Cody Chan
add record                                         2011/05/03              LokMan Chow
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <ctype.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "batchcommon.h"
#include "internal.h"
#include "match_twv_dsp2.h"
//#include "DepositMismatch.h"
#include "ObjPtr.h"


/*******************************************
        usage: -h host file -p psp host
******************************************/

#define  MAX_FIELD_LEN		20 
#define  MAX_FIELD_NO          	8
#define PD_TR           "<tr>"
#define PD_TD           "<td>"
#define PD_TD_STYLE     "<td class=\"format\">"
#define PD_TR_END       "</tr>"
#define PD_TD_END       "</td>"

char    cs_ph_file[PD_MAX_FILE_LEN + 1];
char    cs_psp_file[PD_MAX_FILE_LEN + 1];
char    cs_psp_id[PD_PSP_ID_LEN + 1];

char   	csPhList[MAX_FIELD_NO][MAX_FIELD_LEN+1];
char    csPspList[MAX_FIELD_NO][MAX_FIELD_LEN+1];

char    cDebug;

OBJPTR(DB);

static int parse_arg(int argc,char **argv);
void extract(char* log, char data[][MAX_FIELD_LEN+1]);
void output(char csPhList[][MAX_FIELD_LEN + 1], char csPspList[][MAX_FIELD_LEN + 1],char* remark);
void match(char* cs_ph_buf, char* cs_psp_buf);
int record(char csList[][MAX_FIELD_LEN + 1],char* remark);

int batch_init(int argc, char* argv[])
{

    if (argc < 2) {
        printf("usage:  -h host_file -p psp_file -i psp_id\n");
        return FAILURE;
    }
    else
        return SUCCESS;
}

int batch_terminate(int argc, char* argv[])
{
        return SUCCESS;
}

//int main(int argc, char* argv[])
int batch_proc(int argc, char* argv[])
{
	FILE	*fp_ph,*fp_psp;
	int     i_read_next = PD_TRUE;
	char    cs_h_key[256], cs_p_key[256];
	char    cs_ph_buf[PD_MAX_BUFFER + 1];
        char    cs_psp_buf[PD_MAX_BUFFER + 1];
        int 	i_ret;
	int	iRet;
	
	iRet = parse_arg(argc,argv);
        if (iRet != SUCCESS) {
                printf("usage:  -h host_file -p psp_file -i psp_id\n");
                return (iRet);
        }
	fp_ph = fopen(cs_ph_file, "r");
    	if (fp_ph == NULL){
		printf("unable to open lms file %s\n",cs_ph_file);
		return FAILURE;
    	}

    	fp_psp = fopen(cs_psp_file, "r");
    	if (fp_psp == NULL){
		printf("unable to open cul file %s\n",cs_psp_file);
		return FAILURE;
    	}

	printf("<html><body><table>\n");
	printf("%s%sTID%s%sTxn Date%s%sStatus%s%sPH Txn ID%s%sPayment Mode%s%sTxn Amount%s%sFund In Date%s%sService Fee%s%sResult%s%s\n",PD_TR,PD_TD,PD_TD_END,PD_TD,PD_TD_END,PD_TD,PD_TD_END,PD_TD,PD_TD_END,PD_TD,PD_TD_END,PD_TD,PD_TD_END,PD_TD,PD_TD_END,PD_TD,PD_TD_END,PD_TD,PD_TD_END,PD_TR_END);
	printf("<style type=\"text/css\"> .format{ mso-number-format:'\\@';} </style>\n");

	while (fgets(cs_psp_buf, PD_MAX_BUF, fp_psp) != NULL) {
		if (cs_psp_buf[strlen(cs_psp_buf) - 1] == 0x0A)
                	cs_psp_buf[strlen(cs_psp_buf) - 1] = '\0';
        	if (i_read_next == PD_FALSE || fgets(cs_ph_buf, PD_MAX_BUF, fp_ph) != NULL) {
			if (cs_ph_buf[strlen(cs_ph_buf) - 1] == 0x0A)
                		cs_ph_buf[strlen(cs_ph_buf) - 1] = '\0';
			
                	while (PD_TRUE) {
                     		extract(cs_ph_buf,csPhList); 
                        	extract(cs_psp_buf, csPspList);

				memcpy(cs_h_key, csPhList[IDX_TID],PD_TID_LEN);
				memcpy(cs_p_key, csPspList[IDX_TID],PD_TID_LEN);
				memcpy(&cs_h_key[PD_TID_LEN], csPhList[IDX_TXN_SEQ],PD_TXN_SEQ_LEN);
				memcpy(&cs_p_key[PD_TID_LEN], csPspList[IDX_TXN_SEQ],PD_TXN_SEQ_LEN);
				
				i_ret = memcmp(cs_h_key, cs_p_key, PD_TID_LEN + PD_TXN_SEQ_LEN);
                       		if (i_ret == 0) {
          				match(cs_ph_buf, cs_psp_buf); 
                      			i_read_next = PD_TRUE;
                                	break;
               			}
                        	else if (i_ret < 0) {
                       			extract(cs_ph_buf,csPhList);
					if(record(csPhList,"PSP")!=PD_TRUE){
              					output(csPhList,NULL,(char*)"No Psp Tx"); 
					}
                    			if (fgets(cs_ph_buf, PD_MAX_BUF, fp_ph) == NULL) {
						if (cs_ph_buf[strlen(cs_ph_buf) - 1] == 0x0A)
                					cs_ph_buf[strlen(cs_ph_buf) - 1] = '\0';
                              			extract(cs_psp_buf, csPspList);
						if(record(csPspList,"PH")!=PD_TRUE){
                           				output(NULL, csPspList,(char*)"No Ph Tx");
						}
                                        	break;
                                	}
					if (cs_ph_buf[strlen(cs_ph_buf) - 1] == 0x0A)
                                		cs_ph_buf[strlen(cs_ph_buf) - 1] = '\0';
                                	i_read_next = PD_TRUE;
                   		}
                        	else if (i_ret > 0) {
                   			extract(cs_psp_buf, csPspList);
					if(record(csPspList,"PH")!=PD_TRUE){
                    				output(NULL,csPspList,(char*)"No Ph Tx"); 
					}
                                	i_read_next = PD_FALSE;
                                	break;
                      		}
			}
    		}
		else if(i_read_next == PD_TRUE && fgets(cs_ph_buf, PD_MAX_BUF, fp_ph) == NULL){
                        extract(cs_psp_buf, csPspList);
			if(record(csPspList,"PH")!=PD_TRUE){
                        	output(NULL,csPspList,(char*)"No Ph Tx");
			}
                        i_read_next = PD_TRUE;
                }
	}

	if(i_read_next == PD_FALSE){
		if(record(csPhList,"PSP")!=PD_TRUE){
			output(csPhList,NULL,(char*)"NO Psp Tx");
		}
        }    

	while(fgets(cs_ph_buf, PD_MAX_BUF, fp_ph) != NULL){
                if (cs_ph_buf[strlen(cs_ph_buf) - 1] == 0x0A) 
                        cs_ph_buf[strlen(cs_ph_buf) - 1] = '\0';

                extract(cs_ph_buf,csPhList);
		if(record(csPhList,"PSP")!=PD_TRUE){
                	output(csPhList,NULL,(char*)"No Psp Tx");
		}
        }


	printf("</table></body></html>\n");
    	fclose(fp_psp);
    	fclose(fp_ph);
	return SUCCESS;
}



static int parse_arg(int argc,char **argv)
{
        char    c;
        strcpy(cs_ph_file,"");
        strcpy(cs_psp_file,"");
        strcpy(cs_psp_id,"");

        //while ((c = getopt(argc,argv,"h:p:")) != EOF && c != 0xff) {
        while ((c = getopt(argc,argv,"h:p:i:")) != EOF) {
                switch (c) {
                        case 'h':
                                strcpy(cs_ph_file, optarg);
                                break;
                        case 'p':
                                strcpy(cs_psp_file, optarg);
                                break;
                        case 'i':
                                strcpy(cs_psp_id, optarg);
                                break;
                        default:
                                return FAILURE;
                }
        }

        if (!strcmp(cs_ph_file,"") || !strcmp(cs_psp_file,"") || !strcmp(cs_psp_id,""))
                return FAILURE;

        return SUCCESS;
}

void extract(char* log, char data[][MAX_FIELD_LEN+1])
{       
        char    *p; 
	char*	csTmp;
        int 	i = 0;

	csTmp = (char*) malloc (strlen(log) + 1);
	strcpy(csTmp,log);
	for (i = 0; i < MAX_FIELD_NO; i++) {
                if (i == 0)
                        p = mystrtok(csTmp, (char*)PD_MATCH_TOKEN);
                else
                        p = mystrtok(NULL, (char*)PD_MATCH_TOKEN);
                strcpy(data[i], p);
        }
	free(csTmp);
}     

void output(char csPhList[][MAX_FIELD_LEN + 1], char csPspList[][MAX_FIELD_LEN + 1],char* remark)
{
	int	i;
	double	dTmp;

	printf("%s",PD_TR);

	if (csPspList == NULL ) {
		for (i = 0 ; i < MAX_FIELD_NO; i++) {
			if ((i == IDX_TID) || (i==IDX_TXN_SEQ)) 
				printf("%s%s%s",PD_TD_STYLE,csPhList[i],PD_TD_END);
			else if (i == IDX_TXN_AMOUNT) {
				dTmp = atof(csPhList[i]);
				printf("%s%.2f%s",PD_TD,dTmp,PD_TD_END);
			}
			else
				printf("%s%s%s",PD_TD,csPhList[i],PD_TD_END);
		}
		printf("%s%s%s\n",PD_TD,remark,PD_TD_END);
	}
	else if (csPhList == NULL ) {
		for (i = 0 ; i < MAX_FIELD_NO; i++) {
			if ((i == IDX_TID) || (i==IDX_TXN_SEQ)) 
				printf("%s%s%s",PD_TD_STYLE,csPspList[i],PD_TD_END);
			else if (i == IDX_TXN_AMOUNT) {
				dTmp = atof(csPspList[i]);
				printf("%s%.2f%s",PD_TD,dTmp,PD_TD_END);
			}
			else
				printf("%s%s%s",PD_TD,csPspList[i],PD_TD_END);
		}
		printf("%s%s%s\n",PD_TD,remark,PD_TD_END);
	}
	else {
		for (i = 0 ; i < MAX_FIELD_NO; i++) {
                        if ((i == IDX_TID) || (i==IDX_TXN_SEQ)) {
				if (strcmp(csPspList[i],csPhList[i]))
                                	printf("%s*%s%s",PD_TD_STYLE,csPhList[i],PD_TD_END);
				else
                                	printf("%s%s%s",PD_TD_STYLE,csPhList[i],PD_TD_END);
	
			}
                        else {
				if (strcmp(csPspList[i],csPhList[i])) {
					if (i == IDX_TXN_AMOUNT) {
						dTmp = atof(csPhList[i]);
						printf("%s*%.2f%s",PD_TD,dTmp,PD_TD_END);
					}
					else 
                                		printf("%s*%s%s",PD_TD,csPhList[i],PD_TD_END);
				}
				else {
					if (i == IDX_TXN_AMOUNT) {
						dTmp = atof(csPhList[i]);
						printf("%s%.2f%s",PD_TD,dTmp,PD_TD_END);
					}
					else 
                               			printf("%s%s%s",PD_TD,csPhList[i],PD_TD_END);
				}
			}
                }
                printf("%s%s%s\n",PD_TD,remark,PD_TD_END);
	}

	printf("%s\n",PD_TR_END);
}
void match(char* cs_ph_buf, char* cs_psp_buf)
{
        int i, i_match = PD_TRUE;

        extract(cs_ph_buf, csPhList);
        extract(cs_psp_buf, csPspList);

        for (i = 0; i < MAX_FIELD_NO; i++) {
        	if (strcmp(csPhList[i], csPspList[i]) != 0) {
			i_match = PD_FALSE;
		}
        }
        if (i_match == PD_FALSE) {
                output(csPhList, csPspList, (char*)"Tx Mismatched");
        }
}


int record(char csList[][MAX_FIELD_LEN + 1],char* remark)
{
        int iRet = PD_FALSE;
        char *csAbs= strdup("");

        DBObjPtr = CreateObj(DBPtr,"DBDepositMismatch","GetDspMismatch");
        if((unsigned long)(DBObjPtr)(csList[IDX_TXN_SEQ],PD_TYPE_PSP,csAbs)!=PD_FOUND){
	//if((unsigned long)GetDspMismatch(csList[IDX_TXN_SEQ],PD_TYPE_PSP,csAbs)!=PD_FOUND){

DEBUGLOG(("record: DBDepositMismatch->GetDspMismatch[%s] Not found\n",csList[IDX_TXN_SEQ]));
                DBObjPtr = CreateObj(DBPtr,"DBDepositMismatch","Add");
		if((unsigned long)(DBObjPtr)(csList[IDX_TXN_SEQ],
                                                PD_TYPE_PSP,
                                                cs_psp_id,
                                                csList[IDX_TID],
                                                csList[IDX_TXN_DATE],remark)==PD_OK){
DEBUGLOG(("record: DBDepositMismatch->Add[%s] Success\n",csList[IDX_TXN_SEQ]));
                }
                else{
DEBUGLOG(("record: DBDepositMismatch->Add[%s] Failed\n",csList[IDX_TXN_SEQ]));
                }
        }
        else{
                if(strcmp(csAbs,remark)){
DEBUGLOG(("record: DBDepositMismatch->GetDspMismatch[%s] Success\n",csList[IDX_TXN_SEQ]));
                        iRet = PD_TRUE;

                        DBObjPtr = CreateObj(DBPtr,"DBDepositMismatch","MarkDeleted");
                        if((unsigned long)(DBObjPtr)(csList[IDX_TXN_SEQ],PD_TYPE_PSP,csList[IDX_TXN_DATE])==PD_OK){
			//if((unsigned long)MarkDeleted((const unsigned char *)csList[IDX_TXN_SEQ],PD_TYPE_PSP,(const unsigned char *)csList[IDX_TXN_DATE])==PD_OK){
DEBUGLOG(("record: DBDepositMismatch->MarkDeleted[%s] Success\n",csList[IDX_TXN_SEQ]));
                        }
                        else{
DEBUGLOG(("record: DBDepositMismatch->MarkDeleted[%s] Failed\n",csList[IDX_TXN_SEQ]));
                        }
                }
        }

        FREE_ME(csAbs);
        return iRet;
}
