/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/21	             Simon Fung
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "eod_offsys_glpost.h"
#include "mymd5.h"
#include "eod_glutility.h"
#include "ObjPtr.h"

OBJPTR(BO);
OBJPTR(DB);

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define	PD_MY_DELIMITOR	","
#define	PD_FILE_DELIMITOR "	"
#define	PD_HASHKEY_DELIMITOR ":"

#define	PD_CHAR		0x0D
#define	PD_SPACE	0x20

char    cDebug = 'Y';
char    cs_inputfile[PD_MAX_FILE_LEN + 1];
char    cs_date[PD_DATE_LEN + 1];

short is_float(char* str);
int parse_arg(int argc,char **argv);
int verify_file(FILE *fin);
int process_file(FILE *fin);
int myGroupRecs(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], hash_t *hTxn, char* csKey, double dAmt, int* iJnlKeyCnt);
int myPostTxn(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], const hash_t *hTxn, const int iJnlKeyCnt);

//int process_txn();

short is_float(char* str)
{
	int i_len = strlen(str);
	int i;
	
	for (i = 0; i < i_len; i++)
		if ((!isdigit(str[i])) && (str[i]!='.'))
			return PD_FALSE;
	
	return PD_TRUE;
}

int batch_init(int argc, char* argv[])
{
	if (argc < 1) {
		printf("usage: -d Date\n");
	    return FAILURE;
	}
	else
	    return SUCCESS;
}



int batch_proc(int argc, char* argv[])
{
	FILE	*fin;
	int	iRet;
  //char cs_infile_name[PD_MAX_FILE_LEN + 1];

	
	iRet = parse_arg(argc,argv);

	if (iRet != SUCCESS) {
    		printf("*usage: -d Date\n");
		return (iRet);
	}
	
	DEBUGLOG(("File Path = [%s]\n", getenv("REPORT_DATA")));
	DEBUGLOG(("File directory = [%s]\n", OFFLINE_DATA_FOLDER));
	DEBUGLOG(("File Prefix = [%s]\n", OFFLINE_DATA_FILE_PREFIX));
	DEBUGLOG(("File Date = [%s]\n",cs_date));
	
	sprintf(cs_inputfile, "%s/%s/%s_%s.csv", getenv("REPORT_DATA"), OFFLINE_DATA_FOLDER, OFFLINE_DATA_FILE_PREFIX, cs_date);

	fin = fopen(cs_inputfile,"r");
	if (fin == NULL) {
		DEBUGLOG(("Error Opening file = [%s]\n",cs_inputfile));
		return FAILURE;
	}

	DEBUGLOG(("Opened file = [%s] for read\n",cs_inputfile));

	iRet = verify_file(fin);
	DEBUGLOG(("verify_file result = [%d]\n",iRet));	
	
	
	//iRet = SUCCESS;
	
	if (iRet == SUCCESS) {
		rewind(fin);
		iRet = process_file(fin);
	}

	fclose(fin);

	return iRet;

}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}
                     
int parse_arg(int argc,char **argv)
{               
	char    c;
	strcpy(cs_inputfile,"");
	          
	while ((c = getopt(argc,argv,"d:")) != EOF) {
	  switch (c) {
      case 'd':
              strcpy(cs_date, optarg);
              break;
      default:
              return FAILURE;
	  }
	}       
	
	DEBUGLOG(("[%s]\n",cs_date));
	if (!strcmp(cs_date,""))
	  return FAILURE;
	  
	return SUCCESS; 
}               

int verify_file(FILE *fin)
{
	int iRet = FAILURE;
	int iLineCnt = 0;
	int	iCount = 0;
	int iMerchKeyCnt;
	int iPSPKeyCnt;
	char    csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
	char    cs_input_buf[PD_MAX_BUFFER +1];;
	char	*p=NULL;
	char csKey[PD_TMP_MSG_BUF_LEN];
	
	char *csSign;
	csSign = (char*) malloc (1024 * 2 +1);
	char *csOUT;
	csOUT = (char*) malloc (1024 * 2 +1);

	char csCalSign[OFFLINE_CHECKSUM_LEN+1];
	
  iMerchKeyCnt = 0;
  iPSPKeyCnt = 0;
  
  fgets(cs_input_buf,PD_MAX_BUFFER,fin);
  if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A || cs_input_buf[strlen(cs_input_buf) - 1] == 0x10)
         cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
	strcpy(cs_input_buf,TrimAllChar((const unsigned char *)cs_input_buf,strlen(cs_input_buf),PD_CHAR));

	DEBUGLOG(("%s\n",cs_input_buf));
	
	iCount = 0;
	
	// Breakdown header line
  p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
  if (p == NULL) {
		DEBUGLOG(("Invalid File Header"));
		return FAILURE;
	}
  strcpy(csList[iCount],p);
  iCount++;

  while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
    strcpy(csList[iCount],p);
    iCount++;
  }               

	if (iCount == HEADER_ITEM_SIZE) {

		// Build Key
		strcpy(csKey, csList[IDX_HD_TXN_CNT]);
		strcat(csKey, csList[IDX_HD_TXN_AMT]);
		strcat(csKey, csList[IDX_HD_FEE_AMT]);
		strcat(csKey, csList[IDX_HD_NET_AMT]);
		strcat(csKey, csList[IDX_HD_MU_AMT]);
		DEBUGLOG(("Bulid Header MD5 Key = [%s]\n",csKey));
		
		strcpy(csSign, csList[IDX_HD_CHECKSUM]);		

		DEBUGLOG(("Header Checksum = [%s]\n",csSign));
		md5sum(csKey,strlen(csKey),csOUT);
		
		DEBUGLOG(("Calculated Header Checksum key = [%s], result = [%s]\n",csKey, csOUT));
		
		// Extract Most  left 8 bytes
  	strncpy(csCalSign, csOUT, OFFLINE_CHECKSUM_LEN);
		csCalSign[OFFLINE_CHECKSUM_LEN] = '\0';
		
		if (strcmp(csSign,csCalSign)!=0) {
			DEBUGLOG(("Invalid Header Checksum [%s] <> Calculated:[%s]\n",csSign, csCalSign));
			//return FAILURE;
		}		

		iLineCnt = 0;

	  while (fgets(cs_input_buf,PD_MAX_BUFFER, fin) != NULL) {
	
	  	if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A)
				cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
			strcpy(cs_input_buf,TrimAllChar((const unsigned char *)cs_input_buf,strlen(cs_input_buf),PD_CHAR));
			//DEBUGLOG(("%s\n",cs_input_buf));
	    iCount = 0;
	
	    p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
	    if (p == NULL) {
				DEBUGLOG(("Invalid File Detail"));
				return FAILURE;
			}
	    strcpy(csList[iCount],p);
	    iCount++;
	
	    while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
		    strcpy(csList[iCount],p);
		    iCount++;
	    }               
	
			if (iCount == DETAIL_ITEM_SIZE) {
				iLineCnt++;
				
				// Detail
				/*
				DEBUGLOG(("IDX_TXN_TYPE=[%s]\n",csList[IDX_TXN_TYPE]));
				DEBUGLOG(("IDX_COUNTRY_CODE=[%s]\n",csList[IDX_COUNTRY_CODE]));
				DEBUGLOG(("IDX_TXN_DATE=[%s]\n",csList[IDX_TXN_DATE]));
				DEBUGLOG(("IDX_TXN_ID=[%s]\n",csList[IDX_TXN_ID]));
				DEBUGLOG(("IDX_MERCHANT=[%s]\n",csList[IDX_MERCHANT]));
				DEBUGLOG(("IDX_PSP=[%s]\n",csList[IDX_PSP]));
				DEBUGLOG(("IDX_TXN_AMT_CCY=[%s]\n",csList[IDX_TXN_AMT_CCY]));
				DEBUGLOG(("IDX_TXN_AMT=[%s]\n",csList[IDX_TXN_AMT]));
				DEBUGLOG(("IDX_TXN_FEE_CCY=[%s]\n",csList[IDX_TXN_FEE_CCY]));
				DEBUGLOG(("IDX_TXN_FEE=[%s]\n",csList[IDX_TXN_FEE]));
				DEBUGLOG(("IDX_NET_AMT_CCY=[%s]\n",csList[IDX_NET_AMT_CCY]));
				DEBUGLOG(("IDX_NET_AMT=[%s]\n",csList[IDX_NET_AMT]));
				DEBUGLOG(("IDX_MU_AMT_CCY=[%s]\n",csList[IDX_MU_AMT_CCY]));
				DEBUGLOG(("IDX_MU_AMT=[%s]\n",csList[IDX_MU_AMT]));
				DEBUGLOG(("IDX_PSP_AMT_CCY=[%s]\n",csList[IDX_PSP_AMT_CCY]));
				DEBUGLOG(("IDX_PSP_AMT=[%s]\n",csList[IDX_PSP_AMT]));
				DEBUGLOG(("IDX_TXN_STATUS=[%s]\n",csList[IDX_TXN_STATUS]));
				DEBUGLOG(("IDX_DTL_CHECKSUM=[%s]\n",csList[IDX_DTL_CHECKSUM]));
				DEBUGLOG(("IDX_MERCHANT_REF=[%s]\n",csList[IDX_MERCHANT_REF]));
				*/
				
				// Build Key
				//md5(concat(country code,merchant, txn amt, txn free amt,  net amt, markup amt, psp/deliveried amt))
				strcpy(csKey, csList[IDX_COUNTRY_CODE]);
				strcat(csKey, csList[IDX_MERCHANT]);
				strcat(csKey, csList[IDX_TXN_AMT]);
				strcat(csKey, csList[IDX_TXN_FEE]);
				strcat(csKey, csList[IDX_NET_AMT]);
				strcat(csKey, csList[IDX_MU_AMT]);
				strcat(csKey, csList[IDX_PSP_AMT]);
				//DEBUGLOG(("Bulid MD5 Key = [%s]\n",csKey));
				
				strcpy(csSign, csList[IDX_DTL_CHECKSUM]);		

				//DEBUGLOG(("Detail Checksum = [%s]\n",csSign));
				md5sum(csKey,strlen(csKey),csOUT);
				
				//DEBUGLOG(("Calculated Checksum = [%s]\n",csOUT));

				// Extract Most  left 8 bytes
				//csCalSign=strndup(csOUT, OFFLINE_CHECKSUM_LEN);
				strncpy(csCalSign, csOUT, OFFLINE_CHECKSUM_LEN);
				csCalSign[OFFLINE_CHECKSUM_LEN] = '\0';
										
				if (strcmp(csSign,csCalSign)!=0) {
					DEBUGLOG(("Invalid Detail Checksum at line %d, [%s] <> Calculated:[%s]\n",iCount, csSign, csCalSign));
					return FAILURE;
				}	else {
					//DEBUGLOG(("Detail Checksum Passed\n"));
				}
				
				// Verify date format
				if (strlen(csList[IDX_TXN_DATE])!=PD_DATE_LEN) {
					DEBUGLOG(("Invalid Date format at line %d, [%s]\n",iCount, csList[IDX_TXN_DATE]));
					return FAILURE;				
				}
				
				
			}	else {
				DEBUGLOG(("Invalid Detail size =[%d]\n",iCount));
				return FAILURE;
			}			
		}
	} else {
		DEBUGLOG(("Invalid Header size =[%d]\n",iCount));
		return FAILURE;
	}

	if (iLineCnt == 0) {
		DEBUGLOG(("No File Detail Found\n"));
	}

	

	// Clean up
	FREE_ME(csSign);
	FREE_ME(csOUT);
	FREE_ME(p);

	iRet = SUCCESS;
	DEBUGLOG(("verify_file completed return =[%d]\n",iRet));
	
	return iRet;
}

int process_file(FILE *fin)
{
	int iRet = FAILURE;
	int iLineCnt = 0;
	int	iCount;
	int iJnlKeyCnt=0;	
	char    csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
	char    csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN];
	char    cs_input_buf[PD_MAX_BUFFER +1];;
	char	*p;
	char csPartyType[1];
	double 	dTmpAmt;
	hash_t *hTxnAmt;
	char csKey[PD_TMP_MSG_BUF_LEN];

  hTxnAmt = (hash_t*) malloc (sizeof(hash_t));
  hash_init(hTxnAmt,0);
	
  iCount = 0;
  
  fgets(cs_input_buf,PD_MAX_BUFFER,fin);
  if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A || cs_input_buf[strlen(cs_input_buf) - 1] == 0x10)
         cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
	strcpy(cs_input_buf,TrimAllChar((const unsigned char *)cs_input_buf,strlen(cs_input_buf),PD_CHAR));

	//DEBUGLOG(("%s\n",cs_input_buf));

	iLineCnt = 0;

  while (fgets(cs_input_buf,PD_MAX_BUFFER, fin) != NULL) {
		iLineCnt++;
		
  	if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A)
			cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
		strcpy(cs_input_buf,TrimAllChar((const unsigned char *)cs_input_buf,strlen(cs_input_buf),PD_CHAR));
		//DEBUGLOG(("%s\n",cs_input_buf));
    iCount = 0;

    p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
    if (p == NULL)
			return FAILURE;
    strcpy(csList[iCount],TrimAllChar((const unsigned char *)p, strlen(p), PD_SPACE));
    iCount++;

    while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
	    strcpy(csList[iCount],TrimAllChar((const unsigned char *)p, strlen(p), PD_SPACE));
	    iCount++;
    }               
		
		//DEBUGLOG(("At line [%d] : [%s]\n",iLineCnt,p));
		
		// Detail
		/*
		DEBUGLOG(("IDX_TXN_TYPE=[%s]\n",csList[IDX_TXN_TYPE]));
		DEBUGLOG(("IDX_COUNTRY_CODE=[%s]\n",csList[IDX_COUNTRY_CODE]));
		DEBUGLOG(("IDX_TXN_DATE=[%s]\n",csList[IDX_TXN_DATE]));
		DEBUGLOG(("IDX_TXN_ID=[%s]\n",csList[IDX_TXN_ID]));
		DEBUGLOG(("IDX_MERCHANT=[%s]\n",csList[IDX_MERCHANT]));
		DEBUGLOG(("IDX_PSP=[%s]\n",csList[IDX_PSP]));
		DEBUGLOG(("IDX_TXN_AMT_CCY=[%s]\n",csList[IDX_TXN_AMT_CCY]));
		DEBUGLOG(("IDX_TXN_AMT=[%s]\n",csList[IDX_TXN_AMT]));
		DEBUGLOG(("IDX_TXN_FEE_CCY=[%s]\n",csList[IDX_TXN_FEE_CCY]));
		DEBUGLOG(("IDX_TXN_FEE=[%s]\n",csList[IDX_TXN_FEE]));
		DEBUGLOG(("IDX_NET_AMT_CCY=[%s]\n",csList[IDX_NET_AMT_CCY]));
		DEBUGLOG(("IDX_NET_AMT=[%s]\n",csList[IDX_NET_AMT]));
		DEBUGLOG(("IDX_MU_AMT_CCY=[%s]\n",csList[IDX_MU_AMT_CCY]));
		DEBUGLOG(("IDX_MU_AMT=[%s]\n",csList[IDX_MU_AMT]));
		DEBUGLOG(("IDX_PSP_AMT_CCY=[%s]\n",csList[IDX_PSP_AMT_CCY]));
		DEBUGLOG(("IDX_PSP_AMT=[%s]\n",csList[IDX_PSP_AMT]));
		DEBUGLOG(("IDX_TXN_STATUS=[%s]\n",csList[IDX_TXN_STATUS]));
		DEBUGLOG(("IDX_DTL_CHECKSUM=[%s]\n",csList[IDX_DTL_CHECKSUM]));
		DEBUGLOG(("IDX_MERCHANT_REF=[%s]\n",csList[IDX_MERCHANT_REF]));
		*/
		
		// Convert Transaction Type to PD TXN CODE
		if (!strcmp(csList[IDX_TXN_TYPE],DSP_TYPE)) {
			// Deposit
			strcpy(csList[IDX_TXN_TYPE],PD_OFFSYS_DEPOSIT_TXN_CODE);

			// PSP Txn Amount
			// -----------------------------------------------------------
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_TYPE_TXN_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			sprintf(csPartyType, "%c", PD_TYPE_PSP);
			strcat(csKey, csPartyType);			
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_PSP]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_AMT_CCY]);

			if (!is_float(csList[IDX_TXN_AMT])) {
				DEBUGLOG(("Invalid Txn Amount at line [%d]\n",iLineCnt));
				return FAILURE;
			}				
			dTmpAmt = atof(csList[IDX_TXN_AMT]);
			iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
			// -----------------------------------------------------------
							
			// Merchant Net Amount
			// -----------------------------------------------------------
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_TYPE_NET_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
			strcat(csKey, csPartyType);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_MERCHANT]);	
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_NET_AMT_CCY]);

			if (!is_float(csList[IDX_NET_AMT])) {
				DEBUGLOG(("Invalid Net Amount at line [%d]\n, value = [%s]",iLineCnt,csList[IDX_NET_AMT]));
				return FAILURE;
			}
			
			dTmpAmt = atof(csList[IDX_NET_AMT]);
			iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
			// -----------------------------------------------------------

			// Txn Fee
			// -----------------------------------------------------------
			if (strlen(csList[IDX_TXN_FEE])>0) {
				if (!is_float(csList[IDX_TXN_FEE])) {
					DEBUGLOG(("Invalid Txn Fee at line [%d]\n",iLineCnt));
					return FAILURE;
				}
				
				// Txn Fee
				dTmpAmt = atof(csList[IDX_TXN_FEE]);
				
				if (dTmpAmt != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_FEE);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);						
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_FEE_CCY]);
										
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
				}
			}
			// -----------------------------------------------------------

			// Markup Amount
			// -----------------------------------------------------------
			if (strlen(csList[IDX_MU_AMT])>0) {					
				if (!is_float(csList[IDX_MU_AMT])) {			
					DEBUGLOG(("Invalid Deposit Markup Fee at line [%d] : [%s]\n",iLineCnt,csList[IDX_MU_AMT]));
					return FAILURE;
				}

				// MU Fee
				dTmpAmt = atof(csList[IDX_MU_AMT]);
				
				if (dTmpAmt != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_XU);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);	
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_MU_AMT_CCY]);
										
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
				}
			}
			// -----------------------------------------------------------

		} else if (!strcmp(csList[IDX_TXN_TYPE],WTD_TYPE)) {
			// Payout Request 
			
			if (!strcmp(csList[IDX_TXN_STATUS],DSP_APPROVE_STATUS)) {
				// Approved (A)
				strcpy(csList[IDX_TXN_TYPE],PD_OFFSYS_PAYOUT_TXN_CODE);
			} else if (!strcmp(csList[IDX_TXN_STATUS],DSP_REJFECT_STATUS)) {
				// Rejected (R)
				strcpy(csList[IDX_TXN_TYPE],PD_OFFSYS_PAYOUT_REJ_TXN_CODE);
			} else {
				DEBUGLOG(("Invalid Txn Status at line [%d]\n",iLineCnt));
				return FAILURE;
			}
			
			// Merchant Request Amount
			// -----------------------------------------------------------
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_TYPE_TXN_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
			strcat(csKey, csPartyType);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_MERCHANT]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_AMT_CCY]);

			if (!is_float(csList[IDX_TXN_AMT])) {
				DEBUGLOG(("Invalid Txn Amount at line [%d]\n",iLineCnt));
				return FAILURE;
			}				
			dTmpAmt = atof(csList[IDX_TXN_AMT]);
			iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
			// -----------------------------------------------------------
							
			// PSP Net Amount (to In-transit)
			// -----------------------------------------------------------
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_TYPE_NET_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
			strcat(csKey, csPartyType);						
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, "-");	
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_NET_AMT_CCY]);

			if (!is_float(csList[IDX_NET_AMT])) {
				DEBUGLOG(("Invalid Net Amount at line [%d]\n, value = [%s]",iLineCnt,csList[IDX_NET_AMT]));
				return FAILURE;
			}
			
			dTmpAmt = atof(csList[IDX_NET_AMT]);
			iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
			// -----------------------------------------------------------

			// Txn Fee
			// -----------------------------------------------------------
			if (strlen(csList[IDX_TXN_FEE])>0) {
				if (!is_float(csList[IDX_TXN_FEE])) {
					DEBUGLOG(("Invalid Txn Fee at line [%d]\n",iLineCnt));
					return FAILURE;
				}
				
				// Txn Fee
				dTmpAmt = atof(csList[IDX_TXN_FEE]);
				
				if (dTmpAmt != 0) {
					// Debit Payout Fee
					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_FEE);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);						
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_FEE_CCY]);
										
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
					
					// Credit back to merchant
					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_FEE);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
					strcat(csKey, csPartyType);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_MERCHANT]);					
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_FEE_CCY]);
										
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);					
				}
			}
			// -----------------------------------------------------------

			// Markup Amount
			// -----------------------------------------------------------
			if (strlen(csList[IDX_MU_AMT])>0) {					
				if (!is_float(csList[IDX_MU_AMT])) {
					DEBUGLOG(("Invalid Payout Markup Fee at line [%d]\n",iLineCnt));
					return FAILURE;
				}

				// MU Fee
				dTmpAmt = atof(csList[IDX_MU_AMT]);
				
				if (dTmpAmt != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_XU);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);	
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_MU_AMT_CCY]);
										
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
				}
			}
			// -----------------------------------------------------------
		} else if (!strcmp(csList[IDX_TXN_TYPE],WTDG_TYPE)) {
			// Payout Generated
			strcpy(csList[IDX_TXN_TYPE],PD_OFFSYS_PAYOUT_GEN_TXN_CODE);
							
			// PSP Net Amount (from In-transit)
			// -----------------------------------------------------------
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_TYPE_NET_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
			strcat(csKey, csPartyType);						
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, "-");	
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_NET_AMT_CCY]);

			if (!is_float(csList[IDX_NET_AMT])) {
				DEBUGLOG(("Invalid Net Amount at line [%d]\n, value = [%s]",iLineCnt,csList[IDX_NET_AMT]));
				return FAILURE;
			}
			
			dTmpAmt = atof(csList[IDX_NET_AMT]);
			iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
			// -----------------------------------------------------------

			// PSP/Deliver Amount (to PSP Available)
			// -----------------------------------------------------------
			if (strlen(csList[IDX_PSP_AMT])>0) {
				if (!is_float(csList[IDX_PSP_AMT])) {
					DEBUGLOG(("Invalid PSP/Deliver Amount at line [%d]\n",iLineCnt));
					return FAILURE;
				}

				// PSP/Deliver Amount
				dTmpAmt = atof(csList[IDX_PSP_AMT]);
				
				if (dTmpAmt != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_PSP_AMT);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					sprintf(csPartyType, "%c", PD_TYPE_PSP);
					strcat(csKey, csPartyType);			
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_PSP]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);						
					strcat(csKey, csList[IDX_PSP_AMT_CCY]);
												
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);

				}
			}
			// -----------------------------------------------------------
							
		} else if (!strcmp(csList[IDX_TXN_TYPE],MST_TYPE)) { 
			// Merchant Settlement
			strcpy(csList[IDX_TXN_TYPE],PD_OFFSYS_SETTLEMENT_TXN_CODE);

			// Merchant Txn Amount
			// -----------------------------------------------------------
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_TYPE_TXN_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
			strcat(csKey, csPartyType);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_MERCHANT]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_AMT_CCY]);

			if (!is_float(csList[IDX_TXN_AMT])) {
				DEBUGLOG(("Invalid Txn Amount at line [%d]\n",iLineCnt));
				return FAILURE;
			}				
			dTmpAmt = atof(csList[IDX_TXN_AMT]);
			iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
			// -----------------------------------------------------------
							
			// Deliver Amount (to In-Transit)
			// -----------------------------------------------------------
			if (strlen(csList[IDX_PSP_AMT])>0) {
				if (!is_float(csList[IDX_PSP_AMT])) {
					DEBUGLOG(("Invalid PSP/Deliver Amount at line [%d]\n",iLineCnt));
					return FAILURE;
				}

				dTmpAmt = atof(csList[IDX_PSP_AMT]);
				
				if (dTmpAmt != 0) {
					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_DELI_AMT);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);						
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);						
					strcat(csKey, csList[IDX_PSP_AMT_CCY]);
												
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
				}
			}
			// -----------------------------------------------------------

			// Txn Fee
			// -----------------------------------------------------------
			if (strlen(csList[IDX_TXN_FEE])>0) {
				if (!is_float(csList[IDX_TXN_FEE])) {
					DEBUGLOG(("Invalid Txn Fee at line [%d]\n",iLineCnt));
					return FAILURE;
				}
				
				// Txn Fee
				dTmpAmt = atof(csList[IDX_TXN_FEE]);
				
				if (dTmpAmt != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_FEE);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);						
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_FEE_CCY]);
										
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
					
					// Merchant Debit
					// -----------------------------------------------------------
					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_FEE);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
					strcat(csKey, csPartyType);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_MERCHANT]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_FEE_CCY]);	
					
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
				}
			}
			// -----------------------------------------------------------

			// Markup Amount
			// -----------------------------------------------------------
			if (strlen(csList[IDX_MU_AMT])>0) {					
				if (!is_float(csList[IDX_MU_AMT])) {
					DEBUGLOG(("Invalid Markup Fee at line [%d]\n",iLineCnt));
					return FAILURE;
				}

				// MU Fee
				dTmpAmt = atof(csList[IDX_MU_AMT]);
				
				if (dTmpAmt != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_XU);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);	
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_MU_AMT_CCY]);
										
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);
					
					// Merchant Debit
					// -----------------------------------------------------------
					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_TYPE_M_XU);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
					strcat(csKey, csPartyType);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_MERCHANT]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_MU_AMT_CCY]);	
					
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, csKey, dTmpAmt, &iJnlKeyCnt);					
				}
			}
			// -----------------------------------------------------------
		} else {
			// Unknown
			DEBUGLOG(("Unknown Transaction Type =[%s]\n",csList[IDX_TXN_TYPE]));
			continue;
		}
	}
	
	iRet = myPostTxn(csJnlKeys, hTxnAmt, iJnlKeyCnt);

	if (iRet == PD_OK) {
		DEBUGLOG(("myPostTxn succeed\n"));
	} else {
		DEBUGLOG(("myPostTxn failed\n"));
	}
	// Clean up
	hash_destroy(hTxnAmt);
	FREE_ME(hTxnAmt);
	
	//iRet = SUCCESS;
	
	DEBUGLOG(("process_file return:[%d]\n",iRet));
	return iRet;
}

int myGroupRecs(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], hash_t *hTxn, char *csKey, double dAmt, int *iJnlKeyCnt) 
{
		double dTmpAmt;
		int	iRet = PD_OK;
		
		if (GetField_Double(hTxn,csKey,&dTmpAmt)) {
			//DEBUGLOG(("Found Txn [%s] = [%f]\n",csKey, dTmpAmt));
			// Sum
			dTmpAmt = dTmpAmt + dAmt;

		} else {				
			// Add new
			// Update Key chains
			strcpy(csJnlKeys[*iJnlKeyCnt],csKey);
			(*iJnlKeyCnt)++;
			dTmpAmt = dAmt;				
			//DEBUGLOG(("New Txn [%s] = [%f]\n",csKey, dTmpAmt));
		}
		PutField_Double(hTxn,csKey,dTmpAmt);

		return iRet;
}

int myPostTxn(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], const hash_t *hTxn, const int iJnlKeyCnt) 
{	
	int	iRet = PD_OK;
	int iTmp, iCount, iGetRet, j, iFoundType=0;
	hash_t*	hReq;
	char    csKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN];
	char	*p;
	char 	csTmpKey[IMPORT_MAX_KEY];
	double 	dTmpAmt;
	char* csTxnType[MAX_TXN_TYPE_CNT]={NULL,NULL,NULL,NULL,NULL};
	char csPartyID[PD_CRR_MERCH_ID_LEN];
	//char* csPtr;
	//char cTmp;
	
	
	csTxnType[0] = strdup(PD_OFFSYS_DEPOSIT_TXN_CODE); //Deposit Approved	
	csTxnType[1] = strdup(PD_OFFSYS_PAYOUT_TXN_CODE); // Payout Requested
	csTxnType[2] = strdup(PD_OFFSYS_PAYOUT_REJ_TXN_CODE); // Payout Rejected
	csTxnType[3] = strdup(PD_OFFSYS_PAYOUT_GEN_TXN_CODE); // Payout Generated
	csTxnType[4] = strdup(PD_OFFSYS_SETTLEMENT_TXN_CODE); // Settlement Approved
	
	recordset_t *rRecordSet;
	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));	
	

	hReq = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hReq,0);

	if (iJnlKeyCnt == 0) { 
		DEBUGLOG(("No transaction found\n"));
	} else {
		DEBUGLOG(("Start posting transactions...\n"));
		
		recordset_init(rRecordSet,0);		
		
		for (j=0;j<MAX_TXN_TYPE_CNT;j++) {
			if (csTxnType[j]!=NULL) {
				DEBUGLOG(("Txn Type = [%s]\n",csTxnType[j]));
				iFoundType = 0;
				for (iTmp=0;iTmp<iJnlKeyCnt;iTmp++) {
				
					if (strlen(csJnlKeys[iTmp])>0) {
												
						strcpy(csTmpKey, csJnlKeys[iTmp]);
								
						if (GetField_Double(hTxn,csTmpKey,&dTmpAmt)) {
							
							// Break key into fields
							iCount = 0;
							p = mystrtok(csTmpKey,PD_HASHKEY_DELIMITOR);
							if (p == NULL)
									return FAILURE;
							strcpy(csKeys[iCount],p);
							iCount++;
						
							while ((p = mystrtok(NULL,PD_HASHKEY_DELIMITOR)) != NULL) {
								strcpy(csKeys[iCount],p);
								iCount++;
							} 

							if (strcmp(csKeys[HASHKEY_IDX_TXN_TYPE],csTxnType[j])) {
								// If not equal to current txn type, skip and continue
								continue;
							} else {			
								// Found at least one entry for current txn type
								iFoundType = 1;
							}
							
							//if (GetField_CString(hContext,"PHDATE",&csPtr))  {
							PutField_CString(hReq,"host_posting_date",cs_date);
							//}					
							
							/* txn code */
							PutField_CString(hReq,"txn_code",csKeys[HASHKEY_IDX_TXN_TYPE]);
							
							/*
							DEBUGLOG(("HASHKEY_IDX_AMT_TYPE=[%s]\n",csKeys[HASHKEY_IDX_AMT_TYPE]));	
							DEBUGLOG(("HASHKEY_IDX_TXN_DATE=[%s]\n",csKeys[HASHKEY_IDX_TXN_DATE]));
							DEBUGLOG(("HASHKEY_IDX_TXN_TYPE=[%s]\n",csKeys[HASHKEY_IDX_TXN_TYPE]));
							DEBUGLOG(("HASHKEY_IDX_TXN_STATUS=[%s]\n",csKeys[HASHKEY_IDX_TXN_STATUS]));
							DEBUGLOG(("HASHKEY_IDX_COUNTRY_CODE=[%s]\n",csKeys[HASHKEY_IDX_COUNTRY_CODE]));
							DEBUGLOG(("HASHKEY_IDX_PARTY_TYPE=[%c]\n",csKeys[HASHKEY_IDX_PARTY_TYPE][0]));
							DEBUGLOG(("HASHKEY_IDX_PARTY_ID=[%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
							DEBUGLOG(("HASHKEY_IDX_AMT_CCY=[%s]\n",csKeys[HASHKEY_IDX_AMT_CCY]));	
							DEBUGLOG(("Amount [%s] = [%f]\n",csTmpKey, dTmpAmt));
							*/
							
							/* txn country */
							PutField_CString(hReq,"txn_country",csKeys[HASHKEY_IDX_COUNTRY_CODE]);
							
							/* product */
							PutField_CString(hReq,"product",OFFLINE_PRODUCT_CODE);
							
							/* ccy, convert RMB to CNY if needed */
							if (!strcmp(csKeys[HASHKEY_IDX_AMT_CCY],OFFLINE_RMB_CCY)) {
								PutField_CString(hReq,"ccy",PD_CCY_ISO_CNY);
								//DEBUGLOG(("RMB found, convert to CNY\n"));
							} else
								PutField_CString(hReq,"ccy",csKeys[HASHKEY_IDX_AMT_CCY]);
							
							/* txn_type */
							PutField_CString(hReq,"txn_type",csKeys[HASHKEY_IDX_AMT_TYPE]);
							
							/* amount */
							PutField_Double(hReq,"amount",dTmpAmt);
							
							/* party type */
							PutField_Char(hReq,"type",csKeys[HASHKEY_IDX_PARTY_TYPE][0]);
							
							/* party id */
							if (csKeys[HASHKEY_IDX_PARTY_TYPE][0]==PD_TYPE_MERCHANT) {
								//DEBUGLOG(("Look Merchnant [%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
								// Lookup Merchant ID
								DBObjPtr = CreateObj(DBPtr,"DBCrrExtMerchDetail","GetMerchIDbyExtMerch");
								iGetRet = (unsigned long)(*DBObjPtr)(OFFLINE_PRODUCT_CODE, csKeys[HASHKEY_IDX_PARTY_ID], csPartyID);			
								
								if (iGetRet != FOUND) {
									DEBUGLOG(("Merchnat not found [%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
									iRet = FAILURE;
									continue;									
								}
													
							} else if (csKeys[HASHKEY_IDX_PARTY_TYPE][0]==PD_TYPE_PSP) {
								//DEBUGLOG(("Look PSP [%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
								// Lookup PSP ID
								DBObjPtr = CreateObj(DBPtr,"DBCrrExtPspDetail","GetPspIDbyExtPsp");
								iGetRet = (unsigned long)(*DBObjPtr)(OFFLINE_PRODUCT_CODE, csKeys[HASHKEY_IDX_PARTY_ID], csPartyID);			
								
								if (iGetRet != FOUND) {
									DEBUGLOG(("PSP not found [%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
									iRet = FAILURE;
									continue;									
								}
							} else {
								//Use Default (-) Global Party 
								strcpy(csPartyID,PD_SYS_PARTY_ID);
							}
										
							PutField_CString(hReq,"id",csPartyID);
														
							DEBUGLOG(("Journal Key [%d] = [%s], Amount = [%f]\n",iTmp, csJnlKeys[iTmp], dTmpAmt));
							/*
							GetField_CString(hReq,"host_posting_date",&csPtr);
							DEBUGLOG(("host_posting_date[%d]=[%s]\n",iTmp, csPtr));
							GetField_CString(hReq,"txn_code",&csPtr);
							DEBUGLOG(("txn_code[%d]=[%s]\n",iTmp, csPtr));
							GetField_CString(hReq,"txn_country",&csPtr);
							DEBUGLOG(("txn_country[%d]=[%s]\n",iTmp, csPtr));	
							GetField_CString(hReq,"product",&csPtr);
							DEBUGLOG(("product[%d]=[%s]\n",iTmp, csPtr));
							GetField_CString(hReq,"ccy",&csPtr);
							DEBUGLOG(("ccy[%d]=[%s]\n",iTmp, csPtr));
							GetField_CString(hReq,"txn_type",&csPtr);
							DEBUGLOG(("txn_type[%d]=[%s]\n",iTmp, csPtr));
							GetField_Double(hReq,"txn_type",&dTmpAmt);
							DEBUGLOG(("amount[%d]=[%f]\n",iTmp, dTmpAmt));
							GetField_Char(hReq,"type",&cTmp);
							DEBUGLOG(("type[%d]=[%c]\n",iTmp, cTmp));
							GetField_CString(hReq,"id",&csPtr);	
							DEBUGLOG(("id[%d]=[%s]\n",iTmp, csPtr));
							*/
							
							RecordSet_Add(rRecordSet,hReq);
							//DEBUGLOG(("Added to RS, Journal Key [%d]\n",iTmp));

							hReq = (hash_t*) malloc (sizeof(hash_t));							
							hash_init(hReq,0);	
								
						} else {
							DEBUGLOG(("Not Found for Key [%s]\n",csTmpKey));
							//iRet = FAILURE;
							continue;
						}
												
					} else {
						continue;
					}
				} // for csKey
				
				if (iFoundType) {
					
					DEBUGLOG(("Start BOCrrPost...\n"));
					BOObjPtr = CreateObj(BOPtr,"BOCrrPost","PostOffSysTxn");
					iRet = (unsigned long)(*BOObjPtr)(rRecordSet);
					DEBUGLOG(("End BOCrrPost and return [%d]...\n",iRet));

					// Clean up
					RecordSet_Destroy(rRecordSet);
					
					if (iRet != PD_OK) {
						break;
					}
				} else {
					DEBUGLOG(("No Transaction found for Txn Type = [%s]\n",csTxnType[j]));
				}
			}			
		} // for Txn Type	
	}

	//hash_t	*hRec;
	
	
	//iRet = PD_OK;
	/*
	DEBUGLOG(("Start looping RS...\n"));
	hRec = RecordSet_GetFirst(rRecordSet);
	//DEBUGLOG(("iRet = [%d]...\n", iRet));
	iTmp = 0;
	double dRSAmt;
	while (hRec && iRet == PD_OK) {
		iTmp++;
		GetField_CString(hRec,"host_posting_date",&csPtr);
		DEBUGLOG(("host_posting_date[%d]=[%s]\n",iTmp, csPtr));
		GetField_CString(hRec,"txn_code",&csPtr);
		DEBUGLOG(("txn_code[%d]=[%s]\n",iTmp, csPtr));
		GetField_CString(hRec,"txn_country",&csPtr);
		DEBUGLOG(("txn_country[%d]=[%s]\n",iTmp, csPtr));	
		GetField_CString(hRec,"product",&csPtr);
		DEBUGLOG(("product[%d]=[%s]\n",iTmp, csPtr));
		GetField_CString(hRec,"ccy",&csPtr);
		DEBUGLOG(("ccy[%d]=[%s]\n",iTmp, csPtr));
		GetField_CString(hRec,"txn_type",&csPtr);
		DEBUGLOG(("txn_type[%d]=[%s]\n",iTmp, csPtr));
		GetField_Double(hRec,"amount",&dRSAmt);
		DEBUGLOG(("amount[%d]=[%f]\n",iTmp, dRSAmt));
		GetField_Char(hRec,"type",&cTmp);
		DEBUGLOG(("type[%d]=[%c]\n",iTmp, cTmp));
		GetField_CString(hRec,"id",&csPtr);	
		DEBUGLOG(("id[%d]=[%s]\n",iTmp, csPtr));
		
		hRec = RecordSet_GetNext(rRecordSet);	
	}

	DEBUGLOG(("End looping RS...\n"));
	
	DEBUGLOG(("Start Passing to BOCrrPost...\n"));
	//BOObjPtr = CreateObj(BOPtr,"BOCrrPost","PostPHTxn");
	BOObjPtr = CreateObj(BOPtr,"BOCrrPost","PostOffSysTxn");
	iRet = (unsigned long)(*BOObjPtr)(rRecordSet);
	DEBUGLOG(("End Passing to BOCrrPost...\n"));
	*/
		
	// Clean up
	RecordSet_Destroy(rRecordSet);
	hash_destroy(hReq);
	FREE_ME(hReq);	
	DEBUGLOG(("End posting and return:[%d]\n",iRet));
	
	return iRet;
}
