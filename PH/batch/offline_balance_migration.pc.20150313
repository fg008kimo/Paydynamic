/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/03/09              Elvis Wong
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"
#include "dates.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

int	i_total_field;

char	cs_type[50 + 1];
char    cs_in_file_name[100 + 1];
char    cs_converted_file_name[100 + 1];

char    cDebug = 'Y';

OBJPTR(DB);
OBJPTR(BO);
OBJPTR(Txn);

int parse_arg(int argc,char **argv);
int process_convert_file(hash_t* hRec);
int process_match_keyword(hash_t* hRec);
int check_title(const char *csLine, hash_t *hRls);
int check_detail(const char *csLine, hash_t *hRls);
int add_bank_acct_baid(hash_t *hRls);
//int add_pid(hash_t *hRls);
//int add_provider(hash_t *hRls);
int strlen_content(char *s);
char *mystrtok_r(char *string, const char *seps, char **context);
char *_deleteCharacters(char *str, char *charSet);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}

int batch_proc(int argc, char* argv[])
{
        int     iRet = SUCCESS;

	hash_t *hRec = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hRec, 0);

	iRet = parse_arg(argc,argv);
               
	if (iRet != SUCCESS) {
		printf("usage: -t type -i in_file_name -c converted_file_name -f total_field\n");
                return (iRet);
        } 

	if(iRet == PD_OK){
			
		PutField_CString(hRec,"type",cs_type);
DEBUGLOG(("batch_proc:: type = [%s]\n", cs_type));
		
		//sprintf(cs_in_file_name, "%s", "/home/php3dev/offline_balance_migration/bank_acct_file.xls");
		PutField_CString(hRec,"in_file_name",cs_in_file_name);			
DEBUGLOG(("batch_proc:: in_file_name = [%s]\n", cs_in_file_name));

		//sprintf(cs_converted_file_name, "%s", "/home/php3dev/offline_balance_migration/bank_acct_file_converted.txt");	
		PutField_CString(hRec,"converted_file_name",cs_converted_file_name);	
DEBUGLOG(("batch_proc:: converted_file_name = [%s]\n", cs_converted_file_name));

		//i_total_field = 28;
		PutField_Int(hRec,"total_field",i_total_field);
DEBUGLOG(("batch_proc:: total_field = [%d]\n", i_total_field));

                iRet = process_convert_file(hRec);
        }

        if(iRet == PD_OK){
                iRet = process_match_keyword(hRec);
        }

	if (iRet != PD_OK) {
		iRet = FAILURE;
	}

        hash_destroy(hRec);
        FREE_ME(hRec);

	return iRet;
}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}

int parse_arg(int argc,char **argv)
{
	char    c;

	i_total_field = 0;
	strcpy(cs_type,"");
	strcpy(cs_in_file_name,"");
        strcpy(cs_converted_file_name,"");

	while ((c = getopt(argc,argv,"t:i:c:f:")) != EOF) {
                switch (c) {
                        case 't':
                                strcpy(cs_type, optarg);
                                break;
                        case 'i':
                                strcpy(cs_in_file_name, optarg);
                        case 'c':
                                strcpy(cs_converted_file_name, optarg);
                                break;
			case 'f':
				i_total_field = atoi(optarg);
				break;
                        default:
                                return FAILURE;
                }
        }

        if (!strcmp(cs_type, "") || !strcmp(cs_in_file_name, "") || !strcmp(cs_converted_file_name,"") || i_total_field == 0)
                return FAILURE;

        return SUCCESS;
}

int process_convert_file(hash_t* hRec)
{
	int iRet = PD_OK;

	int iStatus = 0;

	char *csInFileName = NULL;
	char *csConvertedFileName = NULL;

	char csSysCmd[PD_TMP_BUF_LEN*3] = "";

/* in_file_name */
        if (GetField_CString(hRec, "in_file_name", &csInFileName)) {
DEBUGLOG(("process_convert_file:: in_file_name = [%s]\n", csInFileName));
        }

/* converted_file_name */
        if (GetField_CString(hRec, "converted_file_name", &csConvertedFileName)) {
DEBUGLOG(("process_convert_file:: converted_file_name = [%s]\n", csConvertedFileName));
        }

/* do the conversion
example: ol_bal_mr_convert.sh "UTF-8" "UTF-8" "csInFileName" "csConvertedFileName"
*/

	snprintf(csSysCmd, sizeof(csSysCmd), "%s \"%s\" \"%s\" \"%s\" \"%s\"", "ol_bal_mr_convert.sh", "UTF-8", "UTF-8", csInFileName, csConvertedFileName);
DEBUGLOG(("process_convert_file:: call system command [%s][%d]\n", csSysCmd, strlen(csSysCmd)));

        iStatus = system(csSysCmd);
DEBUGLOG(("process_convert_file:: iStatus = [%d]\n", iStatus));

	iRet = WEXITSTATUS(iStatus);

        if (iRet != PD_OK) {
DEBUGLOG(("process_convert_file:: file conversion FAILURE!!!\n"));
ERRLOG("offline_balance_migration::process_convert_file:: file conversion FAILURE!!!\n");
       		iRet = PD_ERR;
        }

DEBUGLOG(("process_convert_file:: iRet = [%d]\n", iRet));
        return iRet;
}

int process_match_keyword(hash_t* hRec)
{
        int iRet = PD_OK;

	int iField = 0;
	int iTotalField = 0;
	int iTitleRow = 0;
	int iStartRow = 0;	
	int iEndRow = 0;
	int iCurrLine = 0;
	int iTotalLine = 0;
	int iSBlankLine = 0;
 	int iEBlankLine = 0;
	int iMatched = 0;	

	int iDtlLine = 0;

	char *csType = NULL;
	char *csConvertedFileName = NULL;
	char *csTmp = NULL;
	
	char csDelimiter[2] = "";	
	char cs_input_buf[PD_TMP_MSG_BUF_LEN] = "";
	char cs_tmp_input_buf[PD_TMP_MSG_BUF_LEN] = "";

	char csTag[PD_TAG_LEN];

	FILE *fin = NULL;

	hash_t *hFileTitleRec = (hash_t*) malloc (sizeof(hash_t));
       	hash_init(hFileTitleRec, 0);

      	hash_t *hFileDetailRec = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hFileDetailRec, 0);

/* type */
        if (GetField_CString(hRec, "type", &csType)) {
DEBUGLOG(("process_match_keyword:: type = [%s]\n", csType));
        }

/* converted_file_name */
        if (GetField_CString(hRec, "converted_file_name", &csConvertedFileName)) {
DEBUGLOG(("process_match_keyword:: converted_file_name = [%s]\n", csConvertedFileName));
        }

/*
 * File Open
 */
        if (iRet == PD_OK) {
DEBUGLOG(("process_match_keyword:: Start Opening File...\n"));
                fin = fopen(csConvertedFileName, "r");
                if (fin == NULL) {
                        iRet = FAILURE;
DEBUGLOG(("process_match_keyword:: cannot open file [%s]!!!\n", csConvertedFileName));
ERRLOG("offline_balance_migration::process_match_keyword:: cannot open file [%s]!!!\n", csConvertedFileName);
                } else {

                        while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
                                if (strlen_content(cs_input_buf) == 0) {
                                        iSBlankLine++;
                                } else {
                                        break;
                                }
                        }
                        rewind(fin);
                        while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
                                if (strlen_content(cs_input_buf) == 0) {
                                        iEBlankLine++;
                                } else {
                                        iEBlankLine = 0;
                                }
                                iTotalLine++;
                        }
DEBUGLOG(("process_match_keyword:: total_line = [%d]\n",iTotalLine));
DEBUGLOG(("process_match_keyword:: starting_blank_line = [%d]\n",iSBlankLine));
DEBUGLOG(("process_match_keyword:: ending_blank_line = [%d]\n",iEBlankLine));
                }
        }

/*
 * File format
 */
        if (iRet == PD_OK) {
DEBUGLOG(("process_match_keyword:: Start Checking Format...\n"));

               	rewind(fin);
		iCurrLine = 0;
                iField = 0;

/* delimiter */
		sprintf(csDelimiter,"%s",",");
DEBUGLOG(("process_match_keyword:: delimiter = [%s]\n",csDelimiter));

/* row_title */
		iTitleRow = 1 + iSBlankLine;
DEBUGLOG(("process_match_keyword:: row_title = [%d]\n",iTitleRow));

/* row_start */
             	iStartRow = 2 + iSBlankLine;
DEBUGLOG(("process_match_keyword:: row_start = [%d]\n",iStartRow));

/* row_end */
          	iEndRow = 1 + iEBlankLine;
DEBUGLOG(("process_match_keyword:: row_end = [%d]\n",iEndRow));

/* total_field */
                if (GetField_Int(hRec, "total_field", &iTotalField)) {
DEBUGLOG(("process_match_keyword:: total_field = [%d]\n", iTotalField));
                }

/* count_field */
		while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
                	iCurrLine++;
                     	if (iCurrLine == iStartRow) {
                        	if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0A) cs_input_buf[strlen(cs_input_buf)-1] = '\0';
                              	if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0D) cs_input_buf[strlen(cs_input_buf)-1] = '\0';
                             	strcpy(cs_tmp_input_buf,cs_input_buf);
                               	csTmp = mystrtok(cs_tmp_input_buf, csDelimiter);
                            	while (csTmp != NULL) {
                                   	iField++;
                                    	csTmp = mystrtok(NULL, csDelimiter);
                            	}
// DEBUGLOG(("process_match_keyword:: line %03d count[%d]/total_field[%d] [%s]\n",iCurrLine,iField,iTotalField,cs_input_buf));
DEBUGLOG(("process_match_keyword:: count_field = [%d]\n",iField));
                                /* Total Field Matched */
                             	if (iField == iTotalField) {
                                   	iMatched = 1;
                               	}
                             	break; 
                     	}
          	}		
	}	
	
/*
 * Read File
 */
	if (iRet == PD_OK) {
DEBUGLOG(("process_match_keyword:: Start Reading File...\n"));

		rewind(fin);
                iCurrLine = 0;

		while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
                        iCurrLine++;

                        if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0A) cs_input_buf[strlen(cs_input_buf)-1] = '\0';
                        if (cs_input_buf[strlen(cs_input_buf)-1] == 0x0D) cs_input_buf[strlen(cs_input_buf)-1] = '\0';

                	/* handle leading and trailing rows */
                        if (iCurrLine < iStartRow || iCurrLine > iTotalLine - iEndRow + 1) {
                                iDtlLine = 0;
                        } else {
                                iDtlLine++;
                        }

			/* ignore rows containing useless info */
                        if (strlen_content(cs_input_buf) == 0) {
                                if (iDtlLine == 0) {
// DEBUGLOG(("process_match_keyword:: line %03d ignore [%s]\n",iCurrLine,cs_input_buf));
                                } else {
// DEBUGLOG(("process_match_keyword:: line %03d ignore [%s]\n",iCurrLine,cs_input_buf));
                                }
                                continue;
                        }

			/* Check Title/Detail */
			if (iCurrLine == iTitleRow) {
				iRet = check_title(cs_input_buf, hFileTitleRec);
			} else if (iCurrLine > iTitleRow){
/* detail_tag */
				sprintf(csTag, "%d_detail", iCurrLine-iTitleRow);
				PutField_CString(hFileDetailRec,"detail_tag",csTag);

                        	iRet = check_detail(cs_input_buf, hFileDetailRec);
			}
		}

/* detail_total_rec */
		PutField_Int(hFileDetailRec,"detail_total_rec",iCurrLine-iTitleRow);
// DEBUGLOG(("process_match_keyword:: detail_total_rec = [%d]\n",iCurrLine-iTitleRow));

/* detail_total_field */
                PutField_Int(hFileDetailRec,"detail_total_field",iTotalField);
                PutField_Int(hFileTitleRec,"detail_total_field",iTotalField);
// DEBUGLOG(("process_match_keyword:: detail_total_field = [%d]\n",iTotalField));

	}

/*
 * File Close
 */
	
        if (iRet == PD_OK) {
DEBUGLOG(("process_match_keyword:: Start Closing File...\n"));

		if (fin) {
                	fclose(fin);
                	fin = NULL;
		}
        }

/*
 * Migrate Data
 */

        if (iRet == PD_OK) {
DEBUGLOG(("process_match_keyword:: Start Migrating Data...\n"));
		
		if (!strcmp(csType, "bank_acct_baid")) {
			iRet = add_bank_acct_baid(hFileDetailRec);	
		} else if (!strcmp(csType, "pid")) {
			//iRet = add_pid(hFileDetailRec);
		} else if (!strcmp(csType, "provider")) {
			//iRet = add_provider(hFileDetailRec);
		}
        }

	hash_destroy(hFileTitleRec);
       	FREE_ME(hFileTitleRec);

     	hash_destroy(hFileDetailRec);
      	FREE_ME(hFileDetailRec);

DEBUGLOG(("process_match_keyword:: iRet = [%d]\n", iRet));
        return iRet;
}

int check_title(const char *csLine, hash_t *hRls)
{
        int iRet = PD_OK;

        char *csTag = (char*) malloc (64);
        char *csLineField = NULL; 
	char *csRemainField = NULL;

        char csDelimiter[2] = "";
        char csNewField[PD_TMP_MSG_BUF_LEN] = ""; 
	char csNewLine[PD_TMP_MSG_BUF_LEN] = "";
       
	int iField = 0;

DEBUGLOG(("check_title:: start!!!\n"));	

/* delimiter */
	sprintf(csDelimiter,"%s",",");
DEBUGLOG(("check_title:: delimiter = [%s]\n",csDelimiter));

        strcpy(csNewLine, csLine);

        csLineField = mystrtok_r(csNewLine, csDelimiter, &csRemainField);
        while (csLineField != NULL && iRet == PD_OK) {
                strcpy(csNewField, TrimAll((const unsigned char*)csLineField, strlen(csLineField)));

                iField++;

		sprintf(csTag, "title_%d", iField);

                if (*csNewField == '\0') {
                        csLineField = mystrtok_r(NULL, csDelimiter, &csRemainField);
DEBUGLOG(("check_title:: [%s] = []\n",csTag));
                        continue;
                }

		PutField_CString(hRls,csTag,csNewField);	
DEBUGLOG(("check_title:: [%s] = [%s]\n",csTag,csNewField));

		csLineField = mystrtok_r(NULL, csDelimiter, &csRemainField);
        }

        FREE_ME(csTag);

DEBUGLOG(("check_title:: end!!!\n"));	
    	return iRet;
}

int check_detail(const char *csLine, hash_t *hRls)
{
        int iRet = PD_OK;

        char *csTag = (char*) malloc (64);
	char *csDetailTag = NULL;
        char *csLineField = NULL;
        char *csRemainField = NULL;
        
	char csDelimiter[2] = "";
        char csNewField[PD_TMP_MSG_BUF_LEN] = "";
        char csNewLine[PD_TMP_MSG_BUF_LEN] = "";

        int iField = 0;

DEBUGLOG(("check_detail:: start!!!\n"));	

/* detail_tag */
        if (GetField_CString(hRls, "detail_tag", &csDetailTag)) {
DEBUGLOG(("process_convert_file:: detail_tag = [%s]\n", csDetailTag));
        }

/* delimiter */
        sprintf(csDelimiter,"%s",",");
DEBUGLOG(("check_detail:: delimiter = [%s]\n",csDelimiter));

        strcpy(csNewLine, csLine);

        csLineField = mystrtok_r(csNewLine, csDelimiter, &csRemainField);
        while (csLineField != NULL && iRet == PD_OK) {
                strcpy(csNewField, TrimAll((const unsigned char*)csLineField, strlen(csLineField)));

                iField++;

		sprintf(csTag, "%s_%d", csDetailTag, iField);

                if (*csNewField == '\0') {
                        csLineField = mystrtok_r(NULL, csDelimiter, &csRemainField);
DEBUGLOG(("check_detail:: [%s] = []\n",csTag));
                        continue;
                }

		PutField_CString(hRls,csTag,csNewField);	
DEBUGLOG(("check_detail:: [%s] = [%s]\n",csTag,csNewField));

                csLineField = mystrtok_r(NULL, csDelimiter, &csRemainField);
        }

        FREE_ME(csTag);

DEBUGLOG(("check_detail:: end!!!\n"));	
        return iRet;
}

int add_bank_acct_baid(hash_t *hRls)
{
	int iRet = PD_OK;
	int iTmpRet = FOUND;
	
	int iTotalRec = 0;
	int iTotalField = 0;
	int i = 0, j = 0;

	char *csRemainField = NULL;
	char *csGetField = NULL;
	char *csTmp;

	char *csField = (char*) malloc (64);
	char *csYear = (char*) malloc (64);
	char *csMonth = (char*) malloc (64);
	char *csDay = (char*) malloc (64);
	char *csTime = (char*) malloc (64);
	char *csDateTime = (char*) malloc (64);
	char *csTag = (char*) malloc (64);
	
	char csBankCode[PD_BANK_CODE_LEN] = "";

	hash_t *hRequest;
        hRequest = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hRequest, 0);

	hash_t *hBaidRequest;
        hBaidRequest = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hBaidRequest, 0);

/* detail_total_rec */
        if (GetField_Int(hRls, "detail_total_rec", &iTotalRec)) {
DEBUGLOG(("add_bank_acct_baid:: detail_total_rec = [%d]\n", iTotalRec));
        }

/* detail_total_field */
        if (GetField_Int(hRls, "detail_total_field", &iTotalField)) {
DEBUGLOG(("add_bank_acct_baid:: detail_total_field = [%d]\n", iTotalField));
        }
	
	PutField_CString(hRequest,"action", "A"); 
	PutField_CString(hRequest, "add_user", "SYSTEM");

	for (i=1; i<=iTotalRec; i++) {
		for (j=1; j<=iTotalField; j++) {

			sprintf(csTag, "%d_detail_%d", i, j);			
			if (GetField_CString(hRls, csTag, &csTmp)) {
DEBUGLOG(("add_bank_acct_baid:: [%s] = [%s]\n", csTag, csTmp));

				// 1 -22 bank acct fields
				// 23 - 28 baid fields
				if (j == 1) {
					PutField_CString(hRequest,"prov_id",csTmp);	
				} else if (j == 2) {
					PutField_CString(hRequest,"name",csTmp);	

DEBUGLOG(("add_bank_acct_baid:: call BankDesc::FindBankCodeByBankAbbrevName()\n"));
                			DBObjPtr = CreateObj(DBPtr, "DBBankDesc", "FindBankCodeByBankAbbrevName");
                			iTmpRet = (unsigned long)(*DBObjPtr)(csTmp, csBankCode);
                			if(iTmpRet == FOUND){
DEBUGLOG(("add_bank_acct_baid:: call BankDesc::FindBankCodeByBankAbbrevName() Found!!!\n"));
	
						PutField_CString(hRequest,"int_bank_code",csBankCode);											
DEBUGLOG(("add_bank_acct_baid:: call BankDesc::FindBankCodeByBankAbbrevName() int_bank_code = [%s]\n", csBankCode));
                			} else {
						iRet = PD_ERR;
DEBUGLOG(("add_bank_acct_baid:: call BankDesc::FindBankCodeByBankAbbrevName() Not Found!!!\n"));
ERRLOG("offline_balance_migration::add_bank_acct_baid::call BankDesc::FindBankCodeByBankAbbrevName Fail!!!\n");
                			}		
				} else if (j == 3) {
                                        PutField_CString(hRequest,"new_acct_num",csTmp);   
                                } else if (j == 4) {
					if (!strcmp(csTmp, "RMB")) {
                                        	PutField_CString(hRequest,"txn_ccy","CNY");
					} else {
                                        	PutField_CString(hRequest,"txn_ccy",csTmp);
					}
				} else if (j == 5) {
                                        PutField_CString(hRequest,"short_name",csTmp);
                                } else if (j == 6) {
					if (!strcmp(csTmp, "Deposit")) {
                                        	PutField_CString(hRequest,"acct_type","DSI");
					} else if (!strcmp(csTmp, "Payout")) {
                                        	PutField_CString(hRequest,"acct_type","POA");
					} else if (!strcmp(csTmp, "Intermediate")) {
                                        	PutField_CString(hRequest,"acct_type","INT");
					} else if (!strcmp(csTmp, "Pending Fund")) {
                                        	PutField_CString(hRequest,"acct_type","PDF");
					} else {
                                        	PutField_CString(hRequest,"acct_type",csTmp);
					}
                                } else if (j == 7) {
					if (!strcmp(csTmp, "No")) {
                                        	PutField_CString(hRequest,"share","0");
					} else if (!strcmp(csTmp, "Yes")) {
                                        	PutField_CString(hRequest,"share","1");
					} else {
                                        	PutField_CString(hRequest,"share",csTmp);
					}
                                } else if (j == 8) {
					if (!strcmp(csTmp, "Disable")) {
                                        	PutField_CString(hRequest,"sys_switch","0");
					} else if (!strcmp(csTmp, "Enable")) {
                                        	PutField_CString(hRequest,"sys_switch","1");
					} else {
                                        	PutField_CString(hRequest,"sys_switch",csTmp);	
					}
                                } else if (j == 9) {
					if (!strcmp(csTmp, "Disable")) {
                                                PutField_CString(hRequest,"sms_stmt","0");
                                        } else if (!strcmp(csTmp, "Enable")) {
                                                PutField_CString(hRequest,"sms_stmt","1");
                                        } else {
                                        	PutField_CString(hRequest,"sms_stmt",csTmp);
					}
                                } else if (j == 10) {
                                        PutField_CString(hRequest,"reg_mob_num",csTmp);
                                } else if (j == 11) {
                                        PutField_CString(hRequest,"owner_id",csTmp);
                                } else if (j == 12) {
                                        PutField_CString(hRequest,"owner",csTmp);
                                } else if (j == 13) {
                                        PutField_CString(hRequest,"branch_code",csTmp);
                                } else if (j == 14) {
                                        PutField_CString(hRequest,"province",csTmp);
                                } else if (j == 15) {
                                        PutField_CString(hRequest,"city",csTmp);
                                } else if (j == 16) {
                                        PutField_CString(hRequest,"branch",csTmp);
                                } else if (j == 17) {
                                        PutField_CString(hRequest,"swift_code",csTmp);
                                } else if (j == 18) {
                                        PutField_CString(hRequest,"remark",csTmp);
                                } else if (j == 19) {
					if (!strcmp(csTmp, "Active")) {
                                        	PutField_CString(hRequest,"status_type","A");
				  	} else if (!strcmp(csTmp, "Not Yet Disposed")) {
                                        	PutField_CString(hRequest,"status_type","ND");
				  	} else if (!strcmp(csTmp, "Frozen")) {
                                        	PutField_CString(hRequest,"status_type","F");
				  	} else if (!strcmp(csTmp, "Not Yet Frozen")) {
                                        	PutField_CString(hRequest,"status_type","NF");
				  	} else if (!strcmp(csTmp, "Spare")) {
                                        	PutField_CString(hRequest,"status_type","S");
				  	} else if (!strcmp(csTmp, "Backup")) {
                                        	PutField_CString(hRequest,"status_type","B");
				  	} else if (!strcmp(csTmp, "New")) {
                                        	PutField_CString(hRequest,"status_type","N");	
				  	} else if (!strcmp(csTmp, "Disposed")) {
                                        	PutField_CString(hRequest,"status_type","D");
					} else {					
                                        	PutField_CString(hRequest,"status_type",csTmp);
					}
                                } else if (j == 20) {
                                        PutField_CString(hRequest,"rec_by",csTmp);
                                } else if (j == 21) {
					sprintf(csField, "%s", csTmp);
					csGetField = mystrtok_r(csField, "-", &csRemainField);
					sprintf(csYear, "%s", csGetField);
DEBUGLOG(("add_bank_acct_baid:: year = [%s]\n", csYear));
	
					sprintf(csField, "%s", csRemainField);	
					csGetField = mystrtok_r(csField, "-", &csRemainField);
					sprintf(csMonth, "%s", csGetField);
DEBUGLOG(("add_bank_acct_baid:: month = [%s]\n", csMonth));

					sprintf(csField, "%s", csRemainField);     
                                        csGetField = mystrtok_r(csField, "-", &csRemainField);
					sprintf(csDay, "%s", csGetField);
DEBUGLOG(("add_bank_acct_baid:: day = [%s]\n", csDay));					

					sprintf(csTime, "%s", "000000");
DEBUGLOG(("add_bank_acct_baid:: time = [%s]\n", csTime));					
						
					sprintf(csDateTime, "%s%s%s%s", csYear, csMonth, csDay, csTime);
DEBUGLOG(("add_bank_acct_baid:: datetime = [%s]\n", csDateTime));					

                                        PutField_CString(hRequest,"rec_datetime",csDateTime);
                                } else if (j == 22) {
					sprintf(csField, "%s", csTmp);
                                        csGetField = mystrtok_r(csField, "-", &csRemainField);
                                        sprintf(csYear, "%s", csGetField);
DEBUGLOG(("add_bank_acct_baid:: year = [%s]\n", csYear));

                                        sprintf(csField, "%s", csRemainField);
                                        csGetField = mystrtok_r(csField, "-", &csRemainField);
                                        sprintf(csMonth, "%s", csGetField);
DEBUGLOG(("add_bank_acct_baid:: month = [%s]\n", csMonth));

					sprintf(csField, "%s", csRemainField);
                                        csGetField = mystrtok_r(csField, "-", &csRemainField);
                                        sprintf(csDay, "%s", csGetField);
DEBUGLOG(("add_bank_acct_baid:: day = [%s]\n", csDay));

                                        sprintf(csTime, "%s", "000000");
DEBUGLOG(("add_bank_acct_baid:: time = [%s]\n", csTime));

                                        sprintf(csDateTime, "%s%s%s%s", csYear, csMonth, csDay, csTime);
DEBUGLOG(("add_bank_acct_baid:: datetime = [%s]\n", csDateTime));

                                        PutField_CString(hRequest,"key_expired_datetime",csDateTime);
				} else if (j == 23) {

				} else if (j == 24) {

                                } else if (j == 25) {

                                } else if (j == 26) {

                                } else if (j == 27) {

                                } else if (j == 28) {

                                }
                	} else {
				if (j == 1) {

                                } else if (j == 2) {
							
				} else if (j == 3) {
						
				} else if (j == 4) {
							
				} else if (j == 5) {
						
				} else if (j == 7) {
						
				} else if (j == 8) {
				
				} else if (j == 9) {
							
				} else if (j == 12) {

				} else if (j == 14) {

				} else if (j == 15) {
						
				} else if (j == 16) {

				} else if (j == 19) {

				} else if (j == 20) {

				} else if (j == 21) {

				}
			}			
		}

DEBUGLOG(("add_bank_acct_baid:: call TxnOmtByUsBKA::Authorize()\n"));
        	TxnObjPtr = CreateObj(TxnPtr, "TxnOmtByUsBKA", "Authorize");
        	iRet = (unsigned long)(*TxnObjPtr)(hRequest, hRequest, hRequest);
        	if(iRet == PD_OK){
DEBUGLOG(("add_bank_acct_baid:: call TxnOmtByUsBKA::Authorize() Success!!!\n"));
        	} else {
			iRet = PD_ERR;
DEBUGLOG(("add_bank_acct_baid:: call TxnOmtByUsBKA::Authorize() Fail!!!\n"));
ERRLOG("offline_balance_migration::add_bank_acct_baid::call TxnOmtByUsBKA::Authorize Fail!!!\n");
        	}	

	}

	hash_destroy(hRequest);
	FREE_ME(hRequest);

	hash_destroy(hBaidRequest);
	FREE_ME(hBaidRequest);

	FREE_ME(csTag);
	FREE_ME(csTag);
	FREE_ME(csField);
	FREE_ME(csYear);
	FREE_ME(csMonth);
	FREE_ME(csDay);
	FREE_ME(csTime);
	FREE_ME(csDateTime);

DEBUGLOG(("add_bank_acct_baid:: iRet = [%d]\n", iRet));
        return iRet;
}

int strlen_content(char *s)
{
        int j = 0;
        while (*s) {
                if ((*s & 0xc0) == 0x00 || (*s & 0xc0) == 0x40) {
                        if ((*s >= '0' && *s <= '9') ||
                            (*s >= 'A' && *s <= 'Z') ||
                            (*s >= 'a' && *s <= 'z')) {
                                j++;
                        }
                } else if ((*s & 0xc0) == 0xc0) {
                        j++;
                }
                s++;
        }
        return j;
}

char *mystrtok_r(char *string, const char *seps, char **context)
{
        char *head; /* Start of word */
        char *tail; /* End of word */

        /* If we're starting up, initialize context */
        if (string) {
                *context = string;
        }

        /* Get potential start of this next word */
        head = *context;
        if (head == NULL) {
                return NULL;
        }

        /* Skip any leading separators
        while (*head && strchr(seps, *head)) {
                head++;
        }*/

        /* Did we hit the end? */
        if (*head == 0) {
                /* Nothing left */
                *context = NULL;
                return NULL;
        }

        /* Skip over word */
        tail = head;
        while (*tail && !strchr(seps, *tail)) {
                tail++;
        }

        /* Save head for next time in context */
        if (*tail == 0) {
                *context = NULL;
        } else {
                *tail = 0;
                tail++;
                *context = tail;
        }

        /* Return current word */
        return head;
}

char *_deleteCharacters(char *str, char *charSet)
{
        int hash [256];
        int i;
        if(NULL == charSet)
                return str;

        for(i = 0; i < 256; i++) {
                hash[i] = 0;
        }

        for(i = 0; i < strlen(charSet); i++)
                hash[(unsigned char)charSet[i]] = 1;

        int currentIndex = 0;
        for(i = 0; i < strlen(str); i++)
        {
                if(!hash[(unsigned char)str[i]])
                str[currentIndex++] = str[i];
        }
        str[currentIndex] = '\0';
        return str;
}
