/*
Partnerdelight (c)2015. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2016/02/04              Dirk Wong
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include <math.h>
#include "utilitys.h"
#include "expat.h"
#include <curl/curl.h>
#include "myhash.h"
#include "ObjPtr.h"
#include "numutility.h"
#include "myrecordset.h"
#include "batchcommon.h"
#include "TxnSeq.h"
#include "import_hist_tbl_data.h"
#include "internal.h"

char    cDebug;
char    cs_date[PD_DATE_LEN + 1];

int 	parse_arg(int argc,char **argv);
int	parse_file(FILE *file1);

int	InsertHistOlFeeSumBatch(char csList[][IMPORT_FIELD_LEN]);
int	DeleteRecord(const char* csDate);


int batch_init(int argc, char* argv[])
{
    if (argc < 2) {
        printf("usage:  -d Date\n");
        return FAILURE;
    }
    else
        return SUCCESS;
}



int batch_proc(int argc, char* argv[])
{
	char	cs_file1[PD_MAX_FILE_LEN + 1];
        FILE    *file1;
        int     iRet;

        iRet = parse_arg(argc,argv);
 
        if (iRet != SUCCESS){
		printf("usage:  -d Date\n");
                return (iRet);
	}

	char	cs_yyyy[PD_YYYY_LEN+1];
	char	cs_yyyymm[PD_YYYYMM_LEN+1];
	memset(cs_yyyy,0,PD_YYYY_LEN+1);
	memset(cs_yyyymm,0,PD_YYYYMM_LEN+1);
	strncpy(cs_yyyy,cs_date,4);
	strncpy(cs_yyyymm,cs_date,6);

	sprintf(cs_file1, "%s/%s/%s/%s/hist_ol_fee_sum_batch_%s.csv",getenv("REPORT_HOME"),cs_yyyy,cs_yyyymm,cs_date,cs_date);
        
        file1 = fopen(cs_file1,"r");
        
        if (file1 == NULL) {
DEBUGLOG(("Error Opening file = [%s]\n",cs_file1));
                return FAILURE;
        }

	iRet = DeleteRecord(cs_date);

	if (iRet == SUCCESS) {
        	iRet = parse_file(file1);
	}

        fclose(file1);

        return iRet;

}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}



int parse_arg(int argc,char **argv)
{
        char    c;
        strcpy(cs_date,"");

        while ((c = getopt(argc,argv,"d:")) != EOF) {
                switch (c) {
                        case 'd':
                                strcpy(cs_date, optarg);
                                break;
                        default:
                                return FAILURE;
                }
        }

        if (!strcmp(cs_date,""))
                return FAILURE;

        return SUCCESS;
}


int     parse_file(FILE *file1)
{
        int     iRet = SUCCESS;
        char    csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
        char    cs_input_buf[PD_MAX_BUFFER +1];;
        char*   p;
        int     iCount;


	while (fgets(cs_input_buf,PD_MAX_BUFFER,file1) != NULL)
        {
                iCount = 0;
                if ((cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A) || (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0D))
                cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
DEBUGLOG(("*[%s]\n",cs_input_buf));
                p = mystrtok(cs_input_buf,",");
                if (p == NULL)  {
                        return FAILURE;
                }

                if (strlen(p) > 0) {

                        if(p[strlen(p) - 1] == 0x0D)
                                p[strlen(p) - 1] = '\0';
                        strcpy(csList[iCount],p);
                }
                else {
                        csList[iCount][0] ='\0';
                }
                iCount++;

                while ( (p = mystrtok(NULL,",")) != NULL) {
                        if(p[strlen(p) - 1] == 0x0D)
                                p[strlen(p) - 1] = '\0';
                        strcpy(csList[iCount],p);
                        iCount++;
                }

		iRet = InsertHistOlFeeSumBatch(csList);
                if (iRet != SUCCESS)
                        break;

        }

DEBUGLOG(("Parsefile ret =[%d]\n",iRet));

        return iRet;
}

int     InsertHistOlFeeSumBatch(char csList[][IMPORT_FIELD_LEN])
{
        int     iRet = SUCCESS;
	int	iTmp;

	EXEC SQL WHENEVER SQLERROR GOTO errorhistolfeesumbatch;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                short		hv_return_value;

		int		hv_batch_id;
                varchar		hv_start_ts[PD_DATETIME_LEN];
                varchar		hv_end_ts[PD_DATETIME_LEN];
		int		hv_disabled;
                varchar		hv_create_ts[PD_DATETIME_LEN];
                varchar         hv_create_user[PD_USER_LEN];

                short           ind_batch_id = -1;
                short           ind_start_ts = -1;
                short           ind_end_ts = -1;
                short           ind_disabled = -1;
                short           ind_create_ts = -1;
                short           ind_create_user = -1;

        EXEC SQL END DECLARE SECTION;
DEBUGLOG(("Insert\n"));


//batch_id
        if (strlen(csList[IDX_BATCH_ID]) > 0 ) {
		iTmp = atoi(csList[IDX_BATCH_ID]);
		hv_batch_id = iTmp;
		ind_batch_id = 0;
DEBUGLOG(("Insert batch_id = [%d]\n",hv_batch_id));
        }

//start_ts
        if (strlen(csList[IDX_START_TS]) > 0 ) {
                hv_start_ts.len = strlen(csList[IDX_START_TS]);
                memcpy(hv_start_ts.arr,csList[IDX_START_TS],hv_start_ts.len);
                ind_start_ts = 0;
DEBUGLOG(("Insert start_ts = [%.*s]\n",hv_start_ts.len,hv_start_ts.arr));
        }

//end_ts
        if (strlen(csList[IDX_END_TS]) > 0 ) {
                hv_end_ts.len = strlen(csList[IDX_END_TS]);
                memcpy(hv_end_ts.arr,csList[IDX_END_TS],hv_end_ts.len);
                ind_end_ts = 0;
DEBUGLOG(("Insert end_ts = [%.*s]\n",hv_end_ts.len,hv_end_ts.arr));
        }

//disabled
        if (strlen(csList[IDX_DISABLED]) > 0 ) {
		iTmp = atoi(csList[IDX_DISABLED]);
		hv_disabled = iTmp;
		ind_disabled = 0;
DEBUGLOG(("Insert disabled = [%d]\n",hv_disabled));
        }

//create_ts
        if (strlen(csList[IDX_CREATE_TS]) > 0 ) {
                hv_create_ts.len = strlen(csList[IDX_CREATE_TS]);
                memcpy(hv_create_ts.arr,csList[IDX_CREATE_TS],hv_create_ts.len);
                ind_create_ts = 0;
DEBUGLOG(("Insert create_ts = [%.*s]\n",hv_create_ts.len,hv_create_ts.arr));
        }

//create_user 
	hv_create_user.len = strlen(PD_UPDATE_USER);
	memcpy(hv_create_user.arr,PD_UPDATE_USER,hv_create_user.len);
	ind_create_user = 0;
DEBUGLOG(("Insert detail create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));


        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_histolfeesumbatch_insert(
                                                :hv_batch_id:ind_batch_id,
						:hv_start_ts:ind_start_ts,
						:hv_end_ts:ind_end_ts,
                                                :hv_disabled:ind_disabled,
                                                :hv_create_ts:ind_create_ts,
                                                :hv_create_user:ind_create_user);
                END;
        END-EXEC;


        return iRet;

errorhistolfeesumbatch:
DEBUGLOG(("insert_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return FAILURE;
}


int     DeleteRecord(const char* csDate)
{
        char    *csBuf;

        EXEC SQL WHENEVER SQLERROR GOTO delete_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

        varchar         hv_dynstmt[PD_TMP_MSG_BUF_LEN];

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("DeleteRcord Start\n"));
        csBuf = (char*) malloc (PD_TMP_BUF_LEN);

/* delete hist_ol_fee_sum_batch2 */
        strcpy((char*)hv_dynstmt.arr,"delete from hist_ol_fee_sum_batch_2 where ");

        strcat((char*)hv_dynstmt.arr, "hb_start_date >= to_date('");
        strcat((char*)hv_dynstmt.arr, csDate);
        strcat((char*)hv_dynstmt.arr, "','YYYYMMDD') and ");
        strcat((char*)hv_dynstmt.arr, "hb_end_date < to_date('");
        strcat((char*)hv_dynstmt.arr, csDate);
        strcat((char*)hv_dynstmt.arr, "','YYYYMMDD')+1");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("delete [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));
        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        return SUCCESS;
delete_error:
DEBUGLOG(("delete_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return FAILURE;

}
