/*
Partnerdelight (c)2014. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/02/28              Virginia Yun
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"
#include "dates.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug = 'Y';
int	avai_po_percentage = 0;

OBJPTR(DB);

int parse_arg(int argc,char **argv);
int process_main();
int get_expired_list(recordset_t* myRec);
int get_txn_list(const char* csMerchantId, int iTxnAutoExpDays, int iTxnAutoExpMins, recordset_t *rRecordSet);

int AddTxnLog(const hash_t* hVal);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}




int batch_proc(int argc, char* argv[])
{
        int     iRet;

	iRet = parse_arg(argc,argv);
               
        if (iRet != SUCCESS) {
       // 	printf("usage:  -d cutoff_date\n");
                return (iRet);
        }

	iRet = process_main();

DEBUGLOG(("iRet = [%d]\n",iRet));

	return iRet;


}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}


int process_main()
{
	int iRet = SUCCESS;

	hash_t *hRec;

	char	*csMerchantID;
	char	*csTxnSeq;

	recordset_t     *rRecordSet;
	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));

	recordset_init(rRecordSet,0);

DEBUGLOG(("process_main\n"));

	iRet = get_expired_list(rRecordSet);

	if (iRet == SUCCESS) {

DEBUGLOG(("=====process update ======\n"));
		// process to lock and update
		hRec = RecordSet_GetFirst(rRecordSet);
		while (hRec) {
			if (GetField_CString(hRec, "merchant_id", &csMerchantID)) {
DEBUGLOG(("process_main merchant_id [%s]\n", csMerchantID));
			}

			if (GetField_CString(hRec, "txn_seq", &csTxnSeq)) {
DEBUGLOG(("process_main txn_seq [%s]\n", csTxnSeq));
			}

			hRec = RecordSet_GetNext(rRecordSet);
		}
	}

        RecordSet_Destroy(rRecordSet);
        FREE_ME(rRecordSet);

	return iRet;
}


int get_expired_list(recordset_t* myRec)
{
        int     iRet = SUCCESS;

        hash_t  *hRec;

        char    *csTmp;

        hash_t  *myHash;
        myHash = (hash_t*) malloc (sizeof(hash_t));

        recordset_t     *rRecordSet;
        rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));

DEBUGLOG(("process_main\n"));
        EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar v_merchant_id[PD_MERCHANT_ID_LEN + 1];
                int     v_txn_auto_exp_days;
                int     v_txn_auto_exp_mins;

                short   ind_merchant_id = -1;
                short   ind_txn_auto_exp_days = -1;
                short   ind_txn_auto_exp_mins = -1;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE c_cursor_get_mid CURSOR FOR
                SELECT md_merchant_id,
                       md_txn_auto_expired_days,
                       md_txn_auto_expired_mins
                FROM   ol_merch_detail
                WHERE  (md_txn_auto_expired_days != 0
                        OR    
                        md_txn_auto_expired_mins != 0
		       )
                ORDER BY md_merchant_id;

        EXEC SQL OPEN c_cursor_get_mid;
        do {

                EXEC SQL FETCH c_cursor_get_mid
                INTO
                        v_merchant_id:ind_merchant_id,
                        v_txn_auto_exp_days:ind_txn_auto_exp_days,
                        v_txn_auto_exp_mins:ind_txn_auto_exp_mins;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if (ind_merchant_id >= 0) {
                        v_merchant_id.arr[v_merchant_id.len] = '\0';
DEBUGLOG(("merchant_id = [%s]\n", v_merchant_id.arr));
                }

                if (ind_txn_auto_exp_days >= 0) {
DEBUGLOG(("txn_auto_exp_days = [%d]\n", v_txn_auto_exp_days));
                }  else {
                        v_txn_auto_exp_days = 0;
                }

                if (ind_txn_auto_exp_mins >= 0) {
DEBUGLOG(("txn_auto_exp_mins = [%d]\n", v_txn_auto_exp_mins));
                } else {
                        v_txn_auto_exp_mins = 0;
                }

		recordset_init(rRecordSet,0);

                if (v_txn_auto_exp_days > 0 && v_txn_auto_exp_mins > 0) {
DEBUGLOG(("!!!!! merchant_id = [%s] IS in List\n",  v_merchant_id.arr));

                        hash_init(myHash,0);
                        iRet = get_txn_list((const char*) v_merchant_id.arr,v_txn_auto_exp_days, v_txn_auto_exp_mins, rRecordSet);
                        if (iRet ==  SUCCESS) {
                                // Fetch rRecordSet
                                hRec = RecordSet_GetFirst(rRecordSet);
                                while (hRec) {

                                        if (GetField_CString(hRec, "merchant_id", &csTmp)) {
                                                PutField_CString(myHash, "merchant_id", csTmp);
                                        }

                                        if (GetField_CString(hRec, "txn_seq", &csTmp)) {
                                                PutField_CString(myHash, "txn_seq", csTmp);
                                        }

                                        hRec = RecordSet_GetNext(rRecordSet);
                                }
                                // Add into myRec
                                RecordSet_Add(myRec, myHash);
                        }

                        //hash_destroy(myHash);
                        //RecordSet_Destroy(rRecordSet);

                } else {
DEBUGLOG(("merchant_id [%s] not in list\n", v_merchant_id.arr));
                }

        } while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_get_mid;


        //FREE_ME(myHash);
        //FREE_ME(rRecordSet);

	return	iRet;

sql_error:
    DEBUGLOG(("process_main error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    ERRLOG("handle_auto_exp_off_merch_txn::process_main sql error %d\n", sqlca.sqlcode);

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_get_mid;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;

}


int get_txn_list(const char* csMerchantId, int iTxnAutoExpDays, int iTxnAutoExpMins, recordset_t *rRecordSet)
{
	int	iRet = SUCCESS;

        hash_t  *myHash;

DEBUGLOG(("get_txn_list\n"));
        EXEC SQL WHENEVER SQLERROR GOTO gettxnlist_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_merchant_id[PD_MERCHANT_ID_LEN];
                int     hv_txn_auto_exp_days;
                int     hv_txn_auto_exp_mins;
                varchar hv_txn_code[PD_TXN_CODE_LEN];
                char    hv_status;
                varchar hv_sub_status[PD_SUB_STATUS_LEN];

                varchar v_txn_id[PD_TXN_SEQ_LEN + 1];
                short   ind_txn_id = -1;
        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("get_txn_list Begin\n"));

        hv_merchant_id.len = strlen((const char*) csMerchantId);
        memcpy(hv_merchant_id.arr, csMerchantId, hv_merchant_id.len);
DEBUGLOG(("get_txn_list merchant_id [%.*s]\n", hv_merchant_id.len, hv_merchant_id.arr));

        hv_txn_auto_exp_days = iTxnAutoExpDays;
DEBUGLOG(("get_txn_list txn_auto_exp_days [%d]\n", hv_txn_auto_exp_days));

        hv_txn_auto_exp_mins = iTxnAutoExpMins;
DEBUGLOG(("get_txn_list txn_auto_exp_mins [%d]\n", hv_txn_auto_exp_mins));

        hv_txn_code.len = strlen(PD_INITIAL_OLN_TXN_CODE);
        memcpy(hv_txn_code.arr, PD_INITIAL_OLN_TXN_CODE, hv_txn_code.len);
DEBUGLOG(("get_txn_list txn_code [%.*s]\n", hv_txn_code.len, hv_txn_code.arr));

        hv_status = PD_TO_PSP;
DEBUGLOG(("get_txn_list status [%c]\n", hv_status));

        hv_sub_status.len = strlen(PD_SENT_TO_PSP);
        memcpy(hv_sub_status.arr, PD_SENT_TO_PSP, hv_sub_status.len);
DEBUGLOG(("get_txn_list sub_status [%.*s]\n", hv_sub_status.len,hv_sub_status.arr));

        EXEC SQL DECLARE c_cursor_get_txn CURSOR FOR
                SELECT oth_txn_id
                FROM   ol_txn_header
                WHERE  oth_merchant_id = :hv_merchant_id
                AND    oth_txn_code = :hv_txn_code
                AND    oth_status = :hv_status
                AND    oth_ar_ind is null
                AND    oth_sub_status = :hv_sub_status
                AND    oth_create_timestamp < sysdate - (:hv_txn_auto_exp_days + :hv_txn_auto_exp_mins/(60*24))
                ORDER BY oth_create_timestamp;

        EXEC SQL OPEN c_cursor_get_txn;
        do {
                EXEC SQL FETCH c_cursor_get_txn
                INTO :v_txn_id:ind_txn_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash, 0);

// Txn ID
                if (ind_txn_id >= 0) {
                        v_txn_id.arr[v_txn_id.len] = '\0';
                        PutField_CString(myHash, "txn_seq", (const char*) v_txn_id.arr);
DEBUGLOG(("get_txn_list txn_id = [%s]\n", v_txn_id.arr));
                }

                PutField_CString(myHash, "merchant_id", csMerchantId);

                RecordSet_Add(rRecordSet, myHash);
        } while (PD_TRUE);

        EXEC SQL CLOSE c_cursor_get_txn;

        return iRet;
gettxnlist_error:
DEBUGLOG(("gettxnlist_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("handle_auto_exp_off_merch_txn::gettxnlist_error error %d\n", sqlca.sqlcode);

        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_get_txn;
        return PD_ERR;
}

int parse_arg(int argc,char **argv)
{
/*
        char    c;
	strcpy(cs_cutoff_date,"");

        while ((c = getopt(argc,argv,"d:")) != EOF) {
                switch (c) {
                        case 'd':
                                strcpy(cs_cutoff_date, optarg);
                                break;
                        default:
                                return FAILURE;
                }
        }

        if (!strcmp(cs_cutoff_date,"")) 
                return FAILURE;

*/
        return SUCCESS;
}


