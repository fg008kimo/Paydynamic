/*
Partnerdelight (c)2011. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/22              Cody Chan

*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "eod_glutility.h"

char	cDebug = 'Y';

void append_node(struct NODE *llist, const char* csKey,const char cType);
void delete_node(struct NODE *llist, const char* csKey);
int search_value(struct NODE *llist, const char* csKey);
int UpdateAmt(hash_t *hRec,
		const char* csKey,
		double	dAmt);

int GenSQL(const char* csTxnDate,
		data_t *data,
		unsigned char* csSQL) 
{
	char*	csBuf;
	int	iRet = PD_OK;

	csBuf = (char*) malloc ( PD_TMP_BUF_LEN  +1);
	if (strlen(csSQL) != 0) {
		sprintf(csBuf,"\nunion\n");
		strcat(csSQL,csBuf);
	}

 	strcat(csSQL,"select th_txn_id,");
 	strcat(csSQL,"\n");
        strcat(csSQL,"th_txn_code,");
 	strcat(csSQL,"\n");
        strcat(csSQL,"td_txn_country,");
 	strcat(csSQL,"\n");
        strcat(csSQL,"th_merchant_id,");
 	strcat(csSQL,"\n");
        strcat(csSQL,"th_service_code,");
 	strcat(csSQL,"\n");
        strcat(csSQL,"tp_psp_id,");

/* txn type */
	sprintf(csBuf,"'%s' as TXN_TYPE,\n",data->type);
	strcat(csSQL,csBuf);

/* ccy */
	sprintf(csBuf,"%s as ccy,\n",data->ccyname);
	strcat(csSQL,csBuf);

/* amt */
	sprintf(csBuf,"%s as amount\n",data->amtname);
	strcat(csSQL,csBuf);

  	strcat(csSQL,"from txn_header, ");
 	strcat(csSQL,"\n");
        strcat(csSQL,"txn_detail, ");
 	strcat(csSQL,"\n");
        strcat(csSQL,"txn_psp_detail ");
 	strcat(csSQL,"\n");
	if (strlen(data->chargetype) > 0) {
        	strcat(csSQL,",txn_fee_charge ");
 		strcat(csSQL,"\n");
	}
/* approval date */
	sprintf(csBuf,"where th_approval_date ='%s'\n ",csTxnDate);
	strcat(csSQL,csBuf);

        strcat(csSQL,"and th_txn_id = td_txn_id ");
 	strcat(csSQL,"\n");
    	strcat(csSQL,"and th_txn_id = tp_txn_id ");
 	strcat(csSQL,"\n");
    	strcat(csSQL,"and th_txn_code in ('DSI','DSP')");
 	strcat(csSQL,"\n");

	if (strlen(data->chargetype) > 0) {
    		strcat(csSQL,"and th_txn_id = tf_txn_id ");
 		strcat(csSQL,"\n");
    		sprintf(csBuf,"and tf_chg_type = '%s' \n",data->chargetype);
 		strcat(csSQL,csBuf);
    		sprintf(csBuf,"and tf_party_type = '%c' ",data->custtype);
 		strcat(csSQL,csBuf);
	}
	
	FREE_ME(csBuf);
	return	iRet;
}

int GroupRecs(hash_t	*hRec,
		struct NODE *llist,
		const char* csTxnCode,
                const char* csCountry,
                const char* csMerchantId,
                const char* csPspId,
                const char* csTxnType,
                const char* csCcy,
                double  dAmt)
{
	int	iRet = PD_OK;
	char	*csTag;
	char	*csTxn;

	csTag = (char*) malloc (PD_TMP_BUF_LEN +1);

/* DSP */
	if (!strcmp(csTxnCode,PD_DEPOSIT_TXN_CODE) || !strcmp(csTxnCode,PD_INITIAL_TXN_CODE)) {
		csTxn = strdup(PD_INITIAL_TXN_CODE);
	}
	else 
		csTxn = strdup(csTxnCode);

	insert_node(llist,csPspId,PD_TYPE_PSP);
	insert_node(llist,csMerchantId,PD_TYPE_MERCHANT);
/* psp */
	if (!strcmp(csTxnType,PD_TYPE_PSP_AMT) ||
	    !strcmp(csTxnType,PD_TYPE_PSP_FEE)) {
		sprintf(csTag,"%s_%s_%s_%s_%s",csTxnCode,csCountry,csPspId,csTxnType,csCcy);
	}
	else {
		sprintf(csTag,"%s_%s_%s_%s_%s",csTxnCode,csCountry,csMerchantId,csTxnType,csCcy);
	}
	iRet = UpdateAmt(hRec,csTag,dAmt);
	FREE_ME(csTag);
	FREE_ME(csTxn);
	return iRet;
}


int UpdateAmt(hash_t *hRec,
		const char* csKey,
		double	dAmt)
{
	int	iRet = PD_OK;
	double	dTmp;

        if (GetField_Double(hRec,csKey,&dTmp)) {
LOGME(("UpdateAmt [%s] = [%lf]\n",csKey,dTmp));
        }
        else {
                dTmp = 0.0;
        }

        dTmp += dAmt;
LOGME(("UpdateAmt *[%s] = [%lf]\n",csKey,dTmp));
        PutField_Double(hRec,csKey,dTmp);
	
	return	iRet;
}


void append_node(struct NODE *llist, const char* csKey,const char cType) {
	while(llist->next != NULL)
  		llist = llist->next;

 	llist->next = (struct NODE *)malloc(sizeof(struct NODE));
 	llist->next->key = strdup(csKey);
 	llist->next->type = cType;
 	llist->next->next = NULL;
}


void delete_node(struct NODE *llist, const char* csKey) {
	struct NODE *temp;
 	temp = (struct NODE *)malloc(sizeof(struct NODE));

 	if(!strcmp(llist->key,csKey)) {
  	/* remove the node */
  		temp = llist->next;
  		free(llist);
  		llist = temp;
 	} else {
  		while(strcmp(llist->next->key,csKey))
   			llist = llist->next;

  		temp = llist->next->next;
  		free(llist->next);
  		llist->next = temp;
 	}   
}



int search_value(struct NODE *llist, const char* csKey) {
	int retval = -1;
 	int i = 1;

 	while(llist->next != NULL) {
  	if(!strcmp(llist->next->key,csKey))
   		return i;
  	else
   		i++;

  	llist = llist->next;
 	}

	return retval;
}

void insert_node(struct NODE *llist, const char* csKey,char cType) {
	int retval = -1;
	if((retval = search_value(llist, csKey)) == -1)
		append_node(llist,csKey,cType);
}
