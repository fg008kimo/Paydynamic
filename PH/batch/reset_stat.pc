/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/05/03              LokMan Chow
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "batchcommon.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode
#define PD_DEADLOCK_ERR -60

char	cs_date[PD_DATE_LEN + 1];
char	cDebug = 'Y';

int	parse_arg(int argc,char **argv);
int	reset_stat(const char cType);
int 	is_first_day_of_week(const char* csDate);
int 	is_first_day_of_month(const char* csDate);
int	check_counter(const char cType);

int batch_init(int argc, char* argv[])
{
/*
    if (argc < 2)
        return FAILURE;
    else
*/
        return SUCCESS;
}


int batch_terminate(int argc, char* argv[])
{
    return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	int iRet = SUCCESS;

	iRet = parse_arg(argc,argv);
	if(iRet != SUCCESS){
		printf("usage: -d date\n");
		return (iRet);
	}
		
	if(iRet==SUCCESS){
		iRet = reset_stat(PD_DAILY);
	}
/*	if(iRet==PD_DEADLOCK_ERR){
		/////try one more time
		iRet = reset_stat(PD_DAILY);
	}
*/
	if(iRet==SUCCESS){
		iRet = check_counter(PD_DAILY);
	}

	if(iRet==SUCCESS){
		if(is_first_day_of_week(cs_date)==PD_TRUE){
			iRet = reset_stat(PD_WEEKLY);
		}
	}

	if(iRet==SUCCESS){
		if(is_first_day_of_month(cs_date)==PD_TRUE){
			iRet = reset_stat(PD_MONTHLY);
		}
	}


	return iRet;
}

int reset_stat(const char cType)
{
	int iRet = SUCCESS;
	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		char         hv_type;

	EXEC SQL END DECLARE SECTION;

	hv_type = cType;
DEBUGLOG(("reset_stat type[%c]\n", cType));

	EXEC SQL DELETE FROM	txn_counters
		WHERE		tc_type = :hv_type;

DEBUGLOG(("reset_stat finished\n"));
        return iRet;

sql_error:
DEBUGLOG(("sql_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("reset_stat::sql_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    iRet = sqlca.sqlcode;
    return FAILURE;
}


int is_first_day_of_week(const char* csDate)
{
	int iRet = PD_FALSE;
	int i=0;
	
	i=day_of_week((const unsigned char *)csDate);
	if(i==1){
		iRet = PD_TRUE;
DEBUGLOG(("is_first_day_of_week = TRUE\n"));
	}
	else if(i==PD_ERR){
DEBUGLOG(("is_first_day_of_week invalid date[%s]\n", csDate));
	}
	else{
DEBUGLOG(("is_first_day_of_week = FALSE\n"));
	}
	
	return iRet;
}

int is_first_day_of_month(const char* csDate)
{
	int iRet = PD_FALSE;

	if(strncmp(&csDate[PD_YYYYMM_LEN],"01",PD_DD_LEN)==0){
		iRet = PD_TRUE;
DEBUGLOG(("is_first_day_of_month = TRUE\n"));
	}
	else{
DEBUGLOG(("is_first_day_of_month = FALSE\n"));
	}

	return iRet;
}


int parse_arg(int argc,char **argv)
{
	char    c;
	strcpy(cs_date,"");

	while ((c = getopt(argc,argv,"d:")) != EOF) {
		switch (c) {
			case 'd':
				strcpy(cs_date, optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (!strcmp(cs_date,""))
		return FAILURE;

	return SUCCESS;
}

int check_counter(const char cType)
{
	EXEC SQL WHENEVER SQLERROR GOTO check_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		char         hv_type;

		int	     v_cnt;

		short	     ind_cnt = -1;
	EXEC SQL END DECLARE SECTION;

	hv_type = cType;
DEBUGLOG(("check_counter type[%c]\n", cType));

	EXEC SQL SELECT count(*)
		INTO	:v_cnt:ind_cnt
		FROM	txn_counters
		WHERE	tc_type = :hv_type;


	if(ind_cnt<0)
		v_cnt = 0;

	if(v_cnt>1){
DEBUGLOG(("check_counter Failed! counter=[%d]\n",v_cnt));
		return FAILURE;
	}
	else{
DEBUGLOG(("check_counter Success! counter=[%d]\n",v_cnt));
		return SUCCESS;
	}

check_error:
DEBUGLOG(("check_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("reset_stat::check_error code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return FAILURE;
}
