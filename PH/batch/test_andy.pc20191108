#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <sqlca.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "myrecordset.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

static char     cDebug = 'Y';
char            cType;
char            csFunc[PD_TAG_LEN] = "";
char            csRemark[PD_REMARK_LEN] = "";
char            csBankCode[PD_BANK_CODE_LEN] = "";
double          dMin_amt = 0.0;
int             iSupport_po = 0;

OBJPTR(DB);

static int parse_arg(int argc, char ** argv)
{
        char c;

        while ((c = getopt(argc, argv, "b:t:s:m:r:f:")) != EOF)
        {
                switch (c)
                {
                        case 'b':
                                strcpy(csBankCode, optarg);
                                break;

                        case 't':
                                cType = optarg[0];
                                break;

                        case 's':
                                iSupport_po = atoi(optarg);
                                break;

                        case 'm':
                                sscanf(optarg, "%lf", &dMin_amt);
                                break;

                        case 'r':
                                strcpy(csRemark, optarg);
                                break;

                        case 'f':
                                strcpy(csFunc, optarg);
                                break;

                        default:
                                return PD_ERR;
                }
        }

        if (!strcmp(csBankCode, "") || (cType == '\0') || (iSupport_po < 0) || (dMin_amt < 0.0) || !strcmp(csRemark, "") || !strcmp(csFunc, ""))
        {
printf("Fail in parsing arguments\n");
                return PD_ERR;
        }

printf("BANK_CODE [%s], TYPE [%c], SUPPORT_PO [%d], MIN_AMT [%lf], REMARK [%s], FUNCTION [%s]\n", csBankCode, cType, iSupport_po, dMin_amt, csRemark, csFunc);
        return PD_OK;
}

int batch_init(int argc, char * argv[])
{
        if (argc < 7)
        {
printf("Usage: %s -b <BANK_CODE> -t <TYPE> -s <SUPPORT_PO> -m <MIN_AMT> -r <REMARK> -f <FUNCTION>\n", argv[0]);
                return FAILURE;
        }
        else
                return SUCCESS;
}

int batch_proc(int argc, char * argv[])
{
        if (parse_arg(argc, argv) != PD_OK)
        {
                exit(1);
        }

        char    cTmp;
        char    * csTmp = NULL;
        double  dTmp = 0.0;
        int     iTmp = 0;
        int     iRet = PD_OK;
        hash_t  * hIn;
        hash_t  * hOut;

        hIn = (hash_t *)malloc(sizeof(hash_t));
        hash_init(hIn, 0);

        hOut = (hash_t *)malloc(sizeof(hash_t));
        hash_init(hOut, 0);

        PutField_CString(hIn, "bank_code", csBankCode);
        PutField_Char(hIn, "type", cType);
        PutField_Int(hIn, "support_po", iSupport_po);
        PutField_Double(hIn, "min_amt", dMin_amt);
        PutField_CString(hIn, "remark", csRemark);
        PutField_CString(hIn, "create_user", PD_UPDATE_USER);

printf("Call TestAndy: %s\n", csFunc);

        DBObjPtr = CreateObj(DBPtr, "DBTestAndy", csFunc);

        if (!strcmp(csFunc, "Add") || !strcmp(csFunc, "Update"))
                iRet = (unsigned long)(DBObjPtr)(hIn);
        else
        {
                iRet = PD_ERR;
printf("Invalid Function!!\n");
        }

printf("TestAndy: %s iRet = [%d]\n", csFunc, iRet);

        if (iRet == PD_OK)
        {
printf("Call TestAndy: GetByBankCode [%s]\n", csBankCode);

                DBObjPtr = CreateObj(DBPtr, "DBTestAndy", "GetByBankCode");

                if ((unsigned long)(DBObjPtr)(csBankCode, hOut) == PD_FOUND)
                {
                        if (GetField_Char(hOut, "type", &cTmp))
printf("Type = [%c]\n", cTmp);

                        if (GetField_Int(hOut, "support_po", &iTmp))
printf("Support_po = [%d]\n", iTmp);

                        if (GetField_Double(hOut, "min_amt", &dTmp))
printf("Min_amt = [%lf]\n", dTmp);

                        if (GetField_CString(hOut, "remark", &csTmp))
printf("Remark = [%s]\n", csTmp);
                }
        }

        if (iRet == PD_OK)
        {
printf("Call TestAndy: GetByType [%c]\n", cType);

                int             iCnt = 0;
                hash_t          * hRec;
                recordset_t     * rInfoSet;

                rInfoSet = (recordset_t *)malloc(sizeof(recordset_t));
                recordset_init(rInfoSet, 0);

                DBObjPtr = CreateObj(DBPtr, "DBTestAndy", "GetByType");

                if ((unsigned long)(DBObjPtr)(cType, rInfoSet) == PD_FOUND)
                {
                        hRec = RecordSet_GetFirst(rInfoSet);

                        while (hRec)
                        {
                                if (GetField_CString(hRec, "bank_code", &csTmp))
printf("[%d] Bank_Code = [%s]\n", iCnt, csTmp);

                                if (GetField_Int(hRec, "support_po", &iTmp))
printf("[%d] Flag = [%d]\n", iCnt, iTmp);

                                if (GetField_Double(hRec, "min_amt", &dTmp))
printf("[%d] Min_amt = [%lf]\n", iCnt, dTmp);

                                if (GetField_CString(hRec, "remark", &csTmp))
printf("[%d] Remark = [%s]\n", iCnt, csTmp);

                                iCnt++;
                                hRec = RecordSet_GetNext(rInfoSet);
                        }
                }

                RecordSet_Destroy(rInfoSet);
                FREE_ME(rInfoSet);
        }

        FREE_ME(hIn);
        FREE_ME(hOut);

printf("batch_proc end\n");
        return iRet;
}

int batch_terminate(int argc, char * argv[])
{
        return SUCCESS;
}

