/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/21	             Simon Fung
Update to new requirment                           2013/12/05	             Virginia Yun
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "eod_offext_glpost.h"
#include "mymd5.h"
#include "eod_glutility.h"
#include "ObjPtr.h"

OBJPTR(BO);
OBJPTR(DB);

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define	PD_MY_DELIMITOR	","
#define	PD_FILE_DELIMITOR "	"
#define	PD_HASHKEY_DELIMITOR ":"

#define	PD_CHAR		0x0D
#define	PD_SPACE	0x20

char    cDebug = 'Y';
char    cs_inputfile[PD_MAX_FILE_LEN + 1];
char    cs_date[PD_DATE_LEN + 1];

short is_float(char* str);
int parse_arg(int argc,char **argv);
int verify_file(FILE *fin);
int process_file(FILE *fin);
int myGroupRecs(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], hash_t *hTxn, hash_t *hCnt, char* csKey, double dAmt, int* iJnlKeyCnt);
int myPostTxn(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], const hash_t *hTxn, const hash_t *hCnt, const int iJnlKeyCnt);
int ChkCloseMonth();

short is_float(char* str)
{
	int i_len = strlen(str);
	int i;
	
	for (i = 0; i < i_len; i++)
		if ((!isdigit(str[i])) && (str[i]!='.'))
			return PD_FALSE;
	
	return PD_TRUE;
}

int batch_init(int argc, char* argv[])
{
	if (argc < 1) {
		printf("usage: -d Date -f data_file\n");
	    return FAILURE;
	}
	else
	    return SUCCESS;
}



int batch_proc(int argc, char* argv[])
{
	FILE	*fin;
	int	iRet;
	
	iRet = parse_arg(argc,argv);

	if (iRet != SUCCESS) {
    		printf("*usage: -d Date -f data_file\n");
		return (iRet);
	}

	iRet = ChkCloseMonth();
DEBUGLOG(("ChkCloseMonth [%d]\n", iRet));

	if (iRet == SUCCESS) {
		fin = fopen(cs_inputfile,"r");
		if (fin == NULL) {
DEBUGLOG(("Error Opening file = [%s]\n",cs_inputfile));
			return FAILURE;
		}

DEBUGLOG(("Opened file = [%s] for read\n",cs_inputfile));

		iRet = verify_file(fin);
DEBUGLOG(("verify_file result = [%d]\n",iRet));	

DEBUGLOG(("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"));

		if (iRet == SUCCESS) {
			rewind(fin);
			iRet = process_file(fin);
		}

		fclose(fin);
	}

DEBUGLOG(("END !!!\n"));

	return iRet;

}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}
                     
int parse_arg(int argc,char **argv)
{               
	char    c;

	strcpy(cs_date, "");
	strcpy(cs_inputfile,"");
	          
	while ((c = getopt(argc,argv,"d:f:")) != EOF) {
		switch (c) {
			case 'd':
				strcpy(cs_date, optarg);
				break;
			case 'f':
				strcpy(cs_inputfile, optarg);
				break;
			default:
				return FAILURE;
		}
	}       

	if (!strcmp(cs_date,"") || !strcmp(cs_inputfile, "")) {
		return FAILURE;
	}
	
DEBUGLOG(("Date [%s]\n",cs_date));
DEBUGLOG(("Input File [%s]\n",cs_inputfile));


	return SUCCESS; 
}               

int verify_file(FILE *fin)
{
	int	iRet = SUCCESS;
	int	iLineCnt = 0;
	int	iCount = 0;
	int	iMerchKeyCnt;
	int	iPSPKeyCnt;
	char	csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
	char	cs_input_buf[PD_MAX_BUFFER +1];;
	char	*p=NULL;
	char	csKey[PD_TMP_MSG_BUF_LEN];
	
	char	*csSign;
	csSign = (char*) malloc (1024 * 2 +1);

	char *csOUT;
	csOUT = (char*) malloc (1024 * 2 +1);

	char	*csBuf;


	char csCalSign[OFFLINE_CHECKSUM_LEN+1];
	
	iMerchKeyCnt = 0;
	iPSPKeyCnt = 0;
  

	while (fgets(cs_input_buf,PD_MAX_BUFFER, fin) != NULL) {

		if ((cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A) || (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0D)) {
			cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
		}

		if(cs_input_buf[strlen(cs_input_buf) - 1] == 0x00) {
			continue;
		}
DEBUGLOG((">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"));
DEBUGLOG(("LineCnt [%d] DATA [%s]\n", iLineCnt, cs_input_buf));

		iCount = 0;
		
		p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
		if (p != NULL) {
			strcpy(csList[iCount], TrimAllChar((const unsigned char *)p, strlen(p), OFFLINE_MY_TOKEN));
			iCount++;

			while ( (p = mystrtok(NULL, PD_MY_DELIMITOR)) != NULL) {
				strcpy(csList[iCount], TrimAllChar((const unsigned char *)p, strlen(p), OFFLINE_MY_TOKEN));
				iCount++;
			}
		} else {
DEBUGLOG(("Invalid File Detail"));
			iRet = FAILURE;
			break;
		}
		
		if (iCount == DETAIL_ITEM_SIZE) {
			iLineCnt++;
				
			// Detail
/*
DEBUGLOG(("IDX_TXN_TYPE=[%s]\n",csList[IDX_TXN_TYPE]));
DEBUGLOG(("IDX_COUNTRY_CODE=[%s]\n",csList[IDX_COUNTRY_CODE]));
DEBUGLOG(("IDX_TXN_DATE=[%s]\n",csList[IDX_TXN_DATE]));
DEBUGLOG(("IDX_TXN_ID=[%s]\n",csList[IDX_TXN_ID]));
DEBUGLOG(("IDX_MERCHANT=[%s]\n",csList[IDX_MERCHANT]));
DEBUGLOG(("IDX_PSP=[%s]\n",csList[IDX_PSP]));
DEBUGLOG(("IDX_TXN_AMT_CCY=[%s]\n",csList[IDX_TXN_AMT_CCY]));
DEBUGLOG(("IDX_TXN_AMT=[%s]\n",csList[IDX_TXN_AMT]));
DEBUGLOG(("IDX_TXN_FEE_CCY=[%s]\n",csList[IDX_TXN_FEE_CCY]));
DEBUGLOG(("IDX_TXN_FEE=[%s]\n",csList[IDX_TXN_FEE]));
DEBUGLOG(("IDX_NET_AMT_CCY=[%s]\n",csList[IDX_NET_AMT_CCY]));
DEBUGLOG(("IDX_NET_AMT=[%s]\n",csList[IDX_NET_AMT]));
DEBUGLOG(("IDX_MU_AMT_CCY=[%s]\n",csList[IDX_MU_AMT_CCY]));
DEBUGLOG(("IDX_MU_AMT=[%s]\n",csList[IDX_MU_AMT]));
DEBUGLOG(("IDX_PSP_AMT_CCY=[%s]\n",csList[IDX_PSP_AMT_CCY]));
DEBUGLOG(("IDX_PSP_AMT=[%s]\n",csList[IDX_PSP_AMT]));
DEBUGLOG(("IDX_TXN_STATUS=[%s]\n",csList[IDX_TXN_STATUS]));
DEBUGLOG(("IDX_MERCHANT_REF=[%s]\n",csList[IDX_MERCHANT_REF]));
*/				
DEBUGLOG(("IDX_DTL_CHECKSUM=[%s]\n",csList[IDX_DTL_CHECKSUM]));
			// Build Key
			memset(csKey, 0, sizeof(csKey));

			strcpy(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, csList[IDX_TXN_ID]);
			strcat(csKey, csList[IDX_MERCHANT]);
			strcat(csKey, csList[IDX_PSP]);
			strcat(csKey, csList[IDX_TXN_AMT_CCY]);
			strcat(csKey, csList[IDX_TXN_AMT]);
			strcat(csKey, csList[IDX_TXN_FEE]);
			strcat(csKey, csList[IDX_NET_AMT]);
			strcat(csKey, csList[IDX_MU_AMT]);
			strcat(csKey, csList[IDX_PSP_AMT]);
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, csList[IDX_MERCHANT_REF]);
		
DEBUGLOG(("csKey [%s]\n", csKey));
	
			strcpy(csSign, csList[IDX_DTL_CHECKSUM]);		

			csBuf = (char*) malloc (1024 * 2 +1);

			md5sum(csKey,strlen(csKey),csOUT);
//DEBUGLOG(("csOUT [%s]\n", csOUT));

			csBuf[0]= '\0';
			U2L(csOUT, strlen(csOUT), csBuf);

			strncpy(csCalSign, csBuf, OFFLINE_CHECKSUM_LEN);
			csCalSign[OFFLINE_CHECKSUM_LEN] = '\0';
DEBUGLOG(("Cal MD5 [%s]\n", csCalSign));
										
			if (strcmp(csSign,csCalSign) != 0) {
DEBUGLOG(("Invalid Detail Checksum at line %d, [%s] <> Calculated:[%s]\n",iLineCnt, csSign, csCalSign));
				iRet = FAILURE;
			}

			if (iRet == SUCCESS) {	
				// Verify date format
				if (strlen(csList[IDX_TXN_DATE])!=PD_DATE_LEN) {
DEBUGLOG(("Invalid Date format at line %d, [%s]\n",iCount, csList[IDX_TXN_DATE]));
					iRet = FAILURE;				
				}
			}

			FREE_ME(csBuf);
				
		} else {
DEBUGLOG(("Invalid Detail size =[%d]\n",iCount));
			iRet = FAILURE;
		}			

	} 

	if (iLineCnt == 0) {
DEBUGLOG(("No File Detail Found\n"));

	}

	// Clean up
	FREE_ME(csSign);
	FREE_ME(csOUT);
	FREE_ME(csBuf);
	FREE_ME(p);

DEBUGLOG(("verify_file completed return =[%d]\n",iRet));
	return iRet;
}

int process_file(FILE *fin)
{
	int iRet = SUCCESS;
	int iLineCnt = 0;
	int	iCount;
	int iJnlKeyCnt=0;	
	char    csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
	char    csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN];
	char    cs_input_buf[PD_MAX_BUFFER +1];;
	char	*p;
	char csPartyType[1];
	double 	dTmpAmt;

	char csPartyID[PD_CRR_MERCH_ID_LEN];
	
	// For calculating FX gain/loss for MST
	double dMstFxGainLoss = 0;
	
	char csKey[PD_TMP_MSG_BUF_LEN];
	
	hash_t *hTxnAmt;
	hTxnAmt = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hTxnAmt,0);
	
	hash_t *hCnt;
	hCnt = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hCnt,0);	
	
	memset(csJnlKeys, 0, sizeof(csJnlKeys));
  
	iLineCnt = 0;
	while (fgets(cs_input_buf,PD_MAX_BUFFER, fin) != NULL) {

		memset(csList, 0, sizeof(csList));
		iLineCnt++;
	
                if ((cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A) || (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0D)) {
			cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
		}

                if(cs_input_buf[strlen(cs_input_buf) - 1] == 0x00) {
                        continue;
		}
DEBUGLOG(("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n"));
DEBUGLOG(("process_file [%d] DATA [%s]\n", iLineCnt, cs_input_buf));

    		iCount = 0;
		p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
		if (p != NULL) {
			strcpy(csList[iCount],TrimAllChar((const unsigned char *)p, strlen(p), OFFLINE_MY_TOKEN));
			iCount++;

                        while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
                                strcpy(csList[iCount], TrimAllChar((const unsigned char*)p, strlen(p), OFFLINE_MY_TOKEN));
                                iCount++;
                        }

		} else  {
			iRet = FAILURE;
			break;
		}

		// Detail
/*
DEBUGLOG(("IDX_TXN_TYPE=[%s]\n",csList[IDX_TXN_TYPE]));
DEBUGLOG(("IDX_COUNTRY_CODE=[%s]\n",csList[IDX_COUNTRY_CODE]));
DEBUGLOG(("IDX_TXN_DATE=[%s]\n",csList[IDX_TXN_DATE]));
DEBUGLOG(("IDX_TXN_ID=[%s]\n",csList[IDX_TXN_ID]));
DEBUGLOG(("IDX_MERCHANT=[%s]\n",csList[IDX_MERCHANT]));
DEBUGLOG(("IDX_PSP=[%s]\n",csList[IDX_PSP]));
DEBUGLOG(("IDX_TXN_AMT_CCY=[%s]\n",csList[IDX_TXN_AMT_CCY]));
DEBUGLOG(("IDX_TXN_AMT=[%s]\n",csList[IDX_TXN_AMT]));
DEBUGLOG(("IDX_TXN_FEE_CCY=[%s]\n",csList[IDX_TXN_FEE_CCY]));
DEBUGLOG(("IDX_TXN_FEE=[%s]\n",csList[IDX_TXN_FEE]));
DEBUGLOG(("IDX_NET_AMT_CCY=[%s]\n",csList[IDX_NET_AMT_CCY]));
DEBUGLOG(("IDX_NET_AMT=[%s]\n",csList[IDX_NET_AMT]));
DEBUGLOG(("IDX_MU_AMT_CCY=[%s]\n",csList[IDX_MU_AMT_CCY]));
DEBUGLOG(("IDX_MU_AMT=[%s]\n",csList[IDX_MU_AMT]));
DEBUGLOG(("IDX_PSP_AMT_CCY=[%s]\n",csList[IDX_PSP_AMT_CCY]));
DEBUGLOG(("IDX_PSP_AMT=[%s]\n",csList[IDX_PSP_AMT]));
DEBUGLOG(("IDX_TXN_STATUS=[%s]\n",csList[IDX_TXN_STATUS]));
DEBUGLOG(("IDX_MERCHANT_REF=[%s]\n",csList[IDX_MERCHANT_REF]));
DEBUGLOG(("IDX_DTL_CHECKSUM=[%s]\n",csList[IDX_DTL_CHECKSUM]));
*/

		memset(csPartyID, 0, sizeof(csPartyID));
		if (strlen(csList[IDX_PSP]) > 0) {
			DBObjPtr = CreateObj(DBPtr,"DBCrrExtPspDetail","GetPspIDbyExtPsp");
			if ((unsigned long)(*DBObjPtr)(OFFLINE_PRODUCT_CODE, csList[IDX_PSP], csPartyID) == FOUND) {
DEBUGLOG(("Provider csPartyID = [%s]\n", csPartyID));

			} else {
				iRet = FAILURE;
				break;
			}

		}


		// Convert Transaction Type to PD TXN CODE
		if (!strcmp(csList[IDX_TXN_TYPE],DSP_TYPE)) {
			// Deposit
			strcpy(csList[IDX_TXN_TYPE], CRR_OFF_DEPOSIT_TXN_CODE);

			// Reset FX Gain/Loss
			dMstFxGainLoss = 0.0;

			// -----------------------------------------------------------
			// Merchant Net Amount
			// -----------------------------------------------------------
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, CRR_AMT_TYPE_NET_AMT); //
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
			strcat(csKey, csPartyType);			
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_MERCHANT]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_NET_AMT_CCY]); //
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_CR);			


			if (!is_float(csList[IDX_NET_AMT])) {
DEBUGLOG(("Invalid Net Amount at line [%d] value [%s]\n",iLineCnt, csList[IDX_NET_AMT]));
				iRet = FAILURE;

			}				

			if (iRet == SUCCESS) {
				dTmpAmt = atof(csList[IDX_NET_AMT]);

DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", DSP_TYPE, CRR_AMT_TYPE_NET_AMT, csKey, dTmpAmt));

				iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);
			}

			if (iRet == SUCCESS) {
			
				// -----------------------------------------------------------
				// Provider Txn Amount
				// -----------------------------------------------------------
				strcpy(csKey, "");
				strcat(csKey, csList[IDX_TXN_TYPE]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, CRR_AMT_TYPE_TXN_AMT); //
				strcat(csKey, PD_HASHKEY_DELIMITOR);
				strcat(csKey, csList[IDX_TXN_DATE]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, csList[IDX_TXN_STATUS]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);				
				strcat(csKey, csList[IDX_COUNTRY_CODE]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);				
				sprintf(csPartyType, "%c", PD_TYPE_PSP);
				strcat(csKey, csPartyType);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				//strcat(csKey, csList[IDX_PSP]);	
				strcat(csKey, csPartyID);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, csList[IDX_TXN_AMT_CCY]); //
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, PD_DR);			

				if (!is_float(csList[IDX_TXN_AMT])) {
DEBUGLOG(("Invalid Txn Amount at line [%d] value = [%s]",iLineCnt,csList[IDX_NET_AMT]));
					iRet = FAILURE; 
				}

				if (iRet == SUCCESS) {
					dTmpAmt = atof(csList[IDX_TXN_AMT]);
DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", DSP_TYPE, CRR_AMT_TYPE_TXN_AMT, csKey, dTmpAmt));
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);
				}
			}
	

			if (iRet == SUCCESS) {	
				// -----------------------------------------------------------
				// Txn Fee
				// -----------------------------------------------------------
				if (strlen(csList[IDX_TXN_FEE])>0) {
					if (!is_float(csList[IDX_TXN_FEE])) {
DEBUGLOG(("Invalid Txn Fee at line [%d] value = [%s]\n",iLineCnt, csList[IDX_TXN_FEE]));
						return FAILURE;
					}
				
					// Txn Fee
					dTmpAmt = atof(csList[IDX_TXN_FEE]);
				
					if (dTmpAmt > 0.0) {

						strcpy(csKey, "");
						strcat(csKey, csList[IDX_TXN_TYPE]);
						strcat(csKey, PD_HASHKEY_DELIMITOR);	
						strcat(csKey, CRR_AMT_TYPE_M_FEE); //
						strcat(csKey, PD_HASHKEY_DELIMITOR);
						strcat(csKey, csList[IDX_TXN_DATE]);
						strcat(csKey, PD_HASHKEY_DELIMITOR);	
						strcat(csKey, csList[IDX_TXN_STATUS]);
						strcat(csKey, PD_HASHKEY_DELIMITOR);				
						strcat(csKey, csList[IDX_COUNTRY_CODE]);
						strcat(csKey, PD_HASHKEY_DELIMITOR);	
						sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
						strcat(csKey, csPartyType);						
						strcat(csKey, PD_HASHKEY_DELIMITOR);	
						strcat(csKey, "-");
						strcat(csKey, PD_HASHKEY_DELIMITOR);	
						strcat(csKey, csList[IDX_TXN_FEE_CCY]); //
						strcat(csKey, PD_HASHKEY_DELIMITOR);	
						strcat(csKey, PD_CR);

DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", DSP_TYPE, CRR_AMT_TYPE_M_FEE, csKey, dTmpAmt));

						iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);
					}
				}
			}
			// ----- End of Deposit Grouping --------
			
		} else if (!strcmp(csList[IDX_TXN_TYPE],WTD_TYPE)) {
			// Payout Request 
			
			if (!strcmp(csList[IDX_TXN_STATUS],DSP_APPROVE_STATUS)) {
				// Approved (A)
				strcpy(csList[IDX_TXN_TYPE], CRR_OFF_PAYOUT_TXN_CODE);
			} else if (!strcmp(csList[IDX_TXN_STATUS],DSP_REJFECT_STATUS)) {
				// Rejected (R)
				strcpy(csList[IDX_TXN_TYPE], CRR_OFF_PAYOUT_REJ_TXN_CODE);
			} else {
DEBUGLOG(("Invalid Txn Status at line [%d]\n",iLineCnt));
				iRet = FAILURE;
			}

			if (iRet == SUCCESS) {

				// -----------------------------------------------------------
				// Merchant Net Amount
				// -----------------------------------------------------------
				strcpy(csKey, "");
				strcat(csKey, csList[IDX_TXN_TYPE]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, CRR_AMT_TYPE_NET_AMT); //
				strcat(csKey, PD_HASHKEY_DELIMITOR);
				strcat(csKey, csList[IDX_TXN_DATE]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, csList[IDX_TXN_STATUS]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);				
				strcat(csKey, csList[IDX_COUNTRY_CODE]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
				strcat(csKey, csPartyType);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, csList[IDX_MERCHANT]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, csList[IDX_NET_AMT_CCY]); //
				strcat(csKey, PD_HASHKEY_DELIMITOR);	

				if (!strcmp(csList[IDX_TXN_STATUS],DSP_APPROVE_STATUS)) {
					strcat(csKey, PD_DR);
				} else {
					strcat(csKey, PD_CR);
				}

			
				if (!is_float(csList[IDX_NET_AMT])) {
DEBUGLOG(("Invalid Txn Fee at line [%d] value = [%s]\n",iLineCnt, csList[IDX_NET_AMT]));
					iRet = FAILURE;
				}				
	
				if (iRet == SUCCESS) {
					dTmpAmt = atof(csList[IDX_NET_AMT]) + atof(csList[IDX_TXN_FEE]);

DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", WTD_TYPE, CRR_AMT_TYPE_NET_AMT, csKey, dTmpAmt));
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);
				}
			}

			if (iRet == SUCCESS) {
				// -----------------------------------------------------------
				// PSP Temp Amount (to In-transit)
				// -----------------------------------------------------------
				strcpy(csKey, "");
				strcat(csKey, csList[IDX_TXN_TYPE]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, CRR_AMT_TYPE_PSP_TEMP); //
				strcat(csKey, PD_HASHKEY_DELIMITOR);
				strcat(csKey, csList[IDX_TXN_DATE]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, csList[IDX_TXN_STATUS]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);				
				strcat(csKey, csList[IDX_COUNTRY_CODE]);
				strcat(csKey, PD_HASHKEY_DELIMITOR);				
				sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
				strcat(csKey, csPartyType);						
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, "-");	
				strcat(csKey, PD_HASHKEY_DELIMITOR);	
				strcat(csKey, csList[IDX_PSP_AMT_CCY]); //
				strcat(csKey, PD_HASHKEY_DELIMITOR);	

				if (!strcmp(csList[IDX_TXN_STATUS],DSP_APPROVE_STATUS)) {
					strcat(csKey, PD_CR);
				} else {
					strcat(csKey, PD_DR);
				}

				if (!is_float(csList[IDX_PSP_AMT])) {
DEBUGLOG(("Invalid PSP Amount at line [%d] value = [%s]",iLineCnt,csList[IDX_PSP_AMT]));
					iRet = FAILURE;
				}
				
				if (iRet == SUCCESS) {
					dTmpAmt = atof(csList[IDX_PSP_AMT]);
DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", WTD_TYPE, CRR_AMT_TYPE_PSP_TEMP, csKey, dTmpAmt));
					iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);
				}

				if (iRet == SUCCESS) {
					// -----------------------------------------------------------
					// Txn Fee
					// -----------------------------------------------------------
					if (strlen(csList[IDX_TXN_FEE])>0) {
						if (!is_float(csList[IDX_TXN_FEE])) {
DEBUGLOG(("Invalid Txn Fee at line [%d] value = [%s]",iLineCnt,csList[IDX_PSP_AMT]));
							iRet = FAILURE;
						}
					}

					if (iRet == SUCCESS) {
						// Txn Fee
						dTmpAmt = atof(csList[IDX_TXN_FEE]);
				
						if (dTmpAmt > 0.0) {
							// Debit Payout Fee
							strcpy(csKey, "");
							strcat(csKey, csList[IDX_TXN_TYPE]);
							strcat(csKey, PD_HASHKEY_DELIMITOR);	
							strcat(csKey, CRR_AMT_TYPE_M_FEE);
							strcat(csKey, PD_HASHKEY_DELIMITOR);
							strcat(csKey, csList[IDX_TXN_DATE]);
							strcat(csKey, PD_HASHKEY_DELIMITOR);	
							strcat(csKey, csList[IDX_TXN_STATUS]);
							strcat(csKey, PD_HASHKEY_DELIMITOR);				
							strcat(csKey, csList[IDX_COUNTRY_CODE]);
							strcat(csKey, PD_HASHKEY_DELIMITOR);	
							sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
							strcat(csKey, csPartyType);						
							strcat(csKey, PD_HASHKEY_DELIMITOR);	
							strcat(csKey, "-");
							strcat(csKey, PD_HASHKEY_DELIMITOR);	
							strcat(csKey, csList[IDX_TXN_FEE_CCY]);
							strcat(csKey, PD_HASHKEY_DELIMITOR);	
		
							if (!strcmp(csList[IDX_TXN_STATUS],DSP_APPROVE_STATUS)) {
								strcat(csKey, PD_CR);
							} else {
								strcat(csKey, PD_DR);
							}
DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", WTD_TYPE, CRR_AMT_TYPE_M_FEE, csKey, dTmpAmt));
					

							iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);
						}
					}
					
				}
			}
			// ----- End of Payout Grouping --------
		} else if (!strcmp(csList[IDX_TXN_TYPE],WTDG_TYPE)) {
			// Payout Generated

			if (!strcmp(csList[IDX_TXN_STATUS],DSP_APPROVE_STATUS)) {
				// Approved (A)
				strcpy(csList[IDX_TXN_TYPE], CRR_OFF_PAYOUT_GEN_TXN_CODE);
			} else if (!strcmp(csList[IDX_TXN_STATUS],DSP_REJFECT_STATUS)) {
				// Rejected (R)
				strcpy(csList[IDX_TXN_TYPE], CRR_OFF_PAYOUT_GEN_REJ_TXN_CODE);
			} else {
DEBUGLOG(("Invalid Txn Status at line [%d]\n",iLineCnt));
				iRet = FAILURE;
			}

			dTmpAmt = 0.0;

			if (iRet == SUCCESS) {

				if (!strcmp(csList[IDX_TXN_STATUS],DSP_APPROVE_STATUS)) {
			
					// PSP Temp Amount (from In-transit)
					// -----------------------------------------------------------
					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, CRR_AMT_TYPE_PSP_TEMP); //
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);						
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");	
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_AMT_CCY]); //
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_DR);

					if (!is_float(csList[IDX_TXN_AMT])) {
DEBUGLOG(("Invalid Net Amount at line [%d] value = [%s]",iLineCnt,csList[IDX_TXN_AMT]));
						iRet = FAILURE;
					}

					if (iRet == SUCCESS) {
						dTmpAmt = atof(csList[IDX_TXN_AMT]);
DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", WTDG_TYPE, CRR_AMT_TYPE_PSP_TEMP , csKey, dTmpAmt));
						iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);
					}
				}
			}
			
	
			if (iRet == SUCCESS) {

				// -----------------------------------------------------------
				// PSP/Deliver Amount (to PSP Available)
				// -----------------------------------------------------------
DEBUGLOG(("xxx [%s]\n", csList[IDX_PSP_AMT]));

				if (strlen(csList[IDX_PSP_AMT])>0) {

					if (!is_float(csList[IDX_PSP_AMT])) {
DEBUGLOG(("Invalid PSP/Deliver Amount at line [%d] [%s]\n",iLineCnt, csList[IDX_PSP_AMT]));
						iRet =  FAILURE;
					}
				}

				if (iRet == SUCCESS) {
					// PSP/Deliver Amount
					dTmpAmt = atof(csList[IDX_PSP_AMT]);
				
					if (dTmpAmt > 0.0) {

						strcpy(csKey, "");
						strcat(csKey, csList[IDX_TXN_TYPE]);
						strcat(csKey, PD_HASHKEY_DELIMITOR);	

						strcat(csKey, CRR_AMT_TYPE_D_TXN_AMT);
						strcat(csKey, PD_HASHKEY_DELIMITOR);
						strcat(csKey, csList[IDX_TXN_DATE]);
						strcat(csKey, PD_HASHKEY_DELIMITOR);	
						strcat(csKey, csList[IDX_TXN_STATUS]);
						strcat(csKey, PD_HASHKEY_DELIMITOR);				
						strcat(csKey, csList[IDX_COUNTRY_CODE]);
						strcat(csKey, PD_HASHKEY_DELIMITOR);				
						sprintf(csPartyType, "%c", PD_TYPE_PSP);
						strcat(csKey, csPartyType);			
						strcat(csKey, PD_HASHKEY_DELIMITOR);
						//strcat(csKey, csList[IDX_PSP]);
						strcat(csKey, csPartyID);
						strcat(csKey, PD_HASHKEY_DELIMITOR);						
						strcat(csKey, csList[IDX_PSP_AMT_CCY]);
						strcat(csKey, PD_HASHKEY_DELIMITOR);	

	
						if (!strcmp(csList[IDX_TXN_STATUS],DSP_APPROVE_STATUS)) {
							strcat(csKey, PD_CR);
						} else {
							strcat(csKey, PD_DR);
						}

DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", WTDG_TYPE, CRR_AMT_TYPE_D_TXN_AMT, csKey, dTmpAmt));
						iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);
					}

				}
			}

			if (iRet == SUCCESS) {
				if (!strcmp(csList[IDX_TXN_STATUS], DSP_REJFECT_STATUS)) {
					/* ------------------------------ */
					/* Merchnat Net Amount            */
					/* ------------------------------ */

					strcpy(csKey, "");
                                        strcat(csKey, csList[IDX_TXN_TYPE]);
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);

                                        strcat(csKey, CRR_AMT_TYPE_NET_AMT);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, csList[IDX_TXN_DATE]);
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, csList[IDX_TXN_STATUS]);
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, csList[IDX_COUNTRY_CODE]);
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        sprintf(csPartyType, "%c", PD_TYPE_MERCHANT);
					strcat(csKey, csPartyType);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, csList[IDX_MERCHANT]);
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, csList[IDX_NET_AMT_CCY]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, PD_CR);

	                                if (!is_float(csList[IDX_NET_AMT])) {
DEBUGLOG(("Invalid Net Amount at line [%d] value = [%s]",iLineCnt,csList[IDX_NET_AMT]));
	                                        iRet = FAILURE;
					}
	
					if (iRet == SUCCESS) {
						//dTmpAmt = atof(csList[IDX_NET_AMT]);
						 dTmpAmt = atof(csList[IDX_NET_AMT]) + atof(csList[IDX_TXN_FEE]);

DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", WTDG_TYPE, CRR_AMT_TYPE_NET_AMT, csKey, dTmpAmt));

                                                iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);

					}
				}
			}

			if (iRet == SUCCESS) {
				if (!strcmp(csList[IDX_TXN_STATUS], DSP_REJFECT_STATUS)) {
					/* ------------------------------ */
					/* Merchnat Net Amount            */
					/* ------------------------------ */

					strcpy(csKey, "");
                                        strcat(csKey, csList[IDX_TXN_TYPE]);
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);

                                        strcat(csKey, CRR_AMT_TYPE_M_FEE);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, csList[IDX_TXN_DATE]);
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, csList[IDX_TXN_STATUS]);
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, csList[IDX_COUNTRY_CODE]);
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        sprintf(csPartyType, "%c", PD_TYPE_GLOBAL);
					strcat(csKey, csPartyType);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, "-");
                                        strcat(csKey, PD_HASHKEY_DELIMITOR);
                                        strcat(csKey, csList[IDX_TXN_FEE_CCY]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, PD_DR);

	                                if (!is_float(csList[IDX_TXN_FEE])) {
DEBUGLOG(("Invalid Net Amount at line [%d] value = [%s]",iLineCnt,csList[IDX_TXN_FEE]));
	                                        iRet = FAILURE;
					}
	
					if (iRet == SUCCESS) {
						dTmpAmt = atof(csList[IDX_TXN_FEE]);

DEBUGLOG(("[%s] [%s] Grouping Key [%s] [%lf]\n", WTDG_TYPE, CRR_AMT_TYPE_M_FEE, csKey, dTmpAmt));

                                                iRet = myGroupRecs(csJnlKeys, hTxnAmt, hCnt, csKey, dTmpAmt, &iJnlKeyCnt);

					}
				}
			}
			// -----End of Payout PSP Grouping ------


		} else {
			// Unknown
DEBUGLOG(("Unknown Transaction Type =[%s]\n",csList[IDX_TXN_TYPE]));
			iRet = FAILURE;
		}

		if (iRet == FAILURE) {
			break;
		}
	}

DEBUGLOG(("iRet = [%d]\n", iRet));

	if (iRet == SUCCESS) {
		iRet = myPostTxn(csJnlKeys, hTxnAmt, hCnt, iJnlKeyCnt);

		if (iRet == SUCCESS) {
DEBUGLOG(("myPostTxn succeed\n"));
		} else {
DEBUGLOG(("myPostTxn failed\n"));
		}
	}


	// Clean up
	hash_destroy(hTxnAmt);
	FREE_ME(hTxnAmt);
	hash_destroy(hCnt);
	FREE_ME(hCnt);
	
	
DEBUGLOG(("process_file return:[%d]\n",iRet));
	return iRet;
}

int myGroupRecs(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], hash_t *hTxn, hash_t *hCnt, char *csKey, double dAmt, int *iJnlKeyCnt) 
{
	double dTmpAmt = 0.00;
	int iCnt = 0;
	int	iRet = SUCCESS ;

	// Accumulate the txn amount
	if (GetField_Double(hTxn,csKey,&dTmpAmt)) {
		//DEBUGLOG(("Found Txn [%s] = [%f]\n",csKey, dTmpAmt));
		// Sum
		dTmpAmt = (double) dTmpAmt + dAmt;

	} else {				
		// Add new
		// Update Key chains
		strcpy(csJnlKeys[*iJnlKeyCnt],csKey);
		(*iJnlKeyCnt)++;
		dTmpAmt = (double) dAmt;				
		//DEBUGLOG(("New Txn [%s] = [%f]\n",csKey, dTmpAmt));
	}
	
	PutField_Double(hTxn,csKey,dTmpAmt);

	// Increment the txn count
	if (GetField_Int(hCnt,csKey,&iCnt)) {
		//DEBUGLOG(("Found Cnt [%s] = [%d]\n",csKey, iCnt));	
		iCnt++;
		
	} else {	
		iCnt = 1;
		//DEBUGLOG(("New Cnt [%s] = [%d]\n",csKey, iCnt));		
	}
	
	PutField_Int(hCnt,csKey,iCnt);

	return iRet;
}

int myPostTxn(char csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN], const hash_t *hTxn, const hash_t *hCnt, const int iJnlKeyCnt) 
{	
	int	iRet = SUCCESS;
	int iTmp, iCount, iGetRet, j, iFoundType=0;
	hash_t*	hReq;
	char    csKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN];
	char	*p;
	char 	csTmpKey[IMPORT_MAX_KEY];
	double 	dTmpAmt;
	char* csTxnType[MAX_TXN_TYPE_CNT]={NULL,NULL,NULL,NULL,NULL};
	char csPartyID[PD_CRR_MERCH_ID_LEN];
	char csFxGainLossCcy[PD_CCY_ID_LEN] = "";
	
	//char* csPtr;
	//char cTmp;
	int		iCnt = 0;
	double dConvertAmt = 0.0;
	double dFxGainLoss = 0.0;
	double dZero = 0.0;
	char   csJnldate[PD_DATE_LEN + 1];

DEBUGLOG(("!!!!!!!!!!!! START myPostTxn !!!!!!!!!!!!!!!!!!!!!\n"));	

	strcpy(csFxGainLossCcy, PD_CCY_ISO_HKD);
	
	csTxnType[0] = CRR_OFF_DEPOSIT_TXN_CODE; //Deposit Approved	
	csTxnType[1] = CRR_OFF_PAYOUT_TXN_CODE; // Payout Requested
	csTxnType[2] = CRR_OFF_PAYOUT_REJ_TXN_CODE; // Payout Requested Rejected
	csTxnType[3] =  CRR_OFF_PAYOUT_GEN_TXN_CODE; // Payout Generated
	csTxnType[4] = CRR_OFF_PAYOUT_GEN_REJ_TXN_CODE; // Payout Generated Rejected
	
	recordset_t *rRecordSet;
	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));	

	recordset_t  *rRec;
	rRec = (recordset_t*) malloc (sizeof(recordset_t));

	hReq = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hReq,0);

	hash_t	*hJnl;
	hash_t  *hDelJnl; // for Clear Journal
	char*	csTmp;


	if (iJnlKeyCnt == 0) { 
DEBUGLOG(("No transaction found\n"));
	} else {
		/* Get Clear Journals */
DEBUGLOG(("Start Cleanup Journal for Date:[%s], Country:[%s], Product:[%s]...\n",cs_date,OFFLINE_COUNTRY_CODE, OFFLINE_PRODUCT_CODE));
		recordset_init(rRec,0);
		DBObjPtr = CreateObj(DBPtr,"DBCrrExtJnlLog","GetAllPostJnl");
		if ((unsigned long)(*DBObjPtr)(rRec, cs_date, OFFLINE_COUNTRY_CODE, OFFLINE_PRODUCT_CODE, PD_JLT_POST_OFFLINE) == PD_OK) {

DEBUGLOG(("Need to clear Journal!\n"));

			hDelJnl = (hash_t*) malloc (sizeof(hash_t));
			hJnl = RecordSet_GetFirst(rRec);
			while(hJnl) {
				hash_init (hDelJnl, 0);

				if (GetField_CString(hJnl, "jnl_id", &csTmp)) {
DEBUGLOG(("deleted jnl_id [%s]\n", csTmp));
					PutField_CString(hDelJnl, "jnl_id", csTmp);

					PutField_Int(hDelJnl, "disabled", PD_TRUE);
					PutField_CString(hDelJnl, "update_user", PD_UPDATE_USER);

DEBUGLOG(("prepare to delete jnl_id [%s]\n", csTmp));
					BOObjPtr = CreateObj(BOPtr,"BOCrrJnl","Delete");
					if ((unsigned long)(*BOObjPtr)(hDelJnl) == PD_OK) {

DEBUGLOG(("prepare to update CrrExtJnlLog jnl_id [%s]\n", csTmp));

						DBObjPtr = CreateObj(DBPtr,"DBCrrExtJnlLog","Update");
						if ((unsigned long) ((*DBObjPtr)(hDelJnl)) != PD_OK) {
DEBUGLOG(("Error on Update CrrExtJnlLog jnl_id [%s]\n", csTmp));
							iRet = FAILURE;
							break;
						}
					} else {
						iRet = FAILURE;
DEBUGLOG(("Failed to clear journal and return [%d].\n",iRet));
						break;
					}
				}
				hJnl = RecordSet_GetNext(rRec); 
				hash_destroy(hDelJnl);
			}
			FREE_ME(hDelJnl);	


			/*
			DBObjPtr = CreateObj(DBPtr,"BOCrrJnl","clearJournal");
			if ((unsigned long)(*DBObjPtr)("Cleanup Journal", rRec, PD_UPDATE_USER) == PD_OK) {
DEBUGLOG(("After Cleanup Journal!!\n"));

				hDelJnl = (hash_t*) malloc (sizeof(hash_t));
				hJnl = RecordSet_GetFirst(rRec);
				while(hJnl) {
					hash_init (hDelJnl, 0);


					if (GetField_CString(hJnl, "jnl_id", &csTmp)) {
DEBUGLOG(("deleted jnl_id [%s]\n", csTmp));
						PutField_CString(hDelJnl, "jnl_id", csTmp);
					}
	
					PutField_Int(hDelJnl, "disabled", PD_TRUE);
					PutField_CString(hDelJnl, "update_user", PD_UPDATE_USER);

					DBObjPtr = CreateObj(DBPtr,"DBCrrExtJnlLog","Update");
				        if ((unsigned long) ((*BOObjPtr)(hDelJnl)) != PD_OK) {
DEBUGLOG(("Error on Update CrrExtJnlLog jnl_id [%s]\n", csTmp));
						iRet = FAILURE;
						break;
					}

					hJnl = RecordSet_GetNext(rRec);
					hash_destroy(hDelJnl);
				}
				FREE_ME(hDelJnl);	
			} else {
				iRet = FAILURE;
DEBUGLOG(("Failed to clear journal and return [%d].\n",iRet));
			}
			*/
		} else {
			iRet = FAILURE;
DEBUGLOG(("Failed to get existing journal.\n"));
		}
DEBUGLOG(("End Cleanup Journal and return [%d]\n",iRet));	



		if (iRet == SUCCESS) {


DEBUGLOG(("Start posting transactions...\n"));
		
		recordset_init(rRecordSet,0);		


DEBUGLOG(("JnlKeyCnt [%d]\n", iJnlKeyCnt));
		
		for (j=0;j<MAX_TXN_TYPE_CNT;j++) {
			if (csTxnType[j]!=NULL) {
DEBUGLOG(("......Txn Type = [%s]\n",csTxnType[j]));
				iFoundType = 0;
				dFxGainLoss = 0.0;
				for (iTmp=0;iTmp<iJnlKeyCnt;iTmp++) {
DEBUGLOG(("iTmp [%d]\n", iTmp));
				
					if (strlen(csJnlKeys[iTmp])>0) {
												
						strcpy(csTmpKey, csJnlKeys[iTmp]);

DEBUGLOG(("csTmpKey [%s]\n", csTmpKey));
						if (GetField_Double(hTxn,csTmpKey,&dTmpAmt)) {
							
DEBUGLOG(("dTmpAmt[%lf]\n", dTmpAmt));
							// Break key into fields
							iCount = 0;
							p = mystrtok(csTmpKey,PD_HASHKEY_DELIMITOR);
							if (p == NULL) {
								return FAILURE;
							}
							strcpy(csKeys[iCount],p);

							iCount++;
						
							while ((p = mystrtok(NULL,PD_HASHKEY_DELIMITOR)) != NULL) {
								strcpy(csKeys[iCount],p);
								iCount++;
							} 

							if (strcmp(csKeys[HASHKEY_IDX_TXN_TYPE],csTxnType[j])) {
								// If not equal to current txn type, skip and continue
								continue;
							} else {			
								// Found at least one entry for current txn type
								iFoundType = 1;
							}
							strcpy(csJnldate, csKeys[HASHKEY_IDX_TXN_DATE]);							
DEBUGLOG(("Jnl_Date [%s]\n", csJnldate));

							//if (GetField_CString(hContext,"PHDATE",&csPtr))  {
							PutField_CString(hReq,"host_posting_date",csJnldate);
							//}					
							
							/* txn code */
							PutField_CString(hReq,"txn_code",csKeys[HASHKEY_IDX_TXN_TYPE]);
														
							/* txn country */
							PutField_CString(hReq,"txn_country",csKeys[HASHKEY_IDX_COUNTRY_CODE]);
							
							/* product */
							PutField_CString(hReq,"product",OFFLINE_PRODUCT_CODE);
							
							/* ccy, convert RMB to CNY if needed */
							if (!strcmp(csKeys[HASHKEY_IDX_AMT_CCY],PD_CCY_ISO_RMB)) {
								PutField_CString(hReq,"ccy",PD_CCY_ISO_CNY);
								//DEBUGLOG(("RMB found, convert to CNY\n"));
							} else {
								PutField_CString(hReq,"ccy",csKeys[HASHKEY_IDX_AMT_CCY]);
							}
							
							/* txn_type */
							PutField_CString(hReq,"txn_type",csKeys[HASHKEY_IDX_AMT_TYPE]);
							
							/* amount */
							PutField_Double(hReq,"amount",dTmpAmt);
							
							/* party type */
							PutField_Char(hReq,"type",csKeys[HASHKEY_IDX_PARTY_TYPE][0]);

DEBUGLOG(("before merchant_id\n"));
							
							/* party id */
							if (csKeys[HASHKEY_IDX_PARTY_TYPE][0]==PD_TYPE_MERCHANT) {
								//DEBUGLOG(("Look Merchnant [%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
								// Lookup Merchant ID
								DBObjPtr = CreateObj(DBPtr,"DBCrrExtMerchDetail","GetMerchIDbyExtMerch");
								iGetRet = (unsigned long)(*DBObjPtr)(OFFLINE_PRODUCT_CODE, csKeys[HASHKEY_IDX_PARTY_ID], csPartyID);			
								if (iGetRet != FOUND) {
DEBUGLOG(("Merchnat not found [%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
									iRet = FAILURE;
									//continue;									
								} else {
DEBUGLOG(("Merchant party id [%s]\n", csPartyID));
								}
													
							} else if (csKeys[HASHKEY_IDX_PARTY_TYPE][0]==PD_TYPE_PSP) {
								//DEBUGLOG(("Look PSP [%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
								// Lookup PSP ID
								DBObjPtr = CreateObj(DBPtr,"DBCrrExtPspDetail","GetPspIDbyExtPsp");
								iGetRet = (unsigned long)(*DBObjPtr)(OFFLINE_PRODUCT_CODE, csKeys[HASHKEY_IDX_PARTY_ID], csPartyID);			
								
								if (iGetRet != FOUND) {
DEBUGLOG(("PSP not found [%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
									iRet = FAILURE;
									//continue;									
								} else {
DEBUGLOG(("Provider party id [%s]\n", csPartyID));
								}
							} else {
								//Use Default (-) Global Party 
								strcpy(csPartyID,PD_SYS_PARTY_ID);
							}

							PutField_CString(hReq,"id",csPartyID);
							
							/* txn_cnt */
							if (GetField_Int(hCnt,csJnlKeys[iTmp],&iCnt)) {
								//DEBUGLOG(("txn_cnt [%s] = [%d]\n",csJnlKeys[iTmp], iCnt));
								PutField_Int(hReq,"txn_cnt",iCnt);
							} else {
								//DEBUGLOG(("txn_cnt not found [%s]\n",csJnlKeys[iTmp]));
								iCnt = 0;
							}
								

							/*
DEBUGLOG(("HASHKEY_IDX_AMT_TYPE=[%s]\n",csKeys[HASHKEY_IDX_AMT_TYPE]));	
DEBUGLOG(("HASHKEY_IDX_TXN_DATE=[%s]\n",csKeys[HASHKEY_IDX_TXN_DATE]));
DEBUGLOG(("HASHKEY_IDX_TXN_TYPE=[%s]\n",csKeys[HASHKEY_IDX_TXN_TYPE]));
DEBUGLOG(("HASHKEY_IDX_TXN_STATUS=[%s]\n",csKeys[HASHKEY_IDX_TXN_STATUS]));
DEBUGLOG(("HASHKEY_IDX_COUNTRY_CODE=[%s]\n",csKeys[HASHKEY_IDX_COUNTRY_CODE]));
DEBUGLOG(("HASHKEY_IDX_PARTY_TYPE=[%c]\n",csKeys[HASHKEY_IDX_PARTY_TYPE][0]));
DEBUGLOG(("HASHKEY_IDX_PARTY_ID=[%s]\n",csKeys[HASHKEY_IDX_PARTY_ID]));
DEBUGLOG(("HASHKEY_IDX_AMT_CCY=[%s]\n",csKeys[HASHKEY_IDX_AMT_CCY]));	
DEBUGLOG(("HASHKEY_IDX_CR_IND=[%s]\n",csKeys[HASHKEY_IDX_CR_IND]));	
DEBUGLOG(("Amount [%s] = [%f]\n",csTmpKey, dTmpAmt));
							*/

							dConvertAmt = 0.0;
							
							BOObjPtr = CreateObj(DBPtr,"BOCrrJnl","GetFXConvertAmt");
							if ((*BOObjPtr)(csKeys[HASHKEY_IDX_TXN_DATE], csKeys[HASHKEY_IDX_AMT_CCY], csFxGainLossCcy, dTmpAmt, &dConvertAmt) != PD_OK) {
DEBUGLOG(("Fail to get FX rate at converted request amount at Journal Key [%d]\n",iTmp));
								return FAILURE;			
							}
							
							// Credit (+), Debit (-)
							if (!strcmp(csKeys[HASHKEY_IDX_CR_IND],"DR"))
								dFxGainLoss = (double) dFxGainLoss + dConvertAmt;
							else
								dFxGainLoss = (double) dFxGainLoss + (dConvertAmt*-1);

DEBUGLOG(("Journal Key [%d] = [%s], Amount = [%f], HKD = [%f], Count = [%d]\n",iTmp, csJnlKeys[iTmp], dTmpAmt, dConvertAmt, iCnt));
							
							// Add to RS
							RecordSet_Add(rRecordSet,hReq);

							// Reset hash
							hReq = (hash_t*) malloc (sizeof(hash_t));							
							hash_init(hReq,0);	
								
						} else {
DEBUGLOG(("Not Found for Key [%s]\n",csTmpKey));
							//iRet = FAILURE;
							continue;
						}
												
					} else {
						continue;
					}

DEBUGLOG(("aaaaaa iRet [%d]\n", iRet));

					if (iRet == FAILURE) {
						break;
					}
					

				} // for csKey
				
				

				if (iRet == SUCCESS) {
				if (iFoundType) {

					
DEBUGLOG(("dFxGainLoss [%f]\n",dFxGainLoss));
					/*
DEBUGLOG(("round 2 dFxGainLoss [%f]\n",newround(dFxGainLoss, 2)));
DEBUGLOG(("dFxGainLoss != 0.000000 [%d]\n",(dFxGainLoss != 0.000000)));
DEBUGLOG(("dFxGainLoss != -0.000000 [%d]\n",(dFxGainLoss != -0.000000)));
DEBUGLOG(("dFxGainLoss == 0.000000 [%d]\n",(dFxGainLoss == 0.000000)));
DEBUGLOG(("dFxGainLoss == -0.000000 [%d]\n",(dFxGainLoss == -0.000000)));

DEBUGLOG(("dFxGainLoss == 0.000000f [%d]\n",(dFxGainLoss == 0.000000f)));
DEBUGLOG(("dFxGainLoss == -0.000000f [%d]\n",(dFxGainLoss == -0.000000f)));
					*/

					// Determine FX Gain/Loss
					if ((dFxGainLoss != 0.000000) && (dFxGainLoss != -0.000000)) {	
						if (dFxGainLoss > dZero) {
DEBUGLOG(("Credit FxGainLoss for Type [%s] = [%f]\n",csTxnType[j], dFxGainLoss));

							//dFxGainLoss =  newround(dFxGainLoss, PD_DECIMAL_LEN);
							//if (dFxGainLoss > dZero) {
								// Credit
								hReq = (hash_t*) malloc (sizeof(hash_t));
								hash_init(hReq,0);						
								PutField_CString(hReq,"host_posting_date",csJnldate);
								PutField_CString(hReq,"txn_code",csTxnType[j]);
								PutField_CString(hReq,"txn_country",OFFLINE_COUNTRY_CODE);
								PutField_CString(hReq,"product",OFFLINE_PRODUCT_CODE);
								PutField_CString(hReq,"ccy",csFxGainLossCcy);
								PutField_CString(hReq,"txn_type","CR_FXGL");
								PutField_Double(hReq,"amount",dFxGainLoss);
								PutField_Char(hReq,"type",PD_TYPE_GLOBAL);
								PutField_CString(hReq,"id",PD_SYS_PARTY_ID);
								PutField_Int(hReq,"txn_cnt",0);
								RecordSet_Add(rRecordSet,hReq);
							//}
							
						} else if ((dFxGainLoss < dZero) && ((dFxGainLoss*-1) > dZero)) {
							dFxGainLoss = dFxGainLoss * -1;
DEBUGLOG(("Debit FxGainLoss for Type [%s] = [%f]\n",csTxnType[j], dFxGainLoss));

							//dFxGainLoss =  newround(dFxGainLoss, PD_DECIMAL_LEN);
							//if (dFxGainLoss > dZero) {
								// Debit
								hReq = (hash_t*) malloc (sizeof(hash_t));
								hash_init(hReq,0);						
								PutField_CString(hReq,"host_posting_date",csJnldate);
								PutField_CString(hReq,"txn_code",csTxnType[j]);
								PutField_CString(hReq,"txn_country",OFFLINE_COUNTRY_CODE);
								PutField_CString(hReq,"product",OFFLINE_PRODUCT_CODE);
								PutField_CString(hReq,"ccy",csFxGainLossCcy);
								PutField_CString(hReq,"txn_type","DR_FXGL");
								PutField_Double(hReq,"amount",dFxGainLoss);
								PutField_Char(hReq,"type",PD_TYPE_GLOBAL);
								PutField_CString(hReq,"id",PD_SYS_PARTY_ID);
								PutField_Int(hReq,"txn_cnt",0);
								RecordSet_Add(rRecordSet,hReq);
							//}
							
						}
					}

					if (iRet == SUCCESS) {
DEBUGLOG(("Start BOCrrPost...\n"));
						BOObjPtr = CreateObj(BOPtr,"BOCrrPost","PostOffSysTxn");
						iRet = (unsigned long)(*BOObjPtr)(rRecordSet);
DEBUGLOG(("End BOCrrPost and return [%d]...\n",iRet));
					}
					
					// Clean up
					RecordSet_Destroy(rRecordSet);
					
					if (iRet != SUCCESS) {
						break;
					}
				} else {
DEBUGLOG(("No Transaction found for Txn Type = [%s]\n",csTxnType[j]));
				}
			
				}
			}			
		} // for Txn Type	
	}
	}
		
	// Clean up
	RecordSet_Destroy(rRecordSet);
	hash_destroy(hReq);
	FREE_ME(hReq);	
DEBUGLOG(("End posting and return:[%d]\n",iRet));
	
	return iRet;
}

int ChkCloseMonth()
{
	int iRet = SUCCESS;

	char	csYear[PD_ACC_YEAR_LEN + 1];
	char	csMonth[PD_ACC_MONTH_LEN + 1];
	int     closed = PD_FALSE;


        hash_t  *hRec;
        hRec = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hRec,0);

	memset(csYear, 0, sizeof(csYear));
	memset(csMonth, 0, sizeof(csMonth));

	strncpy(csYear, cs_date, PD_ACC_YEAR_LEN);
	strncpy(csMonth, cs_date + PD_ACC_YEAR_LEN, PD_ACC_MONTH_LEN);


DEBUGLOG(("chkCloseMonth Year = [%s]\n",csYear));
DEBUGLOG(("ChkCloseMonth Month = [%s]\n",csMonth));


        DBObjPtr = CreateObj(DBPtr,"DBCrrMonthEnd","Get");
        iRet = (unsigned long) ((*DBObjPtr)(csYear, csMonth, hRec));

        if (iRet == PD_OK) {
                // closed //
                if (GetField_Int(hRec,"closed", &closed)) {
DEBUGLOG(("ChkCloseMonth closed = [%d]\n",closed));

			if (closed == PD_TRUE) {
				iRet = FAILURE;
			}

                } else {
DEBUGLOG(("ChkCloseMonth Undetermined for [%s-%s]", csYear, csMonth));
			closed = PD_FALSE;
                }
        }

        hash_destroy(hRec);
        FREE_ME(hRec);


	return iRet;
}
