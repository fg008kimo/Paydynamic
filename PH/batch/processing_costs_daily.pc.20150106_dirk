/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/12/23              Dirk Wong
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sqlca.h>
#include <unistd.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "internal.h"
#include "myrecordset.h"
#include "ObjPtr.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cs_psp_id[PD_PSP_ID_LEN + 1];
char    cs_baid[PD_BAID_LEN + 1];
char	cs_txn_ccy[PD_CCY_ID_LEN + 1];
char	cs_country[PD_COUNTRY_LEN + 1];
char    cDebug;

OBJPTR(Channel);
OBJPTR(DB);
OBJPTR(BO);

int parse_arg(int argc,char **argv);

int process_daily_cal_txn(const char* csPspId);
int ProcessPspCosts(hash_t* hRls,double dTxnAmt);
int CreateNewTxn(hash_t* hRls, char* csChargeTxnSeq);
int UpdateTxnPspDetail(const char* csOrgTxnSeq, const char* csChargeTxnSeq);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}

int batch_proc(int argc, char* argv[])
{
	int     iRet;

	iRet = parse_arg(argc,argv);

	if(iRet != SUCCESS)
printf("usage: -p psp_id\n");

	if(iRet == SUCCESS)
		iRet = process_daily_cal_txn(cs_psp_id);

	return iRet;
}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}

int parse_arg(int argc,char **argv)
{
	if (argc < 3) {
		return PD_ERR;
	}

	char c;
	strcpy(cs_psp_id,"");

	while ((c = getopt(argc,argv,"p:")) != EOF) {
		switch (c) {
			case 'p':
				strcpy(cs_psp_id, optarg);
				break;
			default:
				return PD_ERR;
		}
	}

	if (!strcmp(cs_psp_id,""))
		return PD_ERR;

	return SUCCESS;
}

int process_daily_cal_txn(const char* csPspId)
{
	int	iRet = SUCCESS;

	hash_t	*myHash = NULL;
	hash_t	*hBatchTxnId;

	myHash = (hash_t*) malloc (sizeof(hash_t));
	hash_init(myHash,0);
	hBatchTxnId = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hBatchTxnId,0);

	int	i=0;
	char*	csTmp;
	char	csTag[PD_TAG_LEN+1];

	char	cGroupingType;
	double	iTotalTxnAmt = 0;
	int	iPrevRuleId = 0;

	char	csPrevTxnCode[PD_TXN_CODE_LEN+1];
	char	csTxnCode[PD_TXN_CODE_LEN+1];
	char	csOrgTxnSeq[PD_TXN_SEQ_LEN+1];
	char	csChargeTxnSeq[PD_TXN_SEQ_LEN+1];

	int	iFirstRow = 0;
	int	iCount = 0;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_psp_id[PD_PSP_ID_LEN];
		char	hv_charge_period_type;
		int	hv_charge_txn_created;

		varchar	v_txn_id[PD_TXN_SEQ_LEN+1];
		varchar	v_baid[PD_BAID_LEN+1];
		varchar	v_txn_code[PD_TXN_CODE_LEN+1];
		double	v_txn_amt;
		int	v_rule_id;
		varchar	v_txn_ccy[PD_CCY_ID_LEN+1];
		varchar	v_country[PD_COUNTRY_LEN+1];

		short	ind_txn_id = -1;
		short	ind_baid = -1;
		short	ind_txn_code = -1;
		short	ind_txn_amt = -1;
		short	ind_rule_id = -1;
		short	ind_txn_ccy = -1;
		short	ind_country = -1;
	EXEC SQL END DECLARE SECTION;

	hv_psp_id.len = strlen((char*)csPspId);
	memcpy(hv_psp_id.arr,csPspId,hv_psp_id.len);

	hv_charge_period_type = PD_COST_PERIOD_DAILY;

	hv_charge_txn_created = 0;
printf("PID [%.*s] Start\n",hv_psp_id.len,hv_psp_id.arr);

	EXEC SQL DECLARE c_cursor_getdailycaltxn CURSOR FOR
		SELECT	OTH_TXN_ID,
			OTP_BAID,
			OTH_TXN_CODE, 
			OTH_TRANSACTION_AMOUNT,
			OTP_CHARGE_RULE_ID,
			OTP_TXN_CCY,
			COUNTRY
		FROM	OL_TXN_HEADER,
			OL_TXN_PSP_DETAIL,
			OL_BANK_ACCT_ID,
			BANK_DESC
		WHERE	OTH_TXN_ID=OTP_TXN_ID
		AND	OTP_BAID=OBAI_BAID
		AND	OBAI_INT_BANK_CODE=INTERNAL_BANK_CODE
		AND	OTH_APPROVAL_TIMESTAMP < to_date((SELECT SYS_VAL from SYSTEM_CONTROL WHERE SYS_CODE='CTPHDATE'),'YYYYMMDD')
		AND	OTP_PSP_ID = :hv_psp_id
		AND	OTP_CHARGE_PERIOD_TYPE = :hv_charge_period_type
		AND	OTP_CHARGE_TXN_CREATED = :hv_charge_txn_created
		AND	OTP_PRE_CAL_CHARGE IS NULL
		AND	OTP_CHARGE_RULE_ID IS NOT NULL
		ORDER BY	OTP_CHARGE_RULE_ID,
				OTH_TXN_CODE;

	EXEC SQL OPEN c_cursor_getdailycaltxn;
	do {
		EXEC SQL FETCH c_cursor_getdailycaltxn
		INTO
			:v_txn_id:ind_txn_id,
			:v_baid:ind_baid,
			:v_txn_code:ind_txn_code,
			:v_txn_amt:ind_txn_amt,
			:v_rule_id:ind_rule_id,
			:v_txn_ccy:ind_txn_ccy,
			:v_country:ind_country;

		if (SQLCODE == SQL_NOT_FOUND) {
printf("No more record found, break\n");
			break;
		}

		if (ind_txn_id>=0 && ind_baid>= 0 && ind_txn_code>=0 && 
		    ind_txn_amt>=0 && ind_rule_id>=0 && ind_txn_ccy>=0 && ind_country>=0)
		{
			v_txn_id.arr[v_txn_id.len] = '\0';
			strcpy((char*)csOrgTxnSeq, (const char*)v_txn_id.arr);

			v_txn_code.arr[v_txn_code.len] = '\0';
			strcpy((char*)csTxnCode, (const char*)v_txn_code.arr);

			v_txn_ccy.arr[v_txn_ccy.len] = '\0';
			strcpy((char*)cs_txn_ccy, (const char*)v_txn_ccy.arr);

			v_country.arr[v_country.len] = '\0';
			strcpy((char*)cs_country, (const char*)v_country.arr);
	
			v_baid.arr[v_baid.len] = '\0';
			strcpy((char*)cs_baid, (const char*)v_baid.arr);

			if (iFirstRow == 0) {
				iPrevRuleId = v_rule_id;
				strcpy(csPrevTxnCode, csTxnCode);
				iCount += 1;
				iFirstRow = 1;
			} else {
printf("prev rule_id=[%d], curr rule_id=[%d]\n",iPrevRuleId,v_rule_id);
printf("prev txn_code=[%s], curr txn_code=[%s]\n",csPrevTxnCode,csTxnCode);
				if ((iPrevRuleId!=v_rule_id) || 
				    (strcmp(csTxnCode, csPrevTxnCode)))
				{
printf("diff! ProcessPspCosts for previous txn START\n");
printf("TotalTxnAmt = [%f]\n",iTotalTxnAmt);
					if (ProcessPspCosts(myHash,iTotalTxnAmt) == SUCCESS) {
						if (CreateNewTxn(myHash,(char*)csChargeTxnSeq) == SUCCESS) {
							//Done
						} else {
							iRet = FAILURE;
							break;
						}
					}else {
						iRet = FAILURE;
						break;
					}

					for (i=1;i<=iCount;i++) {
						sprintf(csTag,"txn_id_%d",i);
						if (GetField_CString(hBatchTxnId,csTag,&csTmp)){
							UpdateTxnPspDetail(csTmp,(char*)csChargeTxnSeq);
						}
					}

					iPrevRuleId = v_rule_id;
					strcpy(csPrevTxnCode, csTxnCode);

					iCount = 1;
					iTotalTxnAmt = 0;

					hash_destroy(hBatchTxnId);
					hash_init(hBatchTxnId,0);
				} else {
printf("match!\n");
					iCount += 1;
				}
			}

printf(">>> Process new record\n");
printf("TxnID = [%s]\n",csOrgTxnSeq);
printf("TxnCode = [%s]\n",csTxnCode);
printf("TxnAmt = [%f]\n",v_txn_amt);
printf("RuleId = [%d]\n",v_rule_id);
			v_txn_id.arr[v_txn_id.len] = '\0';
			PutField_CString(myHash,"txn_seq",csOrgTxnSeq);
			v_txn_code.arr[v_txn_code.len] = '\0';
			PutField_CString(myHash,"txn_code",csTxnCode);
			PutField_Double(myHash,"txn_amt",v_txn_amt);
			PutField_Int(myHash,"rule_id",v_rule_id);

			hash_destroy(myHash);
			hash_init(myHash,0);

			DBObjPtr = CreateObj(DBPtr,"DBOLPspCosts","GetOLPspCostsById");
			if ((unsigned long)(*DBObjPtr)(v_rule_id,(const char*)csTxnCode,myHash)==PD_FOUND) {
printf("DBOLPspCosts::GetOLPspCostsById FOUND!\n");
				if (GetField_CString(myHash,"txn_code",&csTmp)) {
					if (strcmp(csTmp,csTxnCode)) {
printf("Txn Code not sync! rule_id [%d] txn_code = [%s]\n",v_rule_id,csTmp);
						iRet = FAILURE;
						break;
					}
				}
				if (GetField_Char(myHash,"grouping_type",&cGroupingType)) {
printf("grouping_type = [%c]\n",cGroupingType);
					if (cGroupingType == PD_COST_GROUPING_TOTAL) {
printf("Before: TotalTxnAmt=[%f]\n",iTotalTxnAmt);
						iTotalTxnAmt += v_txn_amt;
printf("After : TotalTxnAmt=[%f] (txn_amt=[%f])\n",iTotalTxnAmt,v_txn_amt);
						sprintf(csTag,"txn_id_%d",iCount);
						PutField_CString(hBatchTxnId,csTag,csOrgTxnSeq);
					} else if (cGroupingType == PD_COST_GROUPING_SINGLE) {
printf("grouping_type == single >>> shoule not enter here!!\n");
						if (ProcessPspCosts(myHash,v_txn_amt) == SUCCESS) {
							if (CreateNewTxn(myHash,(char*)csChargeTxnSeq) == SUCCESS) {
								UpdateTxnPspDetail(csOrgTxnSeq,(char*)csChargeTxnSeq);
							} else {
								iRet = FAILURE;
								break;
							}
						} else {
							iRet = FAILURE;
							break;
						}
					} else {
						iRet = FAILURE;
						break;
					}
				} else {
					iRet = FAILURE;
					break;
printf("grouping_type not found...\n");
				}
			} else {
printf("DBOLPspCosts::GetOLPspCostsById NOT FOUND, break!!\n");
				iRet = FAILURE;
				break;
			}
		}
	} while (PD_TRUE);



	if (iCount > 0 && cGroupingType == PD_COST_GROUPING_TOTAL && iRet==SUCCESS) {
		if (ProcessPspCosts(myHash,iTotalTxnAmt) == SUCCESS) {
			if (CreateNewTxn(myHash,(char*)csChargeTxnSeq) == SUCCESS) {
				//Done!
			} else {
				iRet = FAILURE;
			}
		} else {
			iRet = FAILURE;
		}

		for (i=1;i<=iCount;i++) {
			sprintf(csTag,"txn_id_%d",i);
printf("get back TxnId: [%s]\n",csTag);
			if (GetField_CString(hBatchTxnId,csTag,&csTmp)) {
printf("Txnid = [%s]\n",csTmp);
				UpdateTxnPspDetail(csTmp,(char*)csChargeTxnSeq);
			}
		}
	}

	EXEC SQL CLOSE c_cursor_getdailycaltxn;

	FREE_ME(myHash);
	FREE_ME(hBatchTxnId);

	return iRet;

sql_error:
DEBUGLOG(("process_daily_cal_txn error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getdailycaltxn;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}

int ProcessPspCosts(hash_t* hRls,double dTxnAmt) {
	int iRet = SUCCESS;
	PutField_Double(hRls,"txn_amt",dTxnAmt);
	BOObjPtr = CreateObj(BOPtr,"BOOLPspCosts","CalOLPspCostsById");
	if ((unsigned long)(*BOObjPtr)(hRls) == PD_OK) {
printf("ProcessPspCosts success\n");
	} else {
		iRet = FAILURE;
printf("ProcessPspCosts fail\n");
	}

	return iRet;
}

int CreateNewTxn(hash_t* hRls, char* csChargeTxnSeq) {
	int iRet = SUCCESS;

	char* csTmp;
	char cTmp;
	char* csAmtType;
	double dAmt = 0.0;
	
	char csLocalTxnDateTime[PD_DATETIME_LEN+1];
	char csTmDate[PD_DATE_LEN+1];
	char csTmTime[PD_TIME_LEN+1];
	char csTmpDate[PD_DATETIME_LEN +1];

	hash_t          *hTxn;
	hTxn = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hTxn,0);

	csChargeTxnSeq[0]='\0';
	csLocalTxnDateTime[0]='\0';
	DBObjPtr = CreateObj(DBPtr,"DBOLTxnSeq","GetNextOmtTxnSeq");
	strcpy((char*)csChargeTxnSeq,(*DBObjPtr)());

	if (GetField_CString(hRls,"gen_txn_code",&csTmp)) {
printf("new txn_code = [%s]\n", csTmp);
		PutField_CString(hTxn,"txn_code",csTmp);
	} else iRet = FAILURE;

	if (GetField_Double(hRls,"precal_fee",&dAmt)) {
printf("precal_fee = [%f]\n",dAmt);
		PutField_Double(hTxn,"txn_amt",dAmt);
		PutField_Double(hTxn,"net_amt",dAmt);
	} else iRet = FAILURE;

	DBObjPtr = CreateObj(DBPtr,"DBSystemControl","FindCode");
	if ((unsigned long)(*DBObjPtr)("CTPHDATE",csTmpDate) != FOUND) {
		iRet = FAILURE;
	}

	PutField_CString(hTxn,"txn_seq", (const char*)csChargeTxnSeq);
	PutField_Int(hTxn,"do_logging",PD_ADD_LOG);
	PutField_CString(hTxn,"channel_code",PD_CHANNEL_OMT);
	PutField_Char(hTxn,"status",PD_COMPLETE);
	PutField_Char(hTxn,"ar_ind",PD_ACCEPT);
//	PutField_CString(hTxn,"sub_status","");
	PutField_CString(hTxn,"host_posting_date",csTmpDate);
	PutField_Int(hTxn,"internal_code",0);
	PutField_CString(hTxn,"response_code","0");

//Get from recordset
	PutField_CString(hTxn,"net_ccy",(char*)cs_txn_ccy);
	PutField_CString(hTxn,"txn_ccy",(char*)cs_txn_ccy);
	PutField_CString(hTxn,"txn_country",(char*)cs_country);

	PutField_Int(hTxn,"db_commit",PD_FALSE);
	PutField_CString(hTxn,"process_code","000000");
	PutField_CString(hTxn,"process_type","0000");

	strcpy(csLocalTxnDateTime,getdatetime());
	sprintf(csTmDate,"%.*s",PD_DATE_LEN,csLocalTxnDateTime);
	PutField_CString(hTxn,"local_tm_date",csTmDate);
	sprintf(csTmTime,"%.*s",PD_TIME_LEN,&csLocalTxnDateTime[PD_DATE_LEN]);
	PutField_CString(hTxn,"local_tm_time",csTmTime);
	PutField_CString(hTxn,"tm_time",csTmTime);

printf("CreateNewTxn TxnId = [%s]\n",csChargeTxnSeq);
	if(iRet==PD_OK){
		ChannelObjPtr = CreateObj(ChannelPtr,"OMTChannel","AddTxnLog");
		iRet = (unsigned long)(*ChannelObjPtr)(hTxn,hTxn);
printf("CreateNewTxn iRet [%d]\n",iRet);
	}

	if (iRet == PD_OK) {
printf("CreateNewTxn:: ready to do update balance\n");
		//do update balance
		PutField_CString(hTxn,"psp_id",cs_psp_id);
		PutField_CString(hTxn,"baid",cs_baid);
		if(GetField_CString(hRls,"amt_type",&csAmtType)) {
			if(!strcmp(csAmtType,PD_CR))
				cTmp = PD_IND_CREDIT;
			else
				cTmp = PD_IND_DEBIT;
			PutField_Char(hTxn,"amt_type",cTmp);
		}
		PutField_CString(hTxn,"pool",PD_ACCT_BAL_POOL);
		BOObjPtr = CreateObj(BOPtr, "BOOLBalance", "UpdateAmount");
		iRet = (unsigned long)(*BOObjPtr)(hTxn);
printf("CreateNewTxn:: call BOOLBalance:UpdateAmount iRet=[%d]\n",iRet);
	}





	if (iRet == PD_OK) {
printf("CreateNewTxn:: ready to add+update ol_txn_psp_detail\n");
		//add+update ol_txn_psp_detail
		PutField_Double(hTxn,"txn_amount",dAmt);
		PutField_CString(hTxn,"add_user",PD_UPDATE_USER);
		PutField_CString(hTxn,"txn_date",csTmDate);
		PutField_CString(hTxn,"txn_time",csTmTime);
		DBObjPtr = CreateObj(DBPtr, "DBOLTxnPspDetail", "Add");
		iRet = (unsigned long)(*DBObjPtr)(hTxn);
		if(iRet==PD_OK){
			DBObjPtr = CreateObj(DBPtr, "DBOLTxnPspDetail", "Update");
			iRet = (unsigned long)(*DBObjPtr)(hTxn);
		}
printf("CreateNewTxn:: call DBOLTxnPspDetail:Add/Update iRet=[%d]\n",iRet);
	}

	if (iRet == PD_OK) {
printf("CreateNewTxn:: ready to update ol_txn_elements\n");
		//update ol_txn_elements
		PutField_CString(hTxn,"txn_element_type",PD_ELEMENT_TXN_AMT);
		PutField_CString(hTxn,"amount_type",csAmtType);
		BOObjPtr = CreateObj(BOPtr,"BOOLTxnElements","AddPspTxnElement");
		iRet = (unsigned long)(*BOObjPtr)(hTxn);
printf("CreateNewTxn:: call DBOLTxnElements:AddPspTxnElement iRet=[%d]\n",iRet);
	}

	if (iRet == PD_OK) {
printf("CreateNewTxn:: ready to update txn_header\n");
		//update txn_header
		DBObjPtr = CreateObj(DBPtr, "DBOLTransaction", "Update");
		if((unsigned long)(*DBObjPtr)(hTxn)!=PD_OK){
			iRet = FAILURE;
printf("CreateNewTxn:: update status failed\n");
		}
	}

	return iRet;
}


int UpdateTxnPspDetail(const char* csOrgTxnSeq, const char* csChargeTxnSeq) {
	int iRet = SUCCESS;

printf("UpdateTxnPspDetail orgTxnSeq = [%s], newTxnSeq = [%s]\n", csOrgTxnSeq, csChargeTxnSeq);

	hash_t  *hRls;

	hRls = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRls, 0);

	PutField_CString(hRls,"txn_seq",csOrgTxnSeq);
	PutField_CString(hRls,"charge_txn_id",csChargeTxnSeq);
	PutField_Int(hRls,"charge_txn_created",1);
	PutField_CString(hRls,"update_user",PD_UPDATE_USER);

	DBObjPtr = CreateObj(DBPtr,"DBOLTxnPspDetail","Update");
	if ((unsigned long)(*DBObjPtr)(hRls) == PD_OK) {
printf("update ol_txn_psp_detail success\n");
	} else {
		iRet = FAILURE;
printf("update ol_txn_psp_detail fail\n");
	}

	FREE_ME(hRls);

	return iRet;
}

