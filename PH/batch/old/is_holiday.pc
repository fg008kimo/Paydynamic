/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/04/29              LokMan Chow
Add non-holiday table				   2013/03/26		   LokMan Chow
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "batchcommon.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char	cs_country[PD_COUNTRY_LEN + 1];
char	cs_date[PD_DATE_LEN + 1];
char	cDebug;

int	parse_arg(int argc,char **argv);
int	is_holiday(const char *csCountry, const char* csDate);
int is_non_holiday(const char* csCountry, const char* csDate);

int batch_init(int argc, char* argv[])
{
/*
    if (argc < 2)
        return FAILURE;
    else
*/
        return SUCCESS;
}


int batch_terminate(int argc, char* argv[])
{
    return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	int iRet = SUCCESS;

	iRet = parse_arg(argc,argv);
	if(iRet != SUCCESS){
		printf("usage: -c country -d date\n");
		return (iRet);
	}

	int iDayOfWeek = day_of_week((const unsigned char*)cs_date);
printf("day of week=[%d]\n",iDayOfWeek);
		
	if(iRet==SUCCESS){
		iRet = is_holiday(cs_country, cs_date);
	}


	return iRet;
}

int is_holiday(const char* csCountry, const char* csDate)
{
	int iRet = FAILURE;

        EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar         hv_country[PD_COUNTRY_LEN];
		varchar         hv_date[PD_DATE_LEN];

		varchar		v_desc[PD_DESC_LEN+1];

		short           ind_desc = -1;
        EXEC SQL END DECLARE SECTION;

        hv_country.len=strlen(csCountry);
	memcpy(hv_country.arr,csCountry,hv_country.len);
	
        hv_date.len=strlen(csDate);
	memcpy(hv_date.arr,csDate,hv_date.len);

        EXEC SQL SELECT	h_desc
		INTO	:v_desc:ind_desc
                FROM    holiday
                WHERE   h_country = :hv_country
		AND	h_date = :hv_date
		AND	h_is_non_holiday = 0;

		
	if(ind_desc>=0){
printf("is holiday\n");
		iRet =  SUCCESS;
	}
	else{
printf("not holiday\n");
	}

	if(is_weekend(csDate)==PD_TRUE){
printf("check non-holiday\n");
                iRet = is_non_holiday(csCountry,csDate);
        }
	return iRet;

sql_error:
    DEBUGLOG(("sql_error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}


int is_non_holiday(const char* csCountry, const char* csDate)
{
        EXEC SQL WHENEVER SQLERROR GOTO sqln_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar         hv_country[PD_COUNTRY_LEN];
		varchar         hv_date[PD_DATE_LEN];

		varchar		v_desc[PD_DESC_LEN+1];

		short           ind_desc = -1;
        EXEC SQL END DECLARE SECTION;

        hv_country.len=strlen(csCountry);
	memcpy(hv_country.arr,csCountry,hv_country.len);
	
        hv_date.len=strlen(csDate);
	memcpy(hv_date.arr,csDate,hv_date.len);

        EXEC SQL SELECT	h_desc
		INTO	:v_desc:ind_desc
                FROM    holiday
                WHERE   h_country = :hv_country
		AND	h_date = :hv_date
		AND	h_is_non_holiday = 1;
		
	if(ind_desc>=0){
printf("non-holiday\n");
		return FAILURE;
	}
	else{
printf("holiday\n");
		return SUCCESS;
	}

sqln_error:
    DEBUGLOG(("sqln_error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}

int parse_arg(int argc,char **argv)
{
	char    c;
	strcpy(cs_country,"");
	strcpy(cs_date,"");

	while ((c = getopt(argc,argv,"c:d:")) != EOF) {
		switch (c) {
			case 'c':
				strcpy(cs_country, optarg);
				break;
			case 'd':
				strcpy(cs_date, optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (!strcmp(cs_country,"") || !strcmp(cs_date,""))
		return FAILURE;

	return SUCCESS;
}

