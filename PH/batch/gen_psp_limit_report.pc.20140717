/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/06/13		   Stan Poon
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sqlca.h>
#include <unistd.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myrecordset.h"
#include "ObjPtr.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define PD_OPEN_TAG             "<tr><td>"
#define PD_OPEN_TAG_CS          "<tr><td style=text-align:right;>"
#define PD_OPEN_TAG_CS_RED      "<tr><td style=text-align:right;color:red>"
#define PD_NEXT_TAG             "</td><td>"
#define PD_NEXT_TAG_CS          "</td><td style=text-align:right;>"
#define PD_NEXT_TAG_CS_RED      "</td><td style=text-align:right;color:red>"
#define PD_END_TAG              "</td></tr>"

char cDebug = 'Y';

int parse_arg(int argc, char **argv);
int process_txn();
int psp_limit_report_summary(char* csMerchantId);
int psp_limit_report_summary_total(char* csMerchantId);
int psp_limit_report_merchant(char* csMerchantId, int iShowEmptyCSegment);
int psp_limit_report_group_o(char* csMerchantId);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}

int batch_proc(int argc, char* argv[])
{
	int iRet;

	iRet = parse_arg(argc, argv);

	if (iRet != SUCCESS) {
printf("usage: \n");
	} else {
		process_txn();
	}

	return iRet;
}

int process_txn()
{
	int	iRet = SUCCESS;

/*
	iRet = psp_limit_report_summary("K000000001");
DEBUGLOG(("psp_limit_report_summary iRet = [%d]\n",iRet));

	if (iRet == PD_OK) {
		iRet = psp_limit_report_summary_total("K000000001");
DEBUGLOG(("psp_limit_report_summary_total iRet = [%d]\n",iRet));
	}

	if (iRet == PD_OK) {
		iRet = psp_limit_report_merchant("K000000001");
DEBUGLOG(("psp_limit_report_summary_merchant iRet = [%d]\n",iRet));
	}
*/

	iRet = psp_limit_report_summary("M8000016");
DEBUGLOG(("psp_limit_report_summary iRet = [%d]\n",iRet));

	if (iRet == PD_OK) {
		iRet = psp_limit_report_summary_total("M8000016");
DEBUGLOG(("psp_limit_report_summary_total iRet = [%d]\n",iRet));
	}

	if (iRet == PD_OK) {
		iRet = psp_limit_report_group_o("M8000016");
DEBUGLOG(("psp_limit_report_summary_merchant iRet = [%d]\n",iRet));
	}

	if (iRet == PD_OK) {
		iRet = psp_limit_report_merchant("M8000016", PD_FALSE);
DEBUGLOG(("psp_limit_report_summary_merchant iRet = [%d]\n",iRet));
	}

printf("<h2>Mobile</h2>\n");

	if (iRet == PD_OK) {
		iRet = psp_limit_report_merchant("M8000020", PD_TRUE);
DEBUGLOG(("psp_limit_report_summary_merchant iRet = [%d]\n",iRet));
	}

	return iRet;
}

int psp_limit_report_summary(char* csMerchantId)
{
	int     iRet = SUCCESS;

printf("<h1>PSP Limit Report (Merchant)</h1>\n");
printf("<h2>Limit Report Summary</h2>\n");
printf("<table border='1'>\n");
printf("<tr><th>Merchant Short Name</th><th>Customer Segment</th><th>PSP Remaining Limit (Normal)</th><th>PSP Remaining Limit (SARIP)</th><th>PSP Remaining Limit (Overflow)</th></tr>\n");

	EXEC SQL WHENEVER SQLERROR GOTO summary_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_merchant_id[PD_MERCHANT_ID_LEN + 1];

		varchar	v_short_name[PD_MERCH_SHORT_NAME_LEN + 1];
		varchar	v_currency[PD_CCY_ID_LEN + 1];
		varchar	v_cg_code[PD_CUSTOMER_GROUP_CODE_LEN + 1];
		varchar	v_cg_desc[PD_DESC_LEN + 1];
		double	v_remaining_limit_normal;
		double	v_remaining_limit_sarip;
		double	v_remaining_limit_overflow;
		int	v_cnt;

		short	ind_short_name = -1;
		short	ind_currency = -1;
		short	ind_cg_code = -1;
		short	ind_cg_desc = -1;
		short	ind_remaining_limit_normal = -1;
		short	ind_remaining_limit_sarip = -1;
		short	ind_remaining_limit_overflow = -1;
		short	ind_cnt = -1;

	EXEC SQL END DECLARE SECTION;

	hv_merchant_id.len = strlen((char*)csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);

	EXEC SQL DECLARE c_summary CURSOR FOR
		SELECT SHORT_NAME AS SHORT_NAME,
			CURRENCY_ID AS CURRENCY_ID,
			CUSTOMER_SEGMENT_CODE AS CUSTOMER_SEGMENT_CODE,
			CUSTOMER_SEGMENT_DESC AS CUSTOMER_SEGMENT_DESC,
			REMAINING_LIMIT_NORMAL AS REMAINING_LIMIT_NORMAL,
			REMAINING_LIMIT_SM_AMT AS REMAINING_LIMIT_SM_AMT,
			REMAINING_LIMIT_OF_AMT AS REMAINING_LIMIT_OF_AMT,
			count(*) OVER () AS TOTAL_ROWS
		FROM (
			SELECT SHORT_NAME AS SHORT_NAME,
				CURRENCY_ID AS CURRENCY_ID,
				CUSTOMER_SEGMENT_CODE AS CUSTOMER_SEGMENT_CODE,
				CUSTOMER_SEGMENT_DESC AS CUSTOMER_SEGMENT_DESC,
				SUM(REMAINING_LIMIT) AS REMAINING_LIMIT_NORMAL,
				(
					SELECT NVL(SUM(REMAINING_LIMIT), 0) AS REMAINING_LIMIT 
					FROM (
						SELECT MERCHANT_ID AS MERCHANT_ID,
							SHORT_NAME AS SHORT_NAME,
							PSP_CLIENT_ID AS PSP_CLIENT_ID,
							PSP_ID AS PSP_ID,
							CURRENCY_ID AS CURRENCY_ID,
							LIMIT AS LIMIT,
							CG_CODE AS CUSTOMER_SEGMENT_CODE,
							CG_DESC AS CUSTOMER_SEGMENT_DESC,
							CASE 
								WHEN (REMAINING_LIMIT > 0)
									THEN REMAINING_LIMIT
								ELSE 0
								END AS REMAINING_LIMIT,
							MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
							MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT
						FROM PSP_LIMIT_MERCHANT_VIEW
						LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = CUSTOMER_SEGMENT
						WHERE MERCHANT_ID = :hv_merchant_id
							AND SERVICE_CODE = 'VNC'
						GROUP BY MERCHANT_ID,
							SHORT_NAME,
							PSP_CLIENT_ID,
							PSP_ID,
							CURRENCY_ID,
							LIMIT,
							REMAINING_LIMIT,
							CG_CODE,
							CG_DESC
						) summary
					WHERE MAX_TRANSACTION_AMOUNT > 0
						AND MAX_TRANSACTION_AMOUNT <= 100
						AND CUSTOMER_SEGMENT_CODE IS NULL
						) AS REMAINING_LIMIT_SM_AMT,
				/*CASE 
					WHEN CUSTOMER_SEGMENT_CODE != 'GRP_N'
						THEN */ (
								SELECT NVL(SUM(REMAINING_LIMIT), 0) AS REMAINING_LIMIT 
								FROM (
									SELECT MERCHANT_ID AS MERCHANT_ID,
										SHORT_NAME AS SHORT_NAME,
										PSP_CLIENT_ID AS PSP_CLIENT_ID,
										PSP_ID AS PSP_ID,
										CURRENCY_ID AS CURRENCY_ID,
										LIMIT AS LIMIT,
										CG_CODE AS CUSTOMER_SEGMENT_CODE,
										CG_DESC AS CUSTOMER_SEGMENT_DESC,
										CASE 
											WHEN (REMAINING_LIMIT > 0)
												THEN REMAINING_LIMIT
											ELSE 0
											END AS REMAINING_LIMIT,
										MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
										MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT
									FROM PSP_LIMIT_MERCHANT_VIEW
									LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = CUSTOMER_SEGMENT
									WHERE MERCHANT_ID = :hv_merchant_id
										AND SERVICE_CODE = 'VNC'
										AND ALLOW_SPECIAL_REGION = 0
									GROUP BY MERCHANT_ID,
										SHORT_NAME,
										PSP_CLIENT_ID,
										PSP_ID,
										CURRENCY_ID,
										LIMIT,
										REMAINING_LIMIT,
										CG_CODE,
										CG_DESC
									) summary
								WHERE MAX_TRANSACTION_AMOUNT = 0
									AND CUSTOMER_SEGMENT_CODE IS NULL
							)
					/* ELSE 0
						END */ AS REMAINING_LIMIT_OF_AMT
			FROM (
				SELECT MERCHANT_ID AS MERCHANT_ID,
					SHORT_NAME AS SHORT_NAME,
					PSP_CLIENT_ID AS PSP_CLIENT_ID,
					PSP_ID AS PSP_ID,
					CURRENCY_ID AS CURRENCY_ID,
					LIMIT AS LIMIT,
					CG_CODE AS CUSTOMER_SEGMENT_CODE,
					CG_DESC AS CUSTOMER_SEGMENT_DESC,
					CASE 
						WHEN (REMAINING_LIMIT > 0)
							THEN REMAINING_LIMIT
						ELSE 0
						END AS REMAINING_LIMIT,
					MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
					MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT
				FROM PSP_LIMIT_MERCHANT_VIEW
				LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = CUSTOMER_SEGMENT
				WHERE MERCHANT_ID = :hv_merchant_id
					AND SERVICE_CODE = 'VNC'
				GROUP BY MERCHANT_ID,
					SHORT_NAME,
					PSP_CLIENT_ID,
					PSP_ID,
					CURRENCY_ID,
					LIMIT,
					REMAINING_LIMIT,
					CG_CODE,
					CG_DESC
				) summary
			WHERE CUSTOMER_SEGMENT_CODE IN (
					'GRP_A',
					'GRP_B',
					'GRP_C',
					'GRP_N'
					)
			GROUP BY SHORT_NAME,
				CURRENCY_ID,
				CUSTOMER_SEGMENT_CODE,
				CUSTOMER_SEGMENT_DESC
			) summary
		ORDER BY SHORT_NAME,
			CURRENCY_ID,
			CUSTOMER_SEGMENT_CODE,
			CUSTOMER_SEGMENT_DESC;


	EXEC SQL OPEN c_summary;
	for (;;) {
		EXEC SQL FETCH c_summary
		INTO
			:v_short_name:ind_short_name,
			:v_currency:ind_currency,
			:v_cg_code:ind_cg_code,
			:v_cg_desc:ind_cg_desc,
			:v_remaining_limit_normal:ind_remaining_limit_normal,
			:v_remaining_limit_sarip:ind_remaining_limit_sarip,
			:v_remaining_limit_overflow:ind_remaining_limit_overflow,
			:v_cnt:ind_cnt;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

printf("%s",PD_OPEN_TAG);

		if (ind_short_name >= 0) {
			v_short_name.arr[v_short_name.len]='\0';
printf("%s",(char*)v_short_name.arr);
DEBUGLOG(("psp_limit_report_summary() short_name = [%s]\n",v_short_name.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_currency >= 0) {
			v_currency.arr[v_currency.len]='\0';
DEBUGLOG(("psp_limit_report_summary() currency = [%s]\n",v_currency.arr));
		}

		if (ind_cg_code >= 0) {
			v_cg_code.arr[v_cg_code.len]='\0';
DEBUGLOG(("psp_limit_report_summary() cg_code = [%s]\n",v_cg_code.arr));
		}

		if (ind_cg_desc >= 0) {
			v_cg_desc.arr[v_cg_desc.len]='\0';
printf("%s",(char*)v_cg_desc.arr);
DEBUGLOG(("psp_limit_report_summary() cg_desc = [%s]\n",v_cg_desc.arr));
		}

		if (ind_remaining_limit_normal >= 0) {
			if (v_remaining_limit_normal > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit_normal,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(v_remaining_limit_normal*-1.0,2));
			}
DEBUGLOG(("psp_remaining_limit_normal_report_summary() remaining_limit_normal = [%.2lf]\n",v_remaining_limit_normal));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

		if (ind_remaining_limit_sarip >= 0) {
			if (v_remaining_limit_sarip > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit_sarip,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(v_remaining_limit_sarip*-1.0,2));
			}
//printf("%.2lf",v_remaining_limit_sarip);
DEBUGLOG(("psp_remaining_limit_sarip_report_summary() remaining_limit_sarip = [%.2lf]\n",v_remaining_limit_sarip));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

		if (ind_remaining_limit_overflow >= 0) {
			if (v_remaining_limit_overflow > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit_overflow,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(v_remaining_limit_overflow*-1.0,2));
			}
//printf("%.2lf",v_remaining_limit_overflow);
DEBUGLOG(("psp_remaining_limit_overflow_report_summary() remaining_limit_overflow = [%.2lf]\n",v_remaining_limit_overflow));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

printf("%s\n",PD_END_TAG);

		if (ind_cnt >= 0) {
DEBUGLOG(("psp_limit_report_summary() cnt = [%d]\n",v_cnt));
		}

	}
	EXEC SQL CLOSE c_summary;

DEBUGLOG(("psp_limit_report_summary() iRet = [%d]\n",iRet));
	return iRet;

summary_error:
DEBUGLOG(("psp_limit_report_summary error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_summary;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}

int psp_limit_report_summary_total(char* csMerchantId)
{
	int     iRet = SUCCESS;

	EXEC SQL WHENEVER SQLERROR GOTO summary_total_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_merchant_id[PD_MERCHANT_ID_LEN + 1];

		double	v_remaining_limit;
		short	ind_remaining_limit = -1;

	EXEC SQL END DECLARE SECTION;

	hv_merchant_id.len = strlen((char*)csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);

	EXEC SQL DECLARE c_summary_total CURSOR FOR
		SELECT NVL(SUM(REMAINING_LIMIT), 0) AS REMAINING_LIMIT
		FROM (
			SELECT MERCHANT_ID AS MERCHANT_ID,
				SHORT_NAME AS SHORT_NAME,
				PSP_CLIENT_ID AS PSP_CLIENT_ID,
				PSP_ID AS PSP_ID,
				CURRENCY_ID AS CURRENCY_ID,
				LIMIT AS LIMIT,
				CG_CODE AS CUSTOMER_SEGMENT_CODE,
				CG_DESC AS CUSTOMER_SEGMENT_DESC,
				CASE
					WHEN (REMAINING_LIMIT > 0)
						THEN REMAINING_LIMIT
					ELSE 0
					END AS REMAINING_LIMIT,
				MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
				MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT
			FROM PSP_LIMIT_MERCHANT_VIEW
			LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = CUSTOMER_SEGMENT
			WHERE MERCHANT_ID = :hv_merchant_id
				/* AND SERVICE_CODE = 'VNC' */
			GROUP BY MERCHANT_ID,
				SHORT_NAME,
				PSP_CLIENT_ID,
				PSP_ID,
				CURRENCY_ID,
				LIMIT,
				REMAINING_LIMIT,
				CG_CODE,
				CG_DESC
			) summary;


	EXEC SQL OPEN c_summary_total;
	for (;;) {
		EXEC SQL FETCH c_summary_total
		INTO
			:v_remaining_limit:ind_remaining_limit;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

printf("%sTotal",PD_OPEN_TAG);
printf("%s",PD_NEXT_TAG);
		if (ind_remaining_limit >= 0) {
			if (v_remaining_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(v_remaining_limit*-1.0,2));
			}
//printf("%.2lf",v_remaining_limit);
DEBUGLOG(("psp_limit_report_summary_total() remaining_limit = [%.2lf]\n",v_remaining_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}
printf("%s",PD_NEXT_TAG_CS);
printf("%s",PD_NEXT_TAG_CS);
printf("%s\n",PD_END_TAG);

	}
	EXEC SQL CLOSE c_summary_total;

printf("</table>\n");

DEBUGLOG(("psp_limit_report_summary_total() iRet = [%d]\n",iRet));
	return iRet;

summary_total_error:
DEBUGLOG(("psp_limit_report_summary_total error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_summary_total;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}

int psp_limit_report_merchant(char* csMerchantId, int iShowEmptyCSegment)
{
	int     iRet = SUCCESS;
	int	iCnt = 0;
	char	csCSegment[PD_DESC_LEN + 1];
	strcpy(csCSegment,"");

	EXEC SQL WHENEVER SQLERROR GOTO merchant_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_merchant_id[PD_MERCHANT_ID_LEN + 1];

		varchar	v_client_id[PD_CLIENT_ID_LEN + 1];
		varchar	v_client_name[PD_CLIENT_NAME_LEN + 1];
		varchar	v_psp_id[PD_PSP_ID_LEN + 1];
		varchar	v_psp_name[PD_PSP_NAME_LEN + 1];
		varchar	v_remark[PD_REMARK_LEN + 1];
		varchar	v_currency[PD_CCY_ID_LEN + 1];
		double	v_ratio;
		varchar	v_customer_segment[PD_DESC_LEN + 1];
		double	v_limit;
		double	v_remaining_limit;
		int	v_cnt;

		short	ind_client_id = -1;
		short	ind_client_name = -1;
		short	ind_psp_id = -1;
		short	ind_psp_name = -1;
		short	ind_remark = -1;
		short	ind_currency = -1;
		short	ind_ratio = -1;
		short	ind_customer_segment = -1;
		short	ind_limit = -1;
		short	ind_remaining_limit = -1;
		short	ind_cnt = -1;

	EXEC SQL END DECLARE SECTION;

	hv_merchant_id.len = strlen((char*)csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);

	EXEC SQL DECLARE c_merchant CURSOR FOR
		SELECT	/* CLIENT_ID AS CLIENT_ID,
			CLIENT_NAME AS CLIENT_NAME,
			MERCHANT_ID AS MERCHANT_ID,
			SHORT_NAME AS SHORT_NAME,
			BUSINESS_TYPE AS BUSINESS_TYPE, */
			PSP_CLIENT_ID AS PSP_CLIENT_ID,
			PSP_CLIENT_NAME AS PSP_CLIENT_NAME,
			PSP_ID AS PSP_ID,
			PSP_NAME AS PSP_NAME,
			PSP_REMARK AS PSP_REMARK,
			CURRENCY_ID AS CURRENCY_ID,
			LIMIT AS LIMIT,
			REMAINING_LIMIT AS REMAINING_LIMIT,
			/* MIN_TRANSACTION_AMOUNT AS MIN_TRANSACTION_AMOUNT,
			MAX_TRANSACTION_AMOUNT AS MAX_TRANSACTION_AMOUNT, */
			NVL(CUSTOMER_SEGMENT_DESC,'-') AS CUSTOMER_SEGMENT,
			/* CRITERIA_POOL_ID AS CRITERIA_POOL_ID,
			POOL_ID AS POOL_ID,
			POOL_RATIO AS POOL_RATIO_BAK, */
			POOL_RM_RATIO AS POOL_RATIO,
			count(*) OVER () AS TOTAL_ROWS
		FROM (
			SELECT CLIENT_ID AS CLIENT_ID,
				CLIENT_NAME AS CLIENT_NAME,
				MERCHANT_ID AS MERCHANT_ID,
				SHORT_NAME AS SHORT_NAME,
				BUSINESS_TYPE AS BUSINESS_TYPE,
				PSP_CLIENT_ID AS PSP_CLIENT_ID,
				PSP_CLIENT_NAME AS PSP_CLIENT_NAME,
				PSP_ID AS PSP_ID,
				PSP_NAME AS PSP_NAME,
				PSP_REMARK AS PSP_REMARK,
				CURRENCY_ID AS CURRENCY_ID,
				LIMIT AS LIMIT,
				REMAINING_LIMIT AS REMAINING_LIMIT,
				MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
				MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT,
				CUSTOMER_SEGMENT AS CUSTOMER_SEGMENT_CODE,
				CUSTOMER_GROUP.CG_DESC AS CUSTOMER_SEGMENT_DESC,
				CRITERIA_POOL_ID AS CRITERIA_POOL_ID,
				POOL_ID AS POOL_ID,
				POOL_RATIO AS POOL_RATIO,
				POOL_RM_RATIO AS POOL_RM_RATIO
			FROM PSP_LIMIT_MERCHANT_VIEW
			LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = PSP_LIMIT_MERCHANT_VIEW.CUSTOMER_SEGMENT
			WHERE MERCHANT_ID = :hv_merchant_id
			GROUP BY CLIENT_ID,
				CLIENT_NAME,
				MERCHANT_ID,
				SHORT_NAME,
				BUSINESS_TYPE,
				PSP_CLIENT_ID,
				PSP_CLIENT_NAME,
				PSP_ID,
				PSP_NAME,
				PSP_REMARK,
				CURRENCY_ID,
				LIMIT,
				REMAINING_LIMIT,
				CUSTOMER_SEGMENT,
				CG_DESC,
				CRITERIA_POOL_ID,
				POOL_ID,
				POOL_RATIO,
				POOL_RM_RATIO
			) summary
		WHERE 1 = 1
		ORDER BY CUSTOMER_SEGMENT,
			CLIENT_NAME,
			SHORT_NAME,
			UPPER(PSP_NAME),
			CURRENCY_ID;

	EXEC SQL OPEN c_merchant;
	for (;;) {
		EXEC SQL FETCH c_merchant
		INTO
			:v_client_id:ind_client_id,
			:v_client_name:ind_client_name,
			:v_psp_id:ind_psp_id,
			:v_psp_name:ind_psp_name,
			:v_remark:ind_remark,
			:v_currency:ind_currency,
			:v_limit:ind_limit,
			:v_remaining_limit:ind_remaining_limit,
			:v_customer_segment:ind_customer_segment,
			:v_ratio:ind_ratio,
			:v_cnt:ind_cnt;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

		if (ind_customer_segment >= 0) {
			v_customer_segment.arr[v_customer_segment.len]='\0';

			if (!strcmp((char*)v_customer_segment.arr,"-") && !iShowEmptyCSegment) continue;

			if (strcmp(csCSegment,(char*)v_customer_segment.arr)) {
				strcpy(csCSegment,(char*)v_customer_segment.arr);

if (iCnt > 1) printf("</table>\n");
if (strcmp(csCSegment,"-")) printf("<h2>%s</h2>\n",csCSegment);

printf("<table border='1'>\n");
printf("<tr><th>PSP Name</th><th>PSP Account Name</th><th>Remark</th><th>Currency</th><th>Ratio</th><th>Customer Segment</th><th>PID Limit</th><th>PSP Remaining Limit</th></tr>\n");
			}
		}

		if (ind_client_id >= 0) {
			v_client_id.arr[v_client_id.len]='\0';
DEBUGLOG(("psp_limit_report_merchant() client_id = [%s]\n",v_client_id.arr));
		}

printf("%s",PD_OPEN_TAG);

		if (ind_client_name >= 0) {
			v_client_name.arr[v_client_name.len]='\0';
printf("%s",(char*)v_client_name.arr);
DEBUGLOG(("psp_limit_report_merchant() client_name = [%s]\n",v_client_name.arr));
		}

		if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len]='\0';
DEBUGLOG(("psp_limit_report_merchant() psp_id = [%s]\n",v_psp_id.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_psp_name >= 0) {
			v_psp_name.arr[v_psp_name.len]='\0';
printf("%s",(char*)v_psp_name.arr);
DEBUGLOG(("psp_limit_report_merchant() psp_name = [%s]\n",v_psp_name.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_remark >= 0) {
			v_remark.arr[v_remark.len]='\0';
printf("%s",(char*)v_remark.arr);
DEBUGLOG(("psp_limit_report_merchant() remark = [%s]\n",v_remark.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_currency >= 0) {
			v_currency.arr[v_currency.len]='\0';
printf("%s",(char*)v_currency.arr);
DEBUGLOG(("psp_limit_report_merchant() currency = [%s]\n",v_currency.arr));
		}

printf("%s",PD_NEXT_TAG_CS);

		if (ind_ratio >= 0) {
printf("%d",(int)v_ratio);
DEBUGLOG(("psp_limit_report_merchant() ratio = [%d]\n",(int)v_ratio));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_customer_segment >= 0) {
			v_customer_segment.arr[v_customer_segment.len]='\0';
printf("%s",(char*)v_customer_segment.arr);
DEBUGLOG(("psp_limit_report_merchant() customer_segment = [%s]\n",v_customer_segment.arr));
		}

		if (ind_limit >= 0) {
			if (v_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(v_limit*-1.0,2));
			}
//printf("%.2lf",v_limit);
DEBUGLOG(("psp_limit_report_merchant() limit = [%.2lf]\n",v_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

		if (ind_remaining_limit >= 0) {
			if (v_remaining_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(v_remaining_limit*-1.0,2));
			}
//printf("%.2lf",v_remaining_limit);
DEBUGLOG(("psp_limit_report_merchant() remaining_limit = [%.2lf]\n",v_remaining_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

printf("%s\n",PD_END_TAG);

		if (ind_cnt >= 0) {
DEBUGLOG(("psp_limit_report_merchant() cnt = [%d]\n",v_cnt));
		}
	}
	EXEC SQL CLOSE c_merchant;

if (iCnt > 1) printf("</table>\n");

DEBUGLOG(("psp_limit_report_merchant() iRet = [%d]\n",iRet));
	return iRet;

merchant_error:
DEBUGLOG(("psp_limit_report_merchant error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_merchant;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int psp_limit_report_group_o(char* csMerchantId)
{
	int     iRet = SUCCESS;
	int	iCnt = 0;
	char	csCSegment[PD_DESC_LEN + 1];
	strcpy(csCSegment,"");

printf("<h2>%s</h2>\n","Segment Overflow");

printf("<table border='1'>\n");
printf("<tr><th>PSP Name</th><th>PSP Account Name</th><th>Remark</th><th>Currency</th><th>Ratio</th><th>Customer Segment</th><th>PID Limit</th><th>PSP Remaining Limit</th></tr>\n");

	EXEC SQL WHENEVER SQLERROR GOTO merchant_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_merchant_id[PD_MERCHANT_ID_LEN + 1];

		varchar	v_client_id[PD_CLIENT_ID_LEN + 1];
		varchar	v_client_name[PD_CLIENT_NAME_LEN + 1];
		varchar	v_psp_id[PD_PSP_ID_LEN + 1];
		varchar	v_psp_name[PD_PSP_NAME_LEN + 1];
		varchar	v_remark[PD_REMARK_LEN + 1];
		varchar	v_currency[PD_CCY_ID_LEN + 1];
		double	v_ratio;
		varchar	v_customer_segment[PD_DESC_LEN + 1];
		double	v_limit;
		double	v_remaining_limit;
		int	v_cnt;

		short	ind_client_id = -1;
		short	ind_client_name = -1;
		short	ind_psp_id = -1;
		short	ind_psp_name = -1;
		short	ind_remark = -1;
		short	ind_currency = -1;
		short	ind_ratio = -1;
		short	ind_customer_segment = -1;
		short	ind_limit = -1;
		short	ind_remaining_limit = -1;
		short	ind_cnt = -1;

	EXEC SQL END DECLARE SECTION;

	hv_merchant_id.len = strlen((char*)csMerchantId);
	memcpy(hv_merchant_id.arr,csMerchantId,hv_merchant_id.len);

	EXEC SQL DECLARE c_group_o CURSOR FOR
		SELECT	/* CLIENT_ID AS CLIENT_ID,
			CLIENT_NAME AS CLIENT_NAME,
			MERCHANT_ID AS MERCHANT_ID,
			SHORT_NAME AS SHORT_NAME,
			BUSINESS_TYPE AS BUSINESS_TYPE, */
			PSP_CLIENT_ID AS PSP_CLIENT_ID,
			PSP_CLIENT_NAME AS PSP_CLIENT_NAME,
			PSP_ID AS PSP_ID,
			PSP_NAME AS PSP_NAME,
			PSP_REMARK AS PSP_REMARK,
			CURRENCY_ID AS CURRENCY_ID,
			LIMIT AS LIMIT,
			REMAINING_LIMIT AS REMAINING_LIMIT,
			/* MIN_TRANSACTION_AMOUNT AS MIN_TRANSACTION_AMOUNT,
			MAX_TRANSACTION_AMOUNT AS MAX_TRANSACTION_AMOUNT, */
			NVL(CUSTOMER_SEGMENT_DESC,'-') AS CUSTOMER_SEGMENT,
			/* CRITERIA_POOL_ID AS CRITERIA_POOL_ID,
			POOL_ID AS POOL_ID,
			POOL_RATIO AS POOL_RATIO_BAK, */
			POOL_RM_RATIO AS POOL_RATIO,
			count(*) OVER () AS TOTAL_ROWS
		FROM (
			SELECT CLIENT_ID AS CLIENT_ID,
				CLIENT_NAME AS CLIENT_NAME,
				MERCHANT_ID AS MERCHANT_ID,
				SHORT_NAME AS SHORT_NAME,
				BUSINESS_TYPE AS BUSINESS_TYPE,
				PSP_CLIENT_ID AS PSP_CLIENT_ID,
				PSP_CLIENT_NAME AS PSP_CLIENT_NAME,
				PSP_ID AS PSP_ID,
				PSP_NAME AS PSP_NAME,
				PSP_REMARK AS PSP_REMARK,
				CURRENCY_ID AS CURRENCY_ID,
				LIMIT AS LIMIT,
				REMAINING_LIMIT AS REMAINING_LIMIT,
				MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
				MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT,
				CUSTOMER_SEGMENT AS CUSTOMER_SEGMENT_CODE,
				CUSTOMER_GROUP.CG_DESC AS CUSTOMER_SEGMENT_DESC,
				CRITERIA_POOL_ID AS CRITERIA_POOL_ID,
				POOL_ID AS POOL_ID,
				POOL_RATIO AS POOL_RATIO,
				POOL_RM_RATIO AS POOL_RM_RATIO
			FROM PSP_LIMIT_MERCHANT_VIEW
			LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = PSP_LIMIT_MERCHANT_VIEW.CUSTOMER_SEGMENT
			WHERE MERCHANT_ID = :hv_merchant_id
			AND psp_id in ( select psp_id from psp_detail where pid_group = 'GRP_O')
			GROUP BY CLIENT_ID,
				CLIENT_NAME,
				MERCHANT_ID,
				SHORT_NAME,
				BUSINESS_TYPE,
				PSP_CLIENT_ID,
				PSP_CLIENT_NAME,
				PSP_ID,
				PSP_NAME,
				PSP_REMARK,
				CURRENCY_ID,
				LIMIT,
				REMAINING_LIMIT,
				CUSTOMER_SEGMENT,
				CG_DESC,
				CRITERIA_POOL_ID,
				POOL_ID,
				POOL_RATIO,
				POOL_RM_RATIO
			) summary
		WHERE 1 = 1
		ORDER BY CUSTOMER_SEGMENT,
			CLIENT_NAME,
			SHORT_NAME,
			UPPER(PSP_NAME),
			CURRENCY_ID;

	EXEC SQL OPEN c_group_o;
	for (;;) {
		EXEC SQL FETCH c_group_o
		INTO
			:v_client_id:ind_client_id,
			:v_client_name:ind_client_name,
			:v_psp_id:ind_psp_id,
			:v_psp_name:ind_psp_name,
			:v_remark:ind_remark,
			:v_currency:ind_currency,
			:v_limit:ind_limit,
			:v_remaining_limit:ind_remaining_limit,
			:v_customer_segment:ind_customer_segment,
			:v_ratio:ind_ratio,
			:v_cnt:ind_cnt;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

		if (ind_customer_segment >= 0) {
			v_customer_segment.arr[v_customer_segment.len]='\0';
		}

		if (ind_client_id >= 0) {
			v_client_id.arr[v_client_id.len]='\0';
DEBUGLOG(("psp_limit_report_group_o() client_id = [%s]\n",v_client_id.arr));
		}

printf("%s",PD_OPEN_TAG);

		if (ind_client_name >= 0) {
			v_client_name.arr[v_client_name.len]='\0';
printf("%s",(char*)v_client_name.arr);
DEBUGLOG(("psp_limit_report_group_o() client_name = [%s]\n",v_client_name.arr));
		}

		if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len]='\0';
DEBUGLOG(("psp_limit_report_group_o() psp_id = [%s]\n",v_psp_id.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_psp_name >= 0) {
			v_psp_name.arr[v_psp_name.len]='\0';
printf("%s",(char*)v_psp_name.arr);
DEBUGLOG(("psp_limit_report_group_o() psp_name = [%s]\n",v_psp_name.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_remark >= 0) {
			v_remark.arr[v_remark.len]='\0';
printf("%s",(char*)v_remark.arr);
DEBUGLOG(("psp_limit_report_group_o() remark = [%s]\n",v_remark.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_currency >= 0) {
			v_currency.arr[v_currency.len]='\0';
printf("%s",(char*)v_currency.arr);
DEBUGLOG(("psp_limit_report_group_o() currency = [%s]\n",v_currency.arr));
		}

printf("%s",PD_NEXT_TAG_CS);

		if (ind_ratio >= 0) {
printf("%d",(int)v_ratio);
DEBUGLOG(("psp_limit_report_group_o() ratio = [%d]\n",(int)v_ratio));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_customer_segment >= 0) {
			v_customer_segment.arr[v_customer_segment.len]='\0';
printf("%s",(char*)v_customer_segment.arr);
DEBUGLOG(("psp_limit_report_group_o() customer_segment = [%s]\n",v_customer_segment.arr));
		}

		if (ind_limit >= 0) {
			if (v_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(v_limit*-1.0,2));
			}
//printf("%.2lf",v_limit);
DEBUGLOG(("psp_limit_report_group_o() limit = [%.2lf]\n",v_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

		if (ind_remaining_limit >= 0) {
			if (v_remaining_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(v_remaining_limit*-1.0,2));
			}
//printf("%.2lf",v_remaining_limit);
DEBUGLOG(("psp_limit_report_group_o() remaining_limit = [%.2lf]\n",v_remaining_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

printf("%s\n",PD_END_TAG);

		if (ind_cnt >= 0) {
DEBUGLOG(("psp_limit_report_group_o() cnt = [%d]\n",v_cnt));
		}
	}
	EXEC SQL CLOSE c_group_o;

if (iCnt > 1) printf("</table>\n");

DEBUGLOG(("psp_limit_report_group_o() iRet = [%d]\n",iRet));
	return iRet;

merchant_error:
DEBUGLOG(("psp_limit_report_group_o error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_group_o;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}

int parse_arg(int argc, char **argv)
{
	return SUCCESS;
}
