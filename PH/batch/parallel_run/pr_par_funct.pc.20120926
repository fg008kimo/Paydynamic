/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/07/06              Virginia Yun

*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sqlca.h>
#include <sqlcpr.h>
#include "common.h"
#include "internal.h"
#include "utilitys.h"
#include "dbutility.h"
#include "../batchcommon.h"
#include "pr_par_funct.h"

char	cDebug;
#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


///////////////////////////////////////////////
//////////////////Service//////////////////////
int Service_FindCountryByService(const unsigned char* ServiceCode, char* TxnCountry)
{

        int iRet = NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO find_country_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];
                int     hv_disabled;

                varchar v_country[PD_COUNTRY_LEN+1];

                short   ind_country=-1;

        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen((const char*)ServiceCode);
        memcpy(hv_service_code.arr,ServiceCode,hv_service_code.len);
DEBUGLOG(("FindCountryByService: ServiceCode = [%.*s]\n",hv_service_code.len,hv_service_code.arr));

        hv_disabled=0;

        EXEC SQL DECLARE c_cursor_find_country CURSOR FOR
                select sc_txn_country
                 from def_service_code
                where sc_code = :hv_service_code;

        EXEC SQL OPEN c_cursor_find_country;
        do{
                EXEC SQL FETCH c_cursor_find_country
                INTO
                        :v_country:ind_country;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if(ind_country>=0){
                        v_country.arr[v_country.len]='\0';
                        strcpy(TxnCountry, (const char*)v_country.arr);
DEBUGLOG(("FindCountryByService: country = [%s]\n",TxnCountry));

                        iRet = FOUND;
                }

        }while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_find_country;

DEBUGLOG(("FindCountryByService iRet = [%d]\n",iRet));
        return iRet;

find_country_error:
DEBUGLOG(("find_country_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_find_country;
    return NOT_FOUND;
}


/////////////////////////////////////////////////////
//////////////////ServicePayMethod///////////////////
int ServicePayMethod_FindPayMethod(const char* csServiceCode,
                  recordset_t* myRec)
{
        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_service_code[PD_SERVICE_CODE_LEN];

                varchar v_pay_method[PD_PAY_METHOD_LEN+1];

                short   ind_pay_method = -1;
        EXEC SQL END DECLARE SECTION;

        hv_service_code.len = strlen(csServiceCode);
        memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);
DEBUGLOG(("FindPayMethod: service_code = [%.*s][%d]\n",hv_service_code.len,hv_service_code.arr,hv_service_code.len));

        EXEC SQL DECLARE c_cursor_find CURSOR FOR
                select  sp_pay_method
                from    service_pay_method
                Where   sp_service_code = :hv_service_code
                and     sp_disabled = '0';

        EXEC SQL OPEN c_cursor_find;
        do {
                EXEC SQL FETCH c_cursor_find
                INTO
                        :v_pay_method:ind_pay_method;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

                if (ind_pay_method >= 0) {
                        v_pay_method.arr[v_pay_method.len] ='\0';
                        PutField_CString(myHash,"pay_method",(const char*)v_pay_method.arr);
DEBUGLOG(("FindPayMethod: pay_method = [%s]\n",v_pay_method.arr));
                }
                RecordSet_Add(myRec,myHash);

        }while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_find;

DEBUGLOG(("FindPayMethod Normal Exit\n"));
        return PD_OK;

find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_find;
    return PD_ERR;
}



///////////////////////////////////////////////
//////////////////ParDefMisc///////////////////
int ParDefMisc_GetValue(const char *csCode,
      		          char *csValue)
{
        EXEC SQL WHENEVER SQLERROR GOTO find_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_code[PD_SP_CODE_LEN];

                varchar v_value[PD_SP_VALUE_LEN +1 ];
                short   ind_value = -1;

        EXEC SQL END DECLARE SECTION;

        hv_code.len = strlen((const char*)csCode);
        memcpy(hv_code.arr, csCode, hv_code.len);
DEBUGLOG(("GetValue: code = [%.*s]\n",hv_code.len,hv_code.arr));

        EXEC SQL SELECT pdm_value
                   INTO :v_value:ind_value
                FROM par_def_misc
                WHERE pdm_code = :hv_code;

        if (ind_value >= 0) {
//DEBUGLOG(("Get Value OK \n"));
                v_value.arr[v_value.len] = '\0';
                strcpy((char*)csValue,(const char*)v_value.arr);
DEBUGLOG(("value = [%s]\n",csValue));
                return FOUND;
        }
DEBUGLOG(("Value NOT FOUND\n"));
        return NOT_FOUND;

find_error:
DEBUGLOG(("find_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}


////////////////////////////////////////////////
//////////////////ParCategory///////////////////
int ParCategory_GetCategory(const char* csSeqTypeName,
                hash_t * hRec)
{
        int iCnt = 0;

        EXEC SQL WHENEVER SQLERROR GOTO getcategory_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_sequence_type_name[PAR_PD_SEQUENCE_TYPE_NAME];

                varchar         v_category[PAR_PD_CATEGORY + 1];
                varchar         v_txn_code[PD_TXN_CODE_LEN + 1];
                varchar         v_reversal_txn_code[PD_TXN_CODE_LEN + 1];

                short           ind_category = -1;
                short           ind_txn_code = -1;
                short           ind_reversal_txn_code = -1;


        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("GetCategory: Begin [%s]\n", csSeqTypeName));

        hv_sequence_type_name.len = strlen(csSeqTypeName);
        memcpy(hv_sequence_type_name.arr, csSeqTypeName, hv_sequence_type_name.len);
//DEBUGLOG(("GetCategory: sequence_type_name = [%.*s]\n",hv_sequence_type_name.len,hv_sequence_type_name.arr));


        EXEC SQL DECLARE c_cursor_getcategory CURSOR FOR
                SELECT pc_category, pc_txn_code, pc_reversal_txn_code
                  FROM par_category
                 WHERE pc_sequence_type_name = :hv_sequence_type_name;

        EXEC SQL OPEN c_cursor_getcategory;
        do {
                EXEC SQL FETCH c_cursor_getcategory
                INTO :v_category:ind_category,
                     :v_txn_code:ind_txn_code,
                     :v_reversal_txn_code:ind_reversal_txn_code;


                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
                iCnt++;

// category
                if (ind_category >= 0) {
                        v_category.arr[v_category.len] = '\0';
                        PutField_CString(hRec, "category", (const char*)v_category.arr);
DEBUGLOG(("GetCategory category = [%s]\n",v_category.arr));
                }

// txn_code
                if (ind_txn_code >= 0) {
                        v_txn_code.arr[v_txn_code.len] = '\0';
                        PutField_CString(hRec, "txn_code", (const char*)v_txn_code.arr);
//DEBUGLOG(("GetCategory txn_code = [%s]\n",v_txn_code.arr));
                }

// reversal_txn_code
                if (ind_reversal_txn_code >= 0) {
                        v_reversal_txn_code.arr[v_reversal_txn_code.len] = '\0';
                        PutField_CString(hRec, "reversal_txn_code", (const char*)v_reversal_txn_code.arr);
//DEBUGLOG(("GetCategory reversal_txn_code = [%s]\n",v_reversal_txn_code.arr));
                }


        }
        while (PD_TRUE);
        EXEC SQL CLOSE c_cursor_getcategory;


        if (iCnt > 0) {
DEBUGLOG(("GetCategory Normal Exit\n"));
                return PD_OK;
        } else {
                return PD_ERR;
        }


getcategory_error:
DEBUGLOG(("getcategory_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getcategory;
        return PD_ERR;
}

////////////////////////////////////////////////////
//////////////////ParMerchProfile///////////////////
int ParMerchProfile_GetMerchant(const char* csMerchAccNmb,
                recordset_t* myRec)
{
        int iRet = PD_OK;

        hash_t *myHash;
        EXEC SQL WHENEVER SQLERROR GOTO getmerchant_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_merch_account_nmb[PAR_PD_MERCH_ACCOUNT_NMB_LEN];

                varchar         v_username[PAR_PD_USERNAME_LEN + 1];
                varchar         v_api_merch_id[PAR_PD_API_MERCH_ID_LEN + 1];
                varchar         v_ack_url[PAR_PD_ACK_URL_LEN + 1];
                int             v_payout_enable;
                varchar         v_service[PD_SERVICE_CODE_LEN + 1];
                varchar         v_ph_merch_id[PD_MERCHANT_ID_LEN + 1];
                varchar         v_client_id[PD_CLIENT_ID_LEN + 1];

                short           ind_username = -1;
                short           ind_api_merch_id = -1;
                short           ind_ack_url = -1;
                short           ind_payout_enable = -1;
                short           ind_service = -1;
                short           ind_ph_merch_id = -1;
                short           ind_client_id = -1;

        EXEC SQL END DECLARE SECTION;

        hv_merch_account_nmb.len = strlen(csMerchAccNmb);
        memcpy(hv_merch_account_nmb.arr,csMerchAccNmb,hv_merch_account_nmb.len);
DEBUGLOG(("GetMerchant merch_account_nmb = [%.*s]\n",hv_merch_account_nmb.len,hv_merch_account_nmb.arr));

        EXEC SQL DECLARE c_cursor_getmerchant CURSOR FOR
                select  pmp_username,
                        pmp_api_merch_id,
                        pmp_ack_url,
                        pmp_payout_enable,
                        pmp_service,
                        pmp_ph_merch_id,
                        client_id
                  from par_merch_profile, merch_detail
                 where pmp_merch_account_nmb = :hv_merch_account_nmb
                   and pmp_ph_merch_id = merchant_id;


        EXEC SQL OPEN c_cursor_getmerchant;
        do {
                EXEC SQL FETCH c_cursor_getmerchant
                INTO
                        :v_username:ind_username,
                        :v_api_merch_id:ind_api_merch_id,
                        :v_ack_url:ind_ack_url,
                        :v_payout_enable:ind_payout_enable,
                        :v_service:ind_service,
                        :v_ph_merch_id:ind_ph_merch_id,
                        :v_client_id:ind_client_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        iRet = SQL_NOT_FOUND;
                        break;
                }

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);
// username
                if (ind_username >= 0) {
                        v_username.arr[v_username.len] = '\0';
                        PutField_CString(myHash,"username",(const char*)v_username.arr);
DEBUGLOG(("GetMerchant username = [%s]\n",v_username.arr));
                }

// api_merch_id
                if (ind_api_merch_id >= 0) {
                        v_api_merch_id.arr[v_api_merch_id.len] = '\0';
                        PutField_CString(myHash,"api_merch_id",(const char*)v_api_merch_id.arr);
//DEBUGLOG(("GetMerchant api_merch_id = [%s]\n",v_api_merch_id.arr));
                }

// ack_url
                if (ind_ack_url >= 0) {
                        v_ack_url.arr[v_ack_url.len] = '\0';
                        PutField_CString(myHash,"ack_url",(const char*)v_ack_url.arr);
//DEBUGLOG(("GetMerchant ack_url = [%s]\n",v_ack_url.arr));
                }

// payout_enable
                if (ind_payout_enable >=0) {
                        PutField_Int(myHash, "payout_enable", v_payout_enable);
//DEBUGLOG(("GetMerchant payout_enable = [%d]\n", v_payout_enable));
                }

// service
                if (ind_service >= 0) {
                        v_service.arr[v_service.len] = '\0';
                        PutField_CString(myHash,"service",(const char*)v_service.arr);
DEBUGLOG(("GetMerchant service = [%s]\n",v_service.arr));
                }

// merchant_id
                if (ind_ph_merch_id >= 0) {
                        v_ph_merch_id.arr[v_ph_merch_id.len] = '\0';
                        PutField_CString(myHash,"merchant_id",(const char*)v_ph_merch_id.arr);
DEBUGLOG(("GetMerchant ph_merch_id = [%s]\n",v_ph_merch_id.arr));
                }

// client_id
                if (ind_client_id >= 0) {
                        v_client_id.arr[v_client_id.len] = '\0';
                        PutField_CString(myHash,"client_id",(const char*)v_client_id.arr);
DEBUGLOG(("GetMerchant client_id = [%s]\n",v_client_id.arr));
                }

                RecordSet_Add(myRec,myHash);
                break; //**************** only one now
        }
        while(PD_TRUE);

        EXEC SQL CLOSE c_cursor_getmerchant;



DEBUGLOG(("GetMerchant Normal Exit\n"));
        if(iRet==0) return  PD_OK;
        else    return iRet;

getmerchant_error:
DEBUGLOG(("getmerchant_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getmerchant;
        return PD_ERR;
}


////////////////////////////////////////////////////
//////////////////ParTxnData////////////////////////
int     ParTxnData_ChkExist(const char *csVNCRefNum)
{
        int     iRet = PD_NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO chkexist_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_vnc_ref_num[PD_TXN_SEQ_LEN];

                int             v_no_of_record;
                short           ind_no_of_record = -1;

        EXEC SQL END DECLARE SECTION;

        hv_vnc_ref_num.len = strlen(csVNCRefNum);
        memcpy(hv_vnc_ref_num.arr, csVNCRefNum, hv_vnc_ref_num.len);
DEBUGLOG(("ChkExist vnc_ref_num = [%.*s]\n",hv_vnc_ref_num.len,hv_vnc_ref_num.arr));


        EXEC SQL
                SELECT count(1)
                   INTO :v_no_of_record:ind_no_of_record
                   FROM txn_header
                  WHERE th_vnc_ref_num = :hv_vnc_ref_num
                    and rownum = 1;

        if (ind_no_of_record >= 0) {
                if (v_no_of_record > 0) {
DEBUGLOG(("ChkExist FOUND\n"));
                        iRet = PD_FOUND;
                }
        }

        if (iRet!= PD_FOUND) {
DEBUGLOG(("ChkExist NOT FOUND\n"));
        }

        return iRet;

chkexist_error:
DEBUGLOG(("ChkExist_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;

}


int UpdateProcessResult(hash_t *hMyHash, const char *csStatus)
{
        int     iRet = SUCCESS;
        int     iTmp;

        if (GetField_Int(hMyHash, "sort_txn_seq", &iTmp)) {
//DEBUGLOG(("UpdateProcessTxnResult sort_txn_seq [%d]\n", iTmp));
        }

//DEBUGLOG(("UpdateProcessTxnResult status [%s]\n", csStatus));
        PutField_CString(hMyHash, "proc_status", csStatus);

        if (UpdateTxnDataStatus(hMyHash) == PD_OK) {
DEBUGLOG(("UpdateProcessTxnResult : txn_data.seq [%d] status [%s]\n", iTmp, csStatus));
        }
        else {
                iRet = FAILURE;
        }

        return iRet;
}

int UpdateTxnDataStatus(const hash_t *hRls)
{
        char    *csTmp;
        char*   csBuf;


        int     iSortTxnSeq;

        EXEC SQL WHENEVER SQLERROR GOTO updatestatus_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

        varchar         hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateStatus: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update par_txn_data set ptd_update_timestamp  = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

        GetField_Int(hRls,"sort_txn_seq",&iSortTxnSeq);
DEBUGLOG(("UpdateStatus:sort_txn_id = [%d]\n",iSortTxnSeq));

        if (GetField_CString(hRls, "proc_status", &csTmp)) {
DEBUGLOG(("UpdateStatus:proc_status= [%s]\n",csTmp));

                strcat((char*)hv_dynstmt.arr, ",ptd_proc_status = '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

        sprintf(csBuf, "%d", iSortTxnSeq);

        strcat((char *)hv_dynstmt.arr, " WHERE ptd_txn_seq = ");
        strcat((char *)hv_dynstmt.arr, csBuf);
        //strcat((char *)hv_dynstmt.arr, "'");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
//DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);
DEBUGLOG(("Update Status Normal Exit\n"));
        return PD_OK;

updatestatus_error:
DEBUGLOG(("updatestatus_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("Transaction_Update: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Update: SP_INTERNAL_ERR TxnAbort\n"));
        return PD_INTERNAL_ERR;
}

int UpdateApprovalTimestamp(const hash_t *hRls)
{
        //char    *csTmp;
        char*   csBuf;
        char*   csTxnId;

        EXEC SQL WHENEVER SQLERROR GOTO update_approvetime_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

        varchar         hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("UpdateApprovalTimestamp: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update txn_header set th_update_timestamp  = sysdate, ");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

        GetField_CString(hRls,"txn_seq",&csTxnId);
DEBUGLOG(("UpdateApprovalTimestamp:txn_id = [%s]\n",csTxnId));

        strcat((char *)hv_dynstmt.arr, "th_approval_timestamp = to_timestamp(th_approval_date || to_char(th_approval_timestamp, 'HH24MISSFF6') , 'YYYYMMDDHH24MISSFF')");
        hv_dynstmt.len=strlen((const char*) hv_dynstmt.arr);


        strcat((char *)hv_dynstmt.arr, " WHERE th_txn_id = '");
        strcat((char *)hv_dynstmt.arr, csTxnId);
        strcat((char *)hv_dynstmt.arr, "'");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);
// update txn sub status
//        AddTxnStatusLog(hRls);

DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;

update_approvetime_error:
DEBUGLOG(("update_approvetime_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("Transaction_Update_approvetime: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Update: SP_INTERNAL_ERR TxnAbort\n"));
//        TxnAbort();
        return PD_INTERNAL_ERR;
}




int  GetOrgTxnID(hash_t * hMyHash, hash_t *hTxnHeader)
{
        int     iRet = SUCCESS;

        char    *csVNCRefNum;

        char    cTmp;
        char    *csTmp;

        if (GetField_CString(hMyHash, "txn_nmb", &csVNCRefNum)) {
DEBUGLOG(("GetOrgTxnID vnc_ref_num [%s]\n", csVNCRefNum));
        }

        if (GetTxnHeaderByVNCRefNum(csVNCRefNum, hTxnHeader) == PD_OK) {
                if (GetField_CString(hTxnHeader, "txn_id", &csTmp)) {
DEBUGLOG(("GetOrgTxnID: ParTxnData:GetTxnHeaderByVNCRefNum txn_id [%s]\n", csTmp));
                }

                if (GetField_Char(hTxnHeader, "status", &cTmp)) {
DEBUGLOG(("GetOrgTxnID: ParTxnData:GetTxnHeaderByVNCRefNum status [%c]\n", cTmp));
                }

                if (GetField_Char(hTxnHeader, "ar_ind", &cTmp)) {
DEBUGLOG(("GetOrgTxnID: ParTxnData:GetTxnHeaderByVNCRefNum ar_ind [%c]\n", cTmp));
                }

                if (GetField_CString(hTxnHeader, "sub_status", &csTmp)) {
DEBUGLOG(("GetOrgTxnID: ParTxnData:GetTxnHeaderByVNCRefNum sub_status[%s]\n", csTmp));
                }

                if (GetField_CString(hTxnHeader, "txn_code", &csTmp)) {
DEBUGLOG(("GetOrgTxnID: ParTxnData:GetTxnHeaderByVNCRefNum txn_code [%s]\n", csTmp));
                }
        }
        else {
DEBUGLOG(("GetOrgTxnID: : ParTxnData:GetTxnHeaderByVNCRefNum FAIL!\n"));
                iRet = FAILURE;
        }

        return iRet;
}

int GetTxnHeaderByVNCRefNum(const char*csVNCRefNum, hash_t *hRec)
{
        int     iRet = PD_OK;

        EXEC SQL WHENEVER SQLERROR GOTO getheader_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_vnc_ref_num[PD_TXN_SEQ_LEN];

                varchar v_txn_id[PD_TXN_SEQ_LEN + 1];
                char    v_status;
                char    v_ar_ind;
                varchar v_sub_status[PD_SUB_STATUS_LEN + 1];
                varchar v_txn_code[PD_TXN_CODE_LEN + 1];

                short   ind_txn_id = -1;
                short   ind_status = -1;
                short   ind_ar_ind = -1;
                short   ind_sub_status = -1;
                short   ind_txn_code = -1;

        EXEC SQL END DECLARE SECTION;

        hv_vnc_ref_num.len = strlen(csVNCRefNum);
        memcpy(hv_vnc_ref_num.arr, csVNCRefNum, hv_vnc_ref_num.len);
DEBUGLOG(("GetDepositTxnHeaderByVNCRefNum vnc_ref_num = [%.*s]\n",hv_vnc_ref_num.len,hv_vnc_ref_num.arr));

        EXEC SQL SELECT th_txn_id,
                        th_status,
                        th_ar_ind,
                        th_sub_status,
                        th_txn_code
                   INTO :v_txn_id:ind_txn_id,
                        :v_status:ind_status,
                        :v_ar_ind:ind_ar_ind,
                        :v_sub_status:ind_sub_status,
                        :v_txn_code:ind_txn_code
                   from (select th_txn_id,
                                th_status,
                                th_ar_ind,
                                th_sub_status,
                                th_txn_code
                         FROM txn_header
                         WHERE th_vnc_ref_num = :hv_vnc_ref_num
                         order by decode(th_txn_code, 'VDS', 1, 'VST', 1, 'VMT', 1, decode(substr(th_txn_code, 1, 1), 'y', 1, 2))
                        )
                   where rownum = 1;

        if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("GetDepositTxnHeaderByVNCRefNum SQL_NOT_FOUND!\n"));
                iRet = NOT_FOUND;
        }
        if (ind_txn_id >= 0) {
                iRet = PD_OK;

                v_txn_id.arr[v_txn_id.len] = '\0';
DEBUGLOG(("GetDepositTxnHeaderByVNCRefNum txn_id [%.*s]\n", v_txn_id.len, v_txn_id.arr));
                PutField_CString(hRec, "txn_id", (const char*)v_txn_id.arr);
        }

        if (ind_status >= 0) {
DEBUGLOG(("GetDepositTxnHeaderByVNCRefNum status [%c]\n", v_status));
                PutField_Char(hRec, "status", v_status);
        }

        if (ind_ar_ind >= 0) {
DEBUGLOG(("GetDepositTxnHeaderByVNCRefNum ar_ind [%.*s]\n", v_ar_ind));
                PutField_Char(hRec, "ar_ind", v_ar_ind);
        }

        if (ind_sub_status >= 0) {
                v_sub_status.arr[v_sub_status.len] = '\0';
DEBUGLOG(("GetDepositTxnHeaderByVNCRefNum sub_status [%.*s]\n", v_sub_status.len, v_sub_status.arr));
                PutField_CString(hRec, "sub_status", (const char*)v_sub_status.arr);
        }

        if (ind_txn_code >= 0) {
                v_txn_code.arr[v_txn_code.len] = '\0';
DEBUGLOG(("GetDepositTxnHeaderByVNCRefNum txn_code [%.*s]\n", v_txn_code.len, v_txn_code.arr));
                PutField_CString(hRec, "txn_code", (const char*)v_txn_code.arr);

        }

        return iRet;

getheader_error:
DEBUGLOG(("getheader_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return NOT_FOUND;
}


int UpdateHeaderVNCRef(const hash_t *hRls)
{
        char    *csTmp;
        char*   csBuf;
        char*   csTxnId;

        EXEC SQL WHENEVER SQLERROR GOTO update_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

        varchar         hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("Update: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update txn_header set th_update_timestamp  = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

        GetField_CString(hRls,"txn_seq",&csTxnId);
DEBUGLOG(("Update:txn_id = [%s]\n",csTxnId));

        if (GetField_CString(hRls, "vnc_ref_num", &csTmp)) {
DEBUGLOG(("Update:vnc_ref_num = [%s]\n",csTmp));
                strcat((char*)hv_dynstmt.arr, ",th_vnc_ref_num = '");
                strcat((char*)hv_dynstmt.arr, csTmp);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }
        strcat((char *)hv_dynstmt.arr, " WHERE th_txn_id = '");
        strcat((char *)hv_dynstmt.arr, csTxnId);
        strcat((char *)hv_dynstmt.arr, "'");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));

        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);

// update txn sub status
//        AddTxnStatusLog(hRls);

DEBUGLOG(("Update Normal Exit\n"));
        return PD_OK;

update_error:
DEBUGLOG(("update_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
ERRLOG("Transaction_Update: SP_INTERNAL_ERR TxnAbort\n");
DEBUGLOG(("Update: SP_INTERNAL_ERR TxnAbort\n"));
        return PD_INTERNAL_ERR;
}








////////////////////////

int ParPspClientMap_GetPspID(hash_t *hRec)
{
        int iRet = NOT_FOUND;
        char    *csTmp;

        EXEC SQL WHENEVER SQLERROR GOTO get_psp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar hv_psp_type_cd[PAR_PD_PSP_TYPE_CD];

                varchar v_psp_id [PD_PSP_ID_LEN + 1];
                varchar v_psp_country[PD_COUNTRY_LEN + 1];

                short   ind_psp_id;
                short   ind_psp_country;

        EXEC SQL END DECLARE SECTION;

        if (GetField_CString(hRec, "psp_type_code", &csTmp)) {
                hv_psp_type_cd.len = strlen(csTmp);
                memcpy(hv_psp_type_cd.arr, csTmp, hv_psp_type_cd.len);
DEBUGLOG(("GetPspID: psp_type_code [%.*s]\n", hv_psp_type_cd.len, hv_psp_type_cd.arr));
        }


        EXEC SQL DECLARE c_cursor_get_pid CURSOR FOR
                select psp_detail.psp_id, psp_country.country
                  from psp_country, psp_detail, par_psp_client_map
                 where ppm_psp_type_cd = :hv_psp_type_cd
                   and ppm_preset_pid = psp_detail.psp_id
                   and psp_detail.psp_id = psp_country.psp_id;

        EXEC SQL OPEN c_cursor_get_pid;
        do {
                EXEc SQL FETCH c_cursor_get_pid
                INTO    :v_psp_id:ind_psp_id,
                        :v_psp_country:ind_psp_country;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if (ind_psp_id >= 0) {
                        v_psp_id.arr[v_psp_id.len]='\0';
                        PutField_CString(hRec, "psp_id", (const char *)v_psp_id.arr);
DEBUGLOG(("GetPspID: psp_id= [%s]\n", v_psp_id.arr));

                        iRet = FOUND;
                }

                if (ind_psp_country >= 0) {
                        v_psp_country.arr[v_psp_country.len]='\0';
                        PutField_CString(hRec, "psp_country", (const char *)v_psp_country.arr);
DEBUGLOG(("GetPspID: psp_country= [%s]\n", v_psp_country.arr));
                }

        }while (PD_TRUE);

        EXEC SQL CLOSE c_cursor_get_pid;

DEBUGLOG(("GetPspID iRet = [%d]\n",iRet));
        return iRet;

get_psp_error:
DEBUGLOG(("get_psp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_get_pid;
    return NOT_FOUND;

}

int ParPspClientMap_GetBankCode(hash_t *hRec)
{
        int iRet = NOT_FOUND;
        char    *csTmp;

        EXEC SQL WHENEVER SQLERROR GOTO get_bankcode_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                //varchar hv_psp_type_cd[PAR_PD_PSP_TYPE_CD];
                varchar hv_ext_bank_code[PD_EXT_BANK_CODE_LEN];

                varchar v_int_bank_code[PD_BANK_CODE_LEN + 1];
                short   ind_int_bank_code = -1;


        EXEC SQL END DECLARE SECTION;

        if (GetField_CString(hRec, "gate_id", &csTmp)) {
                hv_ext_bank_code.len = strlen(csTmp);
                memcpy(hv_ext_bank_code.arr, csTmp, hv_ext_bank_code.len);
DEBUGLOG(("GetBankCode: ext_bank_code [%.*s]\n", hv_ext_bank_code.len, hv_ext_bank_code.arr));
        }

        EXEC SQL DECLARE c_cursor_get_bank_code CURSOR FOR
                select pbm_int_bank_code
                  from par_bank_mapping
                 where pbm_bank_name = :hv_ext_bank_code;

        EXEC SQL OPEN c_cursor_get_bank_code;
        do {
                EXEc SQL FETCH c_cursor_get_bank_code
                INTO    :v_int_bank_code:ind_int_bank_code;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

                if (ind_int_bank_code >= 0) {
                        v_int_bank_code.arr[v_int_bank_code.len]='\0';
                        PutField_CString(hRec, "int_bank_code", (const char *)v_int_bank_code.arr);
DEBUGLOG(("GetBankCode: int_bank_code = [%s]\n", v_int_bank_code.arr));

                        iRet = FOUND;
                }
        }while (PD_TRUE);

        EXEC SQL CLOSE c_cursor_get_bank_code;

DEBUGLOG(("GetBankCode iRet = [%d]\n",iRet));
        return iRet;

get_bankcode_error:
DEBUGLOG(("get_bankcode_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_get_bank_code;
    return NOT_FOUND;

}

int     GetAdjustmentTypeRec(const char cPartyType,
                                const char *csCode ,
                                recordset_t *myRec)
{
        int     iCnt = 0;
        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO getadjustmenttype_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                char            hv_party_type;
                varchar         hv_code[PD_ADJ_TYPE_CODE_LEN];
                /*int           hv_disabled;*/

                char            v_dc_ind;
                varchar         v_desc[PD_ADJ_TYPE_DESC_LEN + 1];
                int             v_disabled;

                short           ind_dc_ind = -1;
                short           ind_desc = -1;
                short           ind_disabled = -1;


        EXEC SQL END DECLARE SECTION;        

	hv_party_type = cPartyType;
DEBUGLOG(("GetAdjustmentTypeRec party_type = [%.c]\n", hv_party_type));

        hv_code.len = strlen(csCode);
        memcpy(hv_code.arr,csCode,hv_code.len);
DEBUGLOG(("GetAdjustmentTypeRec code = [%.*s]\n",hv_code.len,hv_code.arr));


        /*hv_disabled = 0;*/


        EXEC SQL DECLARE c_cursor_getadjtype CURSOR FOR
                select at_dc_ind,
                       at_desc,
                       at_disabled
                  from adjustment_type
                 where at_party_type = :hv_party_type
                   and at_code = :hv_code;
                   /*and at_disabled = :hv_disabled;*/

        EXEC SQL OPEN c_cursor_getadjtype;
        do {
                EXEC SQL FETCH c_cursor_getadjtype
                INTO    :v_dc_ind:ind_dc_ind,
                        :v_desc:ind_desc,
                        :v_disabled:ind_disabled;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }      


                iCnt++;

                myHash = (hash_t*) malloc (sizeof(hash_t));
                hash_init(myHash,0);

/* dc_ind */
                if (ind_dc_ind >= 0) {
                        PutField_Char(myHash, "dc_ind", v_dc_ind);
DEBUGLOG(("GetAdjustmentTypeRec dc_ind = [%c]\n",v_dc_ind));
                }

/* desc */     
                if (ind_desc >= 0) {
                        v_desc.arr[v_desc.len] = '\0';
                        PutField_CString(myHash, "desc", (const char *)v_desc.arr);
DEBUGLOG(("GetAdjustmentTypeRec desc = [%s]\n",v_desc.arr));

                }

/* disabled */
                if (ind_disabled >= 0) {
                        PutField_Int(myHash, "disabled", v_disabled);
DEBUGLOG(("GetAdjustmentTypeRec disabled = [%d]\n", v_disabled));

                }


                RecordSet_Add(myRec, myHash);
        }
        while (PD_TRUE);
        EXEC SQL CLOSE c_cursor_getadjtype;

        if (iCnt > 0 ) {
DEBUGLOG(("GetAdjustmentTypeRec Normal Exit\n"));
                return  PD_OK;
        }
        else {
DEBUGLOG(("GetAdjustmentTypeRec Normal Exit, Not Found\n"));
                return PD_ERR;
        }

getadjustmenttype_error:
DEBUGLOG(("getadjustmenttype_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_getadjtype;
        return PD_ERR;

}


////////// Payout /////////////////////
int     AddParPayoutUploadHD(const hash_t *hRls)
{
	char	*csTmp;

        EXEC SQL WHENEVER SQLERROR GOTO add_par_payout_upload_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar		hv_file_id[PD_TXN_SEQ_LEN];
		varchar         hv_batch_id[PD_TXN_SEQ_LEN];
		varchar		hv_create_user[PD_CREATE_USER_LEN];

		short		ind_file_id;
		short		ind_batch_id;
		short		ind_create_user;

		short		hv_return_value;
        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("AddParPayoutUpload: Begin\n"));

/* batch_id */
        if(GetField_CString(hRls,"batch_id",&csTmp)){
                hv_batch_id.len = strlen(csTmp);
                memcpy(hv_batch_id.arr, csTmp, hv_batch_id.len);
                ind_batch_id= 0;
DEBUGLOG(("AddParPayoutUpload:batch_id= [%.*s]\n",hv_batch_id.len,hv_batch_id.arr));
        }

/* file_id */
	if (GetField_CString(hRls, "file_id", &csTmp)) {
                hv_file_id.len = strlen(csTmp);
                memcpy(hv_file_id.arr, csTmp, hv_file_id.len);
                ind_file_id= 0;
DEBUGLOG(("AddParPayoutUpload:file_id= [%.*s]\n",hv_file_id.len,hv_file_id.arr));
	}

/* create_user */
	if (GetField_CString(hRls, "create_user", &csTmp)) {
                hv_create_user.len = strlen(csTmp);
                memcpy(hv_create_user.arr, csTmp, hv_create_user.len);
                ind_create_user = 0;
DEBUGLOG(("AddParPayoutUpload: create_user = [%.*s]\n",hv_create_user.len,hv_create_user.arr));
	}

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_par_payout_upload_hd_insert(
						:hv_file_id:ind_file_id,
						:hv_batch_id:ind_batch_id,
						:hv_create_user:ind_create_user);
		END;
	END-EXEC;

DEBUGLOG(("AddParPayoutUpload:Ret = [%d]\n",hv_return_value));
        if (hv_return_value == SP_OK)
        {
DEBUGLOG(("AddParPayoutUpload:Normal Exit\n"));
                return PD_OK;
        }

        if (hv_return_value == SP_OTHER_ERR)  {
ERRLOG("AddParPayoutUpload : SP_OTHER_ERR \n");
DEBUGLOG(("AddParPayoutUpload: SP_OTHER_ERR \n"));
                return PD_OTHER_ERR;
        }

        if (hv_return_value == SP_ERR)  {
ERRLOG("AddParPayoutUpload : SP_ERR \n");
DEBUGLOG(("AddParPayoutUpload : SP_ERR \n"));
                return PD_ERR;
        }

add_par_payout_upload_error:
DEBUGLOG(("add_par_payout_upload_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("AddParPayoutUpload: SP_INTERNAL_ERR \n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;

}



int     PayoutUpload_Header_ChkExist(hash_t *hRls) {

	int     iRet = PD_NOT_FOUND;
	char	*csTmp;

        EXEC SQL WHENEVER SQLERROR GOTO payout_hd_chkexist_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

		varchar		hv_file_id[PD_TXN_SEQ_LEN];
		short		ind_file_id;

		varchar         v_batch_id[PD_TXN_SEQ_LEN + 1];
		short		ind_batch_id;


        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("PayoutUpload_Header_ChkExist BEGIN\n"));

/* file_id */
        if (GetField_CString(hRls, "file_id", &csTmp)) {
                hv_file_id.len = strlen(csTmp);
                memcpy(hv_file_id.arr, csTmp, hv_file_id.len);
                ind_file_id= 0;
DEBUGLOG(("Payout_hd_chkexist:file_id= [%.*s]\n",hv_file_id.len,hv_file_id.arr));
        }

	EXEC SQL DECLARE c_cursor_get_batch_id CURSOR FOR
		SELECT	pu_batch_id
		FROM	par_payout_upload_hd
		WHERE	pu_file_id = :hv_file_id;

	EXEC SQL OPEN c_cursor_get_batch_id;
	do {
		EXEC SQL FETCH c_cursor_get_batch_id
		INTO	
			:v_batch_id:ind_batch_id;

		if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("Payout_hd_chkexist: record not found!\n"));
			break;
		}
DEBUGLOG(("Payout_hd_chkexist: found record!\n"));

/* batch_id */
		if (ind_batch_id >= 0) {
                        v_batch_id.arr[v_batch_id.len] = '\0';
                        PutField_CString(hRls,"hd_batch_id",(const char*)v_batch_id.arr);
DEBUGLOG(("Payout_hd_chkexist: batch_id = [%s]\n",v_batch_id.arr));
		}

		iRet = PD_FOUND;

		break; // expect only 1 record!

	} while (PD_TRUE);
	
	EXEC SQL CLOSE c_cursor_get_batch_id;

DEBUGLOG(("Payout_hd_chkexist Normal Exit\n"));
	return iRet;

payout_hd_chkexist_error:

DEBUGLOG(("payout_hd_chkexist_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("Payout_hd_chkexist: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_get_batch_id;
        return PD_ERR;

}

int     PayoutUpload_Detail_ChkExist(hash_t *hRls) 
{
        int     iRet = PD_NOT_FOUND;

	char	*csTmp;
	int	iTmp;

        EXEC SQL WHENEVER SQLERROR GOTO payout_dtl_chkexist_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar         hv_file_id[PD_TXN_SEQ_LEN];
		int		hv_seq_num;

                short           ind_file_id;
		short		ind_seq_num;

                varchar         v_batch_id[PD_TXN_SEQ_LEN + 1];
                short           ind_batch_id;


        EXEC SQL END DECLARE SECTION;

DEBUGLOG(("PayoutUpload_Detail_ChkExist BEGIN\n"));

/* file_id */
        if (GetField_CString(hRls, "file_id", &csTmp)) {
                hv_file_id.len = strlen(csTmp);
                memcpy(hv_file_id.arr, csTmp, hv_file_id.len);
                ind_file_id= 0;
DEBUGLOG(("Payout_dtl_chkexist:file_id= [%.*s]\n",hv_file_id.len,hv_file_id.arr));
        }

/* seq_num */
	if(GetField_Int(hRls,"seq_num",&iTmp)){
		hv_seq_num = iTmp;
                ind_seq_num = 0;
DEBUGLOG(("Payout_dtl_chkexist:seq_num = [%d]\n",hv_seq_num));
	}

/*
        EXEC SQL DECLARE c_cursor_get_batch_id_dt CURSOR FOR
		select pu_batch_id
		from par_payout_upload_dtl
		where pu_file_id = :hv_file_id
		and pu_seq_num = :hv_seq_num;
*/

        EXEC SQL DECLARE c_cursor_get_batch_id_dt CURSOR FOR
		select pu_batch_id
		from   merchant_upload_file_detail, par_payout_upload_hd
		where pu_file_id = :hv_file_id
		and   ud_batch_id = pu_batch_id
		and   ud_seq_num = :hv_seq_num;

        EXEC SQL OPEN c_cursor_get_batch_id_dt;
        do {
                EXEC SQL FETCH c_cursor_get_batch_id_dt
                INTO
                        :v_batch_id:ind_batch_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
DEBUGLOG(("Payout_dtl_chkexist: found record!\n"));

/* batch_id */
                if (ind_batch_id >= 0) {
                        v_batch_id.arr[v_batch_id.len] = '\0';
                        PutField_CString(hRls,"dt_batch_id",(const char*)v_batch_id.arr);
DEBUGLOG(("Payout_dtl_chkexist: batch_id = [%s]\n",v_batch_id.arr));
                }

                iRet = PD_FOUND;

                break; // expect only 1 record!

        } while (PD_TRUE);

        EXEC SQL CLOSE c_cursor_get_batch_id_dt;

DEBUGLOG(("Payout_dtl_chkexist Normal Exit\n"));
        return iRet;

payout_dtl_chkexist_error:

DEBUGLOG(("payout_dtl_chkexist_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("Payout_dtl_chkexist: SP_INTERNAL_ERR TxnAbort\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_get_batch_id_dt;
        return PD_ERR;

}




