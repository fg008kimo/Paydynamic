/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/10/24              Virginia Yun
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include <math.h>
#include "utilitys.h"
#include "expat.h"
#include <curl/curl.h>
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "../batchcommon.h"
#include "TxnSeq.h"
#include "pr_payout_void_generate.h"
#include "internal.h"
#include "ObjPtr.h"
#include "pr_bo_funct.h"
#include "pr_par_funct.h"
#include "pr_log_funct.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug = 'Y';

OBJPTR(DB);


int parse_txn(hash_t   *hMyHash);
int process_payout_psp_reversal(hash_t * hMyHash);
int GetPayoutReversedPSP(const char *csBatchId, int iSeqNum, recordset_t *myRec);
int CreateNewVOGTxn(hash_t *hMyHash);
int HandlePayoutAmount(hash_t *hMyHash);
int UpdateLogs(hash_t *hMyHash);
int UpdateByGenId(const hash_t *hRec);
int	GetPayoutServiceFee(const char *csUploadTxnId , hash_t *hTxn);
int	Reversed_record_exists(const char *csBatchId, int iSeqNum);

int batch_init(int argc, char* argv[])
{
/*
    if (argc < 2) {
        printf("usage:  -h header_file -t detail_file\n");
        return FAILURE;
    }
    else
        return SUCCESS;
*/


	return SUCCESS;

}



int batch_proc(int argc, char* argv[])
{

	int	iRet = SUCCESS;

	int	iCnt = 0;
        char    csDate[PD_DATE_LEN + 1];

        hash_t  *myHash;
        myHash = (hash_t*) malloc (sizeof(hash_t));


	EXEC SQL WHENEVER SQLERROR GOTO get_void_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                SQL_CURSOR      c_cursor_txn_data;

                short           hv_return_value;
                int             v_txn_seq;
                varchar         v_post_date[PD_DATE_LEN + PD_TIME_LEN + 1];
                varchar         v_txn_date[PD_DATE_LEN + PD_TIME_LEN + 1];
                varchar         v_txn_merch_nmb[PAR_TXN_MERCH_NMB_LEN + 1];
                varchar         v_txn_nmb[PAR_TXN_NMB_LEN + 1];
                varchar         v_merch_ref[PD_MERCHANT_REF_LEN + 1];
                varchar         v_txn_type[PAR_TXN_TYPE_LEN + 1];
                varchar         v_txn_status[PAR_TXN_STATUS_LEN + 1];
                varchar         v_txn_status_grp[PAR_TXN_STATUS_GRP_LEN + 1];
                varchar         v_to_ccy[PD_CURRENCY_ID_LEN + 1];
                double          v_to_amount;
                varchar         v_ccy[PD_CURRENCY_ID_LEN + 1];
                double          v_amount;
                double          v_fee;
                double          v_ex_rate;
                double          v_markup_amt;
                //double                v_balance;
                varchar         v_psp_type_code[PAR_PSP_TYPE_CODE_LEN + 1];
                varchar         v_psp_order_id[PAR_PSP_TYPE_CODE_LEN + 1];
                varchar         v_gate_id[PAR_GATE_ID_LEN + 1];
                varchar         v_client_ip[PAR_CLIENT_IP_LEN + 1];
                varchar         v_txn_note[PAR_TXN_NOTE_LEN + 1];
                varchar         v_psp_txn_id[PAR_PSP_TXN_ID_LEN + 1];
                varchar         v_psp_txn_date[PAR_PSP_TXN_DATE_LEN + 1];

                short           ind_txn_seq = -1;
                short           ind_post_date = -1;
                short           ind_txn_date = -1;
                short           ind_txn_merch_nmb = -1;
                short           ind_txn_nmb = -1;
                short           ind_merch_ref = -1;
                short           ind_txn_type = -1;
                short           ind_txn_status = -1;
                short           ind_txn_status_grp = -1;
                short           ind_to_ccy = -1;
                short           ind_to_amount = -1;
                short           ind_ccy = -1;
                short           ind_amount = -1;
                short           ind_fee = -1;
                short           ind_ex_rate = -1;
                short           ind_markup_amt = -1;
                //short         ind_balance = -1;
                short           ind_psp_type_code = -1;
                short           ind_psp_order_id = -1;                
		short           ind_gate_id = -1;
                short           ind_client_ip = -1;
                short           ind_txn_note = -1;
                short           ind_psp_txn_id = -1;
                short           ind_psp_txn_date = -1;

        EXEC SQL END DECLARE SECTION;

	
        EXEC SQL ALLOCATE :c_cursor_txn_data;

        EXEC SQL EXECUTE
                BEGIN
                        :hv_return_value := sp_par_void_po_txn_data(:c_cursor_txn_data);
                END;
        END-EXEC;

        if (hv_return_value == 1) {
DEBUGLOG(("batch_proc:get_txn no more record to be processed!\n"));
        }
        else if (hv_return_value == SP_OK) {
                iCnt = 0;

                for (;;) {
                        hash_init(myHash,0);

                        ind_txn_seq = -1;
                        ind_post_date = -1;
                        ind_txn_date = -1;
                        ind_txn_merch_nmb = -1;
                        ind_txn_nmb = -1;
                        ind_merch_ref = -1;
                        ind_txn_type = -1;
                        ind_txn_status = -1;
                        ind_txn_status_grp = -1;
                        ind_to_ccy = -1;
                        ind_to_amount = -1;
                        ind_ccy = -1;
                        ind_amount = -1;
                        ind_fee = -1;
                        ind_ex_rate = -1;
                        ind_markup_amt = -1;
                        //ind_balance = -1;
                        ind_psp_type_code = -1;
                        ind_psp_order_id = -1;
                        ind_gate_id = -1;
                        ind_client_ip = -1;
                        ind_txn_note = -1;
                        ind_txn_note = -1;
                        ind_psp_txn_id = -1;
                        ind_psp_txn_date = -1;

                        EXEC SQL WHENEVER NOTFOUND DO break;
                        EXEC SQL FETCH :c_cursor_txn_data
                        INTO    :v_txn_seq:ind_txn_seq,
                                :v_post_date:ind_post_date,
                                :v_txn_date:ind_txn_date,
                                :v_txn_merch_nmb:ind_txn_merch_nmb,
                                :v_txn_nmb:ind_txn_nmb,
                                :v_merch_ref:ind_merch_ref,
                                :v_txn_type:ind_txn_type,
                                :v_txn_status:ind_txn_status,
                                :v_txn_status_grp:ind_txn_status_grp,
                                :v_to_ccy:ind_to_ccy,
                                :v_to_amount:ind_to_amount,
                                :v_ccy:ind_ccy,
                                :v_amount:ind_amount,
                                :v_fee:ind_fee,
                                :v_ex_rate:ind_ex_rate,
                                :v_markup_amt:ind_markup_amt,
                                :v_psp_type_code:ind_psp_type_code,
                                :v_psp_order_id:ind_psp_order_id,
                                :v_gate_id:ind_gate_id,
                                :v_client_ip:ind_client_ip,
                                :v_txn_note:ind_txn_note,
                                :v_psp_txn_id:ind_psp_txn_id,
                                :v_psp_txn_date:ind_psp_txn_date ;

                        if (SQLCODE == SQL_NOT_FOUND) {
                                break;
                        }



DEBUGLOG(("batch_proc >>>>>>>>>>>>>>>>>>>>>>>>>\n"));

                        if (ind_txn_seq >= 0) {
DEBUGLOG(("batch_proc: [%d] sort_txn_seq = [%d]\n", iCnt, v_txn_seq));
                                PutField_Int(myHash, "sort_txn_seq", v_txn_seq);
                        }

                        if (ind_post_date >= 0) {
                                v_post_date.arr[v_post_date.len] = '\0';
DEBUGLOG(("batch_proc: [%d] post_date = [%.*s]\n",iCnt, v_post_date.len,v_post_date.arr));

                                strncpy(csDate, (const char *)v_post_date.arr, PD_DATE_LEN);
                                csDate[PD_DATE_LEN] = '\0';
//DEBUGLOG(("batch_proc: [%d] re-format post_date = [%s]\n",iCnt, csDate));

                                PutField_CString(myHash, "post_date", (const char *) csDate);
                                PutField_CString(myHash, "post_datetime", (const char*)v_post_date.arr);
                        }


                        if (ind_txn_date >= 0) {
                                v_txn_date.arr[v_txn_date.len] = '\0';
DEBUGLOG(("batch_proc: [%d] txn_date = [%.*s]\n",iCnt, v_txn_date.len,v_txn_date.arr));
                                PutField_CString(myHash, "txn_date", (const char *) v_txn_date.arr);
                        }
                        if (ind_txn_merch_nmb >= 0) {
                                v_txn_merch_nmb.arr[v_txn_merch_nmb.len] = '\0';
DEBUGLOG(("batch_proc: [%d] txn_merch_nmb = [%.*s]\n",iCnt, v_txn_merch_nmb.len,v_txn_merch_nmb.arr));
                                PutField_CString(myHash, "txn_merch_nmb", (const char *) v_txn_merch_nmb.arr);
                        }

                        if (ind_txn_nmb >= 0) {
                                v_txn_nmb.arr[v_txn_nmb.len] = '\0';
DEBUGLOG(("batch_proc: [%d] txn_nmb = [%.*s]\n",iCnt, v_txn_nmb.len,v_txn_nmb.arr));
                                PutField_CString(myHash, "txn_nmb", (const char *) v_txn_nmb.arr);
                        }

                        if (ind_merch_ref >=0) {
                                v_merch_ref.arr[v_merch_ref.len] = '\0';
//DEBUGLOG(("batch_proc: [%d] merch_ref = [%.*s]\n",iCnt, v_merch_ref.len, v_merch_ref.arr));
                                PutField_CString(myHash, "merch_ref", (const char *) v_merch_ref.arr);
                        }

                        if (ind_txn_type >=0) {
                                v_txn_type.arr[v_txn_type.len] = '\0';
DEBUGLOG(("batch_proc: [%d] txn_type = [%.*s]\n",iCnt, v_txn_type.len, v_txn_type.arr));
                                PutField_CString(myHash, "txn_type", (const char *) v_txn_type.arr);
                        }

                        if (ind_txn_status >=0) {
                                v_txn_status.arr[v_txn_status.len] = '\0';
DEBUGLOG(("batch_proc: [%d] txn_status = [%.*s]\n",iCnt, v_txn_status.len, v_txn_status.arr));
                                PutField_CString(myHash, "txn_status", (const char *) v_txn_status.arr);
                        }

                        if (ind_txn_status_grp >=0) {
                                v_txn_status_grp.arr[v_txn_status_grp.len] = '\0';
DEBUGLOG(("batch_proc: [%d] txn_status_grp = [%.*s]\n",iCnt, v_txn_status_grp.len, v_txn_status_grp.arr));
                                PutField_CString(myHash, "txn_status_grp", (const char *) v_txn_status_grp.arr);
                        }

                        if (ind_to_ccy >=0) {
                                v_to_ccy.arr[v_to_ccy.len] = '\0';
//DEBUGLOG(("batch_proc: [%d] to_ccy = [%.*s]\n",iCnt, v_to_ccy.len, v_to_ccy.arr));
                                PutField_CString(myHash, "to_ccy", (const char *) v_to_ccy.arr);
                        }

                        if (ind_to_amount >=0) {
//DEBUGLOG(("batch_proc: [%d] to_amount = [%lf]\n",iCnt, v_to_amount));
                                PutField_Double(myHash, "to_amount", v_to_amount);
                        }

                        if (ind_ccy >=0) {
                                v_ccy.arr[v_ccy.len] = '\0';
//DEBUGLOG(("batch_proc: [%d] ccy = [%.*s]\n",iCnt, v_ccy.len, v_ccy.arr));
                                PutField_CString(myHash, "ccy", (const char *) v_ccy.arr);
                        }

                        if (ind_amount >=0) {
//DEBUGLOG(("batch_proc: [%d] amount = [%lf]\n",iCnt, v_amount));
                                PutField_Double(myHash, "amount", v_amount);
                        }

                        if (ind_fee >=0) {
//DEBUGLOG(("batch_proc: [%d] fee = [%lf]\n",iCnt, v_fee));
                                PutField_Double(myHash, "fee", v_fee);
                        }

                        if (ind_ex_rate >= 0) {
//DEBUGLOG(("batch_proc: [%d] ex_rate = [%lf]\n",iCnt, v_ex_rate));
                                PutField_Double(myHash, "ex_rate", v_ex_rate);
                        }

                        if (ind_markup_amt >= 0) {
//DEBUGLOG(("batch_proc: [%d] markup_amt = [%lf]\n",iCnt, v_markup_amt));
                                PutField_Double(myHash, "markup_amt", v_markup_amt);
                        }

                        /*
                        if (ind_balance >= 0) {
DEBUGLOG(("batch_proc: [%d] balance = [%lf]\n",iCnt, v_balance));
                                PutField_Double(myHash, "balance", v_balance);
                        }
                        */
                        if (ind_psp_type_code >= 0) {
                                v_psp_type_code.arr[v_psp_type_code.len] = '\0';
DEBUGLOG(("batch_proc: [%d] psp_type_code = [%.*s]\n",iCnt, v_psp_type_code.len, v_psp_type_code.arr));
                                PutField_CString(myHash, "psp_type_code", (const char *) v_psp_type_code.arr);
                        }

                        if (ind_psp_order_id >= 0) {
                                v_psp_order_id.arr[v_psp_order_id.len] = '\0';
//DEBUGLOG(("batch_proc: [%d] psp_order_id = [%.*s]\n",iCnt, v_psp_order_id.len, v_psp_order_id.arr));
                                PutField_CString(myHash, "psp_order_id", (const char *) v_psp_order_id.arr);
                        }

                        if (ind_gate_id >= 0) {
                                v_gate_id.arr[v_gate_id.len] = '\0';
DEBUGLOG(("batch_proc: [%d] gate_id = [%.*s]\n",iCnt, v_gate_id.len, v_gate_id.arr));
                                PutField_CString(myHash, "gate_id", (const char *) v_gate_id.arr);
                        }

                        if (ind_client_ip >= 0) {
                                v_client_ip.arr[v_client_ip.len] = '\0';
//DEBUGLOG(("batch_proc: [%d] client_ip = [%.*s]\n",iCnt, v_client_ip.len, v_client_ip.arr));
                                PutField_CString(myHash, "client_ip", (const char *) v_client_ip.arr);
                        }      

                        if (ind_txn_note >= 0) {
                                v_txn_note.arr[v_txn_note.len] = '\0';
DEBUGLOG(("batch_proc: [%d] txn_note = [%.*s]\n",iCnt, v_txn_note.len, v_txn_note.arr));
                                PutField_CString(myHash, "remark", (const char *) v_txn_note.arr);
                        }      

                        if (ind_psp_txn_id >= 0) {
                                v_psp_txn_id.arr[v_psp_txn_id.len] = '\0';
DEBUGLOG(("batch_proc: [%d] psp_txn_id = [%.*s]\n",iCnt, v_psp_txn_id.len, v_psp_txn_id.arr));
                                PutField_CString(myHash, "psp_tid", (const char *) v_psp_txn_id.arr);
                        }      

                        if (ind_psp_txn_date >= 0) {
                                v_psp_txn_date.arr[v_psp_txn_date.len] = '\0';
DEBUGLOG(("batch_proc: [%d] psp_txn_date = [%.*s]\n",iCnt, v_psp_txn_date.len, v_psp_txn_date.arr));

                                strncpy(csDate, (const char *)v_psp_txn_date.arr, PD_DATE_LEN);
                                csDate[PD_DATE_LEN] = '\0';                                
				PutField_CString(myHash, "psp_txn_date", (const char *) csDate);
                        }      


                        iRet=parse_txn(myHash);

                        if (iRet != SUCCESS) {
                                break;
                        }

                        iCnt++;

                        hash_destroy(myHash);

                }
                EXEC SQL CLOSE :c_cursor_txn_data;
                EXEC SQL FREE :c_cursor_txn_data;


        } else if (hv_return_value == SP_OTHER_ERR) {
                EXEC SQL CLOSE :c_cursor_txn_data;
                EXEC SQL FREE :c_cursor_txn_data;
DEBUGLOG(("batch_proc: exit with error\n"));
ERRLOG("batch_proc: exit with error\n");
                iRet = FAILURE;

        }

DEBUGLOG(("batch_proc: FINAL RET = [%d]\n", iRet));

        FREE_ME(myHash);

        return iRet;

get_void_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));

ERRLOG("batch_proc: error_code %d\n", sqlca.sqlcode);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :c_cursor_txn_data;
    EXEC SQL FREE :c_cursor_txn_data;
    FREE_ME(myHash);

    return PD_ERR;



}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}



/*
int parse_arg(int argc,char **argv)
{
	char    c;
	strcpy(cs_dtfile,"");
	strcpy(cs_hdfile,"");

	while ((c = getopt(argc,argv,"h:t:d:")) != EOF) {
		switch (c) {
			case 'h':
				strcpy(cs_hdfile, optarg);
				break;
			case 't':
				strcpy(cs_dtfile, optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (!strcmp(cs_hdfile,"") || !strcmp(cs_dtfile,""))
		return FAILURE;

        return SUCCESS;
}
*/


int parse_txn(hash_t   *hMyHash) {

	int	iRet = SUCCESS;

	char	*csTmp;

        time_t  ct;
        struct  tm *sct;
        char    sys_date[PD_DATE_LEN + 1];
        char    sys_time[PD_TIME_LEN + 1];
        char    csTranDateTime[PD_DATE_LEN + PD_TIME_LEN + 1];

        ct = time((time_t *) 0);
        sct = localtime(&ct);

        sys_date[0] = '\0';
        sys_time[0] = '\0';
        csTranDateTime[0] = '\0';

        sprintf(sys_date, "%04d%02d%02d",
                sct->tm_year + 1900, sct->tm_mon + 1, sct->tm_mday);

        sprintf(sys_time, "%02d%02d%02d",
                sct->tm_hour, sct->tm_min, sct->tm_sec);

        PutField_CString(hMyHash, "local_tm_date", sys_date);
        PutField_CString(hMyHash, "local_tm_time", sys_time);

	if (iRet == SUCCESS) {
		GetField_CString(hMyHash, "txn_status", &csTmp);

		if (!strcmp(csTmp, "NEW")) {

			PutField_CString(hMyHash, "void_po_status", "NEW-SKIP");
			iRet = UpdateVoidPOTxnStatus(hMyHash);

		} else if (!strcmp(csTmp, "PAYOUT_CREDIT_ADJUSTMENT_APPROVED")) {

			iRet = process_payout_psp_reversal(hMyHash);

			if (iRet == SUCCESS) {
				PutField_CString(hMyHash, "void_po_status", "COMPLETE");
	                        iRet = UpdateVoidPOTxnStatus(hMyHash);
			}

		}
		else {
			iRet = FAILURE;
		}


		if (iRet == SUCCESS) {
			TxnCommit();
		} else {
			TxnAbort();
		}
	}




	return iRet;
}



int process_payout_psp_reversal(hash_t * hMyHash) {

	int	iRet = SUCCESS;

	char	*csVNCRefNum;
	char	*csUploadTxnId;
	char	*csBatchId;
	int     iSeqNum;
	int	iStatus;
	char	*csPSPID;

	char	*csTmp;
	int	iCnt = 0;
	double	dTmp;

        recordset_t     *rRecordSet;
        hash_t          *hRec;

	hash_t		*hTxn;
	hTxn = (hash_t*)malloc(sizeof(hash_t));


	GetField_CString(hMyHash, "txn_nmb", &csVNCRefNum);


        rRecordSet = (recordset_t *)malloc(sizeof(recordset_t));
	recordset_init(rRecordSet, 0);

	if (GetPayoutDetailByAuxVncRefNum(csVNCRefNum,rRecordSet)==PD_OK){
		hRec = RecordSet_GetFirst(rRecordSet);

		while (hRec) {
			iCnt++;

			if(GetField_CString(hRec,"txn_id",&csUploadTxnId)){
				//PutField_CString(hTxnHeader, "org_txn_id", csUploadTxnId);
				PutField_CString(hMyHash, "upload_txn_id", csUploadTxnId);
DEBUGLOG(("process_payout_psp_reversal::GetPayoutDetailByAuxVncRefNum txn_id = [%s]\n",csUploadTxnId));
			}

			if(GetField_CString(hRec,"batch_id",&csBatchId)){
				PutField_CString(hMyHash, "batch_id", csBatchId);
DEBUGLOG(("process_payout_psp_reversal::GetPayoutDetailByAuxVncRefNum batch_id = [%s]\n",csBatchId));
			}
			if(GetField_Int(hRec,"seq_num",&iSeqNum)){
DEBUGLOG(("process_payout_psp_reversal::GetPayoutDetailByAuxVncRefNum seq_num = [%d]\n",iSeqNum));
			}
			if(GetField_Int(hRec,"status",&iStatus)){
DEBUGLOG(("process_payout_psp_reversal::GetPayoutDetailByAuxVncRefNum status = [%d]\n",iStatus));
			}
			if(GetField_CString(hRec,"country",&csTmp)){
				PutField_CString(hMyHash, "country", csTmp);
DEBUGLOG(("process_payout_psp_reversal::GetPayoutDetailByAuxVncRefNum country = [%s]\n",csTmp));
			}

			hRec = RecordSet_GetNext(rRecordSet);
		}
	} else {
DEBUGLOG(("process_payout_psp_reversal::Get PayoutByAuxVncRefNum FAILURE!\n"));
			iRet = FAILURE;
	}
	RecordSet_Destroy(rRecordSet);

	
	if (iCnt == 0) {
DEBUGLOG(("process_payout_psp_reversal::Get PayoutByAuxVncRefNum NO RECORD FOUND!\n"));
		iRet = FAILURE;
	}

	if (iRet == SUCCESS) {
		if (GetPayoutServiceFee(csUploadTxnId, hMyHash) == SUCCESS) {
			if (GetField_Double(hMyHash, "service_fee", &dTmp)) {
DEBUGLOG(("process_payout_psp_reversal::Get service_fee [%lf]\n", dTmp));
			}
		}
	}

	if (iRet == SUCCESS) {
		if (Reversed_record_exists(csBatchId, iSeqNum) == PD_NOT_FOUND) {

DEBUGLOG(("process_payout_psp_reversal:: !!!!!! Reversed record not found !!!!!!\n")); 

			iRet = PD_SKIP_OK;
		}
	}


	if (iRet == SUCCESS) {
		recordset_init(rRecordSet, 0);

		if (GetPayoutReversedPSP(csBatchId, iSeqNum, rRecordSet) == PD_OK) {
			hRec = RecordSet_GetFirst(rRecordSet);

			while (hRec) {
				if (GetField_CString(hRec, "reversed_psp_id", &csTmp)) {		
					PutField_CString(hMyHash, "psp_type_code", csTmp);
DEBUGLOG(("process_payout_psp_reversal: GetPayoutReversedPSP psp_id [%s]\n", csTmp));
				}
				hRec = RecordSet_GetNext(rRecordSet);
			}
		}
		else {
DEBUGLOG(("process_payout_psp_reversal::GetPayoutReversedPSP FAILURE!\n"));
			iRet = FAILURE;

		}
		RecordSet_Destroy(rRecordSet);
	}

	if (iRet == SUCCESS) {
		// GetClient ID by PSP
		if (ParPspClientMap_GetPspID(hMyHash)) {

			if (GetField_CString(hMyHash, "psp_id", &csPSPID)) {
DEBUGLOG(("process_payout_psp_reversal psp_id = [%s] iRet [%d]\n", csPSPID, iRet));
			}
		} else {
			iRet = FAILURE;
DEBUGLOG(("process_payout_psp_reversal psp_id FAILURE\n")); 
		}

		if (iRet == SUCCESS) {
			hash_init(hTxn, 0);

			if (par_GetPspDetail(csPSPID, hTxn) == PD_OK) {

				if (GetField_CString(hTxn, "client_id", &csTmp)) {
DEBUGLOG(("process_payout_psp_reversal client_id = [%s]\n", csTmp));
					PutField_CString(hMyHash, "client_id", csTmp);
				}
			} else {
				iRet = FAILURE;
DEBUGLOG(("process_payout_psp_reversal getpspid FAILURE\n")); 
			}

			hash_destroy(hTxn);
		}

	}

	if (iRet == SUCCESS) {
		// New Txn
		iRet = CreateNewVOGTxn(hMyHash);

	}


	if (iRet == SUCCESS) {
		// handle balance
		//hash_init(hTxn, 0);
		iRet = HandlePayoutAmount(hMyHash);

		//hash_destroy(hTxn);
	}

	if (iRet == SUCCESS) {
		//Update Txn Log
		iRet = UpdateLogs(hMyHash);

	}

	if (iRet == PD_SKIP_OK) {
		iRet = SUCCESS;
	}

	FREE_ME(hTxn);

	return iRet;
}


int	GetPayoutReversedPSP(const char *csBatchId, int iSeqNum, recordset_t *myRec)
{

	int	iRet = FAILURE;
        hash_t *myHash;

        EXEC SQL WHENEVER SQLERROR GOTO get_reverse_psp_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_batch_id[PD_TXN_SEQ_LEN];
		int		hv_seq_num;
	

		varchar		v_psp_id[PD_PSP_ID_LEN + 1];
		short		ind_psp_id = -1;

        EXEC SQL END DECLARE SECTION;


	hv_batch_id.len=strlen(csBatchId);
	memcpy(hv_batch_id.arr, csBatchId, hv_batch_id.len);
DEBUGLOG(("GetPayoutReversedPSP batch_id = [%s]\n", hv_batch_id.arr));

	hv_seq_num = iSeqNum;


        EXEC SQL DECLARE c_cursor_get_psp CURSOR FOR
		select prh_file_psp
		from par_po_reversed_hd, par_po_reversed_dt, par_payout_upload
		where pu_batch_id = :hv_batch_id
		and prd_po_file_id = pu_file_id
		and prd_seq_nmb = :hv_seq_num
		and prd_psp_file_id = prh_file_id;
	
	EXEC SQL OPEN c_cursor_get_psp;
	do {
		EXEC SQL FETCH c_cursor_get_psp
		INTO	
			:v_psp_id:ind_psp_id;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		myHash = (hash_t*)malloc(sizeof(hash_t));
		hash_init(myHash, 0);


		if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len] = '\0';
			PutField_CString(myHash, "reversed_psp_id", (const char *)v_psp_id.arr);
DEBUGLOG(("GetPayoutReversedPSP psp_id [%s]\n", v_psp_id.arr));
		}

		RecordSet_Add(myRec, myHash);

		iRet = SUCCESS;
		
		break;

	} while (PD_TRUE);
	
	EXEC SQL CLOSE c_cursor_get_psp;

DEBUGLOG(("GetPayoutReversedPSP Normal Exit Ret [%d]\n", iRet));
	return iRet;

get_reverse_psp_error:
DEBUGLOG(("getd_everse_psp_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("GetPayoutReversedPSP : SP_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_get_psp;
        return PD_ERR;

}

int  CreateNewVOGTxn(hash_t *hMyHash)
{
	int     iRet = SUCCESS;
        char    csTxnSeq[PD_TXN_SEQ_LEN+1];
	
	char	*csTmp;
	char    *csTxnDateTime;
        char    csDate[PD_DATE_LEN+1];
        char    csTime[PD_TIME_LEN+1];
	double	dTmp;

	hash_t  *hContext, *hRequest;
        hContext = (hash_t *)malloc(sizeof(hash_t));
        hRequest= (hash_t *)malloc(sizeof(hash_t));

	hash_init(hContext, 0);
	hash_init(hRequest, 0);

	strcpy(csTxnSeq,GetNextMgtTxnSeq());

	PutField_CString(hContext,"txn_seq",csTxnSeq);
	PutField_CString(hMyHash, "txn_seq", csTxnSeq);

	PutField_CString(hContext,"txn_code",PD_PAYOUT_VOID_PSP);
	PutField_Int(hContext, "internal_code", 0);
	PutField_CString(hContext, "response_code", "0");	

	if (GetField_CString(hMyHash, "txn_nmb", &csTmp)) {
DEBUGLOG(("CreateNewVOGTxn vnc_ref_num [%s]\n", csTmp));
		PutField_CString(hContext, "vnc_ref_num", csTmp);
	}

	PutField_CString(hContext,"desc","Payout Refund(PSP)");

	if (GetField_CString(hMyHash, "post_date", &csTmp)) {
		PutField_CString(hContext, "PHDATE", csTmp);
	}

	if (GetField_CString(hMyHash, "local_tm_date", &csTmp)) {
		PutField_CString(hContext, "local_tm_date", csTmp);
	}
	if (GetField_CString(hMyHash, "local_tm_time", &csTmp)) {
		PutField_CString(hContext, "local_tm_time", csTmp);
	}
	if (GetField_CString(hMyHash, "txn_date", &csTxnDateTime)) {
		PutField_CString(hRequest, "transmission_datetime", csTxnDateTime);

		csDate[0] = '\0';
		csTime[0] = '\0';

		strncpy(csDate, csTxnDateTime, PD_DATE_LEN);
		strncpy(csTime, csTxnDateTime + PD_DATE_LEN, PD_TIME_LEN);

		csDate[PD_DATE_LEN] = '\0';
		csTime[PD_TIME_LEN] = '\0';

     		PutField_CString(hRequest, "tm_date", csDate);
		PutField_CString(hRequest, "tm_time", csTime);
		PutField_CString(hContext, "txn_date", csDate);
               	PutField_CString(hContext, "approval_date", csDate);

		PutField_CString(hMyHash, "approval_date", csDate);
	}

	if (GetField_CString(hMyHash, "psp_id", &csTmp)) {
		PutField_CString(hContext, "psp_id", csTmp);
	}

	if (GetField_CString(hMyHash, "ccy", &csTmp)) {
		PutField_CString(hRequest, "txn_ccy", csTmp);
	}

	if (GetField_CString(hMyHash, "to_ccy", &csTmp)) {
		PutField_CString(hContext, "txn_ccy", csTmp);
	}

	if (GetField_Double(hMyHash, "to_amount", &dTmp)) {
		PutField_Double(hContext, "txn_amt", dTmp);
	}

	/*
	if (GetField_Double(hMyHash, "fee", &dTmp)) {
		PutField_Double(hContext, "service_fee", dTmp);
	}
	*/

	if (GetField_CString(hMyHash, "country", &csTmp)) {
		PutField_CString(hRequest, "txn_country", csTmp);
	}

	PutField_CString(hContext, "add_user", PD_UPDATE_USER);
	PutField_CString(hContext, "update_user", PD_UPDATE_USER);

	PutField_CString(hRequest, "process_code", PD_PROCESS_CODE_DEF);
	PutField_CString(hRequest, "process_type", PD_PROCESS_TYPE_DEF);

	PutField_CString(hContext, "channel_code", PD_CHANNEL_MGT);

	if (GetField_CString(hMyHash, "client_ip", &csTmp)) {
		PutField_CString(hRequest, "ip_addr", csTmp);
	}



	if (PayoutAddTxnLog(hContext, hRequest) == PD_OK) {
DEBUGLOG(("pr_payout_void_generate:PayoutAddTxnLog  SUCC!\n"));

		if (UpdateHeaderVNCRef(hContext) == PD_OK) {
DEBUGLOG(("pr_payout_void_generate:Deposit init record updated vnc_ref_num succ!\n"));
		}
		else {
DEBUGLOG(("pr_payout_void_generate:Deposit init record updated vnc_ref_num fail!\n"));
			iRet = FAILURE;
		}
	}
	else {
DEBUGLOG(("pr_payout_void_generate:PayoutAddTxnLog FAIL!\n"));
		iRet = FAILURE;
	}	

	if(iRet==SUCCESS){
DEBUGLOG(("pr_payout_void_generate::Call DBTxnPspDetail:Add\n"));

		/*
		DBObjPtr = CreateObj(DBPtr,"DBTxnPspDetail","Add");
		if((unsigned long) ((*DBObjPtr)(hContext))!=PD_OK){
			iRet = FAILURE;
DEBUGLOG(("pr_payout_void_generate::DBTxnPspDetail:Add Failed\n"));
		} else {
DEBUGLOG(("pr_payout_void_generate::DBTxnPspDetail:Add SUCC\n"));
		}
		*/

		if (TxnPspDetail_Add(hContext) != PD_OK) {
			iRet = FAILURE;
DEBUGLOG(("pr_payout_void_generate::DBTxnPspDetail:Add Failed\n"));
		} else {
DEBUGLOG(("pr_payout_void_generate::DBTxnPspDetail:Add SUCC\n"));
		}
	
	}


	hash_destroy(hContext);
	hash_destroy(hRequest);

	FREE_ME(hContext);
	FREE_ME(hRequest);

	return iRet;
}

int HandlePayoutAmount(hash_t *hMyHash)
{
	int iRet = SUCCESS;
	
	char	*csTmp;
	double	dTmp;

	hash_t  *hContext, *hRequest;
        hContext = (hash_t *)malloc(sizeof(hash_t));
        hRequest= (hash_t *)malloc(sizeof(hash_t));

	hash_init(hContext, 0);
	hash_init(hRequest, 0);
	
	PutField_Char(hContext, "response_mode", PD_REVERSED);
	PutField_Char(hContext, "party_type", PD_TYPE_PSP);

	if (GetField_CString(hMyHash, "psp_id", &csTmp)) {
		PutField_CString(hContext, "psp_id", csTmp);
	}

	if (GetField_CString(hMyHash, "country", &csTmp)) {
		PutField_CString(hContext, "country", csTmp);
	}

	if (GetField_CString(hMyHash, "ccy", &csTmp)) {
		PutField_CString(hContext, "ccy", csTmp);
	}

	if (GetField_CString(hMyHash, "to_ccy", &csTmp)) {
		PutField_CString(hContext, "to_ccy", csTmp);
	}

	if (GetField_Double(hMyHash, "to_amount", &dTmp)) {
		PutField_Double(hContext, "dst_net_amt", dTmp);
	}


	if (UpdatePayoutAmount(hContext) == PD_OK) {
		if (GetField_Double(hContext, "psp_total_float", &dTmp)) {
			PutField_Double(hMyHash,"psp_total_float",dTmp);
DEBUGLOG(("UpdatePayoutAmount:total_float [%lf]!\n", dTmp));
		}
		if (GetField_Double(hContext, "psp_balance", &dTmp)) {
			PutField_Double(hMyHash,"psp_bal",dTmp);
DEBUGLOG(("UpdatePayoutAmount:psp_balance[%lf]!\n", dTmp));
		}
		if (GetField_Double(hContext, "psp_total_hold", &dTmp)) {
			PutField_Double(hMyHash,"psp_total_hold",dTmp);
DEBUGLOG(("UpdatePayoutAmount:total_hold [%lf]!\n", dTmp));
		}
	}
	else{
		iRet = FAILURE;
DEBUGLOG(("payout_reversal_handler::UpdatePayoutAmount Failed\n"));
	}


	hash_destroy(hContext);
	hash_destroy(hRequest);

	FREE_ME(hContext);
	FREE_ME(hRequest);

	return iRet;
}

int UpdateLogs(hash_t *hMyHash)
{
	int iRet = SUCCESS;

	char	*csTmp;
	double	dTmp;

	hash_t  *hContext, *hTxn;
        hContext = (hash_t *)malloc(sizeof(hash_t));
        hTxn= (hash_t *)malloc(sizeof(hash_t));

	hash_init(hContext, 0);
	hash_init(hTxn, 0);

	PutField_CString(hContext, "add_user", PD_UPDATE_USER);
	PutField_CString(hContext, "update_user", PD_UPDATE_USER);
	

	// add elements
	PutField_CString(hContext, "amount_type", PD_CR);
	PutField_Char(hContext, "party_type", PD_TYPE_PSP);

	if (GetField_CString(hMyHash, "txn_seq", &csTmp)) {
		PutField_CString(hContext,"txn_seq",csTmp);
	}

	if (GetField_CString(hMyHash, "to_ccy", &csTmp)) {
		PutField_CString(hContext,"ccy",csTmp);
		PutField_CString(hContext,"net_ccy",csTmp);
	}

	if (GetField_Double(hMyHash, "to_amount", &dTmp)) {
		PutField_Double(hContext, "amount", dTmp);
		PutField_Double(hContext, "txn_amt", dTmp);
	}

	if (GetField_CString(hMyHash, "client_id", &csTmp)) {
		PutField_CString(hContext, "client_id", csTmp);
	}

	if(add_txn_element(hContext)!=SUCCESS){
		iRet = FAILURE;
DEBUGLOG(("pr_payout_void_generate::add_txn_element Failed\n"));
	}


	if(iRet==SUCCESS){
		///update txn log
		PutField_Char(hContext,"status",PD_COMPLETE);
		PutField_Char(hContext,"ar_ind",PD_ACCEPT);
		PutField_CString(hContext,"sub_status",PD_REFUND_APPROVED);

		if (GetField_CString(hMyHash, "approval_date", &csTmp)) {
			PutField_CString(hContext, "approval_date", csTmp);
		}

		if (GetField_CString(hMyHash, "upload_txn_id", &csTmp)) {
			PutField_CString(hContext, "org_txn_seq", csTmp);
		}

		/*
		DBObjPtr = CreateObj(DBPtr,"DBTransaction","Update");
		if((unsigned long) ((*DBObjPtr)(hContext))!=PD_OK){
			iRet = FAILURE;
DEBUGLOG(("pr_payout_void_generate::DBTransaction:Update Failed\n"));
		}
		*/
		if (Txn_Header_Update(hContext) != PD_OK) {
			iRet = FAILURE;
DEBUGLOG(("pr_payout_void_generate::DBTransaction:Update Failed\n"));
		}


		if (iRet == SUCCESS) {
			if (GetField_Double(hMyHash, "psp_bal", &dTmp)) {
				PutField_Double(hContext,"bal",dTmp);
			}

			if (GetField_Double(hMyHash, "psp_total_float", &dTmp)) {
				PutField_Double(hContext,"total_float",dTmp);
			}
			if (GetField_Double(hMyHash, "psp_total_hold", &dTmp)) {
				PutField_Double(hContext,"total_hold",dTmp);
			}

			if(iRet==SUCCESS){
DEBUGLOG(("pr_payout_void_generate::Call DBTxnPspDetail:Update\n"));
				/*
				DBObjPtr = CreateObj(DBPtr,"DBTxnPspDetail","Update");
				if((unsigned long) ((*DBObjPtr)(hContext))!=PD_OK){
					iRet = FAILURE;
DEBUGLOG(("pr_payout_void_generate::DBTxnPspDetail:Update Failed\n"));
				}
				*/
				if (TxnPspDetail_Update(hContext) != PD_OK) {
					iRet = FAILURE;
DEBUGLOG(("pr_payout_void_generate::DBTxnPspDetail:Update Failed\n"));
				}
			}
		}

	        if (iRet == SUCCESS) {
			iRet = UpdateApprovalTimestamp(hContext);
        	}

                if(iRet==SUCCESS){
                        ///update payout generated file detail status
                        PutField_Int(hTxn,"status",PAYOUT_MASTER_TRANSACTION_REVERSED);

			if (GetField_CString(hMyHash, "upload_txn_id", &csTmp)) {
				PutField_CString(hTxn, "txn_id", csTmp);
			}

			if (GetField_CString(hMyHash, "txn_seq", &csTmp)) {
				PutField_CString(hTxn, "aux_txn_id", csTmp);
			}

                        if(UpdateByGenId(hTxn)!=PD_OK){
                                iRet = FAILURE;
DEBUGLOG(("pr_payout_void_generate ::UpdateByGenId Failed\n"));
                        }
                }

	}



	hash_destroy(hContext);
	hash_destroy(hTxn);

	FREE_ME(hContext);
	FREE_ME(hTxn);

	return iRet;
}

int UpdateByGenId(const hash_t *hRec)
{
        char*   csBuf;
        char*   csGenId;
        int     iTmp;

        EXEC SQL WHENEVER SQLERROR GOTO updatebygen_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar         hv_dynstmt[1024];

        EXEC SQL END DECLARE SECTION;


DEBUGLOG(("UpdateByGenId: Begin\n"));
        csBuf = (char*) malloc (128);
        strcpy((char*)hv_dynstmt.arr,"update payout_generated_file_dt set fd_update_timestamp = sysdate");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

        if(GetField_CString(hRec,"txn_id",&csGenId)){
DEBUGLOG(("UpdateByGenId:txn_id = [%s]\n",csGenId));
        }
        else{
                FREE_ME(csBuf);
DEBUGLOG(("UpdateByGenId txn_id not found\n"));
                return INT_ERR;
        }

        if(GetField_Int(hRec,"status",&iTmp)){
DEBUGLOG(("UpdateByGenId: status = [%d]\n",iTmp));
                sprintf(csBuf,"%d",iTmp);
                strcat((char*)hv_dynstmt.arr, ",fd_status = ");
                strcat((char*)hv_dynstmt.arr, csBuf);
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }

        if(GetField_CString(hRec,"aux_txn_id",&csBuf)){
DEBUGLOG(("UpdateByGenId: aux_txn_id = [%s]\n",csBuf));
                strcat((char*)hv_dynstmt.arr, ",fd_aux_txn_id = '");
                strcat((char*)hv_dynstmt.arr, csBuf);
                strcat((char*)hv_dynstmt.arr, "'");
                hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);
        }
        //strcat((char*)hv_dynstmt.arr, " WHERE fd_txn_id= '");
        strcat((char*)hv_dynstmt.arr, " WHERE fd_upload_txn_id = '");
        strcat((char*)hv_dynstmt.arr, csGenId);
        strcat((char*)hv_dynstmt.arr, "'");
        hv_dynstmt.len = strlen((const char*)hv_dynstmt.arr);

DEBUGLOG(("SQL = [%.*s]\n",hv_dynstmt.len,hv_dynstmt.arr));


        EXEC SQL PREPARE PS FROM :hv_dynstmt;
        EXEC SQL EXECUTE PS;

        FREE_ME(csBuf);

DEBUGLOG(("UpdateByGenId Normal Exit\n"));
        return PD_OK;

updatebygen_error:
DEBUGLOG(("updatebygen_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("PayoutGeneratedFileDT_UpdateByGenId: SP_INTERNAL_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}

int	GetPayoutServiceFee(const char *csUploadTxnId , hash_t *hTxn)
{

	int	iRet = SUCCESS;

        EXEC SQL WHENEVER SQLERROR GOTO get_payout_service_fee; 
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_upload_txn_id [PD_TXN_SEQ_LEN];

		double          v_service_fee;
		short		ind_service_fee = -1;

        EXEC SQL END DECLARE SECTION;

	hv_upload_txn_id.len=strlen(csUploadTxnId);
	memcpy(hv_upload_txn_id.arr, csUploadTxnId, hv_upload_txn_id.len);
DEBUGLOG(("GetPayoutServiceFee upload_txn_id = [%s]\n", hv_upload_txn_id.arr));

        EXEC SQL DECLARE c_cursor_get_service_fee CURSOR FOR
		select /*fh_txn_id , */tp_service_fee
		from txn_psp_detail, payout_generated_file_hd, payout_generated_file_dt
		where fd_upload_txn_id = :hv_upload_txn_id
		and fd_file_id = fh_file_id
		and fh_txn_id = tp_txn_id;
	
	EXEC SQL OPEN c_cursor_get_service_fee;
	do {
		EXEC SQL FETCH c_cursor_get_service_fee
		INTO	
			:v_service_fee:ind_service_fee;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		if (ind_service_fee >= 0) {
			PutField_Double(hTxn, "service_fee", v_service_fee);
		}

		break;

	} while (PD_TRUE);
	
	EXEC SQL CLOSE c_cursor_get_service_fee;

DEBUGLOG(("GetPayoutService Fee Normal Exit Ret [%d]\n", iRet));
	return iRet;

get_payout_service_fee:
DEBUGLOG(("get_payout_service_fee code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("GetPayoutServiceFee: SP_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_get_service_fee;
        return PD_ERR;

}

int	Reversed_record_exists(const char *csBatchId, int iSeqNum)
{

	int	iRet = PD_NOT_FOUND;

        EXEC SQL WHENEVER SQLERROR GOTO reversed_record_exists_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_batch_id[PD_TXN_SEQ_LEN];
		int		hv_seq_num;

		int		v_no_of_record;
		short		ind_no_of_record = -1;	

        EXEC SQL END DECLARE SECTION;

	hv_batch_id.len=strlen(csBatchId);
	memcpy(hv_batch_id.arr, csBatchId, hv_batch_id.len);
DEBUGLOG(("GetPayoutReversedPSP batch_id = [%s]\n", hv_batch_id.arr));

	hv_seq_num = iSeqNum;


	EXEC SQL
		select count(1)
		into   :v_no_of_record:ind_no_of_record
		from   par_payout_upload, par_po_reversed_dt
		where pu_batch_id = :hv_batch_id
		and prd_po_file_id = pu_file_id
		and prd_seq_nmb = :hv_seq_num
                and rownum = 1;

	if (ind_no_of_record >= 0) {
		if (v_no_of_record > 0) {
DEBUGLOG(("Reversed_record_exists FOUND\n"));
                        iRet = PD_FOUND;
                }
	}

	if (iRet != PD_FOUND) {
DEBUGLOG(("Reversed_record_exists NOT FOUND\n"));
	}

	
	return iRet;

reversed_record_exists_error:
DEBUGLOG(("reversed_record_exists_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("Reversed_record_exists: SP_ERR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;

}

