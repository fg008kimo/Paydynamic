/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2015/01/13		   Virginia Yun
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sqlca.h>
#include <unistd.h>
#include <math.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myrecordset.h"
#include "hash.h"
#include "ObjPtr.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define PD_OPEN_TAG             "<tr><td>"
#define PD_OPEN_TAG_CS          "<tr><td style=text-align:right;>"
#define PD_OPEN_TAG_CS_RED      "<tr><td style=text-align:right;color:red>"
#define PD_NEXT_TAG             "</td><td>"
#define PD_NEXT_TAG_CS          "</td><td style=text-align:right;>"
#define PD_NEXT_TAG_CS_RED      "</td><td style=text-align:right;color:red>"
#define PD_END_TAG              "</td></tr>"

char cDebug = 'Y';

char	cs_fr_date[PD_DATE_LEN + 1];
char	cs_to_date[PD_DATE_LEN + 1];
char	cs_cnt[PD_DESC_LEN + 1];


int parse_arg(int argc, char **argv);
int process_txn();
int psp_limit_report_summary(char* csMerchantId);
int psp_limit_report_summary_total(char* csMerchantId);
int psp_limit_report_merchant(char* csMerchantId, int iShowEmptyCSegment);
int psp_limit_report_group_o(char* csMerchantId);
int psp_limit_report_group_pool(char* csPoolId, char *csServiceCode);
int find_limit_to_gen(recordset_t *myRec);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}

int batch_proc(int argc, char* argv[])
{
	int iRet;

	iRet = parse_arg(argc, argv);

	if (iRet != SUCCESS) {
		printf("usage: -f <from_check_date> -t <to_check_date> -c <no_of_rec> \n");
		return iRet;
	}

	iRet = process_txn();

	return iRet;
}

int process_txn()
{
	int	iRet = SUCCESS;
	int	iCnt = 0;

printf("<h2>Customer Tag Checking</h2>\n");
printf("<br>\n");
printf("<h2> From [%s] to [%s] daily no. of record >= %s</h2>\n", cs_fr_date, cs_to_date, cs_cnt);
printf("<table border='1'>\n");
printf("<tr><th>Date</th><th>Customer Tag</th><th>No of. Record</th></tr>\n");

DEBUGLOG(("START from [%s] to [%s] cnt [%s]\n", cs_fr_date, cs_to_date, cs_cnt));

	EXEC SQL WHENEVER SQLERROR GOTO customertag_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_fr_date[PD_DATE_LEN];
		varchar	hv_to_date[PD_DATE_LEN];
		int     hv_cnt;

		varchar	v_check_date[PD_DATE_LEN + 1];
		varchar	v_customer_tag[PD_CUSTOMER_TAG_LEN + 1];
		int	v_no_of_rec;

		short	ind_check_date = -1;
		short	ind_customer_tag = -1;
		short	ind_no_of_rec = -1;
	
	EXEC SQL END DECLARE SECTION;

	hv_fr_date.len = strlen(cs_fr_date);
	memcpy(hv_fr_date.arr, cs_fr_date, hv_fr_date.len);

	hv_to_date.len = strlen(cs_to_date);
	memcpy(hv_to_date.arr, cs_to_date, hv_to_date.len);

	hv_cnt = atoi(cs_cnt);

	EXEC SQL DECLARE c_customer_tag CURSOR FOR
		select	check_date, 
			td_customer_tag, 
			cnt
		from	(	select	trunc(th_create_timestamp) as check_date, 
					td_customer_tag, 
					count(*) as cnt
				from txn_header, txn_detail
				where	th_create_timestamp >= to_date(:hv_fr_date, 'YYYYMMDD')
				and 	th_create_timestamp < to_date(:hv_to_date, 'YYYYMMDD') + 1 
				and	th_txn_code = 'DSI'
				and th_txn_id = td_txn_id
				and th_merchant_id = 'M8000016'
				group by trunc(th_create_timestamp), td_customer_tag
			)
		where cnt >= :hv_cnt
		order by check_date, td_customer_tag;

	EXEC SQL OPEN c_customer_tag;
	for (;;) {
		EXEC SQL FETCH c_customer_tag
		INTO
			:v_check_date:ind_check_date,
			:v_customer_tag:ind_customer_tag,
			:v_no_of_rec:ind_no_of_rec;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

printf("%s",PD_OPEN_TAG);

		if (ind_check_date >= 0) {
			v_check_date.arr[v_check_date.len]='\0';
printf("%s",(char*)v_check_date.arr);
DEBUGLOG(("check_customer_tag() check_date = [%s]\n",v_check_date.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_customer_tag >= 0) {
			v_customer_tag.arr[v_customer_tag.len]='\0';
printf("%s", (char*)v_customer_tag.arr);
DEBUGLOG(("check_customer_tag() customer_tag = [%s]\n",v_customer_tag.arr));
		}
printf("%s",PD_NEXT_TAG);

		if (ind_no_of_rec >= 0) {
printf("%d", v_no_of_rec);
DEBUGLOG(("check_customer_tag() no_of_rec = [%d]\n", v_no_of_rec));
		}

printf("%s", PD_END_TAG);

	}
	EXEC SQL CLOSE c_customer_tag;

printf("</table>\n");

	if (iCnt > 0) {
		//iRet = PD_FOUND;
		iRet = SUCCESS;
	} else {
printf("<br>\n"); 
printf("No Record matched\n"); 
	}


DEBUGLOG(("check_customer_tag() iRet = [%d]\n",iRet));
	return iRet;

customertag_error:
DEBUGLOG(("check_customer_tag error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_customer_tag;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}

int parse_arg(int argc, char **argv)
{
	char	c;

        while ((c = getopt(argc, argv, "f:t:c:")) != EOF) {
                switch (c) {
                        case 'f':
                                strcpy(cs_fr_date, optarg);
                                cs_fr_date[strlen(cs_fr_date)] = '\0';
                                break;
                        case 't':
                                strcpy(cs_to_date, optarg);
                                cs_to_date[strlen(cs_to_date)] = '\0';
                                break;
                        case 'c':
                                strcpy(cs_cnt, optarg);
                                cs_cnt[strlen(cs_cnt)] = '\0';
                                break;
                        default:
                                return FAILURE;
                }
        }

        if (!strcmp(cs_fr_date, "") || !strcmp(cs_to_date, "") || !strcmp(cs_cnt, ""))
                return FAILURE;


	return SUCCESS;
}
