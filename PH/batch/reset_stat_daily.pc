/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2013/09/11              Stan Poon
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "batchcommon.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char	cs_last_ph_date[PD_DATE_LEN + 1];
char	cDebug = 'Y';

int	parse_arg(int argc,char **argv);
int	reset_stat(char* csDate, char cType);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	int iRet = SUCCESS;

	iRet = parse_arg(argc,argv);
	if(iRet != SUCCESS){
		printf("usage: -l last_ph_date\n");
	}
		
	if(iRet == SUCCESS){
		iRet = reset_stat(cs_last_ph_date, PD_DAILY);
	}

	return iRet;
}


int parse_arg(int argc,char **argv)
{
	char	c;
	strcpy(cs_last_ph_date,"");

	while ((c = getopt(argc,argv,"l:")) != EOF) {
		switch (c) {
			case 'l':
				strcpy(cs_last_ph_date, optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (!strcmp(cs_last_ph_date,""))
		return FAILURE;

	return SUCCESS;
}

int reset_stat(char* csDate, char cType)
{
	EXEC SQL WHENEVER SQLERROR GOTO reset_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_date[PD_DATE_LEN];
		char	hv_type;

		short	hv_return_value;

	EXEC SQL END DECLARE SECTION;

DEBUGLOG(("reset_stat: Begin\n"));

	hv_date.len = strlen(csDate);
	strncpy((char*)hv_date.arr, csDate, hv_date.len);

	hv_type = cType;

	EXEC SQL EXECUTE
		BEGIN
			:hv_return_value := sp_txn_counters_reset(:hv_date,
								:hv_type);
		END;
	END-EXEC;

DEBUGLOG(("reset_stat:Ret = [%d]\n",hv_return_value));

	if (hv_return_value == SP_OK)
	{
		DEBUGLOG(("reset_stat:Normal Exit\n"));
		return PD_OK;
	}

	if (hv_return_value == SP_OTHER_ERR) {
		ERRLOG("reset_stat_daily:reset_stat SP_OTHER_ERR TxnAbort\n");
		DEBUGLOG(("reset_stat: SP_OTHER_ERR TxnAbort\n"));
		return PD_OTHER_ERR;
	}

	if (hv_return_value == SP_ERR) {
		ERRLOG("reset_stat_daily:reset_stat SP_ERR TxnAbort\n");
		DEBUGLOG(("reset_stat: SP_ERR TxnAbort\n"));
		return PD_ERR;
	}

reset_error:
DEBUGLOG(("reset_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("reset_stat_daily:reset_stat SP_INTERNAL_ERR TxnAbort\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;


}

