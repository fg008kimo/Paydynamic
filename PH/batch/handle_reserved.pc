/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/08/16              Cody Chan
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"
#include "dates.h"
#include "dbutility.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char    cDebug = 'Y';


OBJPTR(Txn);
OBJPTR(Channel);

int batch_init(int argc, char* argv[])
{

	return SUCCESS;
}




int batch_proc(int argc, char* argv[])
{
        int     iRet = SUCCESS;

	hash_t  *hContext,*hRequest,*hResponse;

	hContext = (hash_t*) malloc (sizeof(hash_t));
        hash_init(hContext,0);

	hRequest = (hash_t*) malloc (sizeof(hash_t));
	hResponse = (hash_t*) malloc (sizeof(hash_t));

	PutField_CString(hContext,"txn_code",PD_RELEASE_REVERSE);
	PutField_CString(hContext,"channel_code",PD_CHANNEL_MGT);
	PutField_CString(hContext,"process_code",PD_PROCESS_CODE_DEF);
	PutField_CString(hContext,"process_type",PD_PROCESS_TYPE_DEF);
	
	ChannelObjPtr = CreateObj(ChannelPtr,"MGTChannel","UpdateContext");	
	ChannelObjPtr(hContext);

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;	

		varchar		v_merchant_id[PD_MERCHANT_ID_LEN +1];
		int		v_release_period;
		varchar		v_txn_id[PD_TXN_ID_LEN +1];

		short		ind_merchant_id = -1;
		short		ind_release_period = -1;
		short		ind_txn_id = -1;

		SQL_CURSOR	ref_cur;
	EXEC SQL END DECLARE SECTION;	

	EXEC SQL ALLOCATE :ref_cur;
	EXEC SQL DECLARE c_cursor_merchants CURSOR FOR
		SELECT merchant_id,
		       nvl(release_reserved_period,0)
  		  FROM merch_detail;

	EXEC SQL OPEN c_cursor_merchants;
        do {
		EXEC SQL FETCH c_cursor_merchants
                INTO
                        :v_merchant_id:ind_merchant_id,
			:v_release_period:ind_release_period;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }

		if (ind_merchant_id >= 0) {
			v_merchant_id.arr[v_merchant_id.len] = '\0';
		}
		else {
			v_merchant_id.arr[0] = '\0';
		}

		if (ind_release_period < 0) {
			v_release_period = 0;
		}

DEBUGLOG(("merchant id = [%s] release period = [%d]\n",v_merchant_id.arr,v_release_period));

		EXEC SQL EXECUTE
			BEGIN
				RELEASE_PKG.open_reserve(:v_merchant_id,:v_release_period,:ref_cur);
			END;
		END-EXEC;

		do {
			EXEC SQL FETCH :ref_cur
			INTO	
				:v_txn_id:ind_txn_id;

                	if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("no record\n"));
                        	break;
                	}

			if (ind_txn_id >= 0) {
				v_txn_id.arr[v_txn_id.len] = '\0';
			}
			else {
				v_txn_id.arr[0] = '\0';
			}
DEBUGLOG(("txn id = [%s]\n",v_txn_id.arr));
/* release reserved amount */
        		hash_init(hRequest,0);
        		hash_init(hResponse,0);

			PutField_CString(hRequest,"txn_seq",(const char*)v_txn_id.arr);
			TxnObjPtr = CreateObj(TxnPtr,"TxnMgtByUsRLR","Authorize");	
			if ((*TxnObjPtr)((const hash_t*)hContext,hRequest,hResponse) == PD_OK) {
DEBUGLOG(("ret = PD_OK\n"));
				TxnCommit();
			}
			hash_destroy(hRequest);
			hash_destroy(hResponse);
		} while (PD_TRUE);

        	EXEC SQL CLOSE :ref_cur;
	} while (PD_TRUE);

        EXEC SQL CLOSE c_cursor_merchants;
DEBUGLOG(("iRet = [%d]\n",iRet));


	hash_destroy(hContext);
        FREE_ME(hContext);

        FREE_ME(hRequest);
        FREE_ME(hResponse);

	return iRet;

sql_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_merchants;
       	EXEC SQL CLOSE :ref_cur;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}




