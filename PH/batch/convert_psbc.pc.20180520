/*
PDProTech (c)2018. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2018/04/27              David Wong
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "internal.h"
#include "utilitys.h"
#include "ObjPtr.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "dbutility.h"
#include "BOOLBankStmt.h"
#include "convert_psbc.h"
#include "math.h"

OBJPTR(BO);
OBJPTR(DB);

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define INT_BANK_CODE	"086403"
#define ACCT_CCY	"CNY"

char cDebug = 'Y';

int iStmtFileId;
char csRawFile[PD_MAX_FILE_LEN + 1];
char csProcessFile[PD_MAX_FILE_LEN + 1];
char csBankAcctType[PD_ACCT_TYPE_LEN + 1];

int parse_arg(int argc, char **argv);


int batch_init(int argc, char *argv[])
{
	if (argc < 9) {
		printf("usage: -i stmt_file_id -r raw_file -o process_file -t bank_acct_type\n");
		return FAILURE;
	}
	else
		return SUCCESS;
}


int batch_proc(int argc, char *argv[])
{
	int iRet = SUCCESS;

	char *csTmp = NULL, *csTmp2 = NULL;
	char csTmp3[PD_TMP_MSG_BUF_LEN] = "";
	char *csTag = (char*) malloc (64);
	int iTmp;

	FILE *fin, *fout;
	char cs_input_buf[PD_TMP_MSG_BUF_LEN] = "", cs_tmp_input_buf[PD_TMP_MSG_BUF_LEN] = "";
	int iTotalLine = 0, iSBlankLine = 0, iEBlankLine = 0;
	char *csFormatId = NULL;
	char csDelimiter[2] = "";
	int iNegAmount, iNegBalance, iReverse, iTotalField, iStartRow, iEndRow;
	int iLineCnt = 0, iFieldCnt = 0, iMatched = 0;

	char cs_err_msg_buf[PD_TMP_BUF_LEN] = "";
	char csCurrKeyword[PD_TMP_BUF_LEN] = "", csPrevKeyword[PD_TMP_BUF_LEN] = "";
	double dCurrTxnAmt = 0.0, dPrevTxnAmt = 0.0, dCurrBal = 0.0, dPrevBal = 0.0;
	char cs_tmp_buf[PD_TMP_BUF_LEN] = "";
	int iErrorCode = 0;

DEBUGLOG(("batch_proc: start\n"));

	recordset_t *rFormat = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rFormat, 0);

	hash_t *hFormat = NULL;
	hash_t *hCurrRec = NULL;
	hash_t *hPrevRec = NULL;
	hash_t *hError = NULL;

	iRet = parse_arg(argc, argv);

	if (iRet != SUCCESS) {
		printf("*usage: -i stmt_file_id -r raw_file -o process_file -t bank_acct_type\n");
		return iRet;
	}

DEBUGLOG(("stmt_file_id = [%d]\n", iStmtFileId));
DEBUGLOG(("raw_file = [%s]\n", csRawFile));
DEBUGLOG(("process_file = [%s]\n", csProcessFile));
DEBUGLOG(("bank_acct_type = [%s]\n", csBankAcctType));

	fin = fopen(csRawFile, "r");
	if (fin == NULL) {
DEBUGLOG(("Error opening file = [%s]\n", csRawFile));
ERRLOG("convert_psbc: batch_proc: Error opening file = [%s]\n", csRawFile);
		return FAILURE;
	} else {
		while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
			if (strlen_content(cs_input_buf) == 0) {
				iSBlankLine++;
			} else {
				break;
			}
		}
		rewind(fin);
		while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
			if (strlen_content(cs_input_buf) == 0) {
				iEBlankLine++;
			} else {
				iEBlankLine = 0;
			}
			iTotalLine++;
		}
DEBUGLOG(("Summary: Total line = [%d] Starting/Ending Blank Line = [%d]/[%d]\n", iTotalLine, iSBlankLine, iEBlankLine));
	}

	fout = fopen(csProcessFile, "w");
	if (fout == NULL) {
DEBUGLOG(("Error opening file = [%s]\n", csProcessFile));
ERRLOG("convert_psbc: batch_proc: Error opening file = [%s]\n", csProcessFile);
		fclose(fin);
		return FAILURE;
	}

	// get stmt file format
	if (iRet == SUCCESS) {
DEBUGLOG(("call DBOLStmtFormat::GetFormat()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtFormat", "GetFormat");
		if ((unsigned long)(*DBObjPtr)(INT_BANK_CODE, rFormat) != PD_OK) {
DEBUGLOG(("call DBOLStmtFormat::GetFormat() fail\n"));
ERRLOG("convert_psbc: batch_proc: call DBOLStmtFormat::GetFormat() fail\n");
			iErrorCode = INT_FORMAT_TEMPLATE_ERROR;
			iRet = FAILURE;
		}
	}

	// match stmt file format
	if (iRet == SUCCESS) {
		hFormat = RecordSet_GetFirst(rFormat);
		while (hFormat) {
			if (GetField_CString(hFormat, "format_id", &csFormatId)) {
				// delimiter
				sprintf(csTag, "delimiter_%s", csFormatId);
				if (!GetField_CString(hFormat, csTag, &csTmp)) {
DEBUGLOG(("delimiter not found\n"));
ERRLOG("convert_psbc: batch_proc: delimiter not found\n");
					iErrorCode = INT_FORMAT_TEMPLATE_ERROR;
					iRet = FAILURE;
					break;
				} else {
					sprintf(csDelimiter, "%c", atoi(csTmp));
				}
			}

			// neg_amount
			if (!GetField_CString(hFormat, "neg_amount", &csTmp)) {
				iNegAmount = 0;
			} else {
				iNegAmount = atoi(csTmp);
			}

			// neg_balance
			if (!GetField_CString(hFormat, "neg_balance", &csTmp)) {
				iNegBalance = 0;
			} else {
				iNegBalance = atoi(csTmp);
			}

			// reverse
			if (!GetField_CString(hFormat, "reverse", &csTmp)) {
				iReverse = 0;
			} else if (*csTmp == '1') {
				iReverse = 1;
			} else {
				iReverse = 0;
			}

			// row_start
			if (!GetField_CString(hFormat, "row_start", &csTmp)) {
				iStartRow = 1;
			} else {
				iStartRow = atoi(csTmp) + iSBlankLine;
			}

			// row_end
			if (!GetField_CString(hFormat, "row_end", &csTmp)) {
				iEndRow = 1;
			} else {
				iEndRow = atoi(csTmp) + iEBlankLine;
			}

			// total_field
			if (!GetField_CString(hFormat, "total_field", &csTmp)) {
				iTotalField = 0;
			} else {
				iTotalField = atoi(csTmp);
			}

DEBUGLOG(("Summary: Total Field = [%d] Starting/Ending Row = [%d]/[%d]\n", iTotalField, iStartRow, iEndRow));

			// check input file total field
			iLineCnt = 0;
			iFieldCnt = 0;
			rewind(fin);
			while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
				iLineCnt++;
				if (iLineCnt == iStartRow) {
					if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A) cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
					if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0D) cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
					strcpy(cs_tmp_input_buf, cs_input_buf);
					csTmp = mystrtok(cs_tmp_input_buf, csDelimiter);
					while (csTmp != NULL) {
						iFieldCnt++;
						csTmp = mystrtok(NULL, csDelimiter);
					}
DEBUGLOG(("format_id[%s] delimiter[%s]\n", csFormatId, csDelimiter));
DEBUGLOG(("line %03d count[%d]/total_field[%d] [%s]\n", iLineCnt, iFieldCnt, iTotalField, cs_input_buf));
					if (iFieldCnt == iTotalField) iMatched = 1;
					break;
				}
			}

			if (iMatched) break;

			hFormat = RecordSet_GetNext(rFormat);
		}

		// no stmt file format match
		if (iMatched) {
			PutField_Int(hFormat, "neg_amount", iNegAmount);
			PutField_Int(hFormat, "neg_balance", iNegBalance);
		} else {
DEBUGLOG(("no stmt file format match\n"));
ERRLOG("convert_psbc: batch_proc: no stmt file format match\n");
			iErrorCode = INT_INVALID_FILE_FORMAT;
			iRet = FAILURE;
		}
	}

	if (iRet == SUCCESS) {
		iLineCnt = 0;
		rewind(fin);
		while (fgets(cs_input_buf, sizeof(cs_input_buf), fin) != NULL) {
			iLineCnt++;

			if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A) cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
			if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0D) cs_input_buf[strlen(cs_input_buf) - 1] = '\0';

			// output lines before and after detail records
			if (iLineCnt < iStartRow || iLineCnt > iTotalLine - iEndRow + 1) {
				fprintf(fout, "%.*s\n", (int)strlen(cs_input_buf), cs_input_buf);
				continue;
			}

			hPrevRec = (hash_t*) malloc (sizeof(hash_t));
			hash_init(hPrevRec, 0);
			if (SplitLineByhFormat(cs_input_buf, csFormatId, hFormat, hPrevRec) != PD_OK) {
DEBUGLOG(("call SplitLineByhFormat() fail\n"));
ERRLOG("convert_psbc: batch_proc: call SplitLineByhFormat() fail\n");
				iErrorCode = INT_FORMAT_TEMPLATE_ERROR;
				iRet = FAILURE;
				break;
			}

			cs_err_msg_buf[0] = '\0';
			if (CheckDetail(hFormat, hPrevRec, cs_err_msg_buf) != PD_OK) {
DEBUGLOG(("call CheckDetail() fail\n"));
ERRLOG("convert_psbc: batch_proc: call CheckDetail() fail\n");
				iErrorCode = INT_DETAIL_FIELD_ERROR;
				iRet = FAILURE;
				break;
			}

			if (GetField_CString(hPrevRec, "txn_amount", &csTmp)) {
				dPrevTxnAmt = string2doublewithsign((const unsigned char *)csTmp);
			}

			if (GetField_CString(hPrevRec, "balance", &csTmp)) {
				dPrevBal = string2doublewithsign((const unsigned char *)csTmp);
			}

			if (GetField_CString(hPrevRec, "tfr_type", &csTmp)) {
				strcpy(csPrevKeyword, csTmp);
			}

			if (iReverse) {
DEBUGLOG(("--------------------\n"));
DEBUGLOG(("is reverse (Curr): txn_amount = [%.2lf] balance = [%.2lf] tfr_type = [%s]\n", dCurrTxnAmt, dCurrBal, csCurrKeyword));
DEBUGLOG(("is reverse (Prev): txn_amount = [%.2lf] balance = [%.2lf] tfr_type = [%s]\n", dPrevTxnAmt, dPrevBal, csPrevKeyword));

				if (dPrevTxnAmt != 0.0) {
					if (dCurrTxnAmt == 0.0 && dCurrBal == 0.0) {
						// do nothing
					} else {
						// determine curr record sign by balance
						if (dCurrBal - dPrevBal > 1E-9) {
							dCurrTxnAmt = fabs(dCurrTxnAmt);
DEBUGLOG(("determine sign = [%.2lf]\n", dCurrTxnAmt));
							sprintf(cs_tmp_buf, "%.2lf", dCurrTxnAmt);
							PutField_CString(hCurrRec, "txn_amount", cs_tmp_buf);
						} else if (dCurrBal - dPrevBal < -1E-9) {
							dCurrTxnAmt = -1.0 * fabs(dCurrTxnAmt);
DEBUGLOG(("determine sign = [%.2lf]\n", dCurrTxnAmt));
							sprintf(cs_tmp_buf, "%.2lf", dCurrTxnAmt);
							PutField_CString(hCurrRec, "txn_amount", cs_tmp_buf);
						} else {
							if (dCurrTxnAmt != 0.0) {
DEBUGLOG(("[Current Record Balance - Previous Record Balance = 0 but Current Transaction Amount is non-zero]\n"));
								fprintf(fout, "%s\n", "[Current Record Balance - Previous Record Balance = 0 but Current Transaction Amount is non-zero]");
								iErrorCode = INT_DETAIL_FIELD_ERROR;
								iRet = FAILURE;
								break;
							}
						}

						// output curr record
						for (iTmp = 1; iTmp <= iTotalField; iTmp++) {
							sprintf(csTag, "content_desc_%s_%d", csFormatId, iTmp);
//DEBUGLOG(("debug output curr record: csTag = [%s]\n", csTag));
							if (GetField_CString(hCurrRec, csTag, &csTmp)) {
//DEBUGLOG(("debug output curr record: csTmp = [%s]\n", csTmp));
								strcpy(csTmp3, csTmp);
								if (GetField_CString(hCurrRec, csTmp, &csTmp2)) {
//DEBUGLOG(("debug output curr record: csTmp2 = [%s]\n", csTmp2));
									strcpy(csTmp3, csTmp2);
								}
								if (iTmp != iTotalField)
									fprintf(fout, "%.*s%s", (int)strlen(csTmp3), csTmp3, csDelimiter);
								else
									fprintf(fout, "%.*s\n", (int)strlen(csTmp3), csTmp3);
							}
						}
					}

					dCurrTxnAmt = dPrevTxnAmt;
					dCurrBal = dPrevBal;
					strcpy(csCurrKeyword, csPrevKeyword);
					hCurrRec = hPrevRec;
				}

				if (iLineCnt == iTotalLine - iEndRow + 1) {
DEBUGLOG(("--------------------\n"));
					if (dCurrTxnAmt != 0.0 && dCurrBal != 0.0) {
						// determine oldest record sign by keyword
						PutField_CString(hFormat, "int_bank_code", INT_BANK_CODE);
						PutField_CString(hFormat, "bank_acct_type", csBankAcctType);
						PutField_CString(hFormat, "acct_ccy", ACCT_CCY);
						if (determineSignByKeyword(hFormat, hCurrRec) != PD_OK) {
DEBUGLOG(("call determineSignByKeyword() fail\n"));
ERRLOG("convert_psbc: batch_proc: call determineSignByKeyword() fail\n");
							fprintf(fout, "%s\n", "[cannot determine sign by keyword]");
							iErrorCode = INT_FORMAT_KEYWORDS_ERROR;
							iRet = FAILURE;
							break;
						}

						// output oldest record
						for (iTmp = 1; iTmp <= iTotalField; iTmp++) {
							sprintf(csTag, "content_desc_%s_%d", csFormatId, iTmp);
//DEBUGLOG(("debug output oldest record: csTag = [%s]\n", csTag));
							if (GetField_CString(hCurrRec, csTag, &csTmp)) {
//DEBUGLOG(("debug output oldest record: csTmp = [%s]\n", csTmp));
								strcpy(csTmp3, csTmp);
								if (GetField_CString(hCurrRec, csTmp, &csTmp2)) {
//DEBUGLOG(("debug output oldest record: csTmp2 = [%s]\n", csTmp2));
									strcpy(csTmp3, csTmp2);
								}
								if (iTmp != iTotalField)
									fprintf(fout, "%.*s%s", (int)strlen(csTmp3), csTmp3, csDelimiter);
								else
									fprintf(fout, "%.*s\n", (int)strlen(csTmp3), csTmp3);
							}
						}
					}
				}
			}
		}
	}

DEBUGLOG(("iErrorCode = [%d]\n", iErrorCode));
	if (iErrorCode != 0) {
		char csTmpField[PD_TMP_BUF_LEN] = "";

		hError = (hash_t*) malloc (sizeof(hash_t));
		hash_init(hError, 0);

		PutField_Int(hError, "file_id", iStmtFileId);
		//PutField_Int(hError, "message_code", iErrorCode);
DEBUGLOG(("iErrorCode overrided to [%d]\n", INT_INVALID_FILE_FORMAT));
		PutField_Int(hError, "message_code", INT_INVALID_FILE_FORMAT);
		PutField_CString(hError, "create_user", PD_UPDATE_USER);

DEBUGLOG(("call DBOLStmtConvertError::AddError()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtConvertError", "AddError");
		if ((unsigned long)(*DBObjPtr)(hError) != PD_OK) {
DEBUGLOG(("call DBOLStmtConvertError::AddError() fail\n"));
ERRLOG("convert_psbc: batch_proc: call DBOLStmtConvertError::AddError() fail\n");
			iRet = FAILURE;
		}

		hash_destroy(hError);
		FREE_ME(hError);
	}

	FREE_ME(csTag);

	RecordSet_Destroy(rFormat);
	FREE_ME(rFormat);

	fclose(fin);
	fclose(fout);

DEBUGLOG(("batch_proc: iRet = [%d]\n", iRet));
	return SUCCESS;
}


int batch_terminate(int argc, char *argv[])
{
	return SUCCESS;
}


int parse_arg(int argc, char **argv)
{
	char c;
	iStmtFileId = 0;
	strcpy(csRawFile, "");
	strcpy(csProcessFile, "");
	strcpy(csBankAcctType, "");

	while ((c = getopt(argc, argv, "i:r:o:t:")) != EOF) {
		switch (c) {
			case 'i':
				iStmtFileId = atoi(optarg);
				break;
			case 'r':
				strcpy(csRawFile, optarg);
				break;
			case 'o':
				strcpy(csProcessFile, optarg);
				break;
			case 't':
				strcpy(csBankAcctType, optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (iStmtFileId == 0 || !strcmp(csRawFile, "") || !strcmp(csProcessFile, "") || !strcmp(csBankAcctType, ""))
		return FAILURE;

	return SUCCESS;
}


int SplitLineByhFormat(const char *csLine, const char *csFormatId, const hash_t *hFormat, hash_t *hRls)
{
	int iRet = PD_OK;
	char *csTag = (char*) malloc (64);
	char csDelimiter[2], *csDesc = NULL;
	char *csTmp;

	char *csLineField, *csRemainField;
	char csNewField[PD_TMP_MSG_BUF_LEN], csNewLine[PD_TMP_MSG_BUF_LEN];
	int iField = 0;

	/* delimiter */
	sprintf(csTag, "delimiter_%s", csFormatId);
	if (!GetField_CString(hFormat, csTag, &csTmp)) {
DEBUGLOG(("SplitLineByhFormat: [%s] not found\n", csTag));
ERRLOG("convert_psbc: SplitLineByhFormat: [%s] not found\n", csTag);
		iRet = PD_ERR;
	} else {
		sprintf(csDelimiter, "%c", atoi(csTmp));
	}

	strcpy(csNewLine, csLine);

	csLineField = mystrtok_r(csNewLine, csDelimiter, &csRemainField);
	while (csLineField != NULL && iRet == PD_OK) {
		strcpy(csNewField, TrimAll((const unsigned char*)csLineField, strlen(csLineField)));

		iField++;

		if (*csNewField == '\0') {
			csLineField = mystrtok_r(NULL, csDelimiter, &csRemainField);
			continue;
		}

		csDesc = NULL;

		/* desc - CONTENT */
		sprintf(csTag, "content_desc_%s_%d", csFormatId, iField);
		if (GetField_CString(hFormat, csTag, &csDesc)) {
//DEBUGLOG(("debug desc %s (%s)[%s]\n", csTag, csDesc, csNewField));
			PutField_CString(hRls, csTag, csDesc);
			PutField_CString(hRls, csDesc, csNewField);
		} else {
//DEBUGLOG(("debug desc %s [%s]\n", csTag, csNewField));
			PutField_CString(hRls, csTag, csNewField);
		}

		csLineField = mystrtok_r(NULL, csDelimiter, &csRemainField);
	}

	FREE_ME(csTag);
	return iRet;
}


char *CS_DETAIL_TAG[18] = {"statement_date","statement_time","tfr_bank_name","tfr_bank_acct_num","tfr_type","tfr_channel","tfr_text","tfr_customer_text","sender_name","txn_ref_num","balance","amt_type","txn_amount","txn_ccy","bank_charge","sender_baid_name","recipient_baid_name","client_name"};
char *CS_DETAIL_NAME[18] = {"Date","Time","Deposit Bank","Bank Account","Txn Category","Txn Channel","Txn Description","Bank Remark","Sender Name","Txn Ref Number","Balance","Credit/Debit","Amount","Currency","Bank Charge","Sender BAID Name","Recipient BAID Name","Client Name"};
int INT_DETAIL_TAG = (int)sizeof(CS_DETAIL_TAG) / (int)sizeof(*CS_DETAIL_TAG);

int INT_DETAIL_MAX_LEN[18]	= {   8,   6,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  15,   2,  13,   3,  13, 100, 100,  50};
int INT_DETAIL_MAX_UTF8_LEN[18]	= {  -1,  -1,  50,  50, 200, 200,  50, 202,  50,  50,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1};
int INT_DETAIL_CHECK_LEN[18]	= {   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1};

int CheckDetail(const hash_t *hContext, hash_t *hRls, char *cs_err_msg_buf) {
	int iRet = PD_OK;
	int i;
	char *csTmp = NULL;
	double dTmp;

	int iNegAmount, iNegBalance;

	char cs_tmp_buf1[PD_TMP_BUF_LEN] = "";
	char cs_tmp_buf2[PD_TMP_BUF_LEN] = "";

	// neg_amount
	if (!GetField_Int(hContext, "neg_amount", &iNegAmount)) {
DEBUGLOG(("CheckDetail: neg_amount not found\n"));
		iRet = PD_ERR;
	}
	// neg_balance
	if (!GetField_Int(hContext, "neg_balance", &iNegBalance)) {
DEBUGLOG(("CheckDetail: neg_balance not found\n"));
		iRet = PD_ERR;
	}

	// txn_amount
	i = 12;
	if (GetField_CString(hRls, "txn_amount", &csTmp)) {
		_deleteCharacters(csTmp, ",");

		if (sscanf(csTmp, "%lf", &dTmp) == 1 ||
		    sscanf(csTmp, "%*[^0-9+-.]%lf", &dTmp) == 1) {

			sprintf(cs_tmp_buf1, "%.2lf", dTmp);
			csTmp = cs_tmp_buf1;

			// Allow greater than or equal to 0
			if (dTmp > 1E-9) {
//DEBUGLOG(("CheckDetail: txn_amount = [%s]\n", csTmp));
			// Allow less than 0 when NEG_AMOUNT
			} else {
				if (iNegAmount == 1) {
//DEBUGLOG(("CheckDetail: ## txn_amount = [%s] allowed\n", csTmp));
				} else {
DEBUGLOG(("CheckDetail: txn_amount [%s] invalid\n", csTmp));
					INT_DETAIL_CHECK_LEN[i] = 0;
					if (iRet != PD_ERR) iRet = PD_OTHER_ERR;
					snprintf(cs_tmp_buf1, sizeof(cs_tmp_buf1), "[Invalid %s]", CS_DETAIL_NAME[i]);
					strncat(cs_tmp_buf2, cs_tmp_buf1, sizeof(cs_tmp_buf2) - strlen(cs_tmp_buf2) - 1);
				}
			}
		} else {
DEBUGLOG(("CheckDetail: txn_amount [%s] invalid\n", csTmp));
			INT_DETAIL_CHECK_LEN[i] = 0;
			iRet = PD_ERR;
			snprintf(cs_tmp_buf1, sizeof(cs_tmp_buf1), "[Invalid %s]", CS_DETAIL_NAME[i]);
			strncat(cs_tmp_buf2, cs_tmp_buf1, sizeof(cs_tmp_buf2) - strlen(cs_tmp_buf2) - 1);
		}

		PutField_CString(hRls, "txn_amount", csTmp);
	} else {
DEBUGLOG(("CheckDetail: txn_amount not found\n"));
		INT_DETAIL_CHECK_LEN[i] = 0;
		iRet = PD_ERR;
		snprintf(cs_tmp_buf1, sizeof(cs_tmp_buf1), "[%s Not Found]", CS_DETAIL_NAME[i]);
		strncat(cs_tmp_buf2, cs_tmp_buf1, sizeof(cs_tmp_buf2) - strlen(cs_tmp_buf2) - 1);
	}

	// balance
	i = 10;
	if (GetField_CString(hRls, "balance", &csTmp)) {
		_deleteCharacters(csTmp, ",");

		if (sscanf(csTmp, "%lf", &dTmp) == 1 ||
		    sscanf(csTmp, "%*[^0-9+-.]%lf", &dTmp) == 1) {

			sprintf(cs_tmp_buf1, "%.2lf", dTmp);
			csTmp = cs_tmp_buf1;

			// Allow greater than or equal to 0
			if (dTmp > -1E-9) {
//DEBUGLOG(("CheckDetail: balance = [%s]\n", csTmp));
			// Allow less than 0 when NEG_BALANCE
			} else {
				if (iNegBalance == 1) {
//DEBUGLOG(("CheckDetail: ## balance = [%s] allowed\n", csTmp));
				} else {
DEBUGLOG(("CheckDetail: balance [%s] invalid\n", csTmp));
					INT_DETAIL_CHECK_LEN[i] = 0;
					if (iRet != PD_ERR) iRet = PD_OTHER_ERR;
					snprintf(cs_tmp_buf1, sizeof(cs_tmp_buf1), "[Invalid %s]", CS_DETAIL_NAME[i]);
					strncat(cs_tmp_buf2, cs_tmp_buf1, sizeof(cs_tmp_buf2) - strlen(cs_tmp_buf2) - 1);
				}
			}
		} else {
DEBUGLOG(("CheckDetail: balance [%s] invalid\n", csTmp));
			INT_DETAIL_CHECK_LEN[i] = 0;
			iRet = PD_ERR;
			snprintf(cs_tmp_buf1, sizeof(cs_tmp_buf1), "[Invalid %s]", CS_DETAIL_NAME[i]);
			strncat(cs_tmp_buf2, cs_tmp_buf1, sizeof(cs_tmp_buf2) - strlen(cs_tmp_buf2) - 1);
		}

		PutField_CString(hRls, "balance", csTmp);
	} else {
DEBUGLOG(("CheckDetail: balance not found\n", csTmp));
		INT_DETAIL_CHECK_LEN[i] = 0;
		iRet = PD_ERR;
		snprintf(cs_tmp_buf1, sizeof(cs_tmp_buf1), "[%s Not Found]", CS_DETAIL_NAME[i]);
		strncat(cs_tmp_buf2, cs_tmp_buf1, sizeof(cs_tmp_buf2) - strlen(cs_tmp_buf2) - 1);
	}

	// length
	for (i = 0; i < INT_DETAIL_TAG; i++) {
		if (INT_DETAIL_CHECK_LEN[i] > 0) {
			if (GetField_CString(hRls, CS_DETAIL_TAG[i], &csTmp)) {
				if (INT_DETAIL_MAX_LEN[i] != -1) {
					if (strlen(csTmp) > INT_DETAIL_MAX_LEN[i]) {
DEBUGLOG(("CheckDetail: %s [%s] too long\n", CS_DETAIL_NAME[i], csTmp));
						if (iRet != PD_ERR) iRet = PD_OTHER_ERR;
						snprintf(cs_tmp_buf1, sizeof(cs_tmp_buf1), "[%s Too Long]", CS_DETAIL_NAME[i]);
						strncat(cs_tmp_buf2, cs_tmp_buf1, sizeof(cs_tmp_buf2) - strlen(cs_tmp_buf2) - 1);
					}
				}

				if (INT_DETAIL_MAX_UTF8_LEN[i] != -1) {
					if (strlen_utf8(csTmp) > INT_DETAIL_MAX_UTF8_LEN[i]) {
DEBUGLOG(("CheckDetail: %s UTF8[%s] too long\n", CS_DETAIL_NAME[i], csTmp));
						if (iRet != PD_ERR) iRet = PD_OTHER_ERR;
						snprintf(cs_tmp_buf1, sizeof(cs_tmp_buf1), "[%s Too Long]", CS_DETAIL_NAME[i]);
						strncat(cs_tmp_buf2, cs_tmp_buf1, sizeof(cs_tmp_buf2) - strlen(cs_tmp_buf2) - 1);
					}
				}
			}
		}

		INT_DETAIL_CHECK_LEN[i] = 1;
	}

	if (iRet != PD_OK) {
		sprintf(cs_err_msg_buf, "%s", cs_tmp_buf2);
DEBUGLOG(("CheckDetail: err_msg = %s\n", cs_err_msg_buf));
	}

	return iRet;
}


int determineSignByKeyword(const hash_t *hFormat, hash_t *hRec) {
	int iRet = PD_OK, iTmpRet = PD_NOT_FOUND;
	char *csTxnAmt = NULL, *csTxnCode = NULL, *csAmtType = NULL;
	int iFullMatch = 0;
	char *csDesc = NULL, *csTemplate = NULL, *csField = NULL;
	int iIsCredit = PD_FALSE, iIsDebit = PD_FALSE;
	double dTxnAmt = 0.0;
	char cs_tmp_buf[PD_TMP_BUF_LEN] = "";

	recordset_t *rKeywords = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rKeywords, 0);
	hash_t *hKeywords;

	// txn_amount
	if (!GetField_CString(hRec, "txn_amount", &csTxnAmt)) {
DEBUGLOG(("determineSignByKeyword: txn_amount not found\n"));
		iRet = PD_ERR;
	} else {
		dTxnAmt = string2doublewithsign((const unsigned char *)csTxnAmt);
	}

	if (iRet == PD_OK) {
DEBUGLOG(("determineSignByKeyword: call DBOLStmtFormat::GetTxnCodeKeywordsAll()\n"));
		DBObjPtr = CreateObj(DBPtr, "DBOLStmtFormat", "GetTxnCodeKeywordsAll");
		iTmpRet = (unsigned long)(*DBObjPtr)(hFormat, rKeywords);
		if (iTmpRet != PD_FOUND) {
DEBUGLOG(("determineSignByKeyword: call DBOLStmtFormat::GetTxnCodeKeywordsAll() fail\n"));
ERRLOG("determineSignByKeyword: call DBOLStmtFormat::GetTxnCodeKeywordsAll() fail\n");
			iRet = PD_ERR;
		}
	}

	if (iRet == PD_OK) {
		hKeywords = RecordSet_GetFirst(rKeywords);
		while (hKeywords) {
			GetField_CString(hKeywords, "txn_code", &csTxnCode);
			GetField_CString(hKeywords, "amt_type", &csAmtType);
			GetField_CString(hKeywords, "cont_desc", &csDesc);
			GetField_CString(hKeywords, "format_template", &csTemplate);
			GetField_Int(hKeywords, "full_match", &iFullMatch);
//DEBUGLOG(("debug: txn_code = [%s], amt_type = [%s]\n", csTxnCode, csAmtType));
//DEBUGLOG(("debug: cont_desc = [%s], format_template = [%s], full_match = [%d]\n", csDesc, csTemplate, iFullMatch));

			if (GetField_CString(hRec, csDesc, &csField)) {
//DEBUGLOG(("debug: record keyword = [%s]\n", csField));
				if (MultiKeywordsSearch(csField, csTemplate, iFullMatch) == FOUND) {
						if (!strcmp(csAmtType, PD_CR)) {
DEBUGLOG(("txn_code = [%s], amt_type = [%s]\n", csTxnCode, csAmtType));
DEBUGLOG(("cont_desc = [%s], format_template = [%s], full_match = [%d]\n", csDesc, csTemplate, iFullMatch));
DEBUGLOG(("record keyword = [%s]\n", csField));
DEBUGLOG(("credit\n"));
							iIsCredit = PD_TRUE;
							if (iIsDebit) {
DEBUGLOG(("already debit, but credit now\n"));
								iRet = PD_ERR;
								break;
							}
							dTxnAmt = fabs(dTxnAmt);
							sprintf(cs_tmp_buf, "%.2lf", dTxnAmt);
							PutField_CString(hRec, "txn_amount", cs_tmp_buf);
						} else if (!strcmp(csAmtType, PD_DR)) {
DEBUGLOG(("txn_code = [%s], amt_type = [%s]\n", csTxnCode, csAmtType));
DEBUGLOG(("cont_desc = [%s], format_template = [%s], full_match = [%d]\n", csDesc, csTemplate, iFullMatch));
DEBUGLOG(("record keyword = [%s]\n", csField));
DEBUGLOG(("debit\n"));
							iIsDebit = PD_TRUE;
							if (iIsCredit) {
DEBUGLOG(("already credit, but debit now\n"));
								iRet = PD_ERR;
								break;
							}
							dTxnAmt = -1.0 * fabs(dTxnAmt);
							sprintf(cs_tmp_buf, "%.2lf", dTxnAmt);
							PutField_CString(hRec, "txn_amount", cs_tmp_buf);
						}
				}
			}

			hKeywords = RecordSet_GetNext(rKeywords);
		}

		if ((!iIsCredit) && (!iIsDebit)) {
DEBUGLOG(("not credit or debit\n"));
			iRet = PD_ERR;
		}
	}

	_RecordSet_Destroy(rKeywords);
	FREE_ME(rKeywords);

	return iRet;
}


int MultiKeywordsSearch(const char *csLine, char *csTemplate, int iFullMatch)
{
	char *csTemplateField;
	csTemplateField = mystrtok(csTemplate, ",");
	while (csTemplateField != NULL) {
		if (iFullMatch == 0 && strstr(csLine, csTemplateField) != NULL) {
			return FOUND;
		} else if (iFullMatch == 1 && !strcmp(csLine, csTemplateField)) {
			return FOUND;
		}
		csTemplateField = mystrtok(NULL, ",");
	}
	return NOT_FOUND;
}

