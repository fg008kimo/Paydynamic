#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "curl/curl.h"
#include "ObjPtr.h"
#include "myrecordset.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

OBJPTR(DB);
OBJPTR(Txn);

char cDebug = 'Y';
char csOmmMsg[PD_TMP_MSG_BUF_LEN + 1];

int parse_arg(int argc, char **argv);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	int iRet = SUCCESS;
	int iStmtTxnIdCnt = 0;
	char *csTag = (char*) malloc (1024);

	char cMatchingType;
	int iOverrideAmt;
	char csMerchRef[PD_MERCHANT_REF_LEN + 1];
	char csChannelCode[PD_CHANNEL_CODE_LEN + 1];
	char csTxnCode[PD_TXN_CODE_LEN + 1];
	char csSubStatus[PD_SUB_STATUS_LEN + 1];
	char csTxnCcy[PD_CCY_ID_LEN + 1];
	char csBankCode[PD_BANK_CODE_LEN + 1];
	char csBankAcctNum[PD_BANK_ACCT_NUM_LEN + 1];
	char cStatus;
	char cArInd;
	double dDepositAmt = 0.0;
	int iTxnHoldInd = 0;

	iRet = parse_arg(argc, argv);

	if (iRet != SUCCESS) {
		printf("Usage: manual_match_fallback.exec -m omm_msg\n");
		return FAILURE;
	}

	hash_t *hRequest;
	hRequest = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRequest, 0);

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar hv_merchant_ref[PD_MERCHANT_REF_LEN];
		varchar hv_channel_code[PD_CHANNEL_CODE_LEN];
		varchar hv_txn_code[PD_TXN_CODE_LEN];
		varchar hv_sub_status[PD_SUB_STATUS_LEN];
		varchar hv_txn_ccy[PD_CCY_ID_LEN];
		varchar hv_bank_code[PD_BANK_CODE_LEN];
		varchar hv_bank_acct_num[PD_BANK_ACCT_NUM_LEN];
		char hv_status;
		char hv_ar_ind;
		double hv_deposit_amt;
		int hv_txn_hold_ind;

		varchar v_merch_txn_id[PD_TXN_SEQ_LEN + 1];
		varchar v_stmt_txn_id[PD_TXN_SEQ_LEN + 1];

		short ind_merch_txn_id = -1;
		short ind_stmt_txn_id = -1;
	EXEC SQL END DECLARE SECTION;

	char *csTmp;
	int i_field_cnt = 0;
	csTmp = mystrtok(csOmmMsg, ",");
	while (csTmp != NULL) {
		i_field_cnt++;
		switch (i_field_cnt) {
			case 1:
				cMatchingType = csTmp[0];
DEBUGLOG(("[1][cMatchingType] = [%c]\n", cMatchingType));
				break;
			case 2:
				iOverrideAmt = atoi(csTmp);
DEBUGLOG(("[2][iOverrideAmt] = [%d]\n", iOverrideAmt));
				break;
			case 3:
				strcpy(csMerchRef, csTmp);
DEBUGLOG(("[3][csMerchRef] = [%s]\n", csMerchRef));
				break;
			case 4:
				strcpy(csChannelCode, csTmp);
DEBUGLOG(("[4][csChannelCode] = [%s]\n", csChannelCode));
				break;
			case 5:
				strcpy(csTxnCode, csTmp);
DEBUGLOG(("[5][csTxnCode] = [%s]\n", csTxnCode));
				break;
			case 6:
				strcpy(csSubStatus, csTmp);
DEBUGLOG(("[6][csSubStatus] = [%s]\n", csSubStatus));
				break;
			case 7:
				strcpy(csTxnCcy, csTmp);
DEBUGLOG(("[7][csTxnCcy] = [%s]\n", csTxnCcy));
				break;
			case 8:
				strcpy(csBankCode, csTmp);
DEBUGLOG(("[8][csBankCode] = [%s]\n", csBankCode));
				break;
			case 9:
				strcpy(csBankAcctNum, csTmp);
DEBUGLOG(("[9][csBankAcctNum] = [%s]\n", csBankAcctNum));
				break;
			case 10:
				cStatus = csTmp[0];
DEBUGLOG(("[10][cStatus] = [%c]\n", cStatus));
				break;
			case 11:
				cArInd = csTmp[0];
DEBUGLOG(("[11][cArInd] = [%c]\n", cArInd));
				break;
			case 12:
				sscanf(csTmp, "%lf", &dDepositAmt);
DEBUGLOG(("[12][dDepositAmt] = [%lf]\n", dDepositAmt));
				break;
			case 13:
				iTxnHoldInd = atoi(csTmp);
DEBUGLOG(("[13][iTxnHoldInd] = [%d]\n", iTxnHoldInd));
				break;
			default:
DEBUGLOG(("error\n"));
		}
		csTmp = mystrtok(NULL, ",");
	}

	hv_merchant_ref.len = strlen(csMerchRef);
	memcpy(hv_merchant_ref.arr, csMerchRef, hv_merchant_ref.len);

	EXEC SQL DECLARE c_cursor_get_merch_txn_id CURSOR FOR
		select oth_txn_id
		from ol_txn_header
		where oth_merchant_ref = :hv_merchant_ref;

	EXEC SQL OPEN c_cursor_get_merch_txn_id;

	EXEC SQL FETCH c_cursor_get_merch_txn_id
	INTO :v_merch_txn_id:ind_merch_txn_id;

	if (SQLCODE == SQL_NOT_FOUND) {
DEBUGLOG(("manual_match_fallback: merch_txn_id not found\n"));
		return FAILURE;
	}

	// merch_txn_id
	if (ind_merch_txn_id >= 0) {
		v_merch_txn_id.arr[v_merch_txn_id.len] = '\0';
DEBUGLOG(("manual_match_fallback: merch_txn_id = [%s]\n", (const char*)v_merch_txn_id.arr));
	} else {
DEBUGLOG(("manual_match_fallback: merch_txn_id is empty\n"));
		return FAILURE;
	}

	EXEC SQL CLOSE c_cursor_get_merch_txn_id;



	hv_channel_code.len = strlen(csChannelCode);
	memcpy(hv_channel_code.arr, csChannelCode, hv_channel_code.len);

	hv_txn_code.len = strlen(csTxnCode);
	memcpy(hv_txn_code.arr, csTxnCode, hv_txn_code.len);

	hv_sub_status.len = strlen(csSubStatus);
	memcpy(hv_sub_status.arr, csSubStatus, hv_sub_status.len);

	hv_txn_ccy.len = strlen(csTxnCcy);
	memcpy(hv_txn_ccy.arr, csTxnCcy, hv_txn_ccy.len);

	hv_bank_code.len = strlen(csBankCode);
	memcpy(hv_bank_code.arr, csBankCode, hv_bank_code.len);

	hv_bank_acct_num.len = strlen(csBankAcctNum);
	memcpy(hv_bank_acct_num.arr, csBankAcctNum, hv_bank_acct_num.len);

	hv_status = cStatus;

	hv_ar_ind = cArInd;

	hv_deposit_amt = dDepositAmt;

	hv_txn_hold_ind = iTxnHoldInd;

	EXEC SQL DECLARE c_cursor_get_stmt_txn_id cURSOR FOR
		select oth_txn_id
		from ol_txn_header, ol_txn_psp_detail
		where oth_txn_id = otp_txn_id
		and oth_input_channel = :hv_channel_code
		and oth_status = :hv_status
		and oth_ar_ind = :hv_ar_ind
		and oth_txn_code = :hv_txn_code
		and oth_sub_status = :hv_sub_status
		and oth_deposit_amount = :hv_deposit_amt
		and otp_txn_ccy = :hv_txn_ccy
		and otp_bank_code = :hv_bank_code
		and otp_bank_acct_num = :hv_bank_acct_num
		and otp_txn_hold_ind = :hv_txn_hold_ind
		order by oth_approval_timestamp asc;

	EXEC SQL OPEN c_cursor_get_stmt_txn_id;

	for (;;) {
		EXEC SQL FETCH c_cursor_get_stmt_txn_id
		INTO :v_stmt_txn_id:ind_stmt_txn_id;

		if (SQLCODE == SQL_NOT_FOUND) {
			if (iStmtTxnIdCnt == 0) {
DEBUGLOG(("manual_match_fallback: stmt_txn_id not found\n"));
				return FAILURE;
			} else {
				break;
			}
		}

		iStmtTxnIdCnt++;

		// stmt_txn_id
		if (ind_stmt_txn_id >= 0) {
			v_stmt_txn_id.arr[v_stmt_txn_id.len] = '\0';
DEBUGLOG(("manual_match_fallback: stmt_txn_id = [%s]\n", (const char*)v_stmt_txn_id.arr));
		} else {
DEBUGLOG(("manual_match_fallback: stmt_txn_id is empty\n"));
			return FAILURE;
		}
	}

	EXEC SQL CLOSE c_cursor_get_stmt_txn_id;

	hash_destroy(hRequest);
	FREE_ME(hRequest);

	FREE_ME(csTag);

DEBUGLOG(("manual_match_fallback: Normal Exit() iRet = [%d]\n", iRet));
	return iRet;

sql_error:
DEBUGLOG(("sql_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("manual_match_fallback:: sql error\n");
	EXEC SQL WHENEVER SQLERROR CONTINUE;
//EXEC SQL CLOSE c_cursor_get_merch_txn_id
//EXEC SQL CLOSE c_cursor_get_stmt_txn_id;
	EXEC SQL ROLLBACK RELEASE;
	FREE_ME(hRequest);
	return FAILURE;
}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}


int parse_arg(int argc, char **argv)
{
	char c;
	strcpy(csOmmMsg, "");

	while ((c = getopt(argc, argv, "m:")) != EOF) {
		switch (c) {
			case 'm':
				strcpy(csOmmMsg, optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (!strcmp(csOmmMsg, "")) {
		return FAILURE;
	}

	return SUCCESS;
}
