/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version					   2015/03/10              Dirk Wong
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"


#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define	PD_MY_DELIMITOR	','

OBJPTR(BO);

char    cs_date[PD_DATE_LEN + 1];
char	cs_mode[PD_DESC_LEN + 1];
char    cDebug = 'Y';

int parse_arg(int argc,char **argv);
int process_data(const char* csTxnDate, FILE *fp);

int batch_init(int argc, char* argv[])
{

    if (argc < 3) {
        printf("usage:  -d Date -m Mode(FULL/DELTA)\n");
        return FAILURE;
    }
    else
        return SUCCESS;
}




int batch_proc(int argc, char* argv[])
{
        int     iRet;
        char    cs_outfile_name[PD_MAX_FILE_LEN + 1];
        FILE    *fp;

	iRet = parse_arg(argc,argv);
               
        if (iRet != SUCCESS) {
        	printf("usage:  -d Date -m Mode(FULL/DELTA)\n");
                return (iRet);
        }

        char    cs_yyyy[PD_YYYY_LEN+1];
        char    cs_yyyymm[PD_YYYY_LEN+PD_MM_LEN+1];
        strncpy(cs_yyyy,cs_date,4);
        strncpy(cs_yyyymm,cs_date,6);

	sprintf(cs_outfile_name, "%s/%s/%s/%s/crr_ofl_merch_product_code_map_%s.csv",getenv("REPORT_HOME"),cs_yyyy,cs_yyyymm,cs_date,cs_date);
        
        fp = fopen(cs_outfile_name,"w");
        if (fp == NULL) {
DEBUGLOG(("batch_proc:unable to open [%s]\n",cs_outfile_name));
                return FAILURE;
        }
        
        iRet = process_data(cs_date,fp);
        fclose(fp);
	return iRet;


}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}




int process_data(const char* csTxnDate, FILE *fp)
{               
        int     iRet = SUCCESS;
	char	csTmp[PD_TMP_BUF_LEN+1];

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_date[PD_DATE_LEN];

		varchar	v_merchant_id[PD_CRR_MERCH_ID_LEN+1];
		varchar	v_service_code[PD_SERVICE_CODE_LEN+1];
		varchar	v_country[PD_COUNTRY_CODE_LEN+1];
		varchar	v_product_code[PD_PRODUCT_CODE_LEN+1];

		short	ind_merchant_id = -1;
		short	ind_service_code = -1;
		short	ind_country = -1;
		short	ind_product_code = -1;
	EXEC SQL END DECLARE SECTION;

	hv_date.len = strlen((char*)cs_date);
	memcpy(hv_date.arr,cs_date,hv_date.len);

	if (!strcmp(cs_mode,"FULL")) {
		memcpy(hv_date.arr,"19900101",hv_date.len);
	};

	EXEC SQL DECLARE c_cursor_getmerchantlist CURSOR FOR
		SELECT	pm_merchant_id,
			pm_service_code,
			pm_country,
			pm_product_code
		FROM	crr_product_code_map
		WHERE	pm_disabled=0
		  AND	pm_update_timestamp >= TO_DATE(:hv_date,'YYYYMMDD')
		ORDER BY pm_merchant_id;
	EXEC SQL OPEN c_cursor_getmerchantlist;
	do {
		EXEC SQL FETCH c_cursor_getmerchantlist
		INTO	:v_merchant_id:ind_merchant_id,
			:v_service_code:ind_service_code,
			:v_country:ind_country,
			:v_product_code:ind_product_code;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

/* Field #0 merchant_id */
		if (ind_merchant_id >= 0) {
			sprintf(csTmp,"%.*s",v_merchant_id.len,v_merchant_id.arr);
			fprintf(fp,"%s%c",csTmp,PD_MY_DELIMITOR);
		}
		else
			fprintf(fp,"%c",PD_MY_DELIMITOR);

/* Field #1 service_code */
		if (ind_service_code >= 0) {
			sprintf(csTmp,"%.*s",v_service_code.len,v_service_code.arr);
			fprintf(fp,"%s%c",csTmp,PD_MY_DELIMITOR);
		}
		else
			fprintf(fp,"%c",PD_MY_DELIMITOR);

/* Field #2 country */
		if (ind_country >= 0) {
			sprintf(csTmp,"%.*s",v_country.len,v_country.arr);
			fprintf(fp,"%s%c",csTmp,PD_MY_DELIMITOR);
		}
		else
			fprintf(fp,"%c",PD_MY_DELIMITOR);

/* Field #3 record_date */
		fprintf(fp,"%s%c",cs_date,PD_MY_DELIMITOR);

/* Field #4 product_code */
		if (ind_product_code >= 0) {
			sprintf(csTmp,"%.*s",v_product_code.len,v_product_code.arr);
			fprintf(fp,"%s",csTmp);
		}

/* new line */
		fprintf(fp,"\n");

 	} while (PD_TRUE);
	EXEC SQL CLOSE c_cursor_getmerchantlist;

        return iRet;

sql_error:
DEBUGLOG(("extract_crr_ofl_merch_product_map error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getmerchantlist;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int parse_arg(int argc,char **argv)
{
        char    c;
        strcpy(cs_date,"");
	strcpy(cs_mode,"");

        while ((c = getopt(argc,argv,"d:m:")) != EOF) {
                switch (c) {
                        case 'd':
                                strcpy(cs_date, optarg);
                                break;
			case 'm':
				strcpy(cs_mode, optarg);
				break;
                        default:
                                return FAILURE;
                }
        }

        if ((!strcmp(cs_date,"")) || (!strcmp(cs_mode,"")))
                return FAILURE;

        return SUCCESS;
}

