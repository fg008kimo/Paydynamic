/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2017/07/11              Dirk Wong
PRD144 Auto Recon after Gen Inter Log              2018/11/05              David Wong
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "dbutility.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"
#include "internal.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char csTag[PD_TAG_LEN+1];
char csTmp[PD_TMP_BUF_LEN+1];
static char cDebug;

char    cs_psp_id[PD_PSP_ID_LEN+1];
char	cs_batch_id[PD_TXN_SEQ_LEN];

OBJPTR(Txn);
OBJPTR(DB);
OBJPTR(Channel);

int parse_arg(int argc,char **argv);
int check_stmt_unrecon(char* csStmtTxnId);

int batch_init(int argc, char* argv[])
{
        return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	int     iRet = parse_arg(argc,argv);

	if (iRet != SUCCESS) {
printf("Error while reading args!\n");
		return FAILURE;
	}

	int	iDtlRet = PD_OK;
	int	iIntError = FAILURE;

	hash_t	*hContext, *hRequest, *hResponse, *hTxn;

	char	csTmDateTime[PD_DATETIME_LEN + 1];
	char	csTmDate[PD_DATE_LEN + 1];
	char	csTmTime[PD_TIME_LEN + 1];
	char	csBuf[PD_TMP_BUF_LEN + 1];
	unsigned long	lBatchId;

	char	*csTxnSeq;
	char	*csCode = strdup("");
	char	*csValue = strdup("");

	hContext = (hash_t *)malloc(sizeof(hash_t));
	hRequest = (hash_t *)malloc(sizeof(hash_t));
	hResponse = (hash_t *)malloc(sizeof(hash_t));
	hTxn = (hash_t *)malloc(sizeof(hash_t));

DEBUGLOG(("Authorize::batch_id= [%s]\n",cs_batch_id));
	lBatchId = ctol((const unsigned char *)cs_batch_id,strlen(cs_batch_id));

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		unsigned long	hv_batch_id;

		varchar	v_create_user[PD_CREATE_USER_LEN+1];
		varchar	v_stmt_txn_id[PD_TXN_SEQ_LEN+1];
		varchar	v_baid[PD_BAID_LEN+1];
		varchar	v_report_date[PD_DATE_LEN+1];
		varchar	v_amt_type[PD_AMT_TYPE_LEN+1];
		varchar	v_ccy[PD_CCY_ID_LEN+1];
		double	v_txn_amt;
		varchar	v_baid_status[PD_ACCOUNT_STATUS_LEN+1];
		varchar	v_pid_status[PD_ACCOUNT_STATUS_LEN+1];
		varchar	v_pid_nature[PD_ACCT_TYPE_LEN+1];
		varchar	v_pid_product_map[PD_PRODUCT_CODE_LEN+1];

		short	ind_create_user = -1;
		short	ind_stmt_txn_id = -1;
		short	ind_baid = -1;
		short	ind_report_date = -1;
		short	ind_amt_type = -1;
		short	ind_ccy = -1;
		short	ind_txn_amt = -1;
		short	ind_baid_status = -1;
		short	ind_pid_status = -1;
		short	ind_pid_nature = -1;
		short	ind_pid_product_map = -1;
	EXEC SQL END DECLARE SECTION;

	hv_batch_id = lBatchId;
	
	EXEC SQL DECLARE c_cursor_getbatchdt CURSOR FOR
		SELECT	t1.olgd_create_user,
			t1.olgd_stmt_txn_id,
			t2.olsd_baid,
			to_char(t2.olsd_statement_timestamp, 'YYYYMMDD') report_date,
			t2.olsd_amt_type,
			t2.olsd_txn_ccy,
			t2.olsd_txn_amount,
			t3.obai_status,
			t4.opd_status,
			t4.opd_bank_acct_type,
			t5.pm_product_code
		FROM	ol_baid_inter_log_gen t1,
			ol_statement_detail t2,
			ol_bank_acct_id t3,
			ol_psp_detail t4,
			crr_psp_product_code_map t5
		WHERE	t1.olgd_stmt_txn_id = t2.olsd_stat_txn_id
		AND	t2.olsd_baid = t3.obai_baid
		AND	t3.obai_psp_id = t4.opd_psp_id
		AND	t4.opd_psp_id = t5.pm_psp_id(+)
		AND	t1.olgd_batch_id = :hv_batch_id
		AND	t1.olgd_status = 'P'
		;

	EXEC SQL OPEN c_cursor_getbatchdt;
	do {

		hash_init(hContext,0);
		hash_init(hRequest,0);
		hash_init(hResponse,0);
		hash_init(hTxn,0);

		PutField_Int(hRequest,"batch_id",lBatchId);
		PutField_Int(hTxn,"batch_id",lBatchId);

		EXEC SQL FETCH c_cursor_getbatchdt
		INTO
			:v_create_user:ind_create_user,
			:v_stmt_txn_id:ind_stmt_txn_id,
			:v_baid:ind_baid,
			:v_report_date:ind_report_date,
			:v_amt_type:ind_amt_type,
			:v_ccy:ind_ccy,
			:v_txn_amt:ind_txn_amt,
			:v_baid_status:ind_baid_status,
			:v_pid_status:ind_pid_status,
			:v_pid_nature:ind_pid_nature,
			:v_pid_product_map:ind_pid_product_map;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		if (iRet == SUCCESS) {
			v_stmt_txn_id.arr[v_stmt_txn_id.len] = '\0';

			//Check BAID Acct Status
			if (ind_baid_status >= 0) {
				v_baid_status.arr[v_baid_status.len] = '\0';
				if (strcmp((const char*)v_baid_status.arr,PD_BAID_STATUS_OPEN) != 0) {
DEBUGLOG(("SKIPPED!! BAID status is not open!!\n"));
					iDtlRet = INT_BAID_NOT_OPEN;
					iRet = FAILURE;
				}
			}

			//Check PID Acct Status
			if (ind_pid_status >= 0) {
				v_pid_status.arr[v_pid_status.len] = '\0';
				if (strcmp((const char*)v_pid_status.arr,PD_ACC_OPEN) != 0) {
DEBUGLOG(("SKIPPED!! PID status is not open!!\n"));
					iDtlRet = INT_PID_NOT_OPEN;
					iRet = FAILURE;
				}
			}

			//Check PID Product Code Mapping exists
			if (ind_pid_product_map < 0) {
				iDtlRet = INT_PID_PRODUCT_CODE_EMPTY;
				iRet = FAILURE;
DEBUGLOG(("SKIPPED!! PID product code mapping not found!!\n"));	
			}
		}

		if (iRet == SUCCESS) {
			//Check stmt is "Unrecon"
			iRet = check_stmt_unrecon((char*)v_stmt_txn_id.arr);
			if (iRet != SUCCESS) {
				if (iRet == PD_ERR) {
					iDtlRet = INT_ERR;
					iRet = FAILURE;
				} else {
DEBUGLOG(("SKIPPED!! Statement already reconciled!!\n"));
					iDtlRet = INT_STMT_RECON_ALREADY;
					iRet = FAILURE;
				}
			}

		}

		if (iRet == SUCCESS) {

DEBUGLOG(("Processing... [stmt_txn_id] = [%s]\n", (const char*)v_stmt_txn_id.arr));

			DBObjPtr = CreateObj(DBPtr, "DBSystemParameter", "FindCode");
			if ((unsigned long)(*DBObjPtr)(PD_MINI_MMM_ENABLE, csTmp) == PD_FOUND) {
				PutField_CString(hContext,"mini_mmm_mode",csTmp);
DEBUGLOG(("  Mini-MMM Mode= [%s]\n",csTmp));
			}


			//Prepare for OOP
			PutField_Int(hContext, "db_commit", PD_FALSE);

			strcpy(csTmDateTime, getdatetime());
			sprintf(csTmDate, "%.*s", PD_DATE_LEN, csTmDateTime);
			PutField_CString(hContext, "PHDATE", csTmDate);
			PutField_CString(hContext, "local_tm_date", csTmDate);
			sprintf(csTmTime, "%.*s", PD_TIME_LEN, &csTmDateTime[PD_DATE_LEN]);
			PutField_CString(hContext, "local_tm_time", csTmTime);

			//API: baid
			v_baid.arr[v_baid.len] = '\0';
			PutField_CString(hRequest,"baid",(const char*)v_baid.arr);
DEBUGLOG(("  >> baid = [%s]\n",v_baid.arr));

			//API: ccy
			v_ccy.arr[v_ccy.len] = '\0';
			PutField_CString(hRequest,"txn_ccy",(const char*)v_ccy.arr);
			PutField_CString(hRequest,"dst_txn_ccy",(const char*)v_ccy.arr);
			PutField_CString(hContext,"dst_txn_ccy",(const char*)v_ccy.arr);
DEBUGLOG(("  >> ccy = [%s]\n",v_ccy.arr));

			//API: remark
			PutField_CString(hRequest,"remark","Log Gen");
DEBUGLOG(("  >> remark = [Log Gen]\n"));

			//API: report_date
			v_report_date.arr[v_report_date.len] = '\0';
			PutField_CString(hRequest,"report_date",(const char*)v_report_date.arr);
DEBUGLOG(("  >> report_date = [%s]\n",v_report_date.arr));

			//API: gen_unique_amt
			PutField_CString(hRequest,"gen_unique_amt","0");
DEBUGLOG(("  >> gen_unique_amt = [0]\n"));

			//API: txn_amt
			PutField_Double(hContext,"txn_amt",v_txn_amt);
DEBUGLOG(("  >> txn_amt = [%f]\n",v_txn_amt));


			//Gen new txn_seq
DEBUGLOG(("  Call OLTxnSeq:GetNextOmtTxnSeq\n"));
			DBObjPtr = CreateObj(DBPtr,"DBOLTxnSeq","GetNextOmtTxnSeq");
			csTxnSeq  = strdup((*DBObjPtr)());
DEBUGLOG(("  >> GenerateBatchSeq: [%s]\n",csTxnSeq));
			PutField_CString(hContext,"txn_seq",csTxnSeq);
			PutField_CString(hTxn,"gen_txn_id",csTxnSeq);
			FREE_ME(csTxnSeq);
 
			PutField_CString(hContext,"process_type",PD_PROCESS_TYPE_DEF);
			PutField_CString(hContext,"process_code",PD_PROCESS_CODE_DEF);
			PutField_CString(hContext,"txn_code",PD_OL_PSP_BAID_BAL_TRF_INTER);
			PutField_CString(hContext,"channel_code",PD_CHANNEL_OMT);
			PutField_Int(hContext,"do_logging",PD_TRUE);

			//create_user
			v_create_user.arr[v_create_user.len] = '\0';
			PutField_CString(hRequest, "add_user", (const char*)v_create_user.arr);
			PutField_CString(hRequest, "create_user", (const char*)v_create_user.arr);
			PutField_CString(hRequest, "update_user", (const char*)v_create_user.arr);
			PutField_CString(hContext, "add_user", (const char*)v_create_user.arr);
			PutField_CString(hContext, "create_user", (const char*)v_create_user.arr);
			PutField_CString(hContext, "update_user", (const char*)v_create_user.arr);

DEBUGLOG(("  >> Call OMTChannel:AddTxnLog\n"));
			ChannelObjPtr = CreateObj(ChannelPtr,"OMTChannel","AddTxnLog");
			iDtlRet = (unsigned long)(*ChannelObjPtr)(hContext,hRequest);
			if (iDtlRet != PD_OK) {
DEBUGLOG(("  >>   OMTChannel:AddTxnLog Failed\n"));
				iRet = FAILURE;
			}

			if(iRet==SUCCESS){
				PutField_Int(hContext,"internal_code",PD_OK);
				PutField_CString(hContext,"response_code","0");
				PutField_Char(hContext,"ar_ind",PD_ACCEPT);
				PutField_Char(hContext,"status",PD_COMPLETE);
DEBUGLOG(("  >> Call OMTChannel:UpdateTxnLog\n"));
				ChannelObjPtr = CreateObj(ChannelPtr,"OMTChannel","UpdateTxnLog");
				iDtlRet = (unsigned long)(*ChannelObjPtr)(hContext,hRequest,hResponse);
				if (iDtlRet != PD_OK) {
DEBUGLOG(("  >>   OMTChannel:AddTxnDetailLog Failed\n"));
					iRet = FAILURE;
				}
				PutField_Int(hContext,"do_logging",PD_FALSE);

				if(iRet == SUCCESS){
DEBUGLOG(("  >> Call OMTChannel:UpdateTxnDetailLog\n"));
					ChannelObjPtr = CreateObj(ChannelPtr,"OMTChannel","UpdateTxnDetailLog");
					iDtlRet = (unsigned long)(*ChannelObjPtr)(hContext,hRequest,hResponse);
					if (iDtlRet != PD_OK) {
						iRet = FAILURE;
DEBUGLOG(("  >>   OMTChannel:AddTxnDetailLog Failed\n"));
					}
				}
			}


			if (iRet == SUCCESS) {
DEBUGLOG(("  Call TxnOmtByUsCOM:Authorize\n"));
				TxnObjPtr = CreateObj(TxnPtr,"TxnOmtByUsCOM","Authorize");
				iDtlRet = (unsigned long)(*TxnObjPtr)(hContext,hRequest,hResponse);

				if (iDtlRet == PD_OK) {
					if (GetField_Int(hContext, "internal_error", &iIntError)) {
DEBUGLOG(("  >> TxnMgtByUsCOM:Authorize Return internal_error [%d]\n", iIntError));
						iDtlRet = iIntError;
						iRet = FAILURE;
					}
				} else {
					iRet = FAILURE;
				}
			}


			if (iRet == SUCCESS) {
DEBUGLOG(("  Call TxnOmtByUsOOP:Authorize\n"));
				TxnObjPtr = CreateObj(TxnPtr,"TxnOmtByUsOOP","Authorize");
				iDtlRet = (unsigned long)(*TxnObjPtr)(hContext,hRequest,hResponse);

				if (iDtlRet == PD_OK) {
					if (GetField_Int(hContext, "internal_error", &iIntError)) {
DEBUGLOG(("  >> TxnMgtByUsOOP:Authorize Return internal_error [%d]\n", iIntError));
						iDtlRet = iIntError;
						iRet = FAILURE;
					}
				} else {
					iRet = FAILURE;
				}
			}
		}


		//Update ol_baid_inter_log_gen_dt
DEBUGLOG(("  Call DBOLBaidInterLogGen:UpdateByStmtTxnId\n"));
		PutField_CString(hTxn,"stmt_txn_id",(const char*)v_stmt_txn_id.arr);
		sprintf(csBuf,"%ld",lBatchId);
		PutField_CString(hTxn,"batch_id",csBuf);
		PutField_Int(hTxn,"ret_code",iDtlRet);
		PutField_CString(hTxn,"update_user",(const char*)v_create_user.arr);
				
		if (iRet == SUCCESS) {
			PutField_Char(hTxn,"status",PD_ACCEPT);
			//TxnCommit();
		} else {
			PutField_Char(hTxn,"status",PD_REJECT);
			TxnAbort();
		}

		DBObjPtr = CreateObj(DBPtr,"DBOLBaidInterLogGen","UpdateByStmtTxnId");
		iDtlRet = (unsigned long)((*DBObjPtr)(hTxn));
DEBUGLOG(("    iDtlRet = [%d]\n",iDtlRet));

		if (iDtlRet == PD_OK) {
			TxnCommit();
		} else {
			TxnAbort();
		}

		if (iRet == SUCCESS && iDtlRet == PD_OK) {
DEBUGLOG(("start manual recon\n"));
			int iTmpRet = 0;
			char *csTmpField = NULL;

			hash_t *hTmp;
			hTmp = (hash_t*) malloc (sizeof(hash_t));
			hash_init(hTmp, 0);

			GetField_CString(hContext, "create_user", &csTmpField);
			PutField_CString(hTmp, "add_user", csTmpField);
			PutField_CString(hTmp, "activity", PD_TXN_ENGING_ACTIVITIY_RECON);
			PutField_CString(hTmp, "bank_stmt_type", "BALANCE_TRANSFER_INTER");
			PutField_CString(hTmp, "trigger_type", PD_TRIGGER_MANUAL);
			PutField_CString(hTmp, "input_channel", PD_CHANNEL_OMT);
			PutField_CString(hTmp, "recon_type", PD_ENGINE_RECON_SAME);
			PutField_CString(hTmp, "use_pf", "0");
			PutField_CString(hTmp, "have_charge", "0");
			PutField_CString(hTmp, "have_interest", "0");

			PutField_CString(hTmp, "txn_cnt", "1");
			GetField_CString(hContext, "txn_seq", &csTmpField);
			PutField_CString(hTmp, "txnid_1", csTmpField);
DEBUGLOG(("txnid_1 = [%s]\n", csTmpField));

			PutField_CString(hTmp, "stmt_cnt", "1");
			DBObjPtr = CreateObj(DBPtr, "DBOLBAIDTxn", "GetBaidTxnIdByStatTxnId");
			iTmpRet = (unsigned long)(*DBObjPtr)((char*)v_stmt_txn_id.arr, csTmpField);
			PutField_CString(hTmp, "stmt_txnid_1", csTmpField);
DEBUGLOG(("stmt_txnid_1 = [%s]\n", csTmpField));

			TxnObjPtr = CreateObj(TxnPtr, "TxnOmtByUsREC", "Authorize");
			iTmpRet = (unsigned long)(*TxnObjPtr)(hTmp, hTmp, hTmp);

			if (iTmpRet == PD_OK) {
				TxnCommit();
			} else {
				TxnAbort();
			}

			hash_destroy(hTmp);
			FREE_ME(hTmp);
		}

		iRet = SUCCESS;

DEBUGLOG(("  DONE stmt_txn_id [%s]\n", (const char*)v_stmt_txn_id.arr));

		hash_destroy(hContext);
		hash_destroy(hRequest);
		hash_destroy(hResponse);
		hash_destroy(hTxn);

	}
	while(PD_TRUE);
	EXEC SQL CLOSE c_cursor_getbatchdt;

	FREE_ME(hContext);
	FREE_ME(hRequest);
	FREE_ME(hResponse);
	FREE_ME(hTxn);

	FREE_ME(csCode);
	FREE_ME(csValue);

	return iRet;

sql_error:
DEBUGLOG(("error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getbatchdt;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;
}


int batch_terminate(int argc, char* argv[])
{
        return SUCCESS;
}


int parse_arg(int argc,char **argv)
{

        char    c;

	strcpy(cs_batch_id,"");

        if (argc < 3) {
                return FAILURE;
        }
        while ((c = getopt(argc,argv,"p:")) != EOF) {
                switch (c) {
                        case 'p':
                                strcpy(cs_batch_id, optarg);
                                break;
                        default:
                                return FAILURE;
                }
        }

	if (!strcmp(cs_batch_id,""))
		return FAILURE;

	cs_batch_id[strlen(cs_batch_id)]='\0';

        return SUCCESS;
}


int check_stmt_unrecon(char* csStmtTxnId)
{
	int iRet = SUCCESS;

DEBUGLOG(("check_stmt_unrecon() start\n"));

	EXEC SQL WHENEVER SQLERROR GOTO chk_err;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	hv_stmt_txn_id[PD_TXN_SEQ_LEN];
		char	v_recon_status;
		short	ind_recon_status = -1;
	EXEC SQL END DECLARE SECTION;

	hv_stmt_txn_id.len = strlen((const char*)csStmtTxnId);
	memcpy(hv_stmt_txn_id.arr,(const char*)csStmtTxnId,hv_stmt_txn_id.len);
DEBUGLOG(("  hv_stmt_txn_id = [%.*s]\n",hv_stmt_txn_id.len,hv_stmt_txn_id.arr));

	EXEC SQL SELECT	obt_recon_status
		 INTO	:v_recon_status:ind_recon_status
		 FROM	ol_baid_txn
		 WHERE	obt_stat_txn_id = :hv_stmt_txn_id
		 AND	obt_status='C';

	if (ind_recon_status >= 0) {
DEBUGLOG(("  > v_recon_status = [%c]\n",v_recon_status));
		if (v_recon_status != PD_UNRECONCILED) {
			iRet = FAILURE;
		}
	}

	return iRet;
chk_err:
DEBUGLOG(("chk_err code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("ol_bal_trf_in_inter_log_gen:check_stmt_unrecon ERROR\n");
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        return PD_ERR;
}
