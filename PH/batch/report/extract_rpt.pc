/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/07/25              Cody Chan
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/stat.h>
#include <oraca.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include <dlfcn.h>
#include "common.h"
#include "utilitys.h"
#include "extract_rptcommon.h"
#include "batchcommon.h"


char	cDebug;
#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define	FCLIBNAME 	"libBatchExtractRptFC.so"

int batch_init(int argc, char* argv[])
{
	if (argc < 1) {
        	printf("usage:  -d txn_date\n");
        	return FAILURE;
    	}
	else 
		return SUCCESS;
}	


char	csRptDate[PD_DATE_LEN * 2 +1];

int parse_arg(int argc,char **argv);
int batch_proc(int argc, char* argv[])
{
	void 	*handler;
	void	*(*function) ();
	char	*error;
	int	iRet = SUCCESS;
	char	cStatus;
	char	csCurrPath[PD_MAX_FILE_LEN +1];
	char	csMonthEndDate[PD_DATE_LEN +1];
	char	csTmpBuf[PD_TMP_BUF_LEN +1];



	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
    	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_ph_date[PD_DATE_LEN];
		char		hv_status;
		varchar		hv_update_user[PD_DATE_LEN];

		varchar		v_id[PD_RPT_ID_LEN +1];
		varchar		v_report_name[PD_RPT_NAME_LEN +1];
		varchar		v_desc[PD_RPT_DESC_LEN +1];
		char		v_rerunable;
		char		v_type;
		char		v_hold;

		short		v_return_value;
		short		ind_id = -1;
		short		ind_report_name = -1;
		short		ind_desc = -1;
		short		ind_rerunable = -1;
		short		ind_type = -1;
		short		ind_hold = -1;


    	EXEC SQL END DECLARE SECTION;


	iRet = parse_arg(argc,argv);

	if (iRet != SUCCESS){
                printf("usage: -d Date\n");
                return (iRet);
        }

	handler = dlopen (FCLIBNAME,RTLD_LOCAL| RTLD_LAZY);	
	
	 if (!handler) {
                fprintf (stderr, "%s\n", dlerror());
                error = dlerror();
		printf("Error Loading Object %s:%s\n",FCLIBNAME,error);
		return (FAILURE);
        }

	CreateReportPathCustomized((unsigned char*)csCurrPath,csRptDate);

	hv_ph_date.len = strlen(csRptDate);
	memcpy(hv_ph_date.arr,csRptDate,hv_ph_date.len);
DEBUGLOG(("batch_proc:hv_ph_date = [%.*s]\n",hv_ph_date.len,hv_ph_date.arr));

	monthenddate(csRptDate,csMonthEndDate);

	EXEC SQL DECLARE c_cursor_eod_reports CURSOR FOR
		SELECT er_id,
         		er_report_name,
         		er_desc,
         		er_rerunable,
         		er_type,
         		er_hold 
  		 FROM eod_reports
 		ORDER by er_order_num;

	EXEC SQL OPEN c_cursor_eod_reports;
        do {
		EXEC SQL FETCH c_cursor_eod_reports
		INTO 
			:v_id:ind_id,
			:v_report_name:ind_report_name,
			:v_desc:ind_desc,
			:v_rerunable:ind_rerunable,
			:v_type:ind_type,
			:v_hold:ind_hold;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		if (ind_id >= 0) {
			v_id.arr[v_id.len] = '\0';
		}
		else 
			v_id.arr[0] = '\0';
DEBUGLOG(("id = [%s]\n",v_id.arr));

		if (ind_report_name >= 0) {
			v_report_name.arr[v_report_name.len] = '\0';
		}
		else 
			v_report_name.arr[0] = '\0';
DEBUGLOG(("report_name = [%s]\n",v_report_name.arr));

		if (ind_desc >= 0) {
			v_desc.arr[v_desc.len] = '\0';
		}
		else 
			v_desc.arr[0] = '\0';
DEBUGLOG(("desc = [%s]\n",v_desc.arr));

		if (ind_rerunable < 0) 
			v_rerunable = PD_NO;
DEBUGLOG(("rerunable = [%c]\n",v_rerunable));

		if (ind_type < 0) 
			v_type = PD_NO;
DEBUGLOG(("type = [%c]\n",v_type));

		if (ind_hold < 0) 
			v_hold = PD_NO;
DEBUGLOG(("hold = [%c]\n",v_hold));

		
		printf("Try to run report with id %s,",v_id.arr);
		cStatus = ' ';
		cStatus = CurrentReportStatus((const char*)v_id.arr);
DEBUGLOG(("status = [%c]\n",cStatus));
/* processing status */
		if (cStatus == PD_EOD_PROCESSING) {
			printf("in processing\n");
			continue;
		}

/* already run status */
		if (cStatus == PD_EOD_COMPLETED) {
			if (v_rerunable != PD_YES) {	
				printf("had already run\n");
				continue;
			}
		}

		if (cStatus == PD_EOD_NEW_CYCLE) {
			printf("New Cycle\n");
		}

		if (v_hold !=  PD_EOD_HOLD) {
			if (v_type == PD_DAILY) {
			}
			else if (v_type == PD_WEEKLY) {
				if (day_of_week((const unsigned char*)csRptDate) != 0) {
DEBUGLOG(("v_type = [%c] today is not weekend, skip....\n",v_type));
					printf("none weekend, skip...\n");
					continue;
				}
			}
			else if (v_type == PD_MONTHLY) {
				if (strcmp(csRptDate,csMonthEndDate)) {
DEBUGLOG(("v_type = [%c] today is not monthend, skip....\n",v_type));
					printf("none monthend, skip...\n");
					continue;
				}
			}
			else {
DEBUGLOG(("v_type = [%c] is not supported\n",v_type));
				printf("[%c] is not supported\n",v_type);
				continue;
			}

/* run job */
			hv_update_user.len = v_id.len;
			memcpy(hv_update_user.arr,v_id.arr,hv_update_user.len);
DEBUGLOG(("hv_update_user = [%.*s]\n",hv_update_user.len,hv_update_user.arr));
/* processing */
			hv_status = PD_EOD_PROCESSING;
DEBUGLOG(("status = [%c]\n",hv_status));
			EXEC SQL EXECUTE
                	BEGIN
                		:v_return_value := sp_eod_reports_status_run(:v_id,
                                         :hv_status,
                                         :hv_ph_date,
                                         :hv_update_user);

                	END;
        		END-EXEC;

/* end of report */
			function = dlsym(handler,(const char*)v_id.arr);		
			if ((error = dlerror()) != NULL)  {
				printf("Error Loading Constructor for %s self function[%s]\n",v_id.arr,error);
                       		fprintf (stderr, "%s\n", error);
                        	return FAILURE;
                	}
			else {
				iRet = (unsigned long)function(csCurrPath,csRptDate);
			}

			if (iRet == SUCCESS) {
				hv_status = PD_EOD_COMPLETED;
				strcpy(csTmpBuf,"Success...");
			}
			else {
				hv_status = PD_EOD_FAILURE;
				strcpy(csTmpBuf,"Failure...");
			}
DEBUGLOG(("status = [%c]\n",hv_status));
			printf("%s",csTmpBuf);
			EXEC SQL EXECUTE
                	BEGIN
                		:v_return_value := sp_eod_reports_status_run(:v_id,
                                         :hv_status,
                                         :hv_ph_date,
                                         :hv_update_user);

                	END;
        		END-EXEC;
		}
		else {
DEBUGLOG(("[%s] is in hold status\n",v_id.arr));
			printf("[%s] is in hold status\n",v_id.arr);

		}
		printf("\n");
	} while (PD_TRUE);
	
	EXEC SQL CLOSE c_cursor_eod_reports;

DEBUGLOG(("iRet = [%d]\n",iRet));
	return iRet;
sql_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_eod_reports;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}


int batch_terminate(int argc, char* argv[])
{
    return SUCCESS;
}


int parse_arg(int argc,char **argv)
{
        char    c;
        strcpy(csRptDate,"");

        while ((c = getopt(argc,argv,"d:")) != EOF) {
                switch (c) {
                        case 'd':
                                strcpy(csRptDate, optarg);
                                break;
                        default:
                                return FAILURE;
                }
        }

        return SUCCESS;
}

