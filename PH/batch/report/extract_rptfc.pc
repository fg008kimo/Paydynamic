/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/07/25              Cody Chan
                                                   2012/07/26              Gilbert Lum
Separate Ledger into  CB, SB, RB		   2012/12/28		   Stan Poon
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/stat.h>
#include <oraca.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "batchcommon.h"
#include "extract_rptfiles.h"
#include "extract_rptfc.h"


char	cDebug = 'Y';
#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


int RPT002(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_host_posting_date[PD_DATE_LEN];

		varchar	v_client_id[PD_CLIENT_ID_LEN +1];
		varchar	v_merchant_id[PD_MERCHANT_ID_LEN +1];
		varchar	v_psp_id[PD_PSP_ID_LEN +1];

		short	ind_client_id = -1;
		short	ind_merchant_id = -1;
		short	ind_psp_id = -1;

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	EXEC SQL DECLARE c_cursor_clients CURSOR FOR
		SELECT client_id
		  FROM clients
		 WHERE /*type = 'M'
		   AND*/ status = 'O';

	EXEC SQL DECLARE c_cursor_merchants CURSOR FOR
		SELECT a.client_id,
			b.merchant_id
		  FROM clients a,
		       merch_detail b
		 WHERE /*a.TYPE = 'M'AND*/  a.status = 'O'
		   and a.client_id = b.client_id
		   and b.status = 'O'
		   and b.disabled = 0;

	EXEC SQL DECLARE c_cursor_psp CURSOR FOR
		SELECT psp_id 
		  FROM psp_detail
		 WHERE disabled = 0
		   AND status = 'O';

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT002);
	ind_client_id = -1;
	ind_merchant_id = -1;
	ind_psp_id = -1;
	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt002(:hv_host_posting_date,:v_client_id:ind_client_id,:v_merchant_id:ind_merchant_id,:v_psp_id:ind_psp_id,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT002(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;
	if (iRet != SUCCESS) 
		return iRet;

	EXEC SQL OPEN c_cursor_clients;
	do {
		EXEC SQL FETCH c_cursor_clients
		INTO
			:v_client_id:ind_client_id;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		v_client_id.arr[v_client_id.len] = '\0';
DEBUGLOG(("client_id = [%s]\n",v_client_id.arr));

		sprintf(cs_outputfile,"%s/%s_%s.xls",csPath,PD_EOD_RPT002,v_client_id.arr);
		EXEC SQL EXECUTE
			BEGIN
				REPORT_PKG.open_cur_rpt002(:hv_host_posting_date,:v_client_id:ind_client_id,:v_merchant_id:ind_merchant_id,:v_psp_id:ind_psp_id,:c_cursor_rpt);
			END;
		END-EXEC;

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
			return FAILURE;
		}
		iRet = Extract_RPT002(fout,c_cursor_rpt);
		fclose(fout);
/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt;
		if (iRet != SUCCESS)
			break;
	} while (PD_TRUE);	



	EXEC SQL OPEN c_cursor_merchants;
	do {
		EXEC SQL FETCH c_cursor_merchants
		INTO
			:v_client_id:ind_client_id,
			:v_merchant_id:ind_merchant_id;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		v_client_id.arr[v_client_id.len] = '\0';
DEBUGLOG(("client_id = [%s]\n",v_client_id.arr));

		v_merchant_id.arr[v_merchant_id.len] = '\0';
DEBUGLOG(("merchant_id = [%s]\n",v_merchant_id.arr));

		sprintf(cs_outputfile,"%s/%s_%s_%s.xls",csPath,PD_EOD_RPT002,v_client_id.arr,v_merchant_id.arr);
		EXEC SQL EXECUTE
			BEGIN
				REPORT_PKG.open_cur_rpt002(:hv_host_posting_date,:v_client_id:ind_client_id,:v_merchant_id:ind_merchant_id,:v_psp_id:ind_psp_id,:c_cursor_rpt);
			END;
		END-EXEC;

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
			return FAILURE;
		}
		iRet = Extract_RPT002(fout,c_cursor_rpt);
		fclose(fout);
/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt;
		if (iRet != SUCCESS)
			break;
	} while (PD_TRUE);

	ind_client_id = -1;
	ind_merchant_id = -1;
	EXEC SQL OPEN c_cursor_psp;
	do {
		EXEC SQL FETCH c_cursor_psp
		INTO
			:v_psp_id:ind_psp_id;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		v_psp_id.arr[v_psp_id.len] = '\0';
DEBUGLOG(("psp_id = [%s]\n",v_psp_id.arr));

		sprintf(cs_outputfile,"%s/%s_%s.xls",csPath,PD_EOD_RPT002,v_psp_id.arr);
		EXEC SQL EXECUTE
			BEGIN
				REPORT_PKG.open_cur_rpt002(:hv_host_posting_date,:v_client_id:ind_client_id,:v_merchant_id:ind_merchant_id,:v_psp_id:ind_psp_id,:c_cursor_rpt);
			END;
		END-EXEC;

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
			return FAILURE;
		}
		iRet = Extract_RPT002(fout,c_cursor_rpt);
		fclose(fout);
/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt;
		if (iRet != SUCCESS)
			break;
	} while (PD_TRUE);	

	EXEC SQL CLOSE c_cursor_clients;
	EXEC SQL CLOSE c_cursor_merchants;
	EXEC SQL CLOSE c_cursor_psp;
	return iRet;
sql_error:
DEBUGLOG(("get_rpt002_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_clients;
	EXEC SQL CLOSE c_cursor_merchants;
	EXEC SQL CLOSE c_cursor_psp;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}

int RPT003(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_host_posting_date[PD_DATE_LEN];

		char		hv_report_type;
		short	ind_report_type = -1;

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));


	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT003);

	hv_report_type = PD_DAILY;
	ind_report_type = 0;

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt003(:hv_host_posting_date,:hv_report_type:ind_report_type,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT003(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;
	return iRet;

sql_error:
DEBUGLOG(("get_rpt003_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}

int RPT004(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_host_posting_date[PD_DATE_LEN];

		char		v_merchant_type;
		varchar		v_merchant_desc[PD_DESC_LEN + 1];

		short	ind_merchant_type = -1;
		short	ind_merchant_desc = -1;

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	EXEC SQL DECLARE c_cursor_merch_type CURSOR FOR
		SELECT bt_type, bt_desc
		  FROM def_business_type;

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT004);

	ind_merchant_type = -1;

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt004(:hv_host_posting_date,:v_merchant_type:ind_merchant_type,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT004(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;
	if (iRet != SUCCESS) 
		return iRet;

	EXEC SQL OPEN c_cursor_merch_type;
	do {
		EXEC SQL FETCH c_cursor_merch_type
		INTO
			:v_merchant_type:ind_merchant_type,
			:v_merchant_desc:ind_merchant_desc;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		v_merchant_desc.arr[v_merchant_desc.len] = '\0';
DEBUGLOG(("merchant_desc = [%s]\n",v_merchant_desc));

		sprintf(cs_outputfile,"%s/%s_%s.xls",csPath,PD_EOD_RPT004,v_merchant_desc.arr);
		EXEC SQL EXECUTE
			BEGIN
				REPORT_PKG.open_cur_rpt004(:hv_host_posting_date,:v_merchant_type:ind_merchant_type,:c_cursor_rpt);
			END;
		END-EXEC;

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
			return FAILURE;
		}
		iRet = Extract_RPT004(fout,c_cursor_rpt);
		fclose(fout);
/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt;
		if (iRet != SUCCESS)
			break;
	} while (PD_TRUE);	


	EXEC SQL CLOSE c_cursor_merch_type;
	return iRet;
sql_error:
DEBUGLOG(("get_rpt004_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_merch_type;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}

int RPT005(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT005);

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt005(:hv_host_posting_date,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT005(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

       	return iRet;

sql_error:
DEBUGLOG(("get_rpt005_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}


int RPT006(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT006);

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt006(:hv_host_posting_date,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT006(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt006_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
} 


int RPT007(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT007);

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt007(:hv_host_posting_date,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT007(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt007_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
} 


int RPT008(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT008);

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt008(:hv_host_posting_date,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT008(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt008_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
} 


int RPT009(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar       hv_approval_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_approval_date.len = strlen(csDate);
	memcpy(hv_approval_date.arr,csDate,hv_approval_date.len);
DEBUGLOG(("hv_approval_date = [%.*s]\n",hv_approval_date.len,hv_approval_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT009);

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt009(:hv_approval_date,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT009(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt009_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
} 


int RPT010(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar       hv_host_posting_date[PD_DATE_LEN];
		char	v_adj_dc_ind;

		short	ind_adj_dc_ind = -1;

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s_%s.xls",csPath,PD_EOD_RPT010,PD_ADJ_TYPE_DEBIT_DESC);
	v_adj_dc_ind = PD_ADJ_TYPE_DEBIT;
	ind_adj_dc_ind = 0;

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt010(:hv_host_posting_date,:v_adj_dc_ind:ind_adj_dc_ind,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT010(fout,c_cursor_rpt);
	fclose(fout);

	sprintf(cs_outputfile,"%s/%s_%s.xls",csPath,PD_EOD_RPT010,PD_ADJ_TYPE_CREDIT_DESC);
	v_adj_dc_ind = PD_ADJ_TYPE_CREDIT;
	ind_adj_dc_ind = 0;

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt010(:hv_host_posting_date,:v_adj_dc_ind:ind_adj_dc_ind,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT010(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt010_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
} 


int RPT011(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT011);

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt011(:hv_host_posting_date,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT011(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt011_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
} 


int RPT012(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT012);

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt012(:hv_host_posting_date,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	/* file format is same as RPT011 */
	iRet = Extract_RPT011(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt012_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
} 


int RPT013(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT013);

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt013(:hv_host_posting_date,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT013(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

	return iRet;

sql_error:
DEBUGLOG(("get_rpt013_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}


int RPT014(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT014);

	EXEC SQL EXECUTE
       	BEGIN
		REPORT_PKG.open_cur_rpt014(:hv_host_posting_date,:c_cursor_rpt);
			END;
	END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	/* file format is same as RPT011 */
	iRet = Extract_RPT013(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

	return iRet;

sql_error:
DEBUGLOG(("get_rpt014_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}

int RPT015(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_host_posting_date[PD_DATE_LEN];

		varchar	v_merchant_id[PD_MERCHANT_ID_LEN +1];
		varchar	v_service_code[PD_SERVICE_CODE_LEN +1];
		varchar	v_country[PD_COUNTRY_LEN +1];
		varchar	v_ccy[PD_CCY_ID_LEN +1];
	
		short	ind_merchant_id = -1;
		short	ind_service_code = -1;
		short	ind_country = -1;
		short	ind_ccy = -1;

		SQL_CURSOR    c_cursor_rpt015;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt015;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	EXEC SQL DECLARE c_cursor_getmerchant_cbal CURSOR FOR
		 SELECT merchant_id,
			mb_service_code,
			mb_country,
			mb_ccy_id
		  FROM merchant_bal_acct ,
		       (SELECT merchant_id,
			       name
			  FROM merch_detail a,
			       clients b
			 WHERE a.status = 'O'
			   AND a.disabled  = 0
			   AND a.client_id = b.client_id
			   AND A.DISABLED = 0
			   /*AND B.TYPE = 'M'*/)
		 WHERE mb_status = 'O'
		   AND mb_disabled = 0
		   AND merchant_id = mb_merchant_id;

	EXEC SQL OPEN c_cursor_getmerchant_cbal;
	do {
		EXEC SQL FETCH c_cursor_getmerchant_cbal
		INTO
			:v_merchant_id:ind_merchant_id,
			:v_service_code:ind_service_code,
			:v_country:ind_country,
			:v_ccy:ind_ccy;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		v_merchant_id.arr[v_merchant_id.len] = '\0';
		v_service_code.arr[v_service_code.len] = '\0';
		v_country.arr[v_country.len] = '\0';
		v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("batch_proc_15: merchant_id = [%s]\n",v_merchant_id.arr));
DEBUGLOG(("batch_proc_15: service_code = [%s]\n",v_service_code.arr));
DEBUGLOG(("batch_proc_15: country = [%s]\n",v_country.arr));
DEBUGLOG(("batch_proc_15: ccy = [%s]\n",v_ccy.arr));
		EXEC SQL EXECUTE
			BEGIN
				LEDGER_PKG.open_cur_cb_ledger(:hv_host_posting_date,:v_merchant_id,:v_country,:v_service_code,:v_ccy,:c_cursor_rpt015);
			END;
		END-EXEC;

		sprintf(cs_outputfile,"%s/%s_%s_%s_%s.xls",csPath,PD_EOD_RPT015,v_merchant_id.arr,v_service_code.arr, v_ccy.arr);

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
			return FAILURE;
		}
		iRet = Extract_RPT015(fout,c_cursor_rpt015);
		fclose(fout);
		if (iRet != SUCCESS)
			break;

/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt015;
	} while (PD_TRUE);	
	EXEC SQL CLOSE c_cursor_getmerchant_cbal;

	return iRet;
sql_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getmerchant_cbal;
	EXEC SQL CLOSE :c_cursor_rpt015;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}

int RPT016(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_host_posting_date[PD_DATE_LEN];

		varchar	v_merchant_id[PD_MERCHANT_ID_LEN +1];
		varchar	v_service_code[PD_SERVICE_CODE_LEN +1];
		varchar	v_country[PD_COUNTRY_LEN +1];
		varchar	v_ccy[PD_CCY_ID_LEN +1];
	
		short	ind_merchant_id = -1;
		short	ind_service_code = -1;
		short	ind_country = -1;
		short	ind_ccy = -1;

		SQL_CURSOR    c_cursor_rpt016;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt016;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	EXEC SQL DECLARE c_cursor_getmerchant_sbal CURSOR FOR
		 SELECT merchant_id,
			mb_service_code,
			mb_country,
			mb_ccy_id
		  FROM merchant_bal_acct ,
		       (SELECT merchant_id,
			       name
			  FROM merch_detail a,
			       clients b
			 WHERE a.status = 'O'
			   AND a.disabled  = 0
			   AND a.client_id = b.client_id
			   AND A.DISABLED = 0
			   /*AND B.TYPE = 'M'*/)
		 WHERE mb_status = 'O'
		   AND mb_disabled = 0
		   AND merchant_id = mb_merchant_id;

	EXEC SQL OPEN c_cursor_getmerchant_sbal;
	do {
		EXEC SQL FETCH c_cursor_getmerchant_sbal
		INTO
			:v_merchant_id:ind_merchant_id,
			:v_service_code:ind_service_code,
			:v_country:ind_country,
			:v_ccy:ind_ccy;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		v_merchant_id.arr[v_merchant_id.len] = '\0';
		v_service_code.arr[v_service_code.len] = '\0';
		v_country.arr[v_country.len] = '\0';
		v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("batch_proc_16: merchant_id = [%s]\n",v_merchant_id.arr));
DEBUGLOG(("batch_proc_16: service_code = [%s]\n",v_service_code.arr));
DEBUGLOG(("batch_proc_16: country = [%s]\n",v_country.arr));
DEBUGLOG(("batch_proc_16: ccy = [%s]\n",v_ccy.arr));
		EXEC SQL EXECUTE
			BEGIN
				LEDGER_PKG.open_cur_sb_ledger(:hv_host_posting_date,:v_merchant_id,:v_country,:v_service_code,:v_ccy,:c_cursor_rpt016);
			END;
		END-EXEC;

		sprintf(cs_outputfile,"%s/%s_%s_%s_%s.xls",csPath,PD_EOD_RPT016,v_merchant_id.arr,v_service_code.arr, v_ccy.arr);

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
			return FAILURE;
		}
		iRet = Extract_RPT016(fout,c_cursor_rpt016);
		fclose(fout);
		if (iRet != SUCCESS)
			break;

/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt016;
	} while (PD_TRUE);	
	EXEC SQL CLOSE c_cursor_getmerchant_sbal;

	return iRet;
sql_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getmerchant_sbal;
	EXEC SQL CLOSE :c_cursor_rpt016;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}

int RPT017(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar	hv_host_posting_date[PD_DATE_LEN];

		varchar	v_merchant_id[PD_MERCHANT_ID_LEN +1];
		varchar	v_service_code[PD_SERVICE_CODE_LEN +1];
		varchar	v_country[PD_COUNTRY_LEN +1];
		varchar	v_ccy[PD_CCY_ID_LEN +1];
	
		short	ind_merchant_id = -1;
		short	ind_service_code = -1;
		short	ind_country = -1;
		short	ind_ccy = -1;

		SQL_CURSOR    c_cursor_rpt017;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt017;

	hv_host_posting_date.len = strlen(csDate);
	memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	EXEC SQL DECLARE c_cursor_getmerchant_rbal CURSOR FOR
		 SELECT merchant_id,
			mb_service_code,
			mb_country,
			mb_ccy_id
		  FROM merchant_bal_acct ,
		       (SELECT merchant_id,
			       name
			  FROM merch_detail a,
			       clients b
			 WHERE a.status = 'O'
			   AND a.disabled  = 0
			   AND a.client_id = b.client_id
			   AND A.DISABLED = 0
			   /*AND B.TYPE = 'M'*/)
		 WHERE mb_status = 'O'
		   AND mb_disabled = 0
		   AND merchant_id = mb_merchant_id;

	EXEC SQL OPEN c_cursor_getmerchant_rbal;
	do {
		EXEC SQL FETCH c_cursor_getmerchant_rbal
		INTO
			:v_merchant_id:ind_merchant_id,
			:v_service_code:ind_service_code,
			:v_country:ind_country,
			:v_ccy:ind_ccy;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}
		v_merchant_id.arr[v_merchant_id.len] = '\0';
		v_service_code.arr[v_service_code.len] = '\0';
		v_country.arr[v_country.len] = '\0';
		v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("batch_proc_17: merchant_id = [%s]\n",v_merchant_id.arr));
DEBUGLOG(("batch_proc_17: service_code = [%s]\n",v_service_code.arr));
DEBUGLOG(("batch_proc_17: country = [%s]\n",v_country.arr));
DEBUGLOG(("batch_proc_17: ccy = [%s]\n",v_ccy.arr));
		EXEC SQL EXECUTE
			BEGIN
				LEDGER_PKG.open_cur_rb_ledger(:hv_host_posting_date,:v_merchant_id,:v_country,:v_service_code,:v_ccy,:c_cursor_rpt017);
			END;
		END-EXEC;

		sprintf(cs_outputfile,"%s/%s_%s_%s_%s.xls",csPath,PD_EOD_RPT017,v_merchant_id.arr,v_service_code.arr, v_ccy.arr);

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
			return FAILURE;
		}
		iRet = Extract_RPT017(fout,c_cursor_rpt017);
		fclose(fout);
		if (iRet != SUCCESS)
			break;

/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt017;
	} while (PD_TRUE);	
	EXEC SQL CLOSE c_cursor_getmerchant_rbal;

	return iRet;
sql_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getmerchant_rbal;
	EXEC SQL CLOSE :c_cursor_rpt017;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}
