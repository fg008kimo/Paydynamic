/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/07/25              Cody Chan
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/stat.h>
#include <oraca.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "batchcommon.h"
#include "extract_rptfiles.h"
#include "extract_rptfc.h"


char	cDebug = 'Y';
#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode



int RPT001(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar         hv_host_posting_date[PD_DATE_LEN];

		varchar         v_merchant_id[PD_MERCHANT_ID_LEN +1];
                varchar         v_service_code[PD_SERVICE_CODE_LEN +1];
                varchar         v_country[PD_COUNTRY_LEN +1];
		varchar         v_ccy[PD_CCY_ID_LEN +1];
	
		short           ind_merchant_id = -1;
                short           ind_service_code = -1;
                short           ind_country = -1;
                short           ind_ccy = -1;

		SQL_CURSOR    c_cursor_rpt001;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt001;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	EXEC SQL DECLARE c_cursor_getmerchant_bal CURSOR FOR
                 SELECT merchant_id,
                        mb_service_code,
                        mb_country,
                        mb_ccy_id
                  FROM merchant_bal_acct ,
                       (SELECT merchant_id,
                               name
                          FROM merch_detail a,
                               clients b
                         WHERE a.status = 'O'
                           AND a.disabled  = 0
                           AND a.client_id = b.client_id
                           AND A.DISABLED = 0
                           AND B.TYPE = 'M')
                 WHERE mb_status = 'O'
                   AND mb_disabled = 0
                   AND merchant_id = mb_merchant_id;

	EXEC SQL OPEN c_cursor_getmerchant_bal;
        do {
                EXEC SQL FETCH c_cursor_getmerchant_bal
                INTO
                        :v_merchant_id:ind_merchant_id,
                        :v_service_code:ind_service_code,
                        :v_country:ind_country,
                        :v_ccy:ind_ccy;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
                v_merchant_id.arr[v_merchant_id.len] = '\0';
                v_service_code.arr[v_service_code.len] = '\0';
                v_country.arr[v_country.len] = '\0';
                v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("batch_proc: merchant_id = [%s]\n",v_merchant_id.arr));
DEBUGLOG(("batch_proc: service_code = [%s]\n",v_service_code.arr));
DEBUGLOG(("batch_proc: country = [%s]\n",v_country.arr));
DEBUGLOG(("batch_proc: ccy = [%s]\n",v_ccy.arr));
		EXEC SQL EXECUTE
                        BEGIN
                                REPORT_PKG.open_cur_rpt001(:hv_host_posting_date,:v_merchant_id,:v_country,:v_service_code,:v_ccy,:c_cursor_rpt001);
                        END;
                END-EXEC;

		sprintf(cs_outputfile,"%s/%s_%s_%s_%s.xls",csPath,PD_EOD_RPT001,v_merchant_id.arr,v_service_code.arr, v_ccy.arr);

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
        		return FAILURE;
		}
		iRet = Extract_RPT001(fout,c_cursor_rpt001);
		fclose(fout);
                if (iRet != SUCCESS)
                        break;
/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt001;
	} while (PD_TRUE);	
	EXEC SQL CLOSE c_cursor_getmerchant_bal;

	return iRet;
sql_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getmerchant_bal;
	EXEC SQL CLOSE :c_cursor_rpt001;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
}


int RPT002(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar         hv_host_posting_date[PD_DATE_LEN];

		varchar         v_client_id[PD_CLIENT_ID_LEN +1];
		varchar         v_merchant_id[PD_MERCHANT_ID_LEN +1];

                short           ind_client_id = -1;
                short           ind_merchant_id = -1;

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	EXEC SQL DECLARE c_cursor_clients CURSOR FOR
		SELECT client_id
 		  FROM clients
  		 WHERE type = 'M'
     		   AND status = 'O';

	EXEC SQL DECLARE c_cursor_merchants CURSOR FOR
                SELECT a.client_id,
            		b.merchant_id
  		  FROM clients a,
           	       merch_detail b
                 WHERE a.TYPE = 'M' AND a.status = 'O'
                   and a.client_id = b.client_id
     		   and b.status = 'O'
     		   and b.disabled = 0;

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT002);
	ind_client_id = -1;
	ind_merchant_id = -1;
	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt002(:hv_host_posting_date,:v_client_id:ind_client_id,:v_merchant_id:ind_merchant_id,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT002(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;
        if (iRet != SUCCESS) 
        	return iRet;

	EXEC SQL OPEN c_cursor_clients;
        do {
                EXEC SQL FETCH c_cursor_clients
                INTO
                        :v_client_id:ind_client_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
                v_client_id.arr[v_client_id.len] = '\0';
DEBUGLOG(("client_id = [%s]\n",v_client_id.arr));

		sprintf(cs_outputfile,"%s/%s_%s.xls",csPath,PD_EOD_RPT002,v_client_id.arr);
		EXEC SQL EXECUTE
                        BEGIN
                                REPORT_PKG.open_cur_rpt002(:hv_host_posting_date,:v_client_id:ind_client_id,:v_merchant_id:ind_merchant_id,:c_cursor_rpt);
                        END;
                END-EXEC;

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
        		return FAILURE;
		}
		iRet = Extract_RPT002(fout,c_cursor_rpt);
		fclose(fout);
/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt;
                if (iRet != SUCCESS)
                        break;
	} while (PD_TRUE);	



	EXEC SQL OPEN c_cursor_merchants;
        do {
                EXEC SQL FETCH c_cursor_merchants
                INTO
                        :v_client_id:ind_client_id,
                        :v_merchant_id:ind_merchant_id;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
                v_client_id.arr[v_client_id.len] = '\0';
DEBUGLOG(("client_id = [%s]\n",v_client_id.arr));

                v_merchant_id.arr[v_merchant_id.len] = '\0';
DEBUGLOG(("merchant_id = [%s]\n",v_merchant_id.arr));

                sprintf(cs_outputfile,"%s/%s_%s_%s.xls",csPath,PD_EOD_RPT002,v_client_id.arr,v_merchant_id.arr);
                EXEC SQL EXECUTE
                        BEGIN
                                REPORT_PKG.open_cur_rpt002(:hv_host_posting_date,:v_client_id:ind_client_id,:v_merchant_id:ind_merchant_id,:c_cursor_rpt);
                        END;
                END-EXEC;

                fout = fopen(cs_outputfile,"w");
                if (fout == NULL) {
                        fclose(fout);
                        return FAILURE;
                }
                iRet = Extract_RPT002(fout,c_cursor_rpt);
                fclose(fout);
/* must close it */
                EXEC SQL CLOSE :c_cursor_rpt;
                if (iRet != SUCCESS)
                        break;
        } while (PD_TRUE);

	EXEC SQL CLOSE c_cursor_clients;
	EXEC SQL CLOSE c_cursor_merchants;
	return iRet;
sql_error:
DEBUGLOG(("get_rpt002_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_clients;
	EXEC SQL CLOSE c_cursor_merchants;
	EXEC SQL CLOSE :c_cursor_rpt;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
}


int RPT005(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT005);

	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt005(:hv_host_posting_date,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT005(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

       	return iRet;

sql_error:
DEBUGLOG(("get_rpt005_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
}


int RPT006(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT006);

	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt006(:hv_host_posting_date,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT006(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt006_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
} 


int RPT007(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT007);

	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt007(:hv_host_posting_date,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT007(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt007_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
} 


int RPT008(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT008);

	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt008(:hv_host_posting_date,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT008(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt008_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
} 


int RPT009(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar       hv_approval_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_approval_date.len = strlen(csDate);
        memcpy(hv_approval_date.arr,csDate,hv_approval_date.len);
DEBUGLOG(("hv_approval_date = [%.*s]\n",hv_approval_date.len,hv_approval_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT009);

	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt009(:hv_approval_date,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT009(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt009_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
} 


int RPT010(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar       hv_host_posting_date[PD_DATE_LEN];
		char          v_adj_dc_ind;

		short         ind_adj_dc_ind = -1;

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s_%c.xls",csPath,PD_EOD_RPT010,PD_ADJ_TYPE_DEBIT);
	v_adj_dc_ind = PD_ADJ_TYPE_DEBIT;
	ind_adj_dc_ind = 0;

	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt010(:hv_host_posting_date,:v_adj_dc_ind:ind_adj_dc_ind,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT010(fout,c_cursor_rpt);
	fclose(fout);

	sprintf(cs_outputfile,"%s/%s_%c.xls",csPath,PD_EOD_RPT010,PD_ADJ_TYPE_CREDIT);
	v_adj_dc_ind = PD_ADJ_TYPE_CREDIT;
	ind_adj_dc_ind = 0;

	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt010(:hv_host_posting_date,:v_adj_dc_ind:ind_adj_dc_ind,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT010(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt010_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
} 


int RPT011(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT011);

	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt011(:hv_host_posting_date,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT011(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt011_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
} 


int RPT012(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar       hv_host_posting_date[PD_DATE_LEN];

		SQL_CURSOR    c_cursor_rpt;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	sprintf(cs_outputfile,"%s/%s.xls",csPath,PD_EOD_RPT012);

	EXEC SQL EXECUTE
       	BEGIN
        	REPORT_PKG.open_cur_rpt012(:hv_host_posting_date,:c_cursor_rpt);
                        END;
        END-EXEC;

	fout = fopen(cs_outputfile,"w");
	if (fout == NULL) {
		fclose(fout);
       		return FAILURE;
	}
	iRet = Extract_RPT012(fout,c_cursor_rpt);
	fclose(fout);

/* must close it */
	EXEC SQL CLOSE :c_cursor_rpt;

      	return iRet;

sql_error:
DEBUGLOG(("get_rpt012_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE :c_cursor_rpt;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
} 
