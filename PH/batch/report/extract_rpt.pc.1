/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/02/03              Cody Chan
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/stat.h>
#include <oraca.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "extract_rptfiles.h"
#include "extract_rptcommon.h"
#include "batchcommon.h"


char	cDebug;
#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


int batch_init(int argc, char* argv[])
{
	if (argc < 1) {
        	printf("usage:  -d txn_date\n");
        	return FAILURE;
    	}
	else 
		return SUCCESS;
}	


char	csRptDate[PD_DATE_LEN * 2 +1];

int RPT001(const char* csFileName,const char* csDate);
int parse_arg(int argc,char **argv);
int batch_proc(int argc, char* argv[])
{
	int	iRet = SUCCESS;
	char	cStatus;
	char	csCurrPath[PD_MAX_FILE_LEN +1];


	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
    	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar		hv_ph_date[PD_DATE_LEN];
		char		hv_status;
		varchar		hv_update_user[PD_DATE_LEN];

		varchar		v_id[PD_RPT_ID_LEN +1];
		varchar		v_report_name[PD_RPT_NAME_LEN +1];
		varchar		v_desc[PD_RPT_DESC_LEN +1];
		char		v_rerunable;
		char		v_type;
		char		v_hold;

		short		v_return_value;
		short		ind_id = -1;
		short		ind_report_name = -1;
		short		ind_desc = -1;
		short		ind_rerunable = -1;
		short		ind_type = -1;
		short		ind_hold = -1;


    	EXEC SQL END DECLARE SECTION;


	iRet = parse_arg(argc,argv);

	if (iRet != SUCCESS){
                printf("usage: -d Date\n");
                return (iRet);
        }


	CreateReportPathCustomized((unsigned char*)csCurrPath,csRptDate);
printf("current path = [%s]\n",csCurrPath);

	hv_ph_date.len = strlen(csRptDate);
	memcpy(hv_ph_date.arr,csRptDate,hv_ph_date.len);
DEBUGLOG(("batch_proc:hv_ph_date = [%.*s]\n",hv_ph_date.len,hv_ph_date.arr));


	EXEC SQL DECLARE c_cursor_eod_reports CURSOR FOR
		SELECT er_id,
         		er_report_name,
         		er_desc,
         		er_rerunable,
         		er_type,
         		er_hold 
  		 FROM eod_reports
 		ORDER by er_order_num;

	EXEC SQL OPEN c_cursor_eod_reports;
        do {
		EXEC SQL FETCH c_cursor_eod_reports
		INTO 
			:v_id:ind_id,
			:v_report_name:ind_report_name,
			:v_desc:ind_desc,
			:v_rerunable:ind_rerunable,
			:v_type:ind_type,
			:v_hold:ind_hold;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		if (ind_id >= 0) {
			v_id.arr[v_id.len] = '\0';
		}
		else 
			v_id.arr[0] = '\0';
DEBUGLOG(("id = [%s]\n",v_id.arr));

		if (ind_report_name >= 0) {
			v_report_name.arr[v_report_name.len] = '\0';
		}
		else 
			v_report_name.arr[0] = '\0';
DEBUGLOG(("report_name = [%s]\n",v_report_name.arr));

		if (ind_desc >= 0) {
			v_desc.arr[v_desc.len] = '\0';
		}
		else 
			v_desc.arr[0] = '\0';
DEBUGLOG(("desc = [%s]\n",v_desc.arr));

		if (ind_rerunable < 0) 
			v_rerunable = PD_NO;
DEBUGLOG(("rerunable = [%c]\n",v_rerunable));

		if (ind_type < 0) 
			v_type = PD_NO;
DEBUGLOG(("type = [%c]\n",v_type));

		if (ind_hold < 0) 
			v_hold = PD_NO;
DEBUGLOG(("hold = [%c]\n",v_hold));

		
		printf("[%s] ",v_id.arr);
		cStatus = ' ';
		cStatus = CurrentReportStatus((const char*)v_id.arr);
DEBUGLOG(("status = [%c]\n",cStatus));
/* processing status */
		if (cStatus == PD_EOD_PROCESSING) {
			printf("in processing\n");
			continue;
		}

/* already run status */
		if (cStatus == PD_EOD_COMPLETED) {
			if (v_rerunable != PD_YES) {	
				printf("had already run\n");
				continue;
			}
		}

		if (cStatus == PD_EOD_NEW_CYCLE) {
			printf("New Cycle\n");
		}

		if (v_hold !=  PD_EOD_HOLD) {
			if (v_type == PD_DAILY) {
			}
			else if (v_type == PD_WEEKLY) {
			}
			else if (v_type == PD_MONTHLY) {
			}
			else {
DEBUGLOG(("v_type = [%c] is not supported\n"));
				printf("[%c] is not supported\n",v_type);
				continue;
			}

/* run job */
			hv_update_user.len = v_id.len;
			memcpy(hv_update_user.arr,v_id.arr,hv_update_user.len);
DEBUGLOG(("hv_update_user = [%.*s]\n",hv_update_user.len,hv_update_user.arr));
/* processing */
			hv_status = PD_EOD_PROCESSING;
DEBUGLOG(("status = [%c]\n",hv_status));
			EXEC SQL EXECUTE
                	BEGIN
                		:v_return_value := sp_eod_reports_status_run(:v_id,
                                         :hv_status,
                                         :hv_ph_date,
                                         :hv_update_user);

                	END;
        		END-EXEC;

/* end of report */
			if (!strcmp((const char*)v_id.arr,PD_EOD_RPT001)) {
				iRet = RPT001(csCurrPath,csRptDate) ;
			}
			else {
/* function pointer* /
			}

			if (iRet == SUCCESS) {
				hv_status = PD_EOD_COMPLETED;
			}
			else {
				hv_status = PD_EOD_FAILURE;
			}
			hv_status = PD_EOD_PROCESSING;
DEBUGLOG(("status = [%c]\n",hv_status));
			EXEC SQL EXECUTE
                	BEGIN
                		:v_return_value := sp_eod_reports_status_run(:v_id,
                                         :hv_status,
                                         :hv_ph_date,
                                         :hv_update_user);

                	END;
        		END-EXEC;
		}
		else {
DEBUGLOG(("[%s] is in hold status\n",v_id.arr));
			printf("[%s] is in hold status\n",v_id.arr);

		}

		printf("\n");
	} while (PD_TRUE);
	
	EXEC SQL CLOSE c_cursor_eod_reports;

	printf(XLS_HD);
	printf(XLS_NC);
	printf(XLS_FL,"TESTING");
	printf(XLS_EC);
	printf(XLS_SY);
	printf(XLS_TR);
DEBUGLOG(("iRet = [%d]\n",iRet));
	return iRet;
sql_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_eod_reports;
	EXEC SQL ROLLBACK RELEASE;
	return FAILURE;
}


int batch_terminate(int argc, char* argv[])
{
    return SUCCESS;
}



int RPT001(const char* csPath,const char* csDate) 
{
	char    cs_outputfile[PD_MAX_FILE_LEN + 1];
	int     iRet = SUCCESS;
	FILE	*fout;

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;

                varchar         hv_host_posting_date[PD_DATE_LEN];

		varchar         v_merchant_id[PD_MERCHANT_ID_LEN +1];
                varchar         v_service_code[PD_SERVICE_CODE_LEN +1];
                varchar         v_country[PD_COUNTRY_LEN +1];
		varchar         v_ccy[PD_CCY_ID_LEN +1];
	
		short           ind_merchant_id = -1;
                short           ind_service_code = -1;
                short           ind_country = -1;
                short           ind_ccy = -1;

		SQL_CURSOR    c_cursor_rpt001;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL ALLOCATE :c_cursor_rpt001;

	hv_host_posting_date.len = strlen(csDate);
        memcpy(hv_host_posting_date.arr,csDate,hv_host_posting_date.len);
DEBUGLOG(("hv_host_posting_date = [%.*s]\n",hv_host_posting_date.len,hv_host_posting_date.arr));

	EXEC SQL DECLARE c_cursor_getmerchant_bal CURSOR FOR
                 SELECT merchant_id,
                        mb_service_code,
                        mb_country,
                        mb_ccy_id
                  FROM merchant_bal_acct ,
                       (SELECT merchant_id,
                               name
                          FROM merch_detail a,
                               clients b
                         WHERE a.status = 'O'
                           AND a.disabled  = 0
                           AND a.client_id = b.client_id
                           AND A.DISABLED = 0
                           AND B.TYPE = 'M')
                 WHERE mb_status = 'O'
                   AND mb_disabled = 0
                   AND merchant_id = mb_merchant_id;

	EXEC SQL OPEN c_cursor_getmerchant_bal;
        do {
                EXEC SQL FETCH c_cursor_getmerchant_bal
                INTO
                        :v_merchant_id:ind_merchant_id,
                        :v_service_code:ind_service_code,
                        :v_country:ind_country,
                        :v_ccy:ind_ccy;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }
                v_merchant_id.arr[v_merchant_id.len] = '\0';
                v_service_code.arr[v_service_code.len] = '\0';
                v_country.arr[v_country.len] = '\0';
                v_ccy.arr[v_ccy.len] = '\0';
DEBUGLOG(("batch_proc: merchant_id = [%s]\n",v_merchant_id.arr));
DEBUGLOG(("batch_proc: service_code = [%s]\n",v_service_code.arr));
DEBUGLOG(("batch_proc: country = [%s]\n",v_country.arr));
DEBUGLOG(("batch_proc: ccy = [%s]\n",v_ccy.arr));
		EXEC SQL EXECUTE
                        BEGIN
                                REPORT_PKG.open_cur_rpt001(:hv_host_posting_date,:v_merchant_id,:v_country,:v_service_code,:v_ccy,:c_cursor_rpt001);
                        END;
                END-EXEC;

		sprintf(cs_outputfile,"%s/%s_%s.xls",csPath,v_merchant_id.arr,v_service_code.arr);

		fout = fopen(cs_outputfile,"w");
		if (fout == NULL) {
			fclose(fout);
        		return FAILURE;
		}
		iRet = Extract_RPT001(fout,c_cursor_rpt001);
		fclose(fout);
                if (iRet != SUCCESS)
                        break;
/* must close it */
		EXEC SQL CLOSE :c_cursor_rpt001;
	} while (PD_TRUE);	

	return iRet;
sql_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL CLOSE c_cursor_getmerchant_bal;
	EXEC SQL CLOSE :c_cursor_rpt001;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
}

int parse_arg(int argc,char **argv)
{
        char    c;
        strcpy(csRptDate,"");

        while ((c = getopt(argc,argv,"d:")) != EOF) {
                switch (c) {
                        case 'd':
                                strcpy(csRptDate, optarg);
                                break;
                        default:
                                return FAILURE;
                }
        }

        return SUCCESS;
}
