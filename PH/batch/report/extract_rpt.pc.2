/*
Partnerdelight (c)2012. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2012/02/03              Cody Chan
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/stat.h>
#include <oraca.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "extract_rptfiles.h"
#include "extract_rptcommon.h"
#include "batchcommon.h"


char	cDebug;
#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode


int batch_init(int argc, char* argv[])
{
	if (argc < 1) {
        	printf("usage:  -d txn_date\n");
        	return FAILURE;
    	}
	else 
		return SUCCESS;
}	

char    csRptDate[PD_DATE_LEN * 2 +1];

int RPT001(const char* csFileName,const char* csDate);
int parse_arg(int argc,char **argv);

int batch_proc(int argc, char* argv[])
{
        int     iRet = SUCCESS;
        char    cStatus;
        char    csCurrPath[PD_MAX_FILE_LEN +1];


        EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
                varchar         hv_ph_date[PD_DATE_LEN];
                char            hv_status;
                varchar         hv_update_user[PD_DATE_LEN];

                varchar         v_id[PD_RPT_ID_LEN +1];
                varchar         v_report_name[PD_RPT_NAME_LEN +1];
                varchar         v_desc[PD_RPT_DESC_LEN +1];
                char            v_rerunable;
                char            v_type;
                char            v_hold;

                short           v_return_value;
                short           ind_id = -1;
                short           ind_report_name = -1;
                short           ind_desc = -1;
                short           ind_rerunable = -1;
                short           ind_type = -1;
                short           ind_hold = -1;


        EXEC SQL END DECLARE SECTION;


        iRet = parse_arg(argc,argv);

        if (iRet != SUCCESS){
                printf("usage: -d Date\n");
                return (iRet);
        }


        CreateReportPathCustomized((unsigned char*)csCurrPath,csRptDate);
printf("current path = [%s]\n",csCurrPath);

        hv_ph_date.len = strlen(csRptDate);
        memcpy(hv_ph_date.arr,csRptDate,hv_ph_date.len);
DEBUGLOG(("batch_proc:hv_ph_date = [%.*s]\n",hv_ph_date.len,hv_ph_date.arr));


	EXEC SQL DECLARE c_cursor_eod_reports CURSOR FOR
                SELECT er_id,
                        er_report_name,
                        er_desc,
                        er_rerunable,
                        er_type,
                        er_hold
                 FROM eod_reports
                ORDER by er_order_num;

	EXEC SQL OPEN c_cursor_eod_reports;
        do {
                EXEC SQL FETCH c_cursor_eod_reports
                INTO
                        :v_id:ind_id,
                        :v_report_name:ind_report_name,
                        :v_desc:ind_desc,
                        :v_rerunable:ind_rerunable,
                        :v_type:ind_type,
                        :v_hold:ind_hold;

                if (SQLCODE == SQL_NOT_FOUND) {
                        break;
                }


		if (ind_id >= 0) {
                        v_id.arr[v_id.len] = '\0';
                }
                else
                        v_id.arr[0] = '\0';
DEBUGLOG(("id = [%s]\n",v_id.arr));

                if (ind_report_name >= 0) {
                        v_report_name.arr[v_report_name.len] = '\0';
                }
                else
                        v_report_name.arr[0] = '\0';
DEBUGLOG(("report_name = [%s]\n",v_report_name.arr));

                if (ind_desc >= 0) {
                        v_desc.arr[v_desc.len] = '\0';
                }
                else
                        v_desc.arr[0] = '\0';
DEBUGLOG(("desc = [%s]\n",v_desc.arr));

                if (ind_rerunable < 0)
                        v_rerunable = PD_NO;
DEBUGLOG(("rerunable = [%c]\n",v_rerunable));

                if (ind_type < 0)
                        v_type = PD_NO;
DEBUGLOG(("type = [%c]\n",v_type));

                if (ind_hold < 0)
                        v_hold = PD_NO;
DEBUGLOG(("hold = [%c]\n",v_hold));


                printf("[%s] ",v_id.arr);
                cStatus = ' ';
                cStatus = CurrentReportStatus((const char*)v_id.arr);
DEBUGLOG(("status = [%c]\n",cStatus));
/* processing status */
                if (cStatus == PD_EOD_PROCESSING) {
                        printf("in processing\n");
                        continue;
                }


/* already run status */
                if (cStatus == PD_EOD_COMPLETED) {
                        if (v_rerunable != PD_YES) {
                                printf("had already run\n");
                                continue;
                        }
                }

                if (cStatus == PD_EOD_NEW_CYCLE) {
                        printf("New Cycle\n");
                }


	} while (PD_TRUE);

        EXEC SQL CLOSE c_cursor_eod_reports;

DEBUGLOG(("iRet = [%d]\n",iRet));
        return iRet;
sql_error:
DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL CLOSE c_cursor_eod_reports;
        EXEC SQL ROLLBACK RELEASE;
        return FAILURE;
}


int batch_terminate(int argc, char* argv[])
{
    return SUCCESS;
}


int parse_arg(int argc,char **argv)
{
        char    c;
        strcpy(csRptDate,"");

        while ((c = getopt(argc,argv,"d:")) != EOF) {
                switch (c) {
                        case 'd':
                                strcpy(csRptDate, optarg);
                                break;
                        default:
                                return FAILURE;
                }
        }

        return SUCCESS;
}
