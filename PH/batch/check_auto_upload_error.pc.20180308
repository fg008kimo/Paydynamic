/*
PDProTech (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of PDProTech.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2018/01/18              Dirk Wong 
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "ObjPtr.h"
#include "internal.h"
#include "check_auto_upload_error.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

char cs_nature[PD_TAG_LEN+1];
char cs_inputfile[PD_MAX_FILE_LEN + 1];

char csTag[PD_TAG_LEN+1];
char csTmp[PD_TMP_BUF_LEN+1];
char cDebug;
int iCnt=0;

int iDynCnt=0;

OBJPTR(DB);
OBJPTR(BO);

int parse_arg(int argc,char **argv);
int parse_file(FILE *fin);


int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}

int batch_proc(int argc, char* argv[])
{
	int iRet;
	FILE *fin;

	iRet = parse_arg(argc,argv);
	if (iRet != SUCCESS) {
		return FAILURE;
	}
	
	fin = fopen(cs_inputfile,"r");
	
	if (fin == NULL) {
DEBUGLOG(("Error Opening file = [%s]\n",cs_inputfile));
		return FAILURE;
	}
	
	if (iRet == SUCCESS) {
		iRet = parse_file(fin);
	}
	fclose(fin);
	
	return iRet;
}

int parse_arg(int argc,char **argv)
{

	char	c;
	strcpy(cs_inputfile,"");
	strcpy(cs_nature,"");

	if (argc < 3) {
DEBUGLOG(("argc = [%d]\n",argc));
		return FAILURE;
	}

	while ((c = getopt(argc,argv,"f:n:")) != EOF) {
		switch (c) {
			case 'f':
				strcpy(cs_inputfile,optarg);
				break;
			case 'n':
				strcpy(cs_nature,optarg);
				break;
			default:
				return FAILURE;
		}
	}

	if (!strcmp(cs_inputfile,"") || !strcmp(cs_nature,""))
		return FAILURE;

	return SUCCESS;
}

int parse_file(FILE *fin)
{
	int iRet = SUCCESS;
	
	char	csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
	char	cs_input_buf[PD_MAX_BUFFER +1];
	char*	p;
	int	iCount = 0;
	int	iCnt = 0;
	int	iTmp = 0;
	
	hash_t *hContext;
	hContext = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hContext,0);

	while (fgets(cs_input_buf,PD_MAX_BUFFER,fin) != NULL) {
		iCount = 0;
		if ((cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A) || (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0D)) {
			cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
		}
DEBUGLOG(("*[%s]\n",cs_input_buf));
		p = mystrtok(cs_input_buf,",");
		if (p == NULL)  {
			return FAILURE;
		}
		
		if (strlen(p) > 0) {
			if(p[strlen(p) - 1] == 0x0D){
				p[strlen(p) - 1] = '\0';
			}
			strcpy(csList[iCount],p);
		} else {
			csList[iCount][0] ='\0';
		}
		iCount++;
		
		while ( (p = mystrtok(NULL,",")) != NULL) {
			if(p[strlen(p) - 1] == 0x0D) {
				p[strlen(p) - 1] = '\0';
			}
			strcpy(csList[iCount],p);
DEBUGLOG(("csList[%d] = [%s]\n",iCount,p));
			iCount++;
		}

		if (strlen(csList[IDX_PROVIDER]) > 0 ) {
			sprintf(csTag,"fprovider-%d",iCnt);
			sprintf(csTmp,"%s",csList[IDX_PROVIDER]);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
DEBUGLOG(("Set Tpl: csTmp=[%s]\n",csTmp));
		}

		if (strlen(csList[IDX_BANK_NAME]) > 0 ) {
			sprintf(csTag,"fbank_name-%d",iCnt);
			sprintf(csTmp,"%s",csList[IDX_BANK_NAME]);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
DEBUGLOG(("Set Tpl: csTmp=[%s]\n",csTmp));
		}

		if (strlen(csList[IDX_BANK_ACCT_NUM]) > 0 ) {
			sprintf(csTag,"fbank_acct_num-%d",iCnt);
			sprintf(csTmp,"%s",csList[IDX_BANK_ACCT_NUM]);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
DEBUGLOG(("Set Tpl: csTmp=[%s]\n",csTmp));
		}

		if (strlen(csList[IDX_STMT_FILE_NAME]) > 0 ) {
			sprintf(csTag,"fstmt_file_name-%d",iCnt);
			sprintf(csTmp,"%s",csList[IDX_STMT_FILE_NAME]);
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
DEBUGLOG(("Set Tpl: csTmp=[%s]\n",csTmp));
		}

		if (strlen(csList[IDX_STATUS]) > 0 ) {
			sprintf(csTag,"fstatus-%d",iCnt);
			sprintf(csTmp,"%s",csList[IDX_STATUS]);

			if (csTmp[0] == PD_DEPOSIT_FILE_DECLINED) {
				sprintf(csTmp,"%s",PD_DEPOSIT_FILE_DECLINED_DESC);
			} else if (csTmp[0] == PD_DEPOSIT_FILE_CANCEL) {
				sprintf(csTmp,"%s",PD_DEPOSIT_FILE_CANCEL_DESC);
			} else if (csTmp[0] == PD_DEPOSIT_FILE_PENDING) {
				sprintf(csTmp,"%s",PD_DEPOSIT_FILE_PENDING_DESC);
			}
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
DEBUGLOG(("Set Tpl: csTmp=[%s]\n",csTmp));
		}

		if (strlen(csList[IDX_ERR_MSG]) > 0 ) {
			sprintf(csTag,"ferr_msg-%d",iCnt);
			sprintf(csTmp,"%s",csList[IDX_ERR_MSG]);
			iTmp = atoi(csTmp);
			DBObjPtr = CreateObj(DBPtr,"DBInternalMessages","GetMsg");
			if ((unsigned long)((*DBObjPtr)(iTmp,csTmp) == NOT_FOUND)) {
				iRet = INT_CODE_ERROR;
			}
			iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,csTag,"STR","stbl_body-0",csTmp);
DEBUGLOG(("Set Tpl: csTmp=[%s]\n",csTmp));
		}

		iCnt++;
	}
	
	if (iCnt > 0) {
		iDynCnt = set_tpl_dyn_int(hContext,iDynCnt,"stimestamp-0","SEC","stimestamp-0",0);
		iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,"ftimestamp-0","STR","stimestamp-0",write_tpl_timestamp());
		
		iDynCnt = set_tpl_dyn_int(hContext, iDynCnt, "stbl_head-0", "SEC", "stbl_head-0", 0);
		iDynCnt = set_tpl_dyn_int(hContext, iDynCnt, "stbl_body-0", "SEC", "stbl_body-0", iCnt);

		if (!strcmp(cs_nature,PD_AUTO_UPLOAD_NATURE_DSI)) {
			strcpy(cs_nature,PD_NATURE_DEPOSIT_NAME);
		} else if (!strcmp(cs_nature,PD_AUTO_UPLOAD_NATURE_POA)) {
			strcpy(cs_nature,PD_NATURE_PAYOUT_NAME);
		} else if (!strcmp(cs_nature,PD_AUTO_UPLOAD_NATURE_ITM)) {
			strcpy(cs_nature,PD_NATURE_INTERMEDIATE_NAME);
		} else {
			iRet = FAILURE;
		}
		sprintf(csTmp, "Auto Upload %s Bank Statement - Error Occurs", cs_nature);
		iDynCnt = set_tpl_dyn_cstring(hContext,iDynCnt,"MAIL_SUBJECT","GLO","STR",csTmp);
DEBUGLOG(("Set Tpl: csTmp=[%s]\n",csTmp));

		PutField_CString(hContext,"source",PD_EML_SOURCE_BATCH);
		PutField_CString(hContext,"funct",PD_EML_FUNCT_CHK_AUTO_UPL_ERR);
		PutField_Char(hContext,"party_type",PD_TYPE_GLOBAL);
		PutField_CString(hContext,"party_id",PD_EML_PARTY_ID_BATCH);

		PutField_Int(hContext,"total_dyn",iDynCnt);

		if (iRet == SUCCESS) {
			BOObjPtr = CreateObj(BOPtr,"BOAlertEmail","ProcessTpl");
			if((unsigned long)((*BOObjPtr)(hContext) != PD_OK)){
				iRet=INT_CODE_ERROR;
				PutField_Int(hContext,"internal_error",iRet);
//DEBUGLOG(("BOAlertEmail:ProcessTpl Failed\n"));
//ERRLOG("check_auto_upload_error BOAlertEmail::ProcessTpl Failed, iRet=%d\n", iRet);
			}
			else
			{
//DEBUGLOG(("BOAlertEmail:ProcessTpl Success\n"));
			}
		}
	}

//DEBUGLOG(("check_auto_upload_error normal exit!\n"));

	FREE_ME(hContext);

	return iRet;
}

