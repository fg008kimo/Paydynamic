/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/12/04              Dirk Wong
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "batchcommon.h"
#include "utilitys.h"
#include "ObjPtr.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define PD_DETAIL_TAG   "dt"
#define PD_HOLIDAY_ACTION_ADD "A"

char	cDebug = 'Y';
int     iExtMonth;
char	csCurDate[PD_DATE_LEN+1];
char	csMonthStart[PD_DATE_LEN+1];
char	csMonthEnd[PD_DATE_LEN+1];
char    csTmpDate[PD_DATE_LEN+1];
char    csTmp[PD_TMP_BUF_LEN+1];

OBJPTR(Txn);

int	add_holiday(const char* csDate);
int	parse_arg(int argc,char **argv);

int batch_init(int argc, char* argv[])
{
        return SUCCESS;
}

int batch_proc(int argc, char* argv[])
{
	int     iRet = parse_arg(argc,argv);
	int     iTmp = 0;

	if (iRet != SUCCESS) {
		return PD_ERR;
	}

	csCurDate[PD_DATE_LEN]='\0';
	csMonthStart[PD_DATE_LEN]='\0';
	csMonthEnd[PD_DATE_LEN]='\0';

DEBUGLOG(("batch_proc: ext_month = [%d]\n",iExtMonth));

DEBUGLOG(("batch_proc: curdate = [%s]\n", csCurDate));

	if (iExtMonth < 0)
		return FAILURE;

	iRet = addmonth(csCurDate,iExtMonth,csMonthEnd);
	if (iRet == PD_OK)
	{
		memcpy(csMonthStart,csMonthEnd,PD_DATE_LEN);
		csMonthStart[6]='0';
		csMonthStart[7]='1';
DEBUGLOG(("batch_proc: monthstart = [%s]\n", csMonthStart));
DEBUGLOG(("batch_proc: monthend = [%s]\n", csMonthEnd));

		memcpy(csTmpDate,csMonthStart,PD_DATE_LEN);

		while (PD_TRUE) {
			iTmp = day_of_week((const unsigned char *)csTmpDate);
			if (iTmp == 6 || iTmp == 0) {
DEBUGLOG(("batch_proc: [%s] weekend!\n",csTmpDate));
				iRet = add_holiday(csTmpDate);
			}

			if (iRet != PD_OK) {
ERRLOG("ph_auto_gen_holiday::add_holiday fail\n");
				break;
			}

			if (!memcmp(csTmpDate,csMonthEnd,PD_DATE_LEN))
				break;

			iRet = addday(csTmpDate,1,csTmpDate);
			if (iRet != PD_OK) {
ERRLOG("ph_auto_gen_holiday::addday fail\n");
				break;
			}
		}
	} else {
ERRLOG("ph_auto_gen_holiday::addmonth fail\n");
	}

	if (iRet == PD_OK)
		return SUCCESS;
	else
		return iRet;
}

int batch_terminate(int argc, char* argv[])
{
    return SUCCESS;
}

int add_holiday(const char* csDate)
{
	int     iRet = SUCCESS;

	hash_t *hContext;
	hContext = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hContext,0);

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;
		varchar	v_country[PD_COUNTRY_LEN+1];
		varchar	v_service_code[PD_SERVICE_CODE_LEN+1];

		short	ind_country = -1;
		short	ind_service_code = -1;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE c_cursor_getservicelist CURSOR FOR
		SELECT	CS_COUNTRY,
			CS_SERVICE_CODE
		FROM	COUNTRY_SERVICE_MAP;
	EXEC SQL OPEN c_cursor_getservicelist;

	do {
		EXEC SQL FETCH c_cursor_getservicelist
		INTO
			:v_country:ind_country,
			:v_service_code:ind_service_code;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		//Put Field into hash to API
		PutField_CString(hContext, "action", PD_HOLIDAY_ACTION_ADD);
		PutField_Int(hContext, "total_cnt", 1);
		sprintf(csTmp,"%.*s",v_country.len,v_country.arr);
		PutField_CString(hContext, "countries", csTmp);
		sprintf(csTmp,"%.*s",v_service_code.len, v_service_code.arr);
		PutField_CString(hContext, "services", csTmp);
		PutField_CString(hContext, "add_user", PD_UPDATE_USER);
		sprintf(csTmp, "%s_date_1", PD_DETAIL_TAG);
		PutField_CString(hContext, csTmp, csDate);

		TxnObjPtr = CreateObj(TxnPtr,"TxnMgtByUsHDI","Authorize");
		if((unsigned long)((*TxnObjPtr)(hContext,hContext,hContext) != PD_OK)){
			iRet = FAILURE;
DEBUGLOG(("add_holiday::TxnMgtByUsHDI Failure!\n"));
ERRLOG("ph_auto_gen_holiday add_holiday::TxnMgtByUsHDI Failure\n");
			break;
		}
		else {
DEBUGLOG(("add_holiday::TxnMgtByUsHDI success for [%.*s][%.*s] on [%s]\n", v_country.len,v_country.arr,v_service_code.len, v_service_code.arr,csDate));
		}

        } while(PD_TRUE);
        EXEC SQL CLOSE c_cursor_getservicelist;

	FREE_ME(hContext);

	if (iRet == PD_OK)
		return SUCCESS;
	else
		return iRet;

sql_error:
DEBUGLOG(("ph_auto_gen_holiday error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_cursor_getservicelist;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int parse_arg(int argc,char **argv)
{
	char    c;

	if (argc < 2) {
		return PD_ERR;
	}

	while ((c = getopt(argc,argv,"m: d:")) != EOF) {
		switch (c) {
			case 'm':
				iExtMonth = atoi(optarg);
				break;
			case 'd':
				strcpy(csCurDate, optarg);
				//memcpy(csCurDate,argv[1],strlen(argv[1]));
				break;
			default:
				return PD_ERR;
		}
	}

	return SUCCESS;
} 
    
