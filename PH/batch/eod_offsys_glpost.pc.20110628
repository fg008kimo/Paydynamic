/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2011/06/21	             Simon Fung
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myhash.h"
#include "numutility.h"
#include "myrecordset.h"
#include "eod_offsys_glpost.h"
#include "mymd5.h"
#include "eod_glutility.h"
#include "ObjPtr.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define	PD_MY_DELIMITOR	","
#define	PD_FILE_DELIMITOR "	"
#define	PD_HASHKEY_DELIMITOR ":"



#define	PD_CHAR		0x0D
#define	PD_SPACE	0x20

char    cDebug = 'Y';

char    cs_inputfile[PD_MAX_FILE_LEN + 1];
char    cs_date[PD_DATE_LEN + 1];
int parse_arg(int argc,char **argv);
int verify_file(FILE *fin);
int process_file(FILE *fin);
//int process_txn();

int batch_init(int argc, char* argv[])
{
	if (argc < 1) {
		printf("usage: -d Date\n");
	    return FAILURE;
	}
	else
	    return SUCCESS;
}



int batch_proc(int argc, char* argv[])
{
	FILE	*fin;
	int	iRet;
  //char cs_infile_name[PD_MAX_FILE_LEN + 1];

	
	iRet = parse_arg(argc,argv);

	if (iRet != SUCCESS) {
    		printf("*usage: -d Date\n");
		return (iRet);
	}
	
	DEBUGLOG(("File Path = [%s]\n", getenv("REPORT_DATA")));
	DEBUGLOG(("File directory = [%s]\n", OFFLINE_DATA_FOLDER));
	DEBUGLOG(("File Prefix = [%s]\n", OFFLINE_DATA_FILE_PREFIX));
	DEBUGLOG(("File Date = [%s]\n",cs_date));
	
	sprintf(cs_inputfile, "%s/%s/%s_%s.csv", getenv("REPORT_DATA"), OFFLINE_DATA_FOLDER, OFFLINE_DATA_FILE_PREFIX, cs_date);

	fin = fopen(cs_inputfile,"r");
	if (fin == NULL) {
		DEBUGLOG(("Error Opening file = [%s]\n",cs_inputfile));
		return FAILURE;
	}

	DEBUGLOG(("Opened file = [%s] for read\n",cs_inputfile));

	//iRet = verify_file(fin,fout);
	//DEBUGLOG(("verify_file reslut = [%d]\n",iRet));	
	
	iRet = SUCCESS;
	
	if (iRet == SUCCESS) {
		rewind(fin);
		iRet = process_file(fin);
	}

	fclose(fin);

	return iRet;

}

int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}
                     
int parse_arg(int argc,char **argv)
{               
	char    c;
	strcpy(cs_inputfile,"");
	          
	while ((c = getopt(argc,argv,"d:")) != EOF) {
	  switch (c) {
      case 'd':
              strcpy(cs_date, optarg);
              break;
      default:
              return FAILURE;
	  }
	}       
	
	DEBUGLOG(("[%s]\n",cs_date));
	if (!strcmp(cs_date,""))
	  return FAILURE;
	  
	return SUCCESS; 
}               

int verify_file(FILE *fin)
{
	int iRet = FAILURE;
	int iLineCnt = 0;
	int	iCount = 0;
	int iMerchKeyCnt;
	int iPSPKeyCnt;
	char    csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
	char    cs_input_buf[PD_MAX_BUFFER +1];;
	char	*p=NULL;
	char csKey[PD_TMP_MSG_BUF_LEN];
	
	char *csSign;
	csSign = (char*) malloc (1024 * 2 +1);
	char *csOUT;
	csOUT = (char*) malloc (1024 * 2 +1);

  iMerchKeyCnt = 0;
  iPSPKeyCnt = 0;
  
  fgets(cs_input_buf,PD_MAX_BUFFER,fin);
  if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A || cs_input_buf[strlen(cs_input_buf) - 1] == 0x10)
         cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
	strcpy(cs_input_buf,TrimAllChar(cs_input_buf,strlen(cs_input_buf),PD_CHAR));

	DEBUGLOG(("%s\n",cs_input_buf));
	
	iCount = 0;
	
	// Breakdown header line
  p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
  if (p == NULL) {
		DEBUGLOG(("Invalid File Header"));
		return FAILURE;
	}
  strcpy(csList[iCount],p);
  iCount++;

  while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
    strcpy(csList[iCount],p);
    iCount++;
  }               

	if (iCount == HEADER_ITEM_SIZE) {

		// Build Key
		strcpy(csKey, csList[IDX_HD_TXN_CNT]);
		strcat(csKey, csList[IDX_HD_TXN_AMT]);
		strcat(csKey, csList[IDX_HD_FEE_AMT]);
		strcat(csKey, csList[IDX_HD_NET_AMT]);
		strcat(csKey, csList[IDX_HD_MU_AMT]);
		DEBUGLOG(("Bulid Header MD5 Key = [%s]\n",csKey));
		
		strcpy(csSign, csList[IDX_HD_CHECKSUM]);		

		DEBUGLOG(("Header Checksum = [%s]\n",csSign));
		md5sum(csKey,strlen(csKey),csOUT);
		DEBUGLOG(("Calculated Header Checksum = [%s]\n",csOUT));
		
		if (strcmp(csSign,csOUT)!=0) {
			DEBUGLOG(("Invalid Header Checksum [%s] <> Calculated:[%s]\n",csSign, csOUT));
			return FAILURE;
		}		

		iLineCnt = 0;

	  while (fgets(cs_input_buf,PD_MAX_BUFFER, fin) != NULL) {
	
	  	if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A)
				cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
			strcpy(cs_input_buf,TrimAllChar(cs_input_buf,strlen(cs_input_buf),PD_CHAR));
			DEBUGLOG(("%s\n",cs_input_buf));
	    iCount = 0;
	
	    p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
	    if (p == NULL) {
				DEBUGLOG(("Invalid File Detail"));
				return FAILURE;
			}
	    strcpy(csList[iCount],p);
	    iCount++;
	
	    while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
		    strcpy(csList[iCount],p);
		    iCount++;
	    }               
	
			if (iCount == DETAIL_ITEM_SIZE) {
				iLineCnt++;
				
				// Detail
				/*
				DEBUGLOG(("IDX_TXN_TYPE=[%s]\n",csList[IDX_TXN_TYPE]));
				DEBUGLOG(("IDX_COUNTRY_CODE=[%s]\n",csList[IDX_COUNTRY_CODE]));
				DEBUGLOG(("IDX_TXN_DATE=[%s]\n",csList[IDX_TXN_DATE]));
				DEBUGLOG(("IDX_TXN_ID=[%s]\n",csList[IDX_TXN_ID]));
				DEBUGLOG(("IDX_MERCHANT=[%s]\n",csList[IDX_MERCHANT]));
				DEBUGLOG(("IDX_PSP=[%s]\n",csList[IDX_PSP]));
				DEBUGLOG(("IDX_TXN_AMT_CCY=[%s]\n",csList[IDX_TXN_AMT_CCY]));
				DEBUGLOG(("IDX_TXN_AMT=[%s]\n",csList[IDX_TXN_AMT]));
				DEBUGLOG(("IDX_TXN_FEE_CCY=[%s]\n",csList[IDX_TXN_FEE_CCY]));
				DEBUGLOG(("IDX_TXN_FEE=[%s]\n",csList[IDX_TXN_FEE]));
				DEBUGLOG(("IDX_NET_AMT_CCY=[%s]\n",csList[IDX_NET_AMT_CCY]));
				DEBUGLOG(("IDX_NET_AMT=[%s]\n",csList[IDX_NET_AMT]));
				DEBUGLOG(("IDX_MU_AMT_CCY=[%s]\n",csList[IDX_MU_AMT_CCY]));
				DEBUGLOG(("IDX_MU_AMT=[%s]\n",csList[IDX_MU_AMT]));
				DEBUGLOG(("IDX_PSP_AMT_CCY=[%s]\n",csList[IDX_PSP_AMT_CCY]));
				DEBUGLOG(("IDX_PSP_AMT=[%s]\n",csList[IDX_PSP_AMT]));
				DEBUGLOG(("IDX_TXN_STATUS=[%s]\n",csList[IDX_TXN_STATUS]));
				DEBUGLOG(("IDX_DTL_CHECKSUM=[%s]\n",csList[IDX_DTL_CHECKSUM]));
				DEBUGLOG(("IDX_MERCHANT_REF=[%s]\n",csList[IDX_MERCHANT_REF]));
				md5(concat(country code,merchant, txn amt, txn free amt,  net amt, markup amt, psp/deliveried amt))
				*/
				
				// Build Key
				strcpy(csKey, csList[IDX_COUNTRY_CODE]);
				strcat(csKey, csList[IDX_MERCHANT]);
				strcat(csKey, csList[IDX_TXN_AMT]);
				strcat(csKey, csList[IDX_TXN_FEE]);
				strcat(csKey, csList[IDX_NET_AMT]);
				strcat(csKey, csList[IDX_MU_AMT]);
				strcat(csKey, csList[IDX_PSP_AMT]);
				DEBUGLOG(("Bulid MD5 Key = [%s]\n",csKey));
				
				strcpy(csSign, csList[IDX_DTL_CHECKSUM]);		
	
				DEBUGLOG(("Detail Checksum = [%s]\n",csSign));
				md5sum(csKey,strlen(csKey),csOUT);
				//csSign[0] = '\0';
				//U2L(csOUT,strlen(csOUT),csSign);
				//rReq->SIGN=soap_strdup(soap,csSign);
				DEBUGLOG(("Calculated Checksum = [%s]\n",csOUT));
				
				if (strcmp(csSign,csOUT)!=0) {
					DEBUGLOG(("Invalid Detail Checksum [%s] <> Calculated:[%s]\n",csSign, csOUT));
					return FAILURE;
				}			
			}	else {
				DEBUGLOG(("Invalid Detail size =[%d]\n",iCount));
				return FAILURE;
			}			
		}
	} else {
		DEBUGLOG(("Invalid Header size =[%d]\n",iCount));
		return FAILURE;
	}

	if (iLineCnt == 0) {
		DEBUGLOG(("No File Detail Found\n"));
	}

	DEBUGLOG(("verify_file completed return =[%d]\n",iRet));

	iRet = SUCCESS;
	
	return iRet;
}

int process_file(FILE *fin)
{
	int iRet = FAILURE;
	int iLineCnt = 0;
	int	iCount;
	int iJnlKeyCnt=0;	
	char    csList[IMPORT_MAX_FIELD][IMPORT_FIELD_LEN];
	char    csJnlKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN];
	char    csKeys[IMPORT_MAX_KEY][IMPORT_MAX_KEY_LEN];
	char    cs_input_buf[PD_MAX_BUFFER +1];;
	char	*p;
	char 	csTmpKey[IMPORT_MAX_KEY_LEN];
	double 	dTmp;
	double 	dTmpAmt;
	int iTmp;
	
	//char	csTmp[PD_MAX_BUFFER +1];
	//double	dAmt;
	hash_t *hTxnAmt;

	char csKey[PD_TMP_MSG_BUF_LEN];

  hTxnAmt = (hash_t*) malloc (sizeof(hash_t));
  hash_init(hTxnAmt,0);
	
  iCount = 0;
  
  fgets(cs_input_buf,PD_MAX_BUFFER,fin);
  if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A || cs_input_buf[strlen(cs_input_buf) - 1] == 0x10)
         cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
	strcpy(cs_input_buf,TrimAllChar(cs_input_buf,strlen(cs_input_buf),PD_CHAR));

	DEBUGLOG(("%s\n",cs_input_buf));

	iLineCnt = 0;

  while (fgets(cs_input_buf,PD_MAX_BUFFER, fin) != NULL) {
		iLineCnt++;
		
  	if (cs_input_buf[strlen(cs_input_buf) - 1] == 0x0A)
			cs_input_buf[strlen(cs_input_buf) - 1] = '\0';
		strcpy(cs_input_buf,TrimAllChar(cs_input_buf,strlen(cs_input_buf),PD_CHAR));
		DEBUGLOG(("%s\n",cs_input_buf));
    iCount = 0;

    p = mystrtok(cs_input_buf,PD_MY_DELIMITOR);
    if (p == NULL)
			return FAILURE;
    strcpy(csList[iCount],TrimAllChar(p, strlen(p), PD_SPACE));
    iCount++;

    while ( (p = mystrtok(NULL,PD_MY_DELIMITOR)) != NULL) {
	    strcpy(csList[iCount],TrimAllChar(p, strlen(p), PD_SPACE));
	    iCount++;
    }               

		if (1) {
		
			// Detail
			/*
			DEBUGLOG(("IDX_TXN_TYPE=[%s]\n",csList[IDX_TXN_TYPE]));
			DEBUGLOG(("IDX_COUNTRY_CODE=[%s]\n",csList[IDX_COUNTRY_CODE]));
			DEBUGLOG(("IDX_TXN_DATE=[%s]\n",csList[IDX_TXN_DATE]));
			DEBUGLOG(("IDX_TXN_ID=[%s]\n",csList[IDX_TXN_ID]));
			DEBUGLOG(("IDX_MERCHANT=[%s]\n",csList[IDX_MERCHANT]));
			DEBUGLOG(("IDX_PSP=[%s]\n",csList[IDX_PSP]));
			DEBUGLOG(("IDX_TXN_AMT_CCY=[%s]\n",csList[IDX_TXN_AMT_CCY]));
			DEBUGLOG(("IDX_TXN_AMT=[%s]\n",csList[IDX_TXN_AMT]));
			DEBUGLOG(("IDX_TXN_FEE_CCY=[%s]\n",csList[IDX_TXN_FEE_CCY]));
			DEBUGLOG(("IDX_TXN_FEE=[%s]\n",csList[IDX_TXN_FEE]));
			DEBUGLOG(("IDX_NET_AMT_CCY=[%s]\n",csList[IDX_NET_AMT_CCY]));
			DEBUGLOG(("IDX_NET_AMT=[%s]\n",csList[IDX_NET_AMT]));
			DEBUGLOG(("IDX_MU_AMT_CCY=[%s]\n",csList[IDX_MU_AMT_CCY]));
			DEBUGLOG(("IDX_MU_AMT=[%s]\n",csList[IDX_MU_AMT]));
			DEBUGLOG(("IDX_PSP_AMT_CCY=[%s]\n",csList[IDX_PSP_AMT_CCY]));
			DEBUGLOG(("IDX_PSP_AMT=[%s]\n",csList[IDX_PSP_AMT]));
			DEBUGLOG(("IDX_TXN_STATUS=[%s]\n",csList[IDX_TXN_STATUS]));
			DEBUGLOG(("IDX_DTL_CHECKSUM=[%s]\n",csList[IDX_DTL_CHECKSUM]));
			DEBUGLOG(("IDX_MERCHANT_REF=[%s]\n",csList[IDX_MERCHANT_REF]));
			*/
			
			// Flaten into 2D
			// by Txn Type, Country, Txn Date, Merchant, Txn Currency, Txn Fee Currency, Txn Net Amt Currency, Txn Markup Currency, PSP/Delivered Currency.
			
			// Build Key for Merchant Net Amount
			// ========================================================================
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_HASHKEY_NET_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_MERCHANT]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, "-");
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_NET_AMT_CCY]);

						
			// Insert into summary hash table 
			DEBUGLOG(("csKey = [%s]\n",csKey));
			
			// Net Txn Amt
			if (!is_numeric(csList[IDX_NET_AMT])) {
				DEBUGLOG(("Invalid Net Amount at line [%d]\n",iLineCnt));
				return FAILURE;
			}
			
			dTmp = atof(csList[IDX_NET_AMT]);
			DEBUGLOG(("Current TxnNet  = [%f]\n",dTmp));
			// Check key exists
			if (GetField_Double(hTxnAmt,csKey,&dTmpAmt)) {
				DEBUGLOG(("Found hTxnNet [%s] = [%f]\n",csKey, dTmpAmt));
				// Increment				
				dTmpAmt = dTmpAmt + dTmp;

			} else {				
				// Add new
				// Update Key chains
				strcpy(csJnlKeys[iJnlKeyCnt],csKey);
				iJnlKeyCnt++;
				dTmpAmt = dTmp;				
				DEBUGLOG(("New hTxnNet [%s] = [%f]\n",csKey, dTmpAmt));
			}
			PutField_Double(hTxnAmt,csKey,dTmpAmt);
			DEBUGLOG(("Updated hTxnNet [%s] = [%f]\n",csKey, dTmpAmt));			
			// ========================================================================
			
			// Build Key for PSP Txn Amount
			// ========================================================================
			strcpy(csKey, "");
			strcat(csKey, csList[IDX_TXN_TYPE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, PD_HASHKEY_TXN_AMT);
			strcat(csKey, PD_HASHKEY_DELIMITOR);
			strcat(csKey, csList[IDX_TXN_DATE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_STATUS]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);				
			strcat(csKey, csList[IDX_COUNTRY_CODE]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, "-");
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_PSP]);
			strcat(csKey, PD_HASHKEY_DELIMITOR);	
			strcat(csKey, csList[IDX_TXN_AMT_CCY]);

			// Insert into summary hash table 
			DEBUGLOG(("csKey = [%s]\n",csKey));

			if (!is_numeric(csList[IDX_TXN_AMT])) {
				DEBUGLOG(("Invalid Txn Amount at line [%d]\n",iLineCnt));
				return FAILURE;
			}
			
			// Txn Amt
			dTmp = atof(csList[IDX_TXN_AMT]);
			DEBUGLOG(("Current TxnAmt  = [%f]\n",dTmp));
			// Check key exists
			if (GetField_Double(hTxnAmt,csKey,&dTmpAmt)) {
				DEBUGLOG(("Found hTxnAmt [%s] = [%f]\n",csKey, dTmpAmt));
				// Increment				
				dTmpAmt = dTmpAmt + dTmp;

			} else {				
				// Add new
				// Update Key chains
				strcpy(csJnlKeys[iJnlKeyCnt],csKey);
				iJnlKeyCnt++;
				dTmpAmt = dTmp;				
				DEBUGLOG(("New hTxnAmt [%s] = [%f]\n",csKey, dTmpAmt));
			}
			PutField_Double(hTxnAmt,csKey,dTmpAmt);
			DEBUGLOG(("Updated hTxnAmt [%s] = [%f]\n",csKey, dTmpAmt));
			// ========================================================================

			// Build Key for Fee Amount
			// ========================================================================
			if (strlen(csList[IDX_TXN_FEE])>0) {
				if (!is_numeric(csList[IDX_TXN_FEE])) {
					DEBUGLOG(("Invalid Txn Fee at line [%d]\n",iLineCnt));
					return FAILURE;
				}
				
				// Txn Fee
				dTmp = atof(csList[IDX_TXN_FEE]);
				
				if (dTmp != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_HASHKEY_TXN_FEE);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_FEE_CCY]);
										
					// Insert into summary hash table 
					DEBUGLOG(("csKey = [%s]\n",csKey));
					
					DEBUGLOG(("Current TxnFee  = [%f]\n",dTmp));
					// Check key exists
					if (GetField_Double(hTxnAmt,csKey,&dTmpAmt)) {
						DEBUGLOG(("Found hTxnFee [%s] = [%f]\n",csKey, dTmpAmt));
						// Increment				
						dTmpAmt = dTmpAmt + dTmp;
		
					} else {				
						// Add new
						// Update Key chains
						strcpy(csJnlKeys[iJnlKeyCnt],csKey);
						iJnlKeyCnt++;
						dTmpAmt = dTmp;				
						DEBUGLOG(("New hTxnFee [%s] = [%f]\n",csKey, dTmpAmt));
					}
					PutField_Double(hTxnAmt,csKey,dTmpAmt);
					DEBUGLOG(("Updated hTxnFee [%s] = [%f]\n",csKey, dTmpAmt));
				}
			}
			// ========================================================================

			// Build Key for Markup Fee Amount
			// ========================================================================
			if (strlen(csList[IDX_MU_AMT])>0) {
				/*
				if (!is_numeric(csList[IDX_MU_AMT])) {
					DEBUGLOG(("Invalid Markup Fee at line [%d]\n",iLineCnt));
					return FAILURE;
				}
				*/

				// MU Fee
				dTmp = atof(csList[IDX_MU_AMT]);
				
				if (dTmp != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_HASHKEY_MU_AMT);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_MU_AMT_CCY]);
										
					// Insert into summary hash table 
					DEBUGLOG(("csKey = [%s]\n",csKey));
					
					// Txn MU
					DEBUGLOG(("Current MUFee  = [%f]\n",dTmp));
					// Check key exists
					if (GetField_Double(hTxnAmt,csKey,&dTmpAmt)) {
						DEBUGLOG(("Found hTxnMU [%s] = [%f]\n",csKey, dTmpAmt));
						// Increment				
						dTmpAmt = dTmpAmt + dTmp;
		
					} else {				
						// Add new
						// Update Key chains
						strcpy(csJnlKeys[iJnlKeyCnt],csKey);
						iJnlKeyCnt++;
						dTmpAmt = dTmp;				
						DEBUGLOG(("New hTxnMU [%s] = [%f]\n",csKey, dTmpAmt));
					}
					PutField_Double(hTxnAmt,csKey,dTmpAmt);
					DEBUGLOG(("Updated hTxnMU [%s] = [%f]\n",csKey, dTmpAmt));
					
				}
			}
			// ========================================================================

			// Build Key for PSP/Deliver Amount
			// ========================================================================
			if (strlen(csList[IDX_PSP_AMT])>0) {
				/*
				if (!is_numeric(csList[IDX_PSP_AMT])) {
					DEBUGLOG(("Invalid PSP/Deliver Amount at line [%d]\n",iLineCnt));
					return FAILURE;
				}
				*/

				// MU Fee
				dTmp = atof(csList[IDX_PSP_AMT]);
				
				if (dTmp != 0) {

					strcpy(csKey, "");
					strcat(csKey, csList[IDX_TXN_TYPE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, PD_HASHKEY_PSP_AMT);
					strcat(csKey, PD_HASHKEY_DELIMITOR);
					strcat(csKey, csList[IDX_TXN_DATE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_TXN_STATUS]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);				
					strcat(csKey, csList[IDX_COUNTRY_CODE]);
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					if (strcmp(csList[IDX_TXN_TYPE],MST_TYPE)==0)
						strcat(csKey, csList[IDX_MERCHANT]);
					else
						strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					if (strcmp(csList[IDX_TXN_TYPE],MST_TYPE)!=0)
						strcat(csKey, csList[IDX_PSP]);
					else
						strcat(csKey, "-");
					strcat(csKey, PD_HASHKEY_DELIMITOR);	
					strcat(csKey, csList[IDX_PSP_AMT_CCY]);
												
					// Insert into summary hash table 
					DEBUGLOG(("csKey = [%s]\n",csKey));
					
					// Txn MU
					DEBUGLOG(("Current PSP Amt  = [%f]\n",dTmp));
					// Check key exists
					if (GetField_Double(hTxnAmt,csKey,&dTmpAmt)) {
						DEBUGLOG(("Found hPSPAmt [%s] = [%f]\n",csKey, dTmpAmt));
						// Increment				
						dTmpAmt = dTmpAmt + dTmp;
		
					} else {				
						// Add new
						// Update Key chains
						strcpy(csJnlKeys[iJnlKeyCnt],csKey);
						iJnlKeyCnt++;
						dTmpAmt = dTmp;				
						DEBUGLOG(("New hPSPAmt [%s] = [%f]\n",csKey, dTmpAmt));
					}
					PutField_Double(hTxnAmt,csKey,dTmpAmt);
					DEBUGLOG(("Updated hPSPAmt [%s] = [%f]\n",csKey, dTmpAmt));
					
				}
			}
			// ========================================================================
		} // if
	}
	
	for (iTmp=0;iTmp<iJnlKeyCnt;iTmp++) {
		if (strlen(csJnlKeys[iTmp])>0) {
			DEBUGLOG(("Journal Key [%d] = [%s]\n",iTmp, csJnlKeys[iTmp]));

			strcpy(csTmpKey, csJnlKeys[iTmp]);
	
			if (GetField_Double(hTxnAmt,csTmpKey,&dTmpAmt)) {
				
				// Break key into fields
				iCount = 0;
		    p = mystrtok(csTmpKey,PD_HASHKEY_DELIMITOR);
		    if (p == NULL)
					return FAILURE;
		    strcpy(csKeys[iCount],p);
		    iCount++;
		
		    while ((p = mystrtok(NULL,PD_HASHKEY_DELIMITOR)) != NULL) {
			    strcpy(csKeys[iCount],p);
			    iCount++;
		    } 
				/*
				DEBUGLOG(("HASHKEY_IDX_AMT_TYPE=[%s]\n",csKeys[HASHKEY_IDX_AMT_TYPE]));	
				DEBUGLOG(("HASHKEY_IDX_TXN_DATE=[%s]\n",csKeys[HASHKEY_IDX_TXN_DATE]));
				DEBUGLOG(("HASHKEY_IDX_TXN_TYPE=[%s]\n",csKeys[HASHKEY_IDX_TXN_TYPE]));
				DEBUGLOG(("HASHKEY_IDX_TXN_STATUS=[%s]\n",csKeys[HASHKEY_IDX_TXN_STATUS]));
				DEBUGLOG(("HASHKEY_IDX_COUNTRY_CODE=[%s]\n",csKeys[HASHKEY_IDX_COUNTRY_CODE]));
				DEBUGLOG(("HASHKEY_IDX_MERCHANT=[%s]\n",csKeys[HASHKEY_IDX_MERCHANT]));
				DEBUGLOG(("HASHKEY_IDX_PSP=[%s]\n",csKeys[HASHKEY_IDX_PSP]));
				DEBUGLOG(("HASHKEY_IDX_AMT_CCY=[%s]\n",csKeys[HASHKEY_IDX_AMT_CCY]));	
				DEBUGLOG(("Amount [%s] = [%f]\n",csTmpKey, dTmpAmt));
				*/
			} else {
				DEBUGLOG(("Not Found for Key [%s]\n",csTmpKey));
				return FAILURE;
			}
		
		} else {
			break;
		}
	}
	
	iRet = SUCCESS;
	return iRet;
}
