/*
Partnerdelight (c)2010. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/06/13		   Stan Poon
Add Pool Level					   2014/10/16		   Stan Poon
PRD038 Changes, Remove ratio column	   	   2017/02/06		   Dirk Wong
   >> Bug fix for PRD038			   2017/02/10		   Dirk Wong
Fix SARIP                                          2017/02/14              Virginia Yun
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sqlca.h>
#include <unistd.h>
#include <math.h>
#include "batchcommon.h"
#include "common.h"
#include "utilitys.h"
#include "myrecordset.h"
#include "hash.h"
#include "ObjPtr.h"

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

#define PD_OPEN_TAG             "<tr><td>"
#define PD_OPEN_TAG_CS          "<tr><td style=text-align:right;>"
#define PD_OPEN_TAG_CS_RED      "<tr><td style=text-align:right;color:red>"
#define PD_NEXT_TAG             "</td><td>"
#define PD_NEXT_TAG_CS          "</td><td style=text-align:right;>"
#define PD_NEXT_TAG_CS_RED      "</td><td style=text-align:right;color:red>"
#define PD_END_TAG              "</td></tr>"

char cDebug = 'Y';

int parse_arg(int argc, char **argv);
int process_txn();
int psp_limit_report_summary(char* csCheckGroup);
int psp_limit_report_summary_total(char* csCheckGroup);
int psp_limit_report_merchant(char* csCheckGroup, int iShowEmptyCSegment);
int psp_limit_report_group_o(char* csCheckGroup);
int psp_limit_report_group_pool(char* csPoolId, char *csServiceCode);
int find_limit_to_gen(recordset_t *myRec);

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}

int batch_proc(int argc, char* argv[])
{
	int iRet;

	iRet = parse_arg(argc, argv);

	if (iRet != SUCCESS) {
printf("usage: \n");
	} else {
		process_txn();
	}

	return iRet;
}

int process_txn()
{
	int	iRet = SUCCESS;

	char *csPartyId = NULL, *csServiceCode = NULL;


	if (iRet == PD_OK) {
		iRet = psp_limit_report_summary(EML_CHK_GRP_VNCINC);
DEBUGLOG(("psp_limit_report_summary iRet = [%d]\n",iRet));
	}

	if (iRet == PD_OK) {
		iRet = psp_limit_report_summary_total(EML_CHK_GRP_VNCINC);
DEBUGLOG(("psp_limit_report_summary_total iRet = [%d]\n",iRet));
	}

	if (iRet == PD_OK) {
		iRet = psp_limit_report_group_o(EML_CHK_GRP_VNCINC);
DEBUGLOG(("psp_limit_report_group_o iRet = [%d]\n",iRet));
	}

	if (iRet == PD_OK) {
		iRet = psp_limit_report_merchant(EML_CHK_GRP_VNCINC, PD_FALSE);
DEBUGLOG(("psp_limit_report_merchant iRet = [%d]\n",iRet));
	}



printf("<h2>Mobile</h2>\n");

	if (iRet == PD_OK) {
		iRet = psp_limit_report_merchant(EML_CHK_GRP_MPGINC, PD_TRUE);
DEBUGLOG(("psp_limit_report_merchant iRet = [%d]\n",iRet));
	}



	recordset_t *myRec = (recordset_t*) malloc (sizeof(myRec));
	recordset_init(myRec,0);

	hash_t *myHash = NULL;

	if (iRet == PD_OK) {
		iRet = find_limit_to_gen(myRec);
DEBUGLOG(("find_limit_to_gen iRet = [%d]\n",iRet));
	}

	if (iRet == PD_OK) {
		myHash = RecordSet_GetFirst(myRec);
		while (myHash) {
DEBUGLOG(("psp_limit_report_group_pool \n"));
			csPartyId = NULL;
			csServiceCode = NULL;
			GetField_CString(myHash,"party_id",&csPartyId);
			GetField_CString(myHash,"service_code",&csServiceCode);

			iRet = psp_limit_report_group_pool(csPartyId, csServiceCode);
DEBUGLOG(("psp_limit_report_group_pool iRet = [%d]\n",iRet));
			myHash = RecordSet_GetNext(myRec);
		}
	}


	RecordSet_Destroy(myRec);
	//FREE_ME(myRec);

	return iRet;
}


int psp_limit_report_summary(char* csCheckGroup)
{
	int     iRet = SUCCESS;

printf("<h1>PSP Limit Report (Merchant)</h1>\n");
printf("<h2>Limit Report Summary</h2>\n");
printf("<table border='1'>\n");
printf("<tr><th>Merchant Short Name</th><th>Customer Segment</th><th>PSP Remaining Limit (Normal)</th><th>PSP Remaining Limit (SARIP)</th><th>PSP Remaining Limit (Overflow)</th></tr>\n");

	EXEC SQL WHENEVER SQLERROR GOTO summary_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_check_group[EML_CHK_GRP_LEN + 1];

		varchar	v_short_name[PD_MERCH_SHORT_NAME_LEN + 1];
		varchar	v_currency[PD_CCY_ID_LEN + 1];
		varchar	v_cg_code[PD_CUSTOMER_GROUP_CODE_LEN + 1];
		varchar	v_cg_desc[PD_DESC_LEN + 1];
		double	v_remaining_limit_normal;
		double	v_remaining_limit_sarip;
		double	v_remaining_limit_overflow;
		//int	v_cnt;

		short	ind_short_name = -1;
		short	ind_currency = -1;
		short	ind_cg_code = -1;
		short	ind_cg_desc = -1;
		short	ind_remaining_limit_normal = -1;
		short	ind_remaining_limit_sarip = -1;
		short	ind_remaining_limit_overflow = -1;
		//short	ind_cnt = -1;

	EXEC SQL END DECLARE SECTION;

	hv_check_group.len = strlen((char*)csCheckGroup);
	memcpy(hv_check_group.arr,csCheckGroup,hv_check_group.len);

	EXEC SQL DECLARE c_summary CURSOR FOR
		SELECT 	normal_summary.SHORT_NAME,
			normal_summary.CURRENCY_ID,
			normal_summary.CUSTOMER_SEGMENT_CODE,
			normal_summary.CUSTOMER_SEGMENT_DESC,
			normal_summary.REMAINING_LIMIT,
			sarip_summary.SARIP_REMAINING_LIMIT,
			overflow_summary.OVERFLOW_REMAINING_LIMIT
		FROM 	(
			SELECT 	MERCHANT_ID, 
				SHORT_NAME,
				CURRENCY_ID,
				CUSTOMER_SEGMENT_CODE,
				CUSTOMER_SEGMENT_DESC,
				NVL(SUM(REMAINING_LIMIT), 0) AS REMAINING_LIMIT
			FROM (
					SELECT 	MERCHANT_ID AS MERCHANT_ID,
						SHORT_NAME AS SHORT_NAME,
						PSP_CLIENT_ID,
						PSP_ID,
						CURRENCY_ID  AS CURRENCY_ID,
						CG_CODE AS CUSTOMER_SEGMENT_CODE,
						CG_DESC AS CUSTOMER_SEGMENT_DESC,	
						CASE
						WHEN (REMAINING_LIMIT > 0)
						THEN REMAINING_LIMIT
						ELSE 0
						END  AS REMAINING_LIMIT,
						MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
						MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT
					from PSP_LIMIT_MERCHANT_VIEW
					LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = CUSTOMER_SEGMENT
					WHERE MERCHANT_ID IN   (SELECT EPM_PARTY_ID
								FROM EMAIL_CHECK_PARTY_MAP
								WHERE EPM_NAME = 'PSP_LIMIT'
								AND EPM_GROUP =  :hv_check_group
								AND EPM_PARTY_TYPE = 'M'
								AND EPM_SUPPORT_MULTI_ENTRY = 1
								)
					AND SERVICE_CODE = 'VNC'
					AND CG_CODE IN ('GRP_A',
							'GRP_B',
							'GRP_C',	
							'GRP_N'
							)
					GROUP BY	MERCHANT_ID,
							SHORT_NAME,
							PSP_CLIENT_ID,
							PSP_ID,
							CURRENCY_ID,
							CG_CODE,
							CG_DESC,
							REMAINING_LIMIT
				)
			GROUP BY 	MERCHANT_ID, 
					SHORT_NAME,
					CURRENCY_ID,
					CUSTOMER_SEGMENT_CODE,
					CUSTOMER_SEGMENT_DESC
		)  normal_summary,
		(SELECT MERCHANT_ID, 
			SHORT_NAME,
			CURRENCY_ID,
			CUSTOMER_SEGMENT_CODE,
			CUSTOMER_SEGMENT_DESC,
			NVL(SUM(REMAINING_LIMIT), 0) AS SARIP_REMAINING_LIMIT
		FROM (	
			SELECT 	MERCHANT_ID AS MERCHANT_ID,
				SHORT_NAME AS SHORT_NAME,
				PSP_CLIENT_ID AS PSP_CLIENT_ID,
				PSP_ID AS PSP_ID,
				CURRENCY_ID AS CURRENCY_ID,
				LIMIT AS LIMIT,
				CG_CODE AS CUSTOMER_SEGMENT_CODE,
				CG_DESC AS CUSTOMER_SEGMENT_DESC,
				CASE
					WHEN (REMAINING_LIMIT > 0)
					THEN REMAINING_LIMIT
					ELSE 0
				END AS REMAINING_LIMIT,
				MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
				MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT
			FROM PSP_LIMIT_MERCHANT_VIEW
			LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = CUSTOMER_SEGMENT
			WHERE MERCHANT_ID IN (	SELECT EPM_PARTY_ID
						FROM EMAIL_CHECK_PARTY_MAP
						WHERE EPM_NAME = 'PSP_LIMIT'
						AND EPM_GROUP = :hv_check_group
						AND EPM_PARTY_TYPE = 'M'
						AND EPM_SUPPORT_MULTI_ENTRY = 1
						)
			AND SERVICE_CODE = 'VNC'
			AND CG_CODE IS NULL
			AND (	(allow_special_region =1 ) or
				(MAX_TRANSACTION_AMOUNT > 0 
				AND MAX_TRANSACTION_AMOUNT <= (select to_number(sp_val)
                                                        	from system_parameter
                                                        	where sp_code = 'LB_SMALL_AMT')
								)
			)
			GROUP BY	MERCHANT_ID,
					SHORT_NAME,
					PSP_CLIENT_ID,
					PSP_ID,
                            		CURRENCY_ID,
					LIMIT,
					REMAINING_LIMIT,
					CG_CODE,
					CG_DESC
		)
		GROUP BY 	MERCHANT_ID, 
				SHORT_NAME,
				CURRENCY_ID,
				CUSTOMER_SEGMENT_CODE,
				CUSTOMER_SEGMENT_DESC
		) sarip_summary,
		(SELECT MERCHANT_ID, 
			SHORT_NAME,
			CURRENCY_ID,
	                CUSTOMER_SEGMENT_CODE,
			CUSTOMER_SEGMENT_DESC,
			NVL(SUM(REMAINING_LIMIT), 0) AS OVERFLOW_REMAINING_LIMIT
		FROM (
			SELECT 	MERCHANT_ID AS MERCHANT_ID,
				SHORT_NAME AS SHORT_NAME,
				PSP_CLIENT_ID AS PSP_CLIENT_ID,
				PSP_ID AS PSP_ID,
				CURRENCY_ID AS CURRENCY_ID,
				LIMIT AS LIMIT,
				CG_CODE AS CUSTOMER_SEGMENT_CODE,
				CG_DESC AS CUSTOMER_SEGMENT_DESC,
				CASE
					WHEN (REMAINING_LIMIT > 0)
					THEN REMAINING_LIMIT
					ELSE 0
				END AS REMAINING_LIMIT,
				MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
				MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT
			FROM PSP_LIMIT_MERCHANT_VIEW
			LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = CUSTOMER_SEGMENT
			WHERE MERCHANT_ID IN   (SELECT EPM_PARTY_ID
						FROM EMAIL_CHECK_PARTY_MAP
						WHERE EPM_NAME = 'PSP_LIMIT'
						AND EPM_GROUP = :hv_check_group
						AND EPM_PARTY_TYPE = 'M'
						AND EPM_SUPPORT_MULTI_ENTRY = 1
						)
			AND SERVICE_CODE = 'VNC'
			AND ALLOW_SPECIAL_REGION = 0
			AND MAX_TRANSACTION_AMOUNT = 0
			AND CG_CODE IS NULL
			GROUP BY	MERCHANT_ID,
					SHORT_NAME,
					PSP_CLIENT_ID,
					PSP_ID,
                            		CURRENCY_ID,
					LIMIT,
					REMAINING_LIMIT,
					CG_CODE,
					CG_DESC
		)
		GROUP BY 	MERCHANT_ID, 
				SHORT_NAME,
				CURRENCY_ID,
				CUSTOMER_SEGMENT_CODE,
				CUSTOMER_SEGMENT_DESC                                                       
		) overflow_summary
		WHERE normal_summary.MERCHANT_ID = sarip_summary.MERCHANT_ID
		AND normal_summary.CURRENCY_ID = sarip_summary.CURRENCY_ID
		AND normal_summary.MERCHANT_ID = overflow_summary.MERCHANT_ID
		AND normal_summary.CURRENCY_ID = overflow_summary.CURRENCY_ID
		AND sarip_summary.MERCHANT_ID = overflow_summary.MERCHANT_ID
		AND sarip_summary.CURRENCY_ID = overflow_summary.CURRENCY_ID
		GROUP BY 	normal_summary.SHORT_NAME,
				normal_summary.CURRENCY_ID,
				normal_summary.CUSTOMER_SEGMENT_CODE,
				normal_summary.CUSTOMER_SEGMENT_DESC,
				normal_summary.REMAINING_LIMIT,
				sarip_summary.SARIP_REMAINING_LIMIT,
				overflow_summary.OVERFLOW_REMAINING_LIMIT
		ORDER BY	normal_summary.SHORT_NAME,
				normal_summary.CURRENCY_ID,
				normal_summary.CUSTOMER_SEGMENT_CODE,
				normal_summary.CUSTOMER_SEGMENT_DESC;
			
		

	EXEC SQL OPEN c_summary;
	for (;;) {
		EXEC SQL FETCH c_summary
		INTO
			:v_short_name:ind_short_name,
			:v_currency:ind_currency,
			:v_cg_code:ind_cg_code,
			:v_cg_desc:ind_cg_desc,
			:v_remaining_limit_normal:ind_remaining_limit_normal,
			:v_remaining_limit_sarip:ind_remaining_limit_sarip,
			:v_remaining_limit_overflow:ind_remaining_limit_overflow;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

printf("%s",PD_OPEN_TAG);

		if (ind_short_name >= 0) {
			v_short_name.arr[v_short_name.len]='\0';
printf("%s",(char*)v_short_name.arr);
DEBUGLOG(("psp_limit_report_summary() short_name = [%s]\n",v_short_name.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_currency >= 0) {
			v_currency.arr[v_currency.len]='\0';
DEBUGLOG(("psp_limit_report_summary() currency = [%s]\n",v_currency.arr));
		}

		if (ind_cg_code >= 0) {
			v_cg_code.arr[v_cg_code.len]='\0';
DEBUGLOG(("psp_limit_report_summary() cg_code = [%s]\n",v_cg_code.arr));
		}

		if (ind_cg_desc >= 0) {
			v_cg_desc.arr[v_cg_desc.len]='\0';
printf("%s",(char*)v_cg_desc.arr);
DEBUGLOG(("psp_limit_report_summary() cg_desc = [%s]\n",v_cg_desc.arr));
		}

		if (ind_remaining_limit_normal >= 0) {
			if (v_remaining_limit_normal > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit_normal,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_remaining_limit_normal),2));
			}
DEBUGLOG(("psp_remaining_limit_normal_report_summary() remaining_limit_normal = [%.2lf]\n",v_remaining_limit_normal));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

		if (ind_remaining_limit_sarip >= 0) {
			if (v_remaining_limit_sarip > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit_sarip,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_remaining_limit_sarip),2));
			}
//printf("%.2lf",v_remaining_limit_sarip);
DEBUGLOG(("psp_remaining_limit_sarip_report_summary() remaining_limit_sarip = [%.2lf]\n",v_remaining_limit_sarip));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

		if (ind_remaining_limit_overflow >= 0) {
			if (v_remaining_limit_overflow > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit_overflow,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_remaining_limit_overflow),2));
			}
//printf("%.2lf",v_remaining_limit_overflow);
DEBUGLOG(("psp_remaining_limit_overflow_report_summary() remaining_limit_overflow = [%.2lf]\n",v_remaining_limit_overflow));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

printf("%s\n",PD_END_TAG);

		/*	
		if (ind_cnt >= 0) {
DEBUGLOG(("psp_limit_report_summary() cnt = [%d]\n",v_cnt));
		}	
		*/

	}
	EXEC SQL CLOSE c_summary;

DEBUGLOG(("psp_limit_report_summary() iRet = [%d]\n",iRet));
	return iRet;

summary_error:
DEBUGLOG(("psp_limit_report_summary error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_summary;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int psp_limit_report_summary_total(char* csCheckGroup)
{
	int     iRet = SUCCESS;

	EXEC SQL WHENEVER SQLERROR GOTO summary_total_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_check_group[EML_CHK_GRP_LEN + 1];

		double	v_remaining_limit;
		short	ind_remaining_limit = -1;

	EXEC SQL END DECLARE SECTION;

	hv_check_group.len = strlen((char*)csCheckGroup);
	memcpy(hv_check_group.arr,csCheckGroup,hv_check_group.len);

	EXEC SQL DECLARE c_summary_total CURSOR FOR
		SELECT NVL(SUM(REMAINING_LIMIT), 0) AS REMAINING_LIMIT
		FROM (
			SELECT MERCHANT_ID AS MERCHANT_ID,
				SHORT_NAME AS SHORT_NAME,
				PSP_CLIENT_ID AS PSP_CLIENT_ID,
				PSP_ID AS PSP_ID,
				CURRENCY_ID AS CURRENCY_ID,
				LIMIT AS LIMIT,
				CG_CODE AS CUSTOMER_SEGMENT_CODE,
				CG_DESC AS CUSTOMER_SEGMENT_DESC,
				CASE
					WHEN (REMAINING_LIMIT > 0)
						THEN REMAINING_LIMIT
					ELSE 0
					END AS REMAINING_LIMIT,
				MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
				MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT
			FROM PSP_LIMIT_MERCHANT_VIEW
			LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = CUSTOMER_SEGMENT
			WHERE MERCHANT_ID IN   (SELECT EPM_PARTY_ID
						FROM EMAIL_CHECK_PARTY_MAP
						WHERE EPM_NAME = 'PSP_LIMIT'
						AND EPM_GROUP = :hv_check_group
						AND EPM_PARTY_TYPE = 'M'
						AND EPM_SUPPORT_MULTI_ENTRY = 1
						)
				/* AND SERVICE_CODE = 'VNC' */
			GROUP BY MERCHANT_ID,
				SHORT_NAME,
				PSP_CLIENT_ID,
				PSP_ID,
				CURRENCY_ID,
				LIMIT,
				REMAINING_LIMIT,
				CG_CODE,
				CG_DESC
			) summary;


	EXEC SQL OPEN c_summary_total;
	for (;;) {
		EXEC SQL FETCH c_summary_total
		INTO
			:v_remaining_limit:ind_remaining_limit;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

printf("%sTotal",PD_OPEN_TAG);
printf("%s",PD_NEXT_TAG);
		if (ind_remaining_limit >= 0) {
			if (v_remaining_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_remaining_limit),2));
			}
//printf("%.2lf",v_remaining_limit);
DEBUGLOG(("psp_limit_report_summary_total() remaining_limit = [%.2lf]\n",v_remaining_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}
printf("%s",PD_NEXT_TAG_CS);
printf("%s",PD_NEXT_TAG_CS);
printf("%s\n",PD_END_TAG);

	}
	EXEC SQL CLOSE c_summary_total;

printf("</table>\n");

DEBUGLOG(("psp_limit_report_summary_total() iRet = [%d]\n",iRet));
	return iRet;

summary_total_error:
DEBUGLOG(("psp_limit_report_summary_total error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_summary_total;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int psp_limit_report_merchant(char* csCheckGroup, int iShowEmptyCSegment)
{
	int     iRet = SUCCESS;
	int	iCnt = 0;
	char	csCSegment[PD_DESC_LEN + 1];
	strcpy(csCSegment,"");

	EXEC SQL WHENEVER SQLERROR GOTO merchant_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_check_group[EML_CHK_GRP_LEN + 1];

		//varchar	v_merchant_id[PD_MERCHANT_ID_LEN + 1];
		varchar	v_client_id[PD_CLIENT_ID_LEN + 1];
		varchar	v_client_name[PD_CLIENT_NAME_LEN + 1];
		varchar	v_psp_id[PD_PSP_ID_LEN + 1];
		varchar	v_psp_name[PD_PSP_NAME_LEN + 1];
		varchar	v_remark[PD_REMARK_LEN + 1];
		varchar	v_currency[PD_CCY_ID_LEN + 1];
		//double	v_ratio;
		varchar	v_customer_segment[PD_DESC_LEN + 1];
		double	v_limit;
		double	v_remaining_limit;
		double	v_min_txn_amount;
		double	v_max_txn_amount;
		//int	v_criteria_pool_id;
		//int	v_pool_id;
		int	v_cnt;

		//short	ind_merchant_id = -1;
		short	ind_client_id = -1;
		short	ind_client_name = -1;
		short	ind_psp_id = -1;
		short	ind_psp_name = -1;
		short	ind_remark = -1;
		short	ind_currency = -1;
		//short	ind_ratio = -1;
		short	ind_customer_segment = -1;
		short	ind_limit = -1;
		short	ind_remaining_limit = -1;
		short	ind_min_txn_amount = -1;
		short	ind_max_txn_amount = -1;
		//short	ind_criteria_pool_id = -1;
		//short	ind_pool_id = -1;
		short	ind_cnt = -1;

	EXEC SQL END DECLARE SECTION;

	hv_check_group.len = strlen((char*)csCheckGroup);
	memcpy(hv_check_group.arr,csCheckGroup,hv_check_group.len);

	EXEC SQL DECLARE c_merchant CURSOR FOR
		SELECT	/* CLIENT_ID AS CLIENT_ID,
			CLIENT_NAME AS CLIENT_NAME,*/
			--MERCHANT_ID AS MERCHANT_ID,
			/*SHORT_NAME AS SHORT_NAME,
			BUSINESS_TYPE AS BUSINESS_TYPE, */
			PSP_CLIENT_ID AS PSP_CLIENT_ID,
			PSP_CLIENT_NAME AS PSP_CLIENT_NAME,
			PSP_ID AS PSP_ID,
			PSP_NAME AS PSP_NAME,
			PSP_REMARK AS PSP_REMARK,
			CURRENCY_ID AS CURRENCY_ID,
			LIMIT AS LIMIT,
			REMAINING_LIMIT AS REMAINING_LIMIT,
			MIN_TRANSACTION_AMOUNT AS MIN_TRANSACTION_AMOUNT,
			MAX_TRANSACTION_AMOUNT AS MAX_TRANSACTION_AMOUNT,
			NVL(CUSTOMER_SEGMENT_DESC,'-') AS CUSTOMER_SEGMENT,
			--CRITERIA_POOL_ID AS CRITERIA_POOL_ID,
			--POOL_ID AS POOL_ID,
			/*POOL_RATIO AS POOL_RATIO_BAK, */
			--POOL_RM_RATIO AS POOL_RATIO,
			count(*) OVER () AS TOTAL_ROWS
		FROM (
			SELECT CLIENT_ID AS CLIENT_ID,
				CLIENT_NAME AS CLIENT_NAME,
				--MERCHANT_ID AS MERCHANT_ID,
				--SHORT_NAME AS SHORT_NAME,
				BUSINESS_TYPE AS BUSINESS_TYPE,
				PSP_CLIENT_ID AS PSP_CLIENT_ID,
				PSP_CLIENT_NAME AS PSP_CLIENT_NAME,
				PSP_ID AS PSP_ID,
				PSP_NAME AS PSP_NAME,
				PSP_REMARK AS PSP_REMARK,
				CURRENCY_ID AS CURRENCY_ID,
				LIMIT AS LIMIT,
				REMAINING_LIMIT AS REMAINING_LIMIT,
				MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
				MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT,
				CUSTOMER_SEGMENT AS CUSTOMER_SEGMENT_CODE,
				CUSTOMER_GROUP.CG_DESC AS CUSTOMER_SEGMENT_DESC
				/*CRITERIA_POOL_ID AS CRITERIA_POOL_ID,
				POOL_ID AS POOL_ID,
				POOL_RATIO AS POOL_RATIO,
				POOL_RM_RATIO AS POOL_RM_RATIO*/
			FROM PSP_LIMIT_MERCHANT_VIEW
			LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = PSP_LIMIT_MERCHANT_VIEW.CUSTOMER_SEGMENT
			WHERE MERCHANT_ID IN   (SELECT EPM_PARTY_ID
						FROM EMAIL_CHECK_PARTY_MAP
						WHERE EPM_NAME = 'PSP_LIMIT'
						AND EPM_GROUP = :hv_check_group
						AND EPM_PARTY_TYPE = 'M'
						AND EPM_SUPPORT_MULTI_ENTRY = 1
						)
			GROUP BY CLIENT_ID,
				CLIENT_NAME,
				--MERCHANT_ID,
				--SHORT_NAME,
				BUSINESS_TYPE,
				PSP_CLIENT_ID,
				PSP_CLIENT_NAME,
				PSP_ID,
				PSP_NAME,
				PSP_REMARK,
				CURRENCY_ID,
				LIMIT,
				REMAINING_LIMIT,
				CUSTOMER_SEGMENT,
				CG_DESC
				/*CRITERIA_POOL_ID,
				POOL_ID,
				POOL_RATIO,
				POOL_RM_RATIO*/
			) summary
		WHERE 1 = 1
		ORDER BY
			CUSTOMER_SEGMENT,
			--MERCHANT_ID,
			CLIENT_NAME,
			--SHORT_NAME,
			UPPER(PSP_NAME),
			CURRENCY_ID;

	EXEC SQL OPEN c_merchant;
	for (;;) {
		EXEC SQL FETCH c_merchant
		INTO
			:v_client_id:ind_client_id,
			:v_client_name:ind_client_name,
			:v_psp_id:ind_psp_id,
			:v_psp_name:ind_psp_name,
			:v_remark:ind_remark,
			:v_currency:ind_currency,
			:v_limit:ind_limit,
			:v_remaining_limit:ind_remaining_limit,
			:v_min_txn_amount:ind_min_txn_amount,
			:v_max_txn_amount:ind_max_txn_amount,
			:v_customer_segment:ind_customer_segment,
			:v_cnt:ind_cnt;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

		if (ind_customer_segment >= 0) {
			v_customer_segment.arr[v_customer_segment.len]='\0';

			if (!strcmp((char*)v_customer_segment.arr,"-") && !iShowEmptyCSegment) continue;

			if (strcmp(csCSegment,(char*)v_customer_segment.arr)) {
				strcpy(csCSegment,(char*)v_customer_segment.arr);

if (iCnt > 1) printf("</table>\n");
if (strcmp(csCSegment,"-")) printf("<h2>%s</h2>\n",csCSegment);

printf("<table border='1'>\n");
printf("<tr><th>PSP Name</th><th>PSP Account Name</th><th>Remark</th><th>Currency</th><th>Customer Segment</th><th>PID Limit</th><th>PSP Remaining Limit</th></tr>\n");
			}
		}

		if (ind_client_id >= 0) {
			v_client_id.arr[v_client_id.len]='\0';
DEBUGLOG(("psp_limit_report_merchant() client_id = [%s]\n",v_client_id.arr));
		}

printf("%s",PD_OPEN_TAG);

		if (ind_client_name >= 0) {
			v_client_name.arr[v_client_name.len]='\0';
printf("%s",(char*)v_client_name.arr);
DEBUGLOG(("psp_limit_report_merchant() client_name = [%s]\n",v_client_name.arr));
		}

		if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len]='\0';
DEBUGLOG(("psp_limit_report_merchant() psp_id = [%s]\n",v_psp_id.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_psp_name >= 0) {
			v_psp_name.arr[v_psp_name.len]='\0';
printf("%s",(char*)v_psp_name.arr);
DEBUGLOG(("psp_limit_report_merchant() psp_name = [%s]\n",v_psp_name.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_remark >= 0) {
			v_remark.arr[v_remark.len]='\0';
printf("%s",(char*)v_remark.arr);
DEBUGLOG(("psp_limit_report_merchant() remark = [%s]\n",v_remark.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_currency >= 0) {
			v_currency.arr[v_currency.len]='\0';
printf("%s",(char*)v_currency.arr);
DEBUGLOG(("psp_limit_report_merchant() currency = [%s]\n",v_currency.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_customer_segment >= 0) {
			v_customer_segment.arr[v_customer_segment.len]='\0';
printf("%s",(char*)v_customer_segment.arr);
DEBUGLOG(("psp_limit_report_merchant() customer_segment = [%s]\n",v_customer_segment.arr));
		}

		if (ind_limit >= 0) {
			if (v_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_limit),2));
			}
//printf("%.2lf",v_limit);
DEBUGLOG(("psp_limit_report_merchant() limit = [%.2lf]\n",v_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

		if (ind_remaining_limit >= 0) {
			if (v_remaining_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_remaining_limit),2));
			}
//printf("%.2lf",v_remaining_limit);
DEBUGLOG(("psp_limit_report_merchant() remaining_limit = [%.2lf]\n",v_remaining_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

printf("%s\n",PD_END_TAG);

		if (ind_cnt >= 0) {
DEBUGLOG(("psp_limit_report_merchant() cnt = [%d]\n",v_cnt));
		}
	}
	EXEC SQL CLOSE c_merchant;

//if (iCnt > 1) printf("</table>\n");
if (iCnt >= 1) printf("</table>\n");

DEBUGLOG(("psp_limit_report_merchant() iRet = [%d]\n",iRet));
	return iRet;

merchant_error:
DEBUGLOG(("psp_limit_report_merchant error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_merchant;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int psp_limit_report_group_o(char* csCheckGroup)
{
	int     iRet = SUCCESS;
	int	iCnt = 0;

printf("<h2>%s</h2>\n","Segment Overflow");

printf("<table border='1'>\n");
printf("<tr><th>PSP Name</th><th>PSP Account Name</th><th>Remark</th><th>Currency</th><th>Customer Segment</th><th>PID Limit</th><th>PSP Remaining Limit</th></tr>\n");

	EXEC SQL WHENEVER SQLERROR GOTO merchant_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_check_group[EML_CHK_GRP_LEN + 1];

		//varchar	v_merchant_id[PD_MERCHANT_ID_LEN + 1];
		varchar	v_client_id[PD_CLIENT_ID_LEN + 1];
		varchar	v_client_name[PD_CLIENT_NAME_LEN + 1];
		varchar	v_psp_id[PD_PSP_ID_LEN + 1];
		varchar	v_psp_name[PD_PSP_NAME_LEN + 1];
		varchar	v_remark[PD_REMARK_LEN + 1];
		varchar	v_currency[PD_CCY_ID_LEN + 1];
		//double	v_ratio;
		varchar	v_customer_segment[PD_DESC_LEN + 1];
		double	v_limit;
		double	v_remaining_limit;
		double	v_min_txn_amount;
		double	v_max_txn_amount;
		//int	v_criteria_pool_id;
		//int	v_pool_id;
		int	v_cnt;

		//short	ind_merchant_id = -1;
		short	ind_client_id = -1;
		short	ind_client_name = -1;
		short	ind_psp_id = -1;
		short	ind_psp_name = -1;
		short	ind_remark = -1;
		short	ind_currency = -1;
		//short	ind_ratio = -1;
		short	ind_customer_segment = -1;
		short	ind_limit = -1;
		short	ind_remaining_limit = -1;
		short	ind_min_txn_amount = -1;
		short	ind_max_txn_amount = -1;
		//short	ind_criteria_pool_id = -1;
		//short	ind_pool_id = -1;
		short	ind_cnt = -1;

	EXEC SQL END DECLARE SECTION;

	hv_check_group.len = strlen((char*)csCheckGroup);
	memcpy(hv_check_group.arr,csCheckGroup,hv_check_group.len);

	EXEC SQL DECLARE c_group_o CURSOR FOR
		SELECT	/* CLIENT_ID AS CLIENT_ID,
			CLIENT_NAME AS CLIENT_NAME,
			MERCHANT_ID AS MERCHANT_ID,*/
			/*SHORT_NAME AS SHORT_NAME,
			BUSINESS_TYPE AS BUSINESS_TYPE, */
			PSP_CLIENT_ID AS PSP_CLIENT_ID,
			PSP_CLIENT_NAME AS PSP_CLIENT_NAME,
			PSP_ID AS PSP_ID,
			PSP_NAME AS PSP_NAME,
			PSP_REMARK AS PSP_REMARK,
			CURRENCY_ID AS CURRENCY_ID,
			LIMIT AS LIMIT,
			REMAINING_LIMIT AS REMAINING_LIMIT,
			MIN_TRANSACTION_AMOUNT AS MIN_TRANSACTION_AMOUNT,
			MAX_TRANSACTION_AMOUNT AS MAX_TRANSACTION_AMOUNT,
			NVL(CUSTOMER_SEGMENT_DESC,'-') AS CUSTOMER_SEGMENT,
			--CRITERIA_POOL_ID AS CRITERIA_POOL_ID,
			--POOL_ID AS POOL_ID,
			/*POOL_RATIO AS POOL_RATIO_BAK, */
			--POOL_RM_RATIO AS POOL_RATIO,
			count(*) OVER () AS TOTAL_ROWS
		FROM (
			SELECT CLIENT_ID AS CLIENT_ID,
				CLIENT_NAME AS CLIENT_NAME,
				--MERCHANT_ID AS MERCHANT_ID,
				--SHORT_NAME AS SHORT_NAME,
				BUSINESS_TYPE AS BUSINESS_TYPE,
				PSP_CLIENT_ID AS PSP_CLIENT_ID,
				PSP_CLIENT_NAME AS PSP_CLIENT_NAME,
				PSP_ID AS PSP_ID,
				PSP_NAME AS PSP_NAME,
				PSP_REMARK AS PSP_REMARK,
				CURRENCY_ID AS CURRENCY_ID,
				LIMIT AS LIMIT,
				REMAINING_LIMIT AS REMAINING_LIMIT,
				MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
				MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT,
				CUSTOMER_SEGMENT AS CUSTOMER_SEGMENT_CODE,
				CUSTOMER_GROUP.CG_DESC AS CUSTOMER_SEGMENT_DESC
				--CRITERIA_POOL_ID AS CRITERIA_POOL_ID,
				--POOL_ID AS POOL_ID,
				--POOL_RATIO AS POOL_RATIO,
				--POOL_RM_RATIO AS POOL_RM_RATIO
			FROM PSP_LIMIT_MERCHANT_VIEW
			LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = PSP_LIMIT_MERCHANT_VIEW.CUSTOMER_SEGMENT
			WHERE MERCHANT_ID IN   (SELECT EPM_PARTY_ID
						FROM EMAIL_CHECK_PARTY_MAP
						WHERE EPM_NAME = 'PSP_LIMIT'
						AND EPM_GROUP = :hv_check_group
						AND EPM_PARTY_TYPE = 'M'
						AND EPM_SUPPORT_MULTI_ENTRY = 1
						)
			AND psp_id in ( select psp_id from psp_detail where pid_group = 'GRP_O')
			GROUP BY CLIENT_ID,
				CLIENT_NAME,
				--MERCHANT_ID,
				--SHORT_NAME,
				BUSINESS_TYPE,
				PSP_CLIENT_ID,
				PSP_CLIENT_NAME,
				PSP_ID,
				PSP_NAME,
				PSP_REMARK,
				CURRENCY_ID,
				LIMIT,
				REMAINING_LIMIT,
				CUSTOMER_SEGMENT,
				CG_DESC
				--CRITERIA_POOL_ID,
				--POOL_ID,
				--POOL_RATIO,
				--POOL_RM_RATIO
			) summary
		WHERE 1 = 1
		ORDER BY 
			--MERCHANT_ID,
			CUSTOMER_SEGMENT,
			CLIENT_NAME,
			--SHORT_NAME,
			UPPER(PSP_NAME),
			CURRENCY_ID;

	EXEC SQL OPEN c_group_o;
	for (;;) {
		EXEC SQL FETCH c_group_o
		INTO
			//:v_merchant_id:ind_merchant_id,
			:v_client_id:ind_client_id,
			:v_client_name:ind_client_name,
			:v_psp_id:ind_psp_id,
			:v_psp_name:ind_psp_name,
			:v_remark:ind_remark,
			:v_currency:ind_currency,
			:v_limit:ind_limit,
			:v_remaining_limit:ind_remaining_limit,
			:v_min_txn_amount:ind_min_txn_amount,
			:v_max_txn_amount:ind_max_txn_amount,
			:v_customer_segment:ind_customer_segment,
			//:v_criteria_pool_id:ind_criteria_pool_id,
			//:v_pool_id:ind_pool_id,
			//:v_ratio:ind_ratio,
			:v_cnt:ind_cnt;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

		if (ind_client_id >= 0) {
			v_client_id.arr[v_client_id.len]='\0';
DEBUGLOG(("psp_limit_report_group_o() client_id = [%s]\n",v_client_id.arr));
		}

printf("%s",PD_OPEN_TAG);

		if (ind_client_name >= 0) {
			v_client_name.arr[v_client_name.len]='\0';
printf("%s",(char*)v_client_name.arr);
DEBUGLOG(("psp_limit_report_group_o() client_name = [%s]\n",v_client_name.arr));
		}

		if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len]='\0';
DEBUGLOG(("psp_limit_report_group_o() psp_id = [%s]\n",v_psp_id.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_psp_name >= 0) {
			v_psp_name.arr[v_psp_name.len]='\0';
printf("%s",(char*)v_psp_name.arr);
DEBUGLOG(("psp_limit_report_group_o() psp_name = [%s]\n",v_psp_name.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_remark >= 0) {
			v_remark.arr[v_remark.len]='\0';
printf("%s",(char*)v_remark.arr);
DEBUGLOG(("psp_limit_report_group_o() remark = [%s]\n",v_remark.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_currency >= 0) {
			v_currency.arr[v_currency.len]='\0';
printf("%s",(char*)v_currency.arr);
DEBUGLOG(("psp_limit_report_group_o() currency = [%s]\n",v_currency.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_customer_segment >= 0) {
			v_customer_segment.arr[v_customer_segment.len]='\0';
printf("%s",(char*)v_customer_segment.arr);
DEBUGLOG(("psp_limit_report_group_o() customer_segment = [%s]\n",v_customer_segment.arr));
		}

		if (ind_limit >= 0) {
			if (v_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_limit),2));
			}
//printf("%.2lf",v_limit);
DEBUGLOG(("psp_limit_report_group_o() limit = [%.2lf]\n",v_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

		if (ind_remaining_limit >= 0) {
			if (v_remaining_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_remaining_limit),2));
			}
//printf("%.2lf",v_remaining_limit);
DEBUGLOG(("psp_limit_report_group_o() remaining_limit = [%.2lf]\n",v_remaining_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

printf("%s\n",PD_END_TAG);

		if (ind_cnt >= 0) {
DEBUGLOG(("psp_limit_report_group_o() cnt = [%d]\n",v_cnt));
		}
	}
	EXEC SQL CLOSE c_group_o;

printf("</table>\n");

DEBUGLOG(("psp_limit_report_group_o() iRet = [%d]\n",iRet));
	return iRet;

merchant_error:
DEBUGLOG(("psp_limit_report_group_o error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_group_o;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int psp_limit_report_group_pool(char *csPoolId, char *csServiceCode)
{
	int     iRet = SUCCESS;
	int	iCnt = 0;
	int	iPool = -1;

	EXEC SQL WHENEVER SQLERROR GOTO service_pool_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		varchar hv_service_code[PD_SERVICE_CODE_LEN];
		varchar hv_pool_id[PD_MERCHANT_ID_LEN];

		varchar	v_client_id[PD_CLIENT_ID_LEN + 1];
		varchar	v_client_name[PD_CLIENT_NAME_LEN + 1];
		varchar	v_psp_id[PD_PSP_ID_LEN + 1];
		varchar	v_psp_name[PD_PSP_NAME_LEN + 1];
		varchar	v_remark[PD_REMARK_LEN + 1];
		varchar	v_currency[PD_CCY_ID_LEN + 1];
		int	v_pool_id;
		int	v_ratio;
		int	v_priority;
		varchar	v_customer_segment[PD_DESC_LEN + 1];
		double	v_limit;
		double	v_remaining_limit;
		double	v_min_txn_amount;
		double	v_max_txn_amount;
		//int	v_criteria_pool_id;

		short	ind_client_id = -1;
		short	ind_client_name = -1;
		short	ind_psp_id = -1;
		short	ind_psp_name = -1;
		short	ind_remark = -1;
		short	ind_currency = -1;
		short	ind_pool_id = -1;
		short	ind_ratio = -1;
		short	ind_priority = -1;
		short	ind_customer_segment = -1;
		short	ind_limit = -1;
		short	ind_remaining_limit = -1;
		short	ind_min_txn_amount = -1;
		short	ind_max_txn_amount = -1;
		//short	ind_criteria_pool_id = -1;

	EXEC SQL END DECLARE SECTION;

	hv_pool_id.len = strlen((char*)csPoolId);
	memcpy(hv_pool_id.arr,csPoolId,hv_pool_id.len);

	hv_service_code.len = strlen((char*)csServiceCode);
	memcpy(hv_service_code.arr,csServiceCode,hv_service_code.len);

	EXEC SQL DECLARE c_service_pool CURSOR FOR
		SELECT	PSP_CLIENT_ID AS PSP_CLIENT_ID,
			PSP_CLIENT_NAME AS PSP_CLIENT_NAME,
			PSP_ID AS PSP_ID,
			PSP_NAME AS PSP_NAME,
			PSP_REMARK AS PSP_REMARK,
			CURRENCY_ID AS CURRENCY_ID,
			LIMIT AS LIMIT,
			REMAINING_LIMIT AS REMAINING_LIMIT,
			MIN(MIN_TRANSACTION_AMOUNT) AS MIN_TRANSACTION_AMOUNT,
			MAX(MAX_TRANSACTION_AMOUNT) AS MAX_TRANSACTION_AMOUNT,
			NVL(CUSTOMER_SEGMENT,'-') AS CUSTOMER_SEGMENT,
			--CRITERIA_POOL_ID AS CRITERIA_POOL_ID,
			POOL_ID AS POOL_ID,
			POOL_RM_RATIO,
			RM_PRIORITY
		FROM PSP_LIMIT_MERCHANT_VIEW
		LEFT JOIN CUSTOMER_GROUP ON CUSTOMER_GROUP.CG_CODE = PSP_LIMIT_MERCHANT_VIEW.CUSTOMER_SEGMENT,
		RULE_PSP_LB_MAPPING
		WHERE SERVICE_CODE = :hv_service_code
		AND (POOL_ID = :hv_pool_id or :hv_pool_id = '000')
		AND POOL_ID = RM_POOL_ID
		AND PSP_ID = RM_PSP_ID
		AND RM_DISABLED = 0
		GROUP BY PSP_CLIENT_ID,
			PSP_CLIENT_NAME,
			PSP_ID,
			PSP_NAME,
			PSP_REMARK,
			CURRENCY_ID,
			LIMIT,
			REMAINING_LIMIT,
			CUSTOMER_SEGMENT,
			--CRITERIA_POOL_ID,
			POOL_ID,
			POOL_RM_RATIO,
			RM_PRIORITY
		ORDER BY
			POOL_ID,
			CUSTOMER_SEGMENT,
			UPPER(PSP_NAME),
			CURRENCY_ID;

	EXEC SQL OPEN c_service_pool;
	for (;;) {
		EXEC SQL FETCH c_service_pool
		INTO
			:v_client_id:ind_client_id,
			:v_client_name:ind_client_name,
			:v_psp_id:ind_psp_id,
			:v_psp_name:ind_psp_name,
			:v_remark:ind_remark,
			:v_currency:ind_currency,
			:v_limit:ind_limit,
			:v_remaining_limit:ind_remaining_limit,
			:v_min_txn_amount:ind_min_txn_amount,
			:v_max_txn_amount:ind_max_txn_amount,
			:v_customer_segment:ind_customer_segment,
			//:v_criteria_pool_id:ind_criteria_pool_id,
			:v_pool_id:ind_pool_id,
			:v_ratio:ind_ratio,
			:v_priority:ind_priority;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		iCnt++;

		if (ind_pool_id >= 0) {
DEBUGLOG(("psp_limit_report_group_pool() pool_id = [%d]\n",(int)v_pool_id));
			if (iPool != v_pool_id) {
				iPool = v_pool_id;
if (iCnt > 1) printf("</table>\n");
printf("<h2>%s %d</h2>\n","Pool",iPool);

printf("<table border='1'>\n");
//printf("<tr><th>PSP Name</th><th>PSP Account Name</th><th>Remark</th><th>Currency</th><th>Ratio</th><th>Customer Segment</th><th>PID Limit</th><th>PSP Remaining Limit</th></tr>\n");
printf("<tr><th>PSP Name</th><th>PSP Account Name</th><th>Remark</th><th>Currency<th>Priority</th><th>PID Limit</th><th>PSP Remaining Limit</th></tr>\n");
			}
		}

		if (ind_client_id >= 0) {
			v_client_id.arr[v_client_id.len]='\0';
DEBUGLOG(("psp_limit_report_group_pool() client_id = [%s]\n",v_client_id.arr));
		}

printf("%s",PD_OPEN_TAG);

		if (ind_client_name >= 0) {
			v_client_name.arr[v_client_name.len]='\0';
printf("%s",(char*)v_client_name.arr);
DEBUGLOG(("psp_limit_report_group_pool() client_name = [%s]\n",v_client_name.arr));
		}

		if (ind_psp_id >= 0) {
			v_psp_id.arr[v_psp_id.len]='\0';
DEBUGLOG(("psp_limit_report_group_pool() psp_id = [%s]\n",v_psp_id.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_psp_name >= 0) {
			v_psp_name.arr[v_psp_name.len]='\0';
printf("%s",(char*)v_psp_name.arr);
DEBUGLOG(("psp_limit_report_group_pool() psp_name = [%s]\n",v_psp_name.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_remark >= 0) {
			v_remark.arr[v_remark.len]='\0';
printf("%s",(char*)v_remark.arr);
DEBUGLOG(("psp_limit_report_group_pool() remark = [%s]\n",v_remark.arr));
		}

printf("%s",PD_NEXT_TAG);

		if (ind_currency >= 0) {
			v_currency.arr[v_currency.len]='\0';
printf("%s",(char*)v_currency.arr);
DEBUGLOG(("psp_limit_report_group_pool() currency = [%s]\n",v_currency.arr));
		}

printf("%s",PD_NEXT_TAG_CS);

		if (ind_priority >= 0) {
printf("%d",(int)v_priority);
DEBUGLOG(("psp_limit_report_group_pool() priority = [%d]\n",(int)v_priority));
		}

//printf("%s",PD_NEXT_TAG);
//
//		if (ind_customer_segment >= 0) {
//			v_customer_segment.arr[v_customer_segment.len]='\0';
//printf("%s",(char*)v_customer_segment.arr);
//DEBUGLOG(("psp_limit_report_group_pool() customer_segment = [%s]\n",v_customer_segment.arr));
//		}

		if (ind_limit >= 0) {
			if (v_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_limit),2));
			}
//printf("%.2lf",v_limit);
DEBUGLOG(("psp_limit_report_group_pool() limit = [%.2lf]\n",v_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

		if (ind_remaining_limit >= 0) {
			if (v_remaining_limit > 1E-9) {
printf("%s",PD_NEXT_TAG_CS);
printf("%s",commaprintdouble(v_remaining_limit,2));
			} else {
printf("%s",PD_NEXT_TAG_CS_RED);
printf("-%s",commaprintdouble(fabs(v_remaining_limit),2));
			}
//printf("%.2lf",v_remaining_limit);
DEBUGLOG(("psp_limit_report_group_pool() remaining_limit = [%.2lf]\n",v_remaining_limit));
		} else {
printf("%s",PD_NEXT_TAG_CS_RED);
		}

printf("%s\n",PD_END_TAG);
	}
	EXEC SQL CLOSE c_service_pool;

//if (iCnt > 1) printf("</table>\n");
if (iCnt >= 1) printf("</table>\n");

DEBUGLOG(("psp_limit_report_group_pool() iRet = [%d]\n",iRet));
	return iRet;

service_pool_error:
DEBUGLOG(("psp_limit_report_group_pool error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE c_service_pool;
    EXEC SQL ROLLBACK RELEASE;
    return PD_ERR;
}


int find_limit_to_gen(recordset_t *myRec)
{
	int	iRet = SUCCESS;

	hash_t *myHash;

	EXEC SQL WHENEVER SQLERROR GOTO find_error;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL BEGIN DECLARE SECTION;

		char	v_party_type;
		varchar	v_party_id[PD_MERCHANT_ID_LEN + 1];
		varchar	v_service_code[PD_SERVICE_CODE_LEN + 1];

		short	ind_party_type = -1;
		short	ind_party_id = -1;
		short	ind_service_code = -1;

	EXEC SQL END DECLARE SECTION;
	
	EXEC SQL DECLARE c_cursor_findlimittogen CURSOR FOR
		SELECT	PG_PARTY_TYPE,
			PG_PARTY_ID,
			PG_SERVICE_CODE
		FROM	PSP_LIMIT_GEN
		WHERE	PG_DISABLED = 0
		ORDER BY PG_PARTY_TYPE, PG_PARTY_ID, PG_SERVICE_CODE;

	EXEC SQL OPEN c_cursor_findlimittogen;

	for (;;) {
		EXEC SQL FETCH c_cursor_findlimittogen
		INTO	:v_party_type:ind_party_type,
			:v_party_id:ind_party_id,
			:v_service_code:ind_service_code;

		if (SQLCODE == SQL_NOT_FOUND) {
			break;
		}

		myHash = (hash_t*) malloc (sizeof(hash_t));
		hash_init(myHash, 0);

		// party_type
		if (ind_party_type >= 0) {
			PutField_Char(myHash, "party_type", v_party_type);
DEBUGLOG(("find_limit_gen party_type = [%c]\n", v_party_type));
		}

		// party_id
		if (ind_party_id >= 0) {
			v_party_id.arr[v_party_id.len] = '\0';
			PutField_CString(myHash, "party_id", (const char*)v_party_id.arr);
DEBUGLOG(("find_limit_gen party_id = [%s]\n", (const char*)v_party_id.arr));
		}

		// service_code
		if (ind_service_code >= 0) {
			v_service_code.arr[v_service_code.len] = '\0';
			PutField_CString(myHash, "service_code", (const char*)v_service_code.arr);
DEBUGLOG(("find_limit_gen service_code = [%s]\n", (const char*)v_service_code.arr));
		}

		RecordSet_Add(myRec, myHash);
	}

	EXEC SQL CLOSE c_cursor_findlimittogen;

DEBUGLOG(("find_limit_gen Normal Exit! iRet = [%d]\n", iRet));
	return iRet;

find_error:
DEBUGLOG(("find_limit_to_gen error code %d\n", sqlca.sqlcode));
DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
ERRLOG("gen_psp_limit_report find_limit_gen code %d\n", sqlca.sqlcode);
ERRLOG("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	EXEC SQL CLOSE c_cursor_findlimittogen;
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	return PD_ERR;
}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}


int parse_arg(int argc, char **argv)
{
	return SUCCESS;
}
