#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "expat.h"
#include <curl/curl.h>
#include "getrate.h"
#include "myhash.h"
#include "ObjPtr.h"
#include "numutility.h"
#include "myrecordset.h"

#include "ExchangeRate.h"


OBJPTR(DB);
char    cDebug;

struct string
{
	char *ptr;
	size_t len;
};

void init_string(struct string *s)
{
	s->len = 0;
	s->ptr = malloc(s->len+1);
	if (s->ptr == NULL)
	{
		fprintf(stderr, "malloc() failed\n");
		exit(EXIT_FAILURE);
	}
	s->ptr[0] = '\0';
}

size_t writefunc(void *ptr, size_t size, size_t nmemb, struct string *s)
{
	size_t new_len = s->len + size*nmemb;
	s->ptr = realloc(s->ptr, new_len+1);
	if (s->ptr == NULL)
	{
		fprintf(stderr, "realloc() failed\n");
		exit(EXIT_FAILURE);
	}
	memcpy(s->ptr+s->len, ptr, size*nmemb);
	s->ptr[new_len] = '\0';
	s->len = new_len;

	return size*nmemb;
}


int checkRespString(struct string *s, rData *oResp)
{
	int bResult = 0;
	char sRespHeader[RESP_HEADER_LEN]={0};

	strncpy(sRespHeader, s->ptr, RESP_HEADER_LEN);

	if(strncmp(RESP_HEADER,sRespHeader,RESP_HEADER_LEN)!=0)
	{
		DEBUGLOG(("Error: %s\n", s->ptr));
	}

	else
	{
		char *sRate = strstr(s->ptr,"GMT");

		strncpy(oResp->sDate, sRate-strlen("dd mon yyyy hh:mi:ss "), strlen("dd mon yyyy hh:mi:ss"));
		oResp->sDate[strlen("dd mon yyyy hh:mi:ss")]='\0';

		int rc =sscanf(sRate+4,"%s %s %s %s %s %s", oResp->min_bid, oResp->bid, oResp->max_bid, oResp->min_ask, oResp->ask, oResp->max_ask);
		if( (rc!=6))
		{
			DEBUGLOG(("Output Invalid: %s\n",sRate+4));
		}
		else
		{

			if((strncmp("na",oResp->bid,2)!=0)&&(strncmp("na",oResp->ask,2)!=0))
			{
				if(strncmp("na",oResp->min_bid,2)==0) strcpy(oResp->min_bid,oResp->bid);
				if(strncmp("na",oResp->max_bid,2)==0) strcpy(oResp->max_bid,oResp->bid);
				if(strncmp("na",oResp->min_ask,2)==0) strcpy(oResp->min_ask,oResp->ask);
				if(strncmp("na",oResp->max_ask,2)==0) strcpy(oResp->max_ask,oResp->ask);

				bResult=1;
			}
			else
				DEBUGLOG(("All return values are 'na'\n"));
		}
	}

	return bResult;

}



void createReqString(char * sReq, char* sFromCCY, char* sToCCY)
{
	int rc;
	time_t temp;
	struct tm *timeptr;
	char sDate[DATE_LEN]={0};

	temp = time(NULL);
	timeptr = localtime(&temp);

	int nGMT = timeptr->tm_hour - 8;
	if(nGMT<0)
		nGMT += 24;
        timeptr->tm_hour = nGMT;

        mktime(timeptr);

	rc = strftime(sDate,sizeof(sDate),"%a %d %b %Y %H:%M:%S", timeptr); //i.e. Mon 26 Aug 2010 03:23:49

	////convert RMB to CNY////
	if(strncmp(sFromCCY, "RMB", strlen("RMB"))==0)
	{
		strncpy(sFromCCY, "CNY", strlen("RMB"));
	}
	if(strncmp(sToCCY, "RMB", strlen("RMB"))==0)
	{
		strncpy(sToCCY, "CNY", strlen("RMB"));
	}

	//////construct the request URL with all parameters//////
	snprintf(sReq, REQ_STRING_LEN, "%s%s&Quotecurrency: %s&Basecurrency: %s&Date: %s GMT&Quotetype: %s",REQUEST_URL,REQUEST_HEADER, sFromCCY, sToCCY,sDate,QUOTE_TYPE);

}



int proc_CURL(const char *sReq, const char* sFromCCY, const char* sToCCY)
{
	hash_t *hRate;
        CURL *curl;
        CURLcode res;
        rData oRespData;

        double nRate;
        double nBid;
        double dMaxBid;
        double dMedBid;
        double dMinBid;
        double dMaxAsk;
        double dMedAsk;
        double dMinAsk;
        double dMinMax;
        double dMeanMinMax;

	curl = curl_easy_init();
        if(curl)
        {
                struct string sBuffer;
                init_string(&sBuffer);

                curl_easy_setopt(curl, CURLOPT_URL,sReq);
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc);
                curl_easy_setopt(curl, CURLOPT_WRITEDATA, &sBuffer);
                res = curl_easy_perform(curl);

                curl_easy_cleanup(curl);

		//////check the response code which stored in the file//////
                if(checkRespString(&sBuffer, &oRespData))
                {
                        dMaxBid =  atof(oRespData.max_bid);
                        dMedBid =  atof(oRespData.bid);
                        dMinBid =  atof(oRespData.min_bid);
                        nBid    =  atof(oRespData.bid);
                        dMaxAsk =  atof(oRespData.max_ask);
                        dMedAsk =  atof(oRespData.ask);
                        dMinAsk =  atof(oRespData.min_ask);

                        nRate =1;
                        dMeanMinMax=1;
                        dMinMax=1;

                        DEBUGLOG(("id[%s %s] date[%s] values[%f %f %f %f %f %f] rate[%f] MeadMinMax[%f] MidMax[%f]\n",sFromCCY, sToCCY, oRespData.sDate, dMinBid, dMedBid, dMaxBid, dMinAsk, dMedAsk, dMaxAsk, nRate, dMeanMinMax, dMinMax));

                        free(sBuffer.ptr);

                        hRate = (hash_t*) malloc (sizeof(hash_t));
                        hash_init(hRate,0);

                        PutField_CString(hRate,"from_ccy_id",sFromCCY);
                        PutField_CString(hRate,"to_ccy_id",sToCCY);
                        PutField_CString(hRate,"user",PD_UPDATE_USER);
                        PutField_CString(hRate,"effect_date",oRespData.sDate);

                        PutField_Double(hRate,"rate",nRate);
                        PutField_Double(hRate,"bid",nBid);
                        PutField_Double(hRate,"max_bid",dMaxBid);
                        PutField_Double(hRate,"med_bid",dMedBid);
                        PutField_Double(hRate,"min_bid",dMinBid);
                        PutField_Double(hRate,"max_ask",dMaxAsk);
                        PutField_Double(hRate,"med_ask",dMedAsk);
                        PutField_Double(hRate,"min_ask",dMinAsk);
                        PutField_Double(hRate,"min_max",dMinMax);
                        PutField_Double(hRate,"mean_min_max",dMeanMinMax);

                        DBObjPtr = CreateObj(DBPtr,"DBExchangeRate","Add");

                        if ((*DBObjPtr)(hRate) == PD_OK) {
                        }
                        else {
                                DEBUGLOG(("Add Rate Error\n"));
                        }

                }
	}
	else
	{
		DEBUGLOG(("Init CURL failed\n"));
		return FAILURE;
	}

	return SUCCESS;
}


int batch_init(int argc, char* argv[])
{
//DEBUGLOG(("batch_init\n"));
/*	if(argc<2)
	{
		DEBUGLOG(("Please input enought arguments\n"));
		return FAILURE;
	}
	else  {
        	return SUCCESS;
//DEBUGLOG(("exit batch_init\n"));
	}
*/
	return SUCCESS;
}


int batch_proc(int argc, char* argv[])
{
	int iLoop = 0;
	int iRec = 0;
	int jLoop = 0;
	char aCcyList[MAX_CYY_NUM][PD_CCY_ID_LEN+1];
	char sReqString[REQ_STRING_LEN];

	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        EXEC SQL BEGIN DECLARE SECTION;
		varchar v_currencyId[PD_CCY_ID_LEN+1];

		short ind_v_currencyId	= -1;
		int   iCount = -1;
        EXEC SQL END DECLARE SECTION;

	EXEC SQL SELECT COUNT (*) INTO :iCount FROM currency
		WHERE ACTIVE_IND = 'Y';


        DEBUGLOG(("Num of active record in table[CURRENCY] = %d\n", iCount));
        if(iCount<=0)
                return FAILURE;

	EXEC SQL DECLARE currency_cursor CURSOR FOR
		SELECT currency_id
		FROM currency
		WHERE ACTIVE_IND = 'Y';

	EXEC SQL OPEN currency_cursor;

	for(iLoop=0; iLoop<iCount; iLoop++)
	{
		EXEC SQL FETCH currency_cursor
			INTO :v_currencyId:ind_v_currencyId;
		

		if(ind_v_currencyId>=0)
		{
			v_currencyId.arr[v_currencyId.len]='\0';
			snprintf(aCcyList[iRec], PD_CCY_ID_LEN+1, "%s", v_currencyId.arr);
			DEBUGLOG(("Currency_ID List[%d] = %s\n", iRec, aCcyList[iRec]));
			iRec ++;
		}
	}

	EXEC SQL CLOSE currency_cursor;


	for(iLoop=0; iLoop<iRec; iLoop++)
	{
		for(jLoop=0; jLoop<iRec; jLoop++)
		{
			//printf("List[%d][%d] = [%s][%s]\n", iLoop,jLoop, aCcyList[iLoop], aCcyList[jLoop]);
			createReqString(sReqString, aCcyList[iLoop], aCcyList[jLoop]);
			DEBUGLOG(("The request string = [%s]\n", sReqString));

			proc_CURL(sReqString, aCcyList[iLoop], aCcyList[jLoop]);
		}
	}


        EXEC SQL COMMIT WORK RELEASE;


	return SUCCESS;


sql_error:
    DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;
    return FAILURE;    

}

int batch_terminate(int argc, char* argv[])
{
    return SUCCESS;
}

