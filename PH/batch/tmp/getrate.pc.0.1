#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
#include "common.h"
#include "utilitys.h"
#include "expat.h"

char    cDebug = 'Y';

#define SQLCA_STORAGE_CLASS extern
#define SQLCODE sqlca.sqlcode

int ParseXML(const unsigned char *inMsg,int inLen);
int     ret;
int     iTotal;
char* csTag[PD_MAX_TAG];
char* csValue[PD_MAX_TAG];
static void XMLCALL startElement(void *userData, const char *name, const char **atts)
{
  int *depthPtr = userData;
  csTag[iTotal] = (char*)strdup(name);
  csValue[iTotal] = strdup("");
  *depthPtr += 1;
}

static void XMLCALL endElement(void *userData, const char *name)
{
  int *depthPtr = userData;
  *depthPtr -= 1;
}

static void XMLCALL Chars(void *userData, const XML_Char *s, int len)
{
        char* csTmp;
        if (len > 1) {
                csTmp = (char*) malloc (len +1 );
                sprintf(csTmp,"%.*s",len,s);
//DEBUGLOG(("XMLCALL Chars [%s]\n",csTmp));
                csValue[iTotal] = strdup(csTmp);
        }
        else {
//DEBUGLOG(("XMLCALL Chars len !>1\n"));
                sprintf(csTmp,"%c",s[0]);
//DEBUGLOG(("XMLCALL Chars***** [%s]\n",csTmp));
                csValue[iTotal] = strdup(csTmp);
        }
        iTotal ++;
        FREE_ME(csTmp);
}


static void getXMLfile(char *pBuffer)
{
        FILE * pXMLfile;
        pXMLfile = fopen("xml_sample.xml", "r");
        if(pXMLfile==NULL)
        {
                printf("XML file not found\n");
                return;
        }

        fgets(pBuffer, 1024, pXMLfile);
        fclose(pXMLfile);
}


int batch_init(int argc, char* argv[])
{
/*    if (argc < 2)
        return FAILURE;
      else
*/
        return SUCCESS;
}

int batch_proc(int argc, char* argv[])
{
	
	EXEC SQL WHENEVER SQLERROR GOTO sql_error;
    	EXEC SQL WHENEVER NOTFOUND CONTINUE;

    	EXEC SQL BEGIN DECLARE SECTION;
                varchar v_sysdate[PD_DATE_LEN + 1];
		short	ind_sysdate =-1;

		
    	EXEC SQL END DECLARE SECTION;

	EXEC SQL SELECT to_char(sysdate,'yyyymmdd')
                INTO :v_sysdate:ind_sysdate
                FROM dual;

	if (ind_sysdate >= 0)  {
		printf("Sysdate = [%.*s]\n",v_sysdate.len,v_sysdate.arr);

		char sBuffer[1024] = {0};
		getXMLfile(sBuffer);
		if(strlen(sBuffer))
		{
			char sXML[strlen(sBuffer)+1];
			strcpy(sXML,sBuffer);
			sXML[strlen(sBuffer)]='\0';
			printf("check, sBuffer[%s][%d]\n",sXML, (int)strlen(sXML));
			ParseXML((const unsigned char*)sXML, strlen(sXML));

			//iTotal, csTag, csValue
			EXEC SQL INSERT INTO TESTING (SYS_ID, SYS_NAME)
				VALUES (:csValue[0], :csValue[1]);

			
			EXEC SQL COMMIT WORK RELEASE;

		}
		else
		{
			printf("Do nothing\n");
		}

		return SUCCESS;
	}


	return FAILURE;
sql_error:
    printf("SQL Error\n");
    DEBUGLOG(("get_error code %d\n", sqlca.sqlcode));
    DEBUGLOG(("\n%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc));
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK RELEASE;  
    return FAILURE;    
}

int batch_terminate(int argc, char* argv[])
{
    return SUCCESS;
}

int ParseXML(const unsigned char *inMsg,int inLen)
{
        char    *csMsg;
        int     iLen;
        int i;  
        XML_Parser parser = XML_ParserCreate(PD_XML_ENCODING);
        int done;
        int depth = 0;

        ret = PD_OK;

        iTotal = 0;

        XML_SetUserData(parser, &depth);
        XML_SetElementHandler(parser, startElement, endElement);
        XML_SetCharacterDataHandler(parser,Chars);
        csMsg = (char*) malloc (inLen +1);
        iLen = inLen;
        for (i = 0 ; i < iLen; i++) {
                csMsg[i] = inMsg[i];
        }
        csMsg[iLen] = '\0';
        do {
                if (XML_Parse(parser, csMsg, iLen, done) == XML_STATUS_ERROR) {
DEBUGLOG(("%s at line %d\n", XML_ErrorString(XML_GetErrorCode(parser)), XML_GetCurrentLineNumber(parser)));
printf("%s at line %d\n", XML_ErrorString(XML_GetErrorCode(parser)), (int)XML_GetCurrentLineNumber(parser));
                        FREE_ME(csMsg);
                        return PD_ERR;
                }
        } while (!done);
        XML_ParserFree(parser);
        FREE_ME(csMsg);
        for (i = 0; i < iTotal; i++) {
DEBUGLOG(("%s = %s\n",csTag[i],csValue[i]));
		
        }
DEBUGLOG(("ParseXML: Exit Function\n"));
        return ret;
}
