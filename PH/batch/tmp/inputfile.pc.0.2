#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sqlca.h>
#include <sys/types.h>
#include <time.h>
//#include "common.h"
#include "utilitys.h"
#include "expat.h"
#include <curl/curl.h>
#include "myhash.h"
#include "ObjPtr.h"
#include "numutility.h"
#include "myrecordset.h"

#include "inputfile.h"
#include "PayoutRecord.h"
#include "TxnSeq.h"

OBJPTR(BO);
OBJPTR(DB);
char    cDebug;

#define MY_FIELD_TOKEN  "|"

int batch_init(int argc, char* argv[])
{
	return SUCCESS;
}

int insertDB(rData *oOutput)
{
	double	dAmount=0;

	hash_t *hRec;
	hRec = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRec,0);

	PutField_CString(hRec,"seq_num",oOutput->csSeqNum);
	PutField_CString(hRec,"merchant_ref_num",oOutput->csMerchRefNum);
	PutField_CString(hRec,"country",oOutput->csCountry);
	PutField_CString(hRec,"identity_id",oOutput->csIdNo);
	PutField_CString(hRec,"account_num",oOutput->csAccountNum);
	PutField_CString(hRec,"account_name",oOutput->csAccountName);
	PutField_CString(hRec,"bank_name",oOutput->csBankName);
	PutField_CString(hRec,"branch",oOutput->csBranch);
	PutField_CString(hRec,"phone_num",oOutput->csMobileNo);
	PutField_CString(hRec,"province",oOutput->csProvince);
	PutField_CString(hRec,"city",oOutput->csCity);
	PutField_CString(hRec,"payout_currency",oOutput->csPayoutCurr);
	PutField_CString(hRec,"dest_currency",oOutput->csDestCurr);
	PutField_CString(hRec,"checksum",oOutput->csChecksum);
	PutField_CString(hRec,"ref_merch_id",oOutput->csRefMerchId);

	if(is_numeric(oOutput->csAmount)!=PD_TRUE){
DEBUGLOG(("Invalid Amount [%s]. Add Payout Record Stopped\n",oOutput->csAmount));
		return FAILURE;
	}

	dAmount = ctod(oOutput->csAmount, strlen(oOutput->csAmount), 0);
	PutField_Double(hRec,"amount",dAmount);

	DBObjPtr = CreateObj(DBPtr,"DBPayoutRecord","Add");
	if ((unsigned long int)(*DBObjPtr)(hRec) == PD_OK) {

DEBUGLOG(("Record inserted:[%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%f] [%s] [%s] [%s]\n",oOutput->csSeqNum,oOutput->csMerchRefNum,oOutput->csCountry,oOutput->csIdNo,oOutput->csAccountNum,oOutput->csAccountName,oOutput->csBankName,oOutput->csBranch,oOutput->csMobileNo,oOutput->csProvince,oOutput->csCity,dAmount,oOutput->csPayoutCurr,oOutput->csDestCurr,oOutput->csChecksum));
	}
	else {  
DEBUGLOG(("Add Payout Record Error\n"));
		return FAILURE;
	}

	return SUCCESS;
}


int parse_field(const char *csInput, rData *oOutput)
{
	char *pField;
	char csBuffer[BUFFER_LEN];
	char csData[BUFFER_LEN];

	strncpy(csBuffer,csInput, BUFFER_LEN);

	int iDataCnt=0;
	csData[0]='\0';
	pField = strtok(csBuffer,",");
	while(pField){
		if(iDataCnt==0){
			strncpy(oOutput->csSeqNum,pField,PD_SEQ_NUM_LEN);
			oOutput->csSeqNum[PD_SEQ_NUM_LEN]='\0';
			strcat(csData,oOutput->csSeqNum);
			strcat(csData,MY_FIELD_TOKEN);
		}
		else if(iDataCnt==1){
			strncpy(oOutput->csMerchRefNum,pField,PD_MERCHANT_REF_LEN);
			oOutput->csMerchRefNum[PD_MERCHANT_REF_LEN]='\0';
			strcat(csData,oOutput->csMerchRefNum);
			strcat(csData,MY_FIELD_TOKEN);
		}
		else if(iDataCnt==2){
			strncpy(oOutput->csCountry,pField,PD_COUNTRY_LEN);
			oOutput->csCountry[PD_COUNTRY_LEN]='\0';
		}
		else if(iDataCnt==3){
			strncpy(oOutput->csIdNo,pField,PD_IDENTITY_ID_LEN);
			oOutput->csIdNo[PD_IDENTITY_ID_LEN]='\0';
			strcat(csData,oOutput->csIdNo);
			strcat(csData,MY_FIELD_TOKEN);
		}
		else if(iDataCnt==4){
			strncpy(oOutput->csAccountNum,pField,PD_AC_NO_LEN);
			oOutput->csAccountNum[PD_AC_NO_LEN]='\0';
		}
		else if(iDataCnt==5){
			strncpy(oOutput->csAccountName,pField,PD_ACC_NAME_LEN);
			oOutput->csAccountName[PD_ACC_NAME_LEN]='\0';
		}
		else if(iDataCnt==6){
			strncpy(oOutput->csBankName,pField,PD_BANK_NAME_LEN);
			oOutput->csBankName[PD_BANK_NAME_LEN]='\0';
		}
		else if(iDataCnt==7){
			strncpy(oOutput->csBranch,pField,PD_BANK_BRANCH_LEN);
			oOutput->csBranch[PD_BANK_BRANCH_LEN]='\0';
		}
		else if(iDataCnt==8){
			strncpy(oOutput->csMobileNo,pField,PD_MOBILE_NO_LEN);
			oOutput->csMobileNo[PD_MOBILE_NO_LEN]='\0';
		}
		else if(iDataCnt==9){
			strncpy(oOutput->csProvince,pField,PD_PROVINCE_LEN);
			oOutput->csProvince[PD_PROVINCE_LEN]='\0';
		}
		else if(iDataCnt==10){
			strncpy(oOutput->csCity,pField,PD_CITY_LEN);
			oOutput->csCity[PD_CITY_LEN]='\0';
		}
		else if(iDataCnt==11){
			strncpy(oOutput->csAmount,pField,AMOUNT_LEN);
			oOutput->csAmount[AMOUNT_LEN]='\0';
		}
		else if(iDataCnt==12){
			strncpy(oOutput->csPayoutCurr,pField,PD_CCY_ID_LEN);
			oOutput->csPayoutCurr[PD_CCY_ID_LEN]='\0';
		}
		else if(iDataCnt==13){
			strncpy(oOutput->csDestCurr,pField,PD_CCY_ID_LEN);
			oOutput->csDestCurr[PD_CCY_ID_LEN]='\0';
		}
		else if(iDataCnt==14){
			strncpy(oOutput->csChecksum,pField,PD_CHECKSUM_LEN);
			oOutput->csChecksum[PD_CHECKSUM_LEN]='\0';
		}
			

		pField = strtok(NULL,",");
		iDataCnt++;
		
	}
	
	strcat(csData,oOutput->csCountry);
	strcat(csData,MY_FIELD_TOKEN);
	strcat(csData,oOutput->csAmount);

	BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyMac");
	if ((unsigned long int)(*BOObjPtr)(oOutput->csChecksum,oOutput->csShaKey,csData,strlen(csData)) == PD_OK){

DEBUGLOG(("parse_field success:[%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s]\n",oOutput->csSeqNum,oOutput->csMerchRefNum,oOutput->csCountry,oOutput->csIdNo,oOutput->csAccountNum,oOutput->csAccountName,oOutput->csBankName,oOutput->csBranch,oOutput->csMobileNo,oOutput->csProvince,oOutput->csCity,oOutput->csAmount,oOutput->csPayoutCurr,oOutput->csDestCurr,oOutput->csChecksum));

	}
	else{

DEBUGLOG(("parse_field failed (invalid checksum):[%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s] [%s]\n",oOutput->csSeqNum,oOutput->csMerchRefNum,oOutput->csCountry,oOutput->csIdNo,oOutput->csAccountNum,oOutput->csAccountName,oOutput->csBankName,oOutput->csBranch,oOutput->csMobileNo,oOutput->csProvince,oOutput->csCity,oOutput->csAmount,oOutput->csPayoutCurr,oOutput->csDestCurr,oOutput->csChecksum));
		return FAILURE;
	}

	
	return SUCCESS;
}

int checkMerchId(const char* csMerchId, char* csShaKey)
{
	char *csTmp = NULL;
	recordset_t     *rRecordSet;
	rRecordSet = (recordset_t*) malloc (sizeof(recordset_t));
	recordset_init(rRecordSet,0);
	DBObjPtr = CreateObj(DBPtr,"DBMerchDetail","GetMerchant");
	if ((*DBObjPtr)(csMerchId,rRecordSet) != PD_OK) {
DEBUGLOG(("checkMerchId: Merchant Id[%s] not found\n",csMerchId));
		return FAILURE;
	}
	else{
		hash_t  *hRec;
		hRec = RecordSet_GetFirst(rRecordSet);
		while (hRec) {
			if (GetField_CString(hRec,"sha_key",&csTmp)){
				strncpy(csShaKey,csTmp,PD_SHA_KEY_LEN);
				csShaKey[PD_SHA_KEY_LEN]='\0';
DEBUGLOG(("checkMerchId: Sha Key found [%s]\n",csShaKey));
			}

			hRec = RecordSet_GetNext(rRecordSet);
		}
	}

	return SUCCESS;
}

int parse_header(const char *csInput, rData *oOutput)
{
	char *pField;
	char csBuffer[BUFFER_LEN];
	int iData = 0;
	int iNumofRec = 0;
	char csData[BUFFER_LEN];
	char csCheckSum[PD_CHECKSUM_LEN+1];

	strncpy(csBuffer,csInput, BUFFER_LEN);

	pField = strtok(csBuffer,",");
	while(pField){
		if(iData==0){
			if(checkMerchId(pField,oOutput->csShaKey)==SUCCESS){
				strncpy(oOutput->csRefMerchId,pField,PD_MERCHANT_ID_LEN);
				strncpy(csData,pField,PD_MERCHANT_ID_LEN);
				strcat(csData,MY_FIELD_TOKEN);
			}
			else
				return -1;
		}
		else if(iData==1){
			if(is_numeric(pField)!=PD_TRUE){
DEBUGLOG(("parse_header: Invalid no. of record[%s]\n",pField));
				return -1;
			}
			iNumofRec = atoi(pField);
			strcat(csData,pField);
			csData[strlen(csData)]='\0';;
		}
		else if(iData==2){
			strncpy(csCheckSum,pField,PD_CHECKSUM_LEN);
			csCheckSum[PD_CHECKSUM_LEN]='\0';
			BOObjPtr = CreateObj(BOPtr,"BOSecurity","VerifyMac");
			if((unsigned long int)(*BOObjPtr)(csCheckSum,oOutput->csShaKey,csData,strlen(csData)) == PD_OK){
			}
			else{
DEBUGLOG(("parse_header: Invalid checksum [%s]\n",pField));
				return -1;
			}
		}
		else{
DEBUGLOG(("parse_header error: More than 3 fields\n"));
			return -1;
		}

		pField = strtok(NULL,",");
		iData++;
	}

DEBUGLOG(("parse_header:[%s] [%d] [%s]\n",oOutput->csRefMerchId,iNumofRec,csCheckSum));

	return iNumofRec;
}

int checkHeader(rData *oOutput)
{
	char csBuffer[BUFFER_LEN]={0};
	int iNumOfLine = 0;
	int iNumofRec = 0;

	FILE *pFile;
	pFile = fopen(IMPORT_FILE_NAME,"r");
	if(!pFile){
DEBUGLOG(("cannot open file:[%s]\n",IMPORT_FILE_NAME));
		return FAILURE;
	}

	while( fgets(csBuffer, BUFFER_LEN, pFile) != NULL ){
		if(iNumOfLine==0){
			iNumofRec = parse_header(csBuffer, oOutput);
		}
		iNumOfLine++;
	}

	fclose(pFile);

	if((iNumOfLine==1)||(iNumofRec==0)){
DEBUGLOG(("checkHeader: This file only contains Header record[%d][%d]\n",iNumOfLine,iNumofRec));
		return FAILURE;
	}
	else if(iNumofRec<0){
		return FAILURE;
	}
	else if((iNumOfLine-1)!=iNumofRec){
DEBUGLOG(("checkHeader: No. of record not match: Count[%d], Header[%d]\n",iNumOfLine-1,iNumofRec));
		return FAILURE;
	}

	return SUCCESS;
}


int read_file(rData *oOutput)
{
	FILE *pFile;
	char csBuffer[BUFFER_LEN]={0};
	int iFirstLineChecked = 0;


	pFile = fopen(IMPORT_FILE_NAME,"r");
	if(!pFile){
		return FAILURE;
	}

	while( fgets(csBuffer, BUFFER_LEN, pFile) != NULL ){
		if(iFirstLineChecked==0){
			if(checkHeader(oOutput)!=SUCCESS){
				fclose(pFile);
DEBUGLOG(("Invalid file. Stop update.\n"));
				return FAILURE;
			}
		}
		else{
			if(parse_field(csBuffer,oOutput)==SUCCESS){
				insertDB(oOutput);
			}
		}
		iFirstLineChecked=1;
	}

	fclose(pFile);

	return SUCCESS;
}



int batch_proc(int argc, char* argv[])
{
	rData oResult;
DEBUGLOG(("Start reading file\n"));
	if(read_file(&oResult)!=SUCCESS)
		return FAILURE;

DEBUGLOG(("process end\n"));
	return SUCCESS;

}


int batch_terminate(int argc, char* argv[])
{
	return SUCCESS;
}
