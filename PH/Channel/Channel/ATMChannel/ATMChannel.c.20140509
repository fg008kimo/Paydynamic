/*
Partnerdelight (c)2014. All rights reserved. No part of this software may be reproduced in any form without written permission
of an authorized representative of Partnerdelight.

Change Description                                 Change Date             Change By
-------------------------------                    ------------            --------------
Init Version                                       2014/04/25              David Wong
*/

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <string.h>
#include <ctype.h>
#include "queue_utility.h"
#include "ATMChannel.h"
#include "utilitys.h"
#include "common.h"
#include "ObjPtr.h"
#include "myrecordset.h"
#include "internal.h"
#include "mydb.h"
#include "mq_db.h"
#include "dbutility.h"
#include "langconvert.h"

char cDebug;

void ATMChannel(char cdebug)
{
	cDebug = cdebug;
}

OBJPTR(DB);
OBJPTR(Msg);
OBJPTR(BO);

int process_txn(hash_t *hContext,
		const hex_t *inMsg,
		hex_t *outMsg)
{
	int iRet = PD_OK;
	char *csQueueName;
	char *csChannelCode = strdup("ATM");
	char *csStmtTxnId;
	long lKey;
	long lResponseQueueMtype;
	struct msg_t* msg;
	hash_t *hRequest;
	hash_t *hResponse;
	char csCmd[PD_MAX_FILE_LEN + 1];

DEBUGLOG(("process_txn\n"));

	hRequest = (hash_t*) malloc (sizeof(hash_t));
	hResponse = (hash_t*) malloc (sizeof(hash_t));
	hash_init(hRequest, 0);
	hash_init(hResponse, 0);

	if (GetField_CString(hContext, "reply_queue", &csQueueName)) {
DEBUGLOG(("process_txn: reply queue = [%s]\n", csQueueName));
		lKey = GetMQKey((unsigned char*)csQueueName);
		PutField_Long(hContext, "queue_key", lKey);
DEBUGLOG(("process_txn: reply queue key = [%ld]\n", lKey));
	}

	if (iRet == PD_OK) {
DEBUGLOG(("process_txn: Call AtmMsg [%d]\n", inMsg->len));
		MsgObjPtr = CreateObj(MsgPtr, "AtmMsg", "BreakDownMsg");
		if ((*MsgObjPtr)(hRequest, inMsg->msg, inMsg->len) != PD_OK) {
			iRet = INT_BREAKDOWN_ERR;
			PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("process_txn: BreakDown AtmMsg Error\n"));
ERRLOG("ATMChannel: process_txn: BreakDown AtmMsg Error\n");
		}
	}

	if (iRet == PD_OK) {
		if (GetField_CString(hRequest, "stmt_txn_id", &csStmtTxnId)) {
DEBUGLOG(("process_txn: stmt_txn_id = [%s]\n", csStmtTxnId));
			PutField_CString(hContext, "stmt_txn_id", csStmtTxnId);
		} else {
			iRet = INT_INVALID_TXN;
			PutField_Int(hContext, "internal_error", iRet);
DEBUGLOG(("process_txn: Cannot Get Stmt Txn ID\n"));
ERRLOG("ATMChannel: process_txn: Cannot Get Stmt Txn ID\n");
		}
	}

	if (iRet == PD_OK) {
DEBUGLOG(("process_txn: backgroud process matching\n"));
		sprintf(csCmd, "offline_auto_match_bg_run.exec -s %s &", csStmtTxnId);
		system(csCmd);
//		BOObjPtr = CreateObj(BOPtr, "BOOLDepositMatch", "ProcessMatching");
//		iRet = (unsigned long)(*BOObjPtr)(hContext);
	}

	/******** reply to remote host if success ********/
	if (iRet == PD_OK) {
DEBUGLOG(("process_txn: reply\n"));
		GetField_Long(hContext, "queue_key", &lKey);

		GetField_Long(hContext, "response_queue_mtype", &lResponseQueueMtype);

		msg = (struct msg_t*) malloc (sizeof(struct msg_t) + MAX_MSG_SIZE);
		msg->mtype = lResponseQueueMtype;
DEBUGLOG(("process_txn: key = [%ld] mtype = [%ld]\n", lKey, lResponseQueueMtype));

		long lRemoteKey;
		GetField_Long(hContext, "remote_reply_key", &lRemoteKey);
		memset(msg->mtext, 0, sizeof(msg->mtext));
		MQ_build_header((unsigned char*)msg->mtext,
						MQ_RESP,
						csChannelCode,
						0,
						NULL,
						lRemoteKey);
DEBUGLOG(("process_txn: build header\n"));
		msg->mtext[MQ_HEADER_LEN] = '\0';
DEBUGLOG(("process_txn: send len = [%d]\n", MQ_HEADER_LEN));

		iRet = MQSend(lKey, msg, MQ_HEADER_LEN);

		FREE_ME(msg);
	}
	/******** ********/

DEBUGLOG(("process_txn: iRet = [%d]\n", iRet));
	FREE_ME(csChannelCode);
	FREE_ME(hRequest);
	FREE_ME(hResponse);
	return iRet;
}
